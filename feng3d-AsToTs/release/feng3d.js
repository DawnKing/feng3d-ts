var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var feng3d;
(function (feng3d) {
    /**
     * feng3d引擎
     * @author feng 2014-3-14
     */
    var Feng3D = (function () {
        function Feng3D() {
        }
        Feng3D.WEBSITE_URL = "http://www.feng3d.me";
        Feng3D.MAJOR_VERSION = 0;
        Feng3D.MINOR_VERSION = 0;
        Feng3D.REVISION = 0;
        return Feng3D;
    }());
    feng3d.Feng3D = Feng3D;
})(feng3d || (feng3d = {}));
/*
Copyright (c) 2011, Adobe Systems Incorporated
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

* Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.

* Neither the name of Adobe Systems Incorporated nor the names of its
contributors may be used to endorse or promote products derived from
this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var feng3d;
(function (feng3d) {
    // ===========================================================================
    //	Imports
    // ---------------------------------------------------------------------------
        * ;
        * ;
    // ===========================================================================
    //	Class
    // ---------------------------------------------------------------------------
    var AGALMiniAssembler = (function () {
        // ======================================================================
        //	Constructor
        // ----------------------------------------------------------------------
        function AGALMiniAssembler(debugging) {
            if (debugging === void 0) { debugging = false; }
            // ======================================================================
            //	Properties
            // ----------------------------------------------------------------------
            // AGAL bytes and error buffer 
            this._agalcode = null;
            this._error = "";
            this.debugEnabled = false;
            this.verbose = false;
            this.debugEnabled = debugging;
            if (!initialized)
                this.init();
        }
        Object.defineProperty(AGALMiniAssembler.prototype, "error", {
            // ======================================================================
            //	Getters
            // ----------------------------------------------------------------------
            get: function () { return _error; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AGALMiniAssembler.prototype, "agalcode", {
            get: function () { return _agalcode; },
            enumerable: true,
            configurable: true
        });
        // ======================================================================
        //	Methods
        // ----------------------------------------------------------------------
        AGALMiniAssembler.prototype.assemble2 = function (ctx3d, version, vertexsrc, fragmentsrc) {
            var agalvertex = this.assemble(VERTEX, vertexsrc, version);
            var agalfragment = this.assemble(FRAGMENT, fragmentsrc, version);
            var prog = ctx3d.createProgram();
            prog.upload(agalvertex, agalfragment);
            return prog;
        };
        AGALMiniAssembler.prototype.assemble = function (mode, source, version, ignorelimits) {
            if (version === void 0) { version = 2; }
            if (ignorelimits === void 0) { ignorelimits = false; }
            var start = getTimer();
            this._agalcode = new ByteArray();
            this._error = "";
            var isFrag = false;
            if (mode == FRAGMENT)
                isFrag = true;
            else if (mode != VERTEX)
                this._error = 'ERROR: mode needs to be "' + FRAGMENT + '" or "' + VERTEX + '" but is "' + mode + '".';
            this.agalcode.endian = Endian.LITTLE_ENDIAN;
            this.agalcode.writeByte(0xa0); // tag version
            this.agalcode.writeUnsignedInt(version); // AGAL version, big endian, bit pattern will be 0x01000000
            this.agalcode.writeByte(0xa1); // tag program id
            this.agalcode.writeByte(isFrag ? 1 : 0); // vertex or fragment
            this.initregmap(version, ignorelimits);
            var lines = source.replace(/[\f\n\r\v]+/g, "\n").split("\n");
            //var nest:number = 0;
            var nops = 0;
            var i;
            var lng = lines.length;
            for (i = 0; i < lng && this._error == ""; i++) {
                var line = new string(lines[i]);
                line = line.replace(REGEXP_OUTER_SPACES, "");
                // remove comments
                var startcomment = line.search("//");
                if (startcomment != -1)
                    line = line.slice(0, startcomment);
                // grab options
                var optsi = line.search(/<.*>/g);
                var opts;
                if (optsi != -1) {
                    opts = line.slice(optsi).match(/([\w\.\-\+]+)/gi);
                    line = line.slice(0, optsi);
                }
                // find opcode
                var opCode = line.match(/^\w{3}/ig);
                if (!opCode) {
                    if (line.length >= 3)
                        trace("warning: bad line " + i + ": " + lines[i]);
                    continue;
                }
                var opFound = OPMAP[opCode[0]];
                // if debug is enabled, output the opcodes
                if (this.debugEnabled)
                    trace(opFound);
                if (opFound == null) {
                    if (line.length >= 3)
                        trace("warning: bad line " + i + ": " + lines[i]);
                    continue;
                }
                line = line.slice(line.search(opFound.name) + opFound.name.length);
                if ((opFound.flags & OP_VERSION2) && version < 2) {
                    this._error = "this.error: opcode requires version 2.";
                    break;
                }
                if ((opFound.flags & OP_VERT_ONLY) && isFrag) {
                    this._error = "this.error: opcode is only allowed in vertex programs.";
                    break;
                }
                if ((opFound.flags & OP_FRAG_ONLY) && !isFrag) {
                    this._error = "this.error: opcode is only allowed in fragment programs.";
                    break;
                }
                if (this.verbose)
                    trace("emit opcode=" + opFound);
                this.agalcode.writeUnsignedInt(opFound.emitCode);
                nops++;
                if (nops > MAX_OPCODES) {
                    this._error = "this.error: too many opcodes. maximum is " + MAX_OPCODES + ".";
                    break;
                }
                // get operands, use regexp
                var regs;
                // will match both syntax
                regs = line.match(/vc\[([vof][acostdip]?)(\d*)?(\.[xyzw](\+\d{1,3})?)?\](\.[xyzw]{1,4})?|([vof][acostdip]?)(\d*)?(\.[xyzw]{1,4})?/gi);
                if (!regs || regs.length != opFound.numRegister) {
                    this._error = "this.error: wrong number of operands. found " + regs.length + " but expected " + opFound.numRegister + ".";
                    break;
                }
                var badreg = false;
                var pad = 64 + 64 + 32;
                var regLength = regs.length;
                for (var j = 0; j < regLength; j++) {
                    var isRelative = false;
                    var relreg = regs[j].match(/\[.*\]/ig);
                    if (relreg && relreg.length > 0) {
                        regs[j] = regs[j].replace(relreg[0], "0");
                        if (this.verbose)
                            trace("IS REL");
                        isRelative = true;
                    }
                    var res = regs[j].match(/^\b[A-Za-z]{1,2}/ig);
                    if (!res) {
                        this._error = "this.error: could not parse operand " + j + " (" + regs[j] + ").";
                        badreg = true;
                        break;
                    }
                    var regFound = REGMAP[res[0]];
                    // if debug is enabled, output the registers
                    if (this.debugEnabled)
                        trace(regFound);
                    if (regFound == null) {
                        this._error = "this.error: could not find register this.name for operand " + j + " (" + regs[j] + ").";
                        badreg = true;
                        break;
                    }
                    if (isFrag) {
                        if (!(regFound.flags & REG_FRAG)) {
                            this._error = "this.error: register operand " + j + " (" + regs[j] + ") only allowed in vertex programs.";
                            badreg = true;
                            break;
                        }
                        if (isRelative) {
                            this._error = "this.error: register operand " + j + " (" + regs[j] + ") relative adressing not allowed in fragment programs.";
                            badreg = true;
                            break;
                        }
                    }
                    else {
                        if (!(regFound.flags & REG_VERT)) {
                            this._error = "this.error: register operand " + j + " (" + regs[j] + ") only allowed in fragment programs.";
                            badreg = true;
                            break;
                        }
                    }
                    regs[j] = regs[j].slice(regs[j].search(regFound.name) + regFound.name.length);
                    //trace( "REGNUM: " +regs[j] );
                    var idxmatch = isRelative ? relreg[0].match(/\d+/) : regs[j].match(/\d+/);
                    var regidx = 0;
                    if (idxmatch)
                        regidx = number(idxmatch[0]);
                    if (regFound.range < regidx) {
                        this._error = "this.error: register operand " + j + " (" + regs[j] + ") index exceeds limit of " + (regFound.range + 1) + ".";
                        badreg = true;
                        break;
                    }
                    var regmask = 0;
                    var maskmatch = regs[j].match(/(\.[xyzw]{1,4})/);
                    var isDest = (j == 0 && !(opFound.flags & OP_NO_DEST));
                    var isSampler = (j == 2 && (opFound.flags & OP_SPECIAL_TEX));
                    var reltype = 0;
                    var relsel = 0;
                    var reloffset = 0;
                    if (isDest && isRelative) {
                        this._error = "this.error: relative can not be destination";
                        badreg = true;
                        break;
                    }
                    if (maskmatch) {
                        regmask = 0;
                        var cv;
                        var maskLength = maskmatch[0].length;
                        for (var k = 1; k < maskLength; k++) {
                            cv = maskmatch[0].charCodeAt(k) - "x".charCodeAt(0);
                            if (cv > 2)
                                cv = 3;
                            if (isDest)
                                regmask |= 1 << cv;
                            else
                                regmask |= cv << ((k - 1) << 1);
                        }
                        if (!isDest)
                            for (; k <= 4; k++)
                                regmask |= cv << ((k - 1) << 1); // repeat last								
                    }
                    else {
                        regmask = isDest ? 0xf : 0xe4; // id swizzle or this.mask						
                    }
                    if (isRelative) {
                        var relname = relreg[0].match(/[A-Za-z]{1,2}/ig);
                        var regFoundRel = REGMAP[relname[0]];
                        if (regFoundRel == null) {
                            this._error = "this.error: bad index register";
                            badreg = true;
                            break;
                        }
                        reltype = regFoundRel.emitCode;
                        var selmatch = relreg[0].match(/(\.[xyzw]{1,1})/);
                        if (selmatch.length == 0) {
                            this._error = "this.error: bad index register select";
                            badreg = true;
                            break;
                        }
                        relsel = selmatch[0].charCodeAt(1) - "x".charCodeAt(0);
                        if (relsel > 2)
                            relsel = 3;
                        var relofs = relreg[0].match(/\+\d{1,3}/ig);
                        if (relofs.length > 0)
                            reloffset = relofs[0];
                        if (reloffset < 0 || reloffset > 255) {
                            this._error = "this.error: index offset " + reloffset + " out of bounds. [0..255]";
                            badreg = true;
                            break;
                        }
                        if (this.verbose)
                            trace("RELATIVE: type=" + reltype + "==" + relname[0] + " sel=" + relsel + "==" + selmatch[0] + " idx=" + regidx + " offset=" + reloffset);
                    }
                    if (this.verbose)
                        trace("  emit argcode=" + regFound + "[" + regidx + "][" + regmask + "]");
                    if (isDest) {
                        this.agalcode.writeShort(regidx);
                        this.agalcode.writeByte(regmask);
                        this.agalcode.writeByte(regFound.emitCode);
                        pad -= 32;
                    }
                    else {
                        if (isSampler) {
                            if (this.verbose)
                                trace("  emit sampler");
                            var samplerbits = 5; // type 5 
                            var optsLength = opts == null ? 0 : opts.length;
                            var bias = 0;
                            for (k = 0; k < optsLength; k++) {
                                if (this.verbose)
                                    trace("    opt: " + opts[k]);
                                var optfound = SAMPLEMAP[opts[k]];
                                if (optfound == null) {
                                    // todo check that it's a number...
                                    //trace( "Warning, unknown sampler option: "+opts[k] );
                                    bias = number(opts[k]);
                                    if (this.verbose)
                                        trace("    bias: " + bias);
                                }
                                else {
                                    if (optfound.flag != SAMPLER_SPECIAL_SHIFT)
                                        samplerbits &= ~(0xf << optfound.flag);
                                    samplerbits |= number(optfound.mask) << number(optfound.flag);
                                }
                            }
                            this.agalcode.writeShort(regidx);
                            this.agalcode.writeByte(number(bias * 8.0));
                            this.agalcode.writeByte(0);
                            this.agalcode.writeUnsignedInt(samplerbits);
                            if (this.verbose)
                                trace("    bits: " + (samplerbits - 5));
                            pad -= 64;
                        }
                        else {
                            if (j == 0) {
                                this.agalcode.writeUnsignedInt(0);
                                pad -= 32;
                            }
                            this.agalcode.writeShort(regidx);
                            this.agalcode.writeByte(reloffset);
                            this.agalcode.writeByte(regmask);
                            this.agalcode.writeByte(regFound.emitCode);
                            this.agalcode.writeByte(reltype);
                            this.agalcode.writeShort(isRelative ? (relsel | (1 << 15)) : 0);
                            pad -= 64;
                        }
                    }
                }
                // pad unused regs
                for (j = 0; j < pad; j += 8)
                    this.agalcode.writeByte(0);
                if (badreg)
                    break;
            }
            if (this._error != "") {
                this._error += "\n  at line " + i + " " + lines[i];
                this.agalcode.length = 0;
                trace(this._error);
            }
            // trace the bytecode bytes if debugging is enabled
            if (this.debugEnabled) {
                var dbgLine = "generated bytecode:";
                var agalLength = this.agalcode.length;
                for (var index = 0; index < agalLength; index++) {
                    if (!(index % 16))
                        dbgLine += "\n";
                    if (!(index % 4))
                        dbgLine += " ";
                    var byteStr = this.agalcode[index].toString(16);
                    if (byteStr.length < 2)
                        byteStr = "0" + byteStr;
                    dbgLine += byteStr;
                }
                trace(dbgLine);
            }
            if (this.verbose)
                trace("AGALMiniAssembler.assemble time: " + ((getTimer() - start) / 1000) + "s");
            return this.agalcode;
        };
        AGALMiniAssembler.prototype.initregmap = function (version, ignorelimits) {
            // version changes limits				
            REGMAP[VA] = new Register(VA, "vertex attribute", 0x0, ignorelimits ? 1024 : 7, REG_VERT | REG_READ);
            REGMAP[VC] = new Register(VC, "vertex constant", 0x1, ignorelimits ? 1024 : (version == 1 ? 127 : 250), REG_VERT | REG_READ);
            REGMAP[VT] = new Register(VT, "vertex temporary", 0x2, ignorelimits ? 1024 : (version == 1 ? 7 : 27), REG_VERT | REG_WRITE | REG_READ);
            REGMAP[VO] = new Register(VO, "vertex output", 0x3, ignorelimits ? 1024 : 0, REG_VERT | REG_WRITE);
            REGMAP[VI] = new Register(VI, "varying", 0x4, ignorelimits ? 1024 : (version == 1 ? 7 : 11), REG_VERT | REG_FRAG | REG_READ | REG_WRITE);
            REGMAP[FC] = new Register(FC, "fragment constant", 0x1, ignorelimits ? 1024 : (version == 1 ? 27 : 63), REG_FRAG | REG_READ);
            REGMAP[FT] = new Register(FT, "fragment temporary", 0x2, ignorelimits ? 1024 : (version == 1 ? 7 : 27), REG_FRAG | REG_WRITE | REG_READ);
            REGMAP[FS] = new Register(FS, "texture sampler", 0x5, ignorelimits ? 1024 : 7, REG_FRAG | REG_READ);
            REGMAP[FO] = new Register(FO, "fragment output", 0x3, ignorelimits ? 1024 : (version == 1 ? 0 : 3), REG_FRAG | REG_WRITE);
            REGMAP[FD] = new Register(FD, "fragment depth output", 0x6, ignorelimits ? 1024 : (version == 1 ? -1 : 0), REG_FRAG | REG_WRITE);
            // aliases
            REGMAP["op"] = REGMAP[VO];
            REGMAP["i"] = REGMAP[VI];
            REGMAP["v"] = REGMAP[VI];
            REGMAP["oc"] = REGMAP[FO];
            REGMAP["od"] = REGMAP[FD];
            REGMAP["fi"] = REGMAP[VI];
        };
        AGALMiniAssembler.init = function () {
            initialized = true;
            // Fill the dictionaries with opcodes and registers
            OPMAP[MOV] = new OpCode(MOV, 2, 0x00, 0);
            OPMAP[ADD] = new OpCode(ADD, 3, 0x01, 0);
            OPMAP[SUB] = new OpCode(SUB, 3, 0x02, 0);
            OPMAP[MUL] = new OpCode(MUL, 3, 0x03, 0);
            OPMAP[DIV] = new OpCode(DIV, 3, 0x04, 0);
            OPMAP[RCP] = new OpCode(RCP, 2, 0x05, 0);
            OPMAP[MIN] = new OpCode(MIN, 3, 0x06, 0);
            OPMAP[MAX] = new OpCode(MAX, 3, 0x07, 0);
            OPMAP[FRC] = new OpCode(FRC, 2, 0x08, 0);
            OPMAP[SQT] = new OpCode(SQT, 2, 0x09, 0);
            OPMAP[RSQ] = new OpCode(RSQ, 2, 0x0a, 0);
            OPMAP[POW] = new OpCode(POW, 3, 0x0b, 0);
            OPMAP[LOG] = new OpCode(LOG, 2, 0x0c, 0);
            OPMAP[EXP] = new OpCode(EXP, 2, 0x0d, 0);
            OPMAP[NRM] = new OpCode(NRM, 2, 0x0e, 0);
            OPMAP[SIN] = new OpCode(SIN, 2, 0x0f, 0);
            OPMAP[COS] = new OpCode(COS, 2, 0x10, 0);
            OPMAP[CRS] = new OpCode(CRS, 3, 0x11, 0);
            OPMAP[DP3] = new OpCode(DP3, 3, 0x12, 0);
            OPMAP[DP4] = new OpCode(DP4, 3, 0x13, 0);
            OPMAP[ABS] = new OpCode(ABS, 2, 0x14, 0);
            OPMAP[NEG] = new OpCode(NEG, 2, 0x15, 0);
            OPMAP[SAT] = new OpCode(SAT, 2, 0x16, 0);
            OPMAP[M33] = new OpCode(M33, 3, 0x17, OP_SPECIAL_MATRIX);
            OPMAP[M44] = new OpCode(M44, 3, 0x18, OP_SPECIAL_MATRIX);
            OPMAP[M34] = new OpCode(M34, 3, 0x19, OP_SPECIAL_MATRIX);
            OPMAP[DDX] = new OpCode(DDX, 2, 0x1a, OP_VERSION2 | OP_FRAG_ONLY);
            OPMAP[DDY] = new OpCode(DDY, 2, 0x1b, OP_VERSION2 | OP_FRAG_ONLY);
            OPMAP[IFE] = new OpCode(IFE, 2, 0x1c, OP_NO_DEST | OP_VERSION2 | OP_INCNEST | OP_SCALAR);
            OPMAP[INE] = new OpCode(INE, 2, 0x1d, OP_NO_DEST | OP_VERSION2 | OP_INCNEST | OP_SCALAR);
            OPMAP[IFG] = new OpCode(IFG, 2, 0x1e, OP_NO_DEST | OP_VERSION2 | OP_INCNEST | OP_SCALAR);
            OPMAP[IFL] = new OpCode(IFL, 2, 0x1f, OP_NO_DEST | OP_VERSION2 | OP_INCNEST | OP_SCALAR);
            OPMAP[ELS] = new OpCode(ELS, 0, 0x20, OP_NO_DEST | OP_VERSION2 | OP_INCNEST | OP_DECNEST | OP_SCALAR);
            OPMAP[EIF] = new OpCode(EIF, 0, 0x21, OP_NO_DEST | OP_VERSION2 | OP_DECNEST | OP_SCALAR);
            // space			
            OPMAP[TED] = new OpCode(TED, 3, 0x26, OP_FRAG_ONLY | OP_SPECIAL_TEX | OP_VERSION2);
            OPMAP[KIL] = new OpCode(KIL, 1, 0x27, OP_NO_DEST | OP_FRAG_ONLY);
            OPMAP[TEX] = new OpCode(TEX, 3, 0x28, OP_FRAG_ONLY | OP_SPECIAL_TEX);
            OPMAP[SGE] = new OpCode(SGE, 3, 0x29, 0);
            OPMAP[SLT] = new OpCode(SLT, 3, 0x2a, 0);
            OPMAP[SGN] = new OpCode(SGN, 2, 0x2b, 0);
            OPMAP[SEQ] = new OpCode(SEQ, 3, 0x2c, 0);
            OPMAP[SNE] = new OpCode(SNE, 3, 0x2d, 0);
            SAMPLEMAP[RGBA] = new Sampler(RGBA, SAMPLER_TYPE_SHIFT, 0);
            SAMPLEMAP[DXT1] = new Sampler(DXT1, SAMPLER_TYPE_SHIFT, 1);
            SAMPLEMAP[DXT5] = new Sampler(DXT5, SAMPLER_TYPE_SHIFT, 2);
            SAMPLEMAP[VIDEO] = new Sampler(VIDEO, SAMPLER_TYPE_SHIFT, 3);
            SAMPLEMAP[D2] = new Sampler(D2, SAMPLER_DIM_SHIFT, 0);
            SAMPLEMAP[D3] = new Sampler(D3, SAMPLER_DIM_SHIFT, 2);
            SAMPLEMAP[CUBE] = new Sampler(CUBE, SAMPLER_DIM_SHIFT, 1);
            SAMPLEMAP[MIPNEAREST] = new Sampler(MIPNEAREST, SAMPLER_MIPMAP_SHIFT, 1);
            SAMPLEMAP[MIPLINEAR] = new Sampler(MIPLINEAR, SAMPLER_MIPMAP_SHIFT, 2);
            SAMPLEMAP[MIPNONE] = new Sampler(MIPNONE, SAMPLER_MIPMAP_SHIFT, 0);
            SAMPLEMAP[NOMIP] = new Sampler(NOMIP, SAMPLER_MIPMAP_SHIFT, 0);
            SAMPLEMAP[NEAREST] = new Sampler(NEAREST, SAMPLER_FILTER_SHIFT, 0);
            SAMPLEMAP[LINEAR] = new Sampler(LINEAR, SAMPLER_FILTER_SHIFT, 1);
            SAMPLEMAP[CENTROID] = new Sampler(CENTROID, SAMPLER_SPECIAL_SHIFT, 1 << 0);
            SAMPLEMAP[SINGLE] = new Sampler(SINGLE, SAMPLER_SPECIAL_SHIFT, 1 << 1);
            SAMPLEMAP[IGNORESAMPLER] = new Sampler(IGNORESAMPLER, SAMPLER_SPECIAL_SHIFT, 1 << 2);
            SAMPLEMAP[REPEAT] = new Sampler(REPEAT, SAMPLER_REPEAT_SHIFT, 1);
            SAMPLEMAP[WRAP] = new Sampler(WRAP, SAMPLER_REPEAT_SHIFT, 1);
            SAMPLEMAP[CLAMP] = new Sampler(CLAMP, SAMPLER_REPEAT_SHIFT, 0);
        };
        //	Constants
        // ----------------------------------------------------------------------				
        AGALMiniAssembler.REGEXP_OUTER_SPACES = /^\s+|\s+$/g;
        AGALMiniAssembler.initialized = false;
        // ======================================================================
        //	Constants
        // ----------------------------------------------------------------------
        AGALMiniAssembler.OPMAP = {};
        AGALMiniAssembler.REGMAP = {};
        AGALMiniAssembler.SAMPLEMAP = {};
        AGALMiniAssembler.MAX_NESTING = 4;
        AGALMiniAssembler.MAX_OPCODES = 2048;
        AGALMiniAssembler.FRAGMENT = "fragment";
        AGALMiniAssembler.VERTEX = "vertex";
        // masks and shifts
        AGALMiniAssembler.SAMPLER_TYPE_SHIFT = 8;
        AGALMiniAssembler.SAMPLER_DIM_SHIFT = 12;
        AGALMiniAssembler.SAMPLER_SPECIAL_SHIFT = 16;
        AGALMiniAssembler.SAMPLER_REPEAT_SHIFT = 20;
        AGALMiniAssembler.SAMPLER_MIPMAP_SHIFT = 24;
        AGALMiniAssembler.SAMPLER_FILTER_SHIFT = 28;
        // regmap flags
        AGALMiniAssembler.REG_WRITE = 0x1;
        AGALMiniAssembler.REG_READ = 0x2;
        AGALMiniAssembler.REG_FRAG = 0x20;
        AGALMiniAssembler.REG_VERT = 0x40;
        // opmap flags
        AGALMiniAssembler.OP_SCALAR = 0x1;
        AGALMiniAssembler.OP_SPECIAL_TEX = 0x8;
        AGALMiniAssembler.OP_SPECIAL_MATRIX = 0x10;
        AGALMiniAssembler.OP_FRAG_ONLY = 0x20;
        AGALMiniAssembler.OP_VERT_ONLY = 0x40;
        AGALMiniAssembler.OP_NO_DEST = 0x80;
        AGALMiniAssembler.OP_VERSION2 = 0x100;
        AGALMiniAssembler.OP_INCNEST = 0x200;
        AGALMiniAssembler.OP_DECNEST = 0x400;
        // opcodes
        AGALMiniAssembler.MOV = "mov";
        AGALMiniAssembler.ADD = "add";
        AGALMiniAssembler.SUB = "sub";
        AGALMiniAssembler.MUL = "mul";
        AGALMiniAssembler.DIV = "div";
        AGALMiniAssembler.RCP = "rcp";
        AGALMiniAssembler.MIN = "min";
        AGALMiniAssembler.MAX = "max";
        AGALMiniAssembler.FRC = "frc";
        AGALMiniAssembler.SQT = "sqt";
        AGALMiniAssembler.RSQ = "rsq";
        AGALMiniAssembler.POW = "pow";
        AGALMiniAssembler.LOG = "log";
        AGALMiniAssembler.EXP = "exp";
        AGALMiniAssembler.NRM = "nrm";
        AGALMiniAssembler.SIN = "sin";
        AGALMiniAssembler.COS = "cos";
        AGALMiniAssembler.CRS = "crs";
        AGALMiniAssembler.DP3 = "dp3";
        AGALMiniAssembler.DP4 = "dp4";
        AGALMiniAssembler.ABS = "abs";
        AGALMiniAssembler.NEG = "neg";
        AGALMiniAssembler.SAT = "sat";
        AGALMiniAssembler.M33 = "m33";
        AGALMiniAssembler.M44 = "m44";
        AGALMiniAssembler.M34 = "m34";
        AGALMiniAssembler.DDX = "ddx";
        AGALMiniAssembler.DDY = "ddy";
        AGALMiniAssembler.IFE = "ife";
        AGALMiniAssembler.INE = "ine";
        AGALMiniAssembler.IFG = "ifg";
        AGALMiniAssembler.IFL = "ifl";
        AGALMiniAssembler.ELS = "els";
        AGALMiniAssembler.EIF = "eif";
        AGALMiniAssembler.TED = "ted";
        AGALMiniAssembler.KIL = "kil";
        AGALMiniAssembler.TEX = "tex";
        AGALMiniAssembler.SGE = "sge";
        AGALMiniAssembler.SLT = "slt";
        AGALMiniAssembler.SGN = "sgn";
        AGALMiniAssembler.SEQ = "seq";
        AGALMiniAssembler.SNE = "sne";
        // registers
        AGALMiniAssembler.VA = "va";
        AGALMiniAssembler.VC = "vc";
        AGALMiniAssembler.VT = "vt";
        AGALMiniAssembler.VO = "vo";
        AGALMiniAssembler.VI = "vi";
        AGALMiniAssembler.FC = "fc";
        AGALMiniAssembler.FT = "ft";
        AGALMiniAssembler.FS = "fs";
        AGALMiniAssembler.FO = "fo";
        AGALMiniAssembler.FD = "fd";
        // samplers
        AGALMiniAssembler.D2 = "2d";
        AGALMiniAssembler.D3 = "3d";
        AGALMiniAssembler.CUBE = "cube";
        AGALMiniAssembler.MIPNEAREST = "mipnearest";
        AGALMiniAssembler.MIPLINEAR = "miplinear";
        AGALMiniAssembler.MIPNONE = "mipnone";
        AGALMiniAssembler.NOMIP = "nomip";
        AGALMiniAssembler.NEAREST = "nearest";
        AGALMiniAssembler.LINEAR = "linear";
        AGALMiniAssembler.CENTROID = "centroid";
        AGALMiniAssembler.SINGLE = "single";
        AGALMiniAssembler.IGNORESAMPLER = "ignoresampler";
        AGALMiniAssembler.REPEAT = "repeat";
        AGALMiniAssembler.WRAP = "wrap";
        AGALMiniAssembler.CLAMP = "clamp";
        AGALMiniAssembler.RGBA = "rgba";
        AGALMiniAssembler.DXT1 = "dxt1";
        AGALMiniAssembler.DXT5 = "dxt5";
        AGALMiniAssembler.VIDEO = "video";
        return AGALMiniAssembler;
    }());
    feng3d.AGALMiniAssembler = AGALMiniAssembler;
})(feng3d || (feng3d = {}));
// ================================================================================
//	Helper Classes
// --------------------------------------------------------------------------------
{
    // ===========================================================================
    //	Class
    // ---------------------------------------------------------------------------
    var OpCode = (function () {
        function OpCode() {
        }
        Object.defineProperty(OpCode.prototype, "emitCode", {
            // ======================================================================
            //	Getters
            // ----------------------------------------------------------------------
            get: function () { return _emitCode; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(OpCode.prototype, "flags", {
            get: function () { return _flags; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(OpCode.prototype, "name", {
            get: function () { return _name; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(OpCode.prototype, "numRegister", {
            get: function () { return _numRegister; },
            enumerable: true,
            configurable: true
        });
        // ======================================================================
        //	Constructor
        // ----------------------------------------------------------------------
        OpCode.prototype.OpCode = function (name, numRegister, emitCode, flags) {
            this._name = name;
            this._numRegister = numRegister;
            this._emitCode = emitCode;
            this._flags = flags;
        };
        // ======================================================================
        //	Methods
        // ----------------------------------------------------------------------
        OpCode.prototype.toString = function () {
            return "[OpCode this.name=\"" + this._name + "\", this.numRegister=" + this._numRegister + ", this.emitCode=" + this._emitCode + ", this.flags=" + this._flags + "]";
        };
        return OpCode;
    }());
    // ===========================================================================
    //	Class
    // ---------------------------------------------------------------------------
    var Register = (function () {
        function Register() {
        }
        Object.defineProperty(Register.prototype, "emitCode", {
            // ======================================================================
            //	Getters
            // ----------------------------------------------------------------------
            get: function () { return _emitCode; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Register.prototype, "longName", {
            get: function () { return _longName; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Register.prototype, "name", {
            get: function () { return _name; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Register.prototype, "flags", {
            get: function () { return _flags; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Register.prototype, "range", {
            get: function () { return _range; },
            enumerable: true,
            configurable: true
        });
        // ======================================================================
        //	Constructor
        // ----------------------------------------------------------------------
        Register.prototype.Register = function (name, longName, emitCode, range, flags) {
            this._name = name;
            this._longName = longName;
            this._emitCode = emitCode;
            this._range = range;
            this._flags = flags;
        };
        // ======================================================================
        //	Methods
        // ----------------------------------------------------------------------
        Register.prototype.toString = function () {
            return "[Register this.name=\"" + this._name + "\", this.longName=\"" + this._longName + "\", this.emitCode=" + this._emitCode + ", this.range=" + this._range + ", this.flags=" + this._flags + "]";
        };
        return Register;
    }());
    // ===========================================================================
    //	Class
    // ---------------------------------------------------------------------------
    var Sampler = (function () {
        function Sampler() {
        }
        Object.defineProperty(Sampler.prototype, "flag", {
            // ======================================================================
            //	Getters
            // ----------------------------------------------------------------------
            get: function () { return _flag; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Sampler.prototype, "mask", {
            get: function () { return _mask; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Sampler.prototype, "name", {
            get: function () { return _name; },
            enumerable: true,
            configurable: true
        });
        // ======================================================================
        //	Constructor
        // ----------------------------------------------------------------------
        Sampler.prototype.Sampler = function (name, flag, mask) {
            this._name = name;
            this._flag = flag;
            this._mask = mask;
        };
        // ======================================================================
        //	Methods
        // ----------------------------------------------------------------------
        Sampler.prototype.toString = function () {
            return "[Sampler this.name=\"" + this._name + "\", this.flag=\"" + this._flag + "\", this.mask=" + this.mask + "]";
        };
        return Sampler;
    }());
}
var feng3dBeat;
(function (feng3dBeat) {
    /**
     * 心跳基础类
     * @author cdz 2015-10-27
     */
    var BeatBase = (function () {
        function BeatBase() {
            this._isSuspend = false;
            this._beatInterval = 50 / 3; //设置默认时间
        }
        /**
         * 设置跳动间隔， 毫秒为单位
         * @param interval 时间间隔
         *
         */
        BeatBase.prototype.setInterval = function (interval) {
            this._beatInterval = interval;
        };
        /**
         * 开始跳动
         *
         */
        BeatBase.prototype.beginBeat = function () {
            this._lastBeatTime = new Date();
        };
        /**
         * 心跳
         * @param nowDate
         *
         */
        BeatBase.prototype.beat = function (nowDate) {
            if (this._isSuspend) {
                return;
            }
            var deltaTime = nowDate.getTime() - this._lastBeatTime.getTime();
            if (deltaTime >= this._beatInterval) {
                this._lastBeatTime = nowDate;
                GlobalDispatcher.instance.dispatchEvent(new feng3dBeat.HeartBeatEvent(this.BeatType));
            }
        };
        /**
         * 挂起
         */
        BeatBase.prototype.suspend = function () {
            this._isSuspend = true;
        };
        /**
         * 恢复
         */
        BeatBase.prototype.resume = function () {
            this._isSuspend = false;
        };
        /**
         * 析构
         */
        BeatBase.prototype.dispose = function () {
            this._lastBeatTime = null;
        };
        return BeatBase;
    }());
    feng3dBeat.BeatBase = BeatBase;
})(feng3dBeat || (feng3dBeat = {}));
var feng3dBeat;
(function (feng3dBeat) {
    /**
     ** 心跳模块类
     * @includeExample HeatBeatModuleTest.as
     * @author cdz 2015-10-31
     */
    var HeartBeat = (function () {
        function HeartBeat() {
        }
        /**
         * 初始化模块
         */
        HeartBeat.init = function () {
            HeartBeat.heartBeatManager || (HeartBeat.heartBeatManager = new feng3dBeat.HeartBeatManager());
        };
        return HeartBeat;
    }());
    feng3dBeat.HeartBeat = HeartBeat;
})(feng3dBeat || (feng3dBeat = {}));
var feng3d;
(function (feng3d) {
    /**
     * 生成日志
     * <p>此处使用CommonDebug.loggerFunc方法输出日志</p>
     * @see	me.feng.debug.CommonDebug
     */
    function logger() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i - 0] = arguments[_i];
        }
        if (feng3d.DebugCommon.loggerFunc != null)
            feng3d.DebugCommon.loggerFunc.apply(null, args);
    }
    feng3d.logger = logger;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 添加组件事件数据
     * @author feng 2015-12-2
     */
    var AddedComponentEventVO = (function () {
        /**
         * 添加组件事件数据
         * @param container			组件容器
         * @param child				子组件
         */
        function AddedComponentEventVO(container, child) {
            this.container = container;
            this.child = child;
        }
        return AddedComponentEventVO;
    }());
    feng3d.AddedComponentEventVO = AddedComponentEventVO;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     *
     * @author feng 2015-12-2
     */
    var RemovedComponentEventVO = (function () {
        /**
         * 添加组件事件数据
         * @param container			组件容器
         * @param child				子组件
         */
        function RemovedComponentEventVO(container, child) {
            this.container = container;
            this.child = child;
        }
        return RemovedComponentEventVO;
    }());
    feng3d.RemovedComponentEventVO = RemovedComponentEventVO;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 模块管理者
     * <p>负责模块与外部的事件交互</p>
     * @author feng
     */
    var FModuleManager = (function () {
        /**
         * 创建一个模块
         */
        function FModuleManager() {
        }
        /**
         * 初始化模块
         */
        FModuleManager.prototype.init = function () {
        };
        /**
         * 派发全局事件
         *
         * @param event						调度到事件流中的 Event 对象。如果正在重新调度事件，则会自动创建此事件的一个克隆。在调度了事件后，其 target 属性将无法更改，因此您必须创建此事件的一个新副本以能够重新调度。
         * @return 							如果成功调度了事件，则值为 true。值 false 表示失败或对事件调用了 preventDefault()。
         */
        FModuleManager.prototype.dispatchEvent = function (event) {
            return feng3d.GlobalDispatcher.instance.dispatchEvent(event);
        };
        /**
         * 监听全局事件
         * 使用 EventDispatcher 对象注册事件侦听器对象，以使侦听器能够接收事件通知. 可以为特定类型的事件、阶段和优先级在显示列表中的所有节点上注册事件侦听器。
         *
         * <p>成功注册一个事件侦听器后，无法通过额外调用 addEventListener() 来更改其优先级。要更改侦听器的优先级，必须首先调用 removeListener()。然后，可以使用新的优先级再次注册该侦听器。 </p>
         * <p>请记住，注册该侦听器后，如果继续调用具有不同 type 或 useCapture 值的 addEventListener()，则会创建单独的侦听器注册。例如，如果首先注册 useCapture 设置为 true 的侦听器，则该侦听器只在捕获阶段进行侦听。如果使用同一个侦听器对象再次调用 addEventListener()，并将 useCapture 设置为 false，那么便会拥有两个单独的侦听器：一个在捕获阶段进行侦听，另一个在目标和冒泡阶段进行侦听。 </p>
         * <p>不能只为目标阶段或冒泡阶段注册事件侦听器。这些阶段在注册期间是成对出现的，因为冒泡阶段只适用于目标节点的祖代。</p>
         * <p>如果不再需要某个事件侦听器，可调用 removeEventListener() 删除它，否则会产生内存问题。事件侦听器不会自动从内存中删除，因为只要调度对象存在，垃圾回收器就不会删除侦听器（除非 useWeakReference 参数设置为 true）。</p>
         * <p>复制 EventDispatcher 实例时并不复制其中附加的事件侦听器。（如果新近创建的节点需要一个事件侦听器，必须在创建该节点后附加该侦听器。）但是，如果移动 EventDispatcher 实例，则其中附加的事件侦听器也会随之移动。</p>
         * <p>如果在正在处理事件的节点上注册事件侦听器，则不会在当前阶段触发事件侦听器，但会在事件流的稍后阶段触发，如冒泡阶段。</p>
         * <p>如果从正在处理事件的节点中删除事件侦听器，则该事件侦听器仍由当前操作触发。删除事件侦听器后，决不会再次调用该事件侦听器（除非再次注册以备将来处理）。 </p>
         * <P>类级别成员函数不属于垃圾回收的对象，因此可以对类级别成员函数将 useWeakReference 设置为 true 而不会使它们受垃圾回收的影响。如果对作为嵌套内部函数的侦听器将 useWeakReference 设置为 true，则该函数将作为垃圾回收并且不再是永久函数。如果创建对该内部函数的引用（将该函数保存到另一个变量中），则该函数将不作为垃圾回收并仍将保持永久。</P>
         *
         * @param type						事件的类型。
         * @param listener					处理事件的侦听器函数。此函数必须接受 Event 对象作为其唯一的参数，并且不能返回任何结果，如下面的实例所示： <pre>function(evt:Event)</pre>函数可以有任何名称。
         * @param useCapture				确定侦听器是运行于捕获阶段还是运行于目标和冒泡阶段。如果将 useCapture 设置为 true，则侦听器只在捕获阶段处理事件，而不在目标或冒泡阶段处理事件。如果 useCapture 为 false，则侦听器只在目标或冒泡阶段处理事件。要在所有三个阶段都侦听事件，请调用 addEventListener 两次：一次将 useCapture 设置为 true，一次将 useCapture 设置为 false。
         * @param priority					事件侦听器的优先级。优先级由一个带符号的 32 位整数指定。数字越大，优先级越高。优先级为 n 的所有侦听器会在优先级为 n -1 的侦听器之前得到处理。如果两个或更多个侦听器共享相同的优先级，则按照它们的添加顺序进行处理。默认优先级为 0。
         * @param useWeakReference			确定对侦听器的引用是强引用，还是弱引用。强引用（默认值）可防止您的侦听器被当作垃圾回收。弱引用则没有此作用。
         *
         * @see flash.events.EventDispatcher.addEventListener()
         */
        FModuleManager.prototype.addEventListener = function (type, listener, useCapture, priority, useWeakReference) {
            if (useCapture === void 0) { useCapture = false; }
            if (priority === void 0) { priority = 0; }
            if (useWeakReference === void 0) { useWeakReference = false; }
            feng3d.GlobalDispatcher.instance.addEventListener(type, listener, useCapture, priority, useWeakReference);
        };
        /**
         * 全局事件
         */
        FModuleManager.dispatcher = feng3d.GlobalDispatcher.instance;
        return FModuleManager;
    }());
    feng3d.FModuleManager = FModuleManager;
})(feng3d || (feng3d = {}));
var feng3dBeat;
(function (feng3dBeat) {
    /**
     *
     * @author cdz 2015-10-28
     */
    var HeartBeatManager = (function (_super) {
        __extends(HeartBeatManager, _super);
        function HeartBeatManager() {
            _super.call(this);
            this._frameEventDriver = new Shape();
            this.init();
            this._frameEventDriver.addEventListener(Event.ENTER_FRAME, this.onEnterFrame);
        }
        /**
         * @inheritDoc
         */
        HeartBeatManager.prototype.init = function () {
            //初始化默认任务集合类型字典
            this._HeartBeatDic = {};
            this.addListeners();
        };
        /**
         * 添加事件监听器
         */
        HeartBeatManager.prototype.addListeners = function () {
            dispatcher.addEventListener(feng3dBeat.HeartBeatModuleEvent.REGISTER_BEAT_TYPE, this.registerBeat);
            dispatcher.addEventListener(feng3dBeat.HeartBeatModuleEvent.UNREGISTER_BEAT_TYPE, this.unregisterBeat);
            dispatcher.addEventListener(feng3dBeat.HeartBeatModuleEvent.SUSPEND_ONE_BEAT, this.suspendOne);
            dispatcher.addEventListener(feng3dBeat.HeartBeatModuleEvent.RESUME_ONE_BEAT, this.resumeOne);
            dispatcher.addEventListener(feng3dBeat.HeartBeatModuleEvent.SUSPEND_All_BEAT, this.suspendAll);
            dispatcher.addEventListener(feng3dBeat.HeartBeatModuleEvent.RESUME_ALL_BEAT, this.resumeAll);
        };
        /**
         * 注册心跳
         */
        HeartBeatManager.prototype.registerBeat = function (e) {
            var registerData = e.data;
            if (registerData) {
                var beatType = registerData.BeatType;
                var beatInterval = registerData.Interval;
                if (this._HeartBeatDic == null) {
                    this._HeartBeatDic = new Dictionary;
                }
                if (this._HeartBeatDic[beatType] == null) {
                    var beat = new feng3dBeat.BeatBase();
                    beat.BeatType = beatType;
                    beat.setInterval(beatInterval);
                    beat.beginBeat();
                    this._HeartBeatDic[beatType] = beat;
                }
            }
        };
        /**
         * 注销心跳
         */
        HeartBeatManager.prototype.unregisterBeat = function (e) {
            var beatType = e.data;
            if (beatType != null && beatType != "") {
                if (this._HeartBeatDic == null) {
                    return;
                }
                var beat = this._HeartBeatDic[beatType];
                beat.dispose();
                this._HeartBeatDic[beatType] = null;
            }
        };
        /**
         * 暂停一个
         */
        HeartBeatManager.prototype.suspendOne = function (e) {
            var beatType = e.data;
            if (beatType != null && beatType != "") {
                if (this._HeartBeatDic == null) {
                    return;
                }
                var pHeartBeat = this._HeartBeatDic[beatType];
                if (pHeartBeat) {
                    pHeartBeat.suspend();
                }
            }
        };
        /**
         * 恢复跳动一个
         */
        HeartBeatManager.prototype.resumeOne = function (e) {
            var beatType = e.data;
            if (beatType != null && beatType != "") {
                if (this._HeartBeatDic == null) {
                    return;
                }
                var pHeartBeat = this._HeartBeatDic[beatType];
                if (pHeartBeat) {
                    pHeartBeat.resume();
                }
            }
        };
        /**
         * 全部暂停
         */
        HeartBeatManager.prototype.suspendAll = function (e) {
            if (e === void 0) { e = null; }
            if (this._HeartBeatDic) {
                for (each(); ; )
                    var pHeartBeat;
                 in this._HeartBeatDic;
                {
                    if (pHeartBeat) {
                        pHeartBeat.suspend();
                    }
                }
            }
        };
        /**
         * 恢复跳动
         */
        HeartBeatManager.prototype.resumeAll = function (e) {
            if (this._HeartBeatDic) {
                for (each(); ; )
                    var pHeartBeat;
                 in this._HeartBeatDic;
                {
                    if (pHeartBeat) {
                        pHeartBeat.resume();
                    }
                }
            }
        };
        HeartBeatManager.prototype.onEnterFrame = function (e) {
            if (this._HeartBeatDic) {
                var date = new Date;
                for (each(); ; )
                    var pHeartBeat;
                 in this._HeartBeatDic;
                {
                    if (pHeartBeat) {
                        pHeartBeat.beat(date);
                    }
                }
            }
        };
        return HeartBeatManager;
    }(FModuleManager));
    feng3dBeat.HeartBeatManager = HeartBeatManager;
})(feng3dBeat || (feng3dBeat = {}));
var feng3d;
(function (feng3d) {
    /**
     * 界面管理器
     * <p>为界面模块搭建框架</p>
     * @author feng
     */
    var ViewManager = (function (_super) {
        __extends(ViewManager, _super);
        /**
         * 创建一个界面管理器
         */
        function ViewManager() {
        }
        /**
         * 显示界面
         */
        ViewManager.prototype.show = function () {
        };
        /**
         * 更新界面
         */
        ViewManager.prototype.updateView = function () {
        };
        /**
         * 关闭界面
         */
        ViewManager.prototype.close = function () {
        };
        /**
         * 添加侦听修改界面表现的事件等
         */
        ViewManager.prototype.onAddToStage = function (event) {
        };
        /**
         * 移除侦听修改界面表现的事件等
         */
        ViewManager.prototype.onRemovedFromStage = function (event) {
        };
        return ViewManager;
    }(feng3d.FModuleManager));
    feng3d.ViewManager = ViewManager;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 加载管理器
     * @author feng 2014-7-25
     */
    var LoadManager = (function (_super) {
        __extends(LoadManager, _super);
        /**
         * 创建一个加载管理器
         */
        function LoadManager() {
            /** 完成一个资源后执行的函数字典 */
            this.urlFuncsDic = {};
            /** 完成一组资源后执行的函数字典 */
            this.urlsFuncsDic = {};
            this.init();
        }
        /**
         * 初始化加载模块
         */
        LoadManager.prototype.init = function () {
            // creates a BulkLoader instance with a name of "main-site", that can be used to retrieve items without having a reference to this instance
            this.loader = new BulkLoader("main-site");
            // set level to verbose, for debugging only
            this.loader.logLevel = BulkLoader.LOG_ERRORS;
            this.addListeners();
        };
        /**
         * 添加事件监听器
         */
        LoadManager.prototype.addListeners = function () {
            this.loader.addEventListener(BulkLoader.COMPLETE, this.onAllItemsLoaded);
            this.loader.addEventListener(BulkLoader.PROGRESS, this.onAllItemsProgress);
            this.addEventListener(feng3d.LoadModuleEvent.LOAD_RESOURCE, this.onLoadResource);
        };
        /**
         * 处理加载资源事件
         * @param event
         */
        LoadManager.prototype.onLoadResource = function (event) {
            var taskModuleEventData = event.loadEventData.taskModuleEventData;
            taskModuleEventData.params = this.loader;
            this.dispatchEvent(new feng3d.TaskModuleEvent(feng3d.TaskModuleEvent.DISPATCH_TASK, taskModuleEventData));
            if (!this.loader.isRunning)
                this.loader.start();
        };
        /**
         * 加载完成所有资源事件
         * @param evt
         */
        LoadManager.prototype.onAllItemsLoaded = function (evt) {
            //			logger("every thing is loaded!");
        };
        /**
         * 加载进度事件
         */
        LoadManager.prototype.onAllItemsProgress = function (evt) {
            //			logger(evt.loadingStatus());
        };
        return LoadManager;
    }(feng3d.FModuleManager));
    feng3d.LoadManager = LoadManager;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 任务模块管理类
     * @author feng 2015-10-29
     */
    var TaskManager = (function (_super) {
        __extends(TaskManager, _super);
        /**
         * 创建一个任务管理器
         */
        function TaskManager() {
            this.init();
        }
        /**
         * @inheritDoc
         */
        TaskManager.prototype.init = function () {
            //初始化默认任务集合类型字典
            this.taskCollectionTypeDic = {};
            this.executingTaskCollectionDic = {};
            this.registerTaskCollectionType(feng3d.TaskCollectionType.LIST, feng3d.TaskList);
            this.registerTaskCollectionType(feng3d.TaskCollectionType.QUEUE, feng3d.TaskQueue);
            this.addListeners();
        };
        /**
         * 注册任务集合类型
         * @param taskCollectionType			任务类型名称
         * @param taskCollectionTypeClass		任务类型定义
         */
        TaskManager.prototype.registerTaskCollectionType = function (taskCollectionType, taskCollectionTypeClass) {
            this.taskCollectionTypeDic[taskCollectionType] = taskCollectionTypeClass;
        };
        /**
         * 添加事件监听器
         */
        TaskManager.prototype.addListeners = function () {
            dispatcher.addEventListener(feng3d.TaskModuleEvent.DISPATCH_TASK, this.onDispatchTask);
            dispatcher.addEventListener(feng3d.TaskModuleEvent.REGISTER_TASKCOLLECTIONTYPE, this.onRegisterTaskCollectionType);
        };
        TaskManager.prototype.onRegisterTaskCollectionType = function (event) {
            var data = event.data;
            this.registerTaskCollectionType(data.taskCollectionType, data.taskCollectionTypeClass);
        };
        /**
         * 处理派发的任务事件
         */
        TaskManager.prototype.onDispatchTask = function (event) {
            var data = event.data;
            var taskCollectionCls = this.taskCollectionTypeDic[data.taskCollectionType];
            feng3d.assert(taskCollectionCls != null, "尝试使用未注册的（" + data.taskCollectionType + "）任务集合类型");
            var taskCollection = new taskCollectionCls();
            this.executingTaskCollectionDic[taskCollection] = data;
            taskCollection.addEventListener(feng3d.TaskEvent.COMPLETEDITEM, this.onCompletedItem);
            taskCollection.addEventListener(feng3d.TaskEvent.COMPLETED, this.onCompleted);
            taskCollection.addItems(data.taskList);
            taskCollection.execute(data.params);
        };
        /**
         * 处理完成任务事件
         */
        TaskManager.prototype.onCompleted = function (event) {
            var taskCollection = event.currentTarget;
            var data = this.executingTaskCollectionDic[taskCollection];
            data.dispatchEvent(event);
            taskCollection.removeEventListener(feng3d.TaskEvent.COMPLETEDITEM, this.onCompletedItem);
            taskCollection.removeEventListener(feng3d.TaskEvent.COMPLETED, this.onCompleted);
            delete this.executingTaskCollectionDic[taskCollection];
        };
        /**
         * 处理完成单个任务事件
         */
        TaskManager.prototype.onCompletedItem = function (event) {
            var taskCollection = event.currentTarget;
            var data = this.executingTaskCollectionDic[taskCollection];
            data.dispatchEvent(event);
        };
        return TaskManager;
    }(feng3d.FModuleManager));
    feng3d.TaskManager = TaskManager;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 公共库调试类
     * @author feng 2015-7-23
     */
    var DebugCommon = (function () {
        function DebugCommon() {
        }
        /**
         * 日志方法
         */
        DebugCommon.loggerFunc = console.log;
        return DebugCommon;
    }());
    feng3d.DebugCommon = DebugCommon;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 断言
     * @b			判定为真的表达式
     * @msg			在表达式为假时将输出的错误信息
     * @author feng 2014-10-29
     */
    function assert(b, msg) {
        if (msg === void 0) { msg = "assert"; }
        if (!b)
            throw new Error(msg);
    }
    feng3d.assert = assert;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 枚举类
     * <p>用于实现类似其他语言的枚举对象，该类为虚类，无法直接实例化，请使用子类</p>
     * <p>枚举元素必须使用 public static 定义</p>
     * @includeExample EnumTest.as
     * @includeExample TypeEnum.as
     * @includeExample TypeEnum1.as
     *
     * @author feng 2015-5-7
     */
    var Enum = (function () {
        /**
         * 无法直接实例化
         */
        function Enum() {
            this.className = getQualifiedClassName(this);
            this.type = this.className.split("::").pop();
            //获取枚举的值
            this.value = number(autoIndexDic[this.className]);
            autoIndexDic[this.className] = this.value + 1;
        }
        /**
         * 转换值
         * @see http://filimanjaro.com/blog/2012/operators-overloading-in-as3-javascript-too-%E2%80%93-workaround/
         */
        Enum.prototype.valueOf = function () {
            return this.value;
        };
        /**
         * 输出为字符串
         */
        Enum.prototype.toString = function () {
            return this.type + "-" + this.value;
        };
        /**
         * 枚举计数字典
         */
        Enum.autoIndexDic = {};
        return Enum;
    }());
    feng3d.Enum = Enum;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 动画类型
     * @author feng 2015-1-27
     */
    var AnimationType = (function (_super) {
        __extends(AnimationType, _super);
        function AnimationType() {
            _super.apply(this, arguments);
        }
        /** 没有动画 */
        AnimationType.NONE = new AnimationType();
        /** 顶点动画由GPU计算 */
        AnimationType.VERTEX_CPU = new AnimationType();
        /** 顶点动画由GPU计算 */
        AnimationType.VERTEX_GPU = new AnimationType();
        /** 骨骼动画由GPU计算 */
        AnimationType.SKELETON_CPU = new AnimationType();
        /** 骨骼动画由GPU计算 */
        AnimationType.SKELETON_GPU = new AnimationType();
        /** 粒子特效 */
        AnimationType.PARTICLE = new AnimationType();
        return AnimationType;
    }(feng3d.Enum));
    feng3d.AnimationType = AnimationType;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 抽象类错误
     * @author feng 2015-2-13
     */
    var AbstractClassError = (function (_super) {
        __extends(AbstractClassError, _super);
        /**
         * 创建一个抽象类错误
         * @param message 与 Error 对象关联的字符串；此参数为可选。
         * @param id 与特定错误消息关联的引用数字。
         */
        function AbstractClassError(message, id) {
            if (message === void 0) { message = null; }
            if (id === void 0) { id = 0; }
            _super.call(this, message || "无法直接实例化抽象类", id);
        }
        /**
         * 核查可能存在的创建抽象类错误
         * @param obj			用来检测的对象
         */
        AbstractClassError.check = function (obj) {
            var className = getQualifiedClassName(obj);
            //通过抽象类获取 完全限定类名
            var error = new AbstractClassError("无法直接实例化抽象类" + className);
            var stackTrace = error.getStackTrace();
            var classLine = stackTrace.split("\n")[2];
            var className0 = classLine.substring(classLine.indexOf("at") + 2, classLine.indexOf("("));
            className0 = className0.replace(/\s/g, "");
            //判断是否实例化抽象类
            if (className == className0) {
                throw error;
            }
        };
        return AbstractClassError;
    }(Error));
    feng3d.AbstractClassError = AbstractClassError;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 抽象方法错误
     * @author feng 2015-2-13
     */
    var AbstractMethodError = (function (_super) {
        __extends(AbstractMethodError, _super);
        /**
         * 创建一个抽象方法错误
         * @param message 与 Error 对象关联的字符串；此参数为可选。
         * @param id 与特定错误消息关联的引用数字。
         */
        function AbstractMethodError(message, id) {
            if (message === void 0) { message = null; }
            if (id === void 0) { id = 0; }
            _super.call(this, message || "子类没有重写抽象方法", id);
        }
        return AbstractMethodError;
    }(Error));
    feng3d.AbstractMethodError = AbstractMethodError;
})(feng3d || (feng3d = {}));
var feng3dBeat;
(function (feng3dBeat) {
    /**
     *
     * @author cdz 2015-10-31
     */
    var HeartBeatModuleData = (function () {
        /**
         *
         * @param taskCollectionType			任务集合类型名称
         * @param taskCollectionTypeClass		任务集合类型定义
         */
        function HeartBeatModuleData(BeatType, Interval) {
            this.BeatType = BeatType;
            this.Interval = Interval;
        }
        return HeartBeatModuleData;
    }());
    feng3dBeat.HeartBeatModuleData = HeartBeatModuleData;
})(feng3dBeat || (feng3dBeat = {}));
var feng3d;
(function (feng3d) {
    /**
     * 任务模块事件注册任务类型数据
     * @author feng 2015-10-30
     */
    var TaskModuleEventRegisterData = (function () {
        /**
         *
         * @param taskCollectionType			任务集合类型名称
         * @param taskCollectionTypeClass		任务集合类型定义
         */
        function TaskModuleEventRegisterData(taskCollectionType, taskCollectionTypeClass) {
            this.taskCollectionType = taskCollectionType;
            this.taskCollectionTypeClass = taskCollectionTypeClass;
        }
        return TaskModuleEventRegisterData;
    }());
    feng3d.TaskModuleEventRegisterData = TaskModuleEventRegisterData;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 自定义事件
     * @author warden_feng 2014-5-7
     */
    var Event = (function () {
        /**
         * 创建一个作为参数传递给事件侦听器的 Event 对象。
         * @param type 事件的类型，可以作为 Event.type 访问。
         * @param bubbles 确定 Event 对象是否参与事件流的冒泡阶段。默认值为 false。
         * @param cancelable 确定是否可以取消 Event 对象。默认值为 false。
         */
        function Event(type, data, bubbles, cancelable) {
            if (data === void 0) { data = null; }
            if (bubbles === void 0) { bubbles = false; }
            if (cancelable === void 0) { cancelable = false; }
            this._type = type;
            this._data = data;
            this._bubbles = bubbles;
        }
        /**
         * 防止对事件流中当前节点中和所有后续节点中的事件侦听器进行处理。此方法会立即生效，并且会影响当前节点中的事件侦听器。相比之下，在当前节点中的所有事件侦听器都完成处理之前，stopPropagation() 方法不会生效。
         */
        Event.prototype.stopImmediatePropagation = function () {
            this._stopsPropagation = this._stopsImmediatePropagation = true;
        };
        /**
         * 防止对事件流中当前节点的后续节点中的所有事件侦听器进行处理。此方法不会影响当前节点 (currentTarget) 中的任何事件侦听器。相比之下，stopImmediatePropagation() 方法可以防止对当前节点中和后续节点中的事件侦听器进行处理。对此方法的其他调用没有任何效果。可以在事件流的任何阶段中调用此方法。
         */
        Event.prototype.stopPropagation = function () {
            this._stopsPropagation = true;
        };
        Event.prototype.tostring = function () {
            return "[" + (typeof this) + " type=\"" + this._type + "\" bubbles=" + this._bubbles + "]";
        };
        Object.defineProperty(Event.prototype, "bubbles", {
            /**
             * 表示事件是否为冒泡事件。如果事件可以冒泡，则此值为 true；否则为 false。
             */
            get: function () {
                return this._bubbles;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Event.prototype, "type", {
            /**
             * 事件的类型。类型区分大小写。
             */
            get: function () {
                return this._type;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Event.prototype, "data", {
            /** 事件携带的自定义数据 */
            get: function () {
                return this._data;
            },
            /**
             * @private
             */
            set: function (value) {
                this._data = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Event.prototype, "target", {
            /**
             * 事件目标。
             */
            get: function () {
                return this._target;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Event.prototype, "currentTarget", {
            /**
             * 当前正在使用某个事件侦听器处理 Event 对象的对象。
             */
            get: function () {
                return this._currentTarget;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Event.prototype, "stopsImmediatePropagation", {
            get: function () {
                return this._stopsImmediatePropagation;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Event.prototype, "stopsPropagation", {
            get: function () {
                return this._stopsPropagation;
            },
            enumerable: true,
            configurable: true
        });
        Event.prototype.setTarget = function (value) {
            this._target = value;
        };
        Event.prototype.setCurrentTarget = function (value) {
            this._currentTarget = value;
        };
        return Event;
    }());
    feng3d.Event = Event;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 为了实现非flash原生显示列表的冒泡事件，自定义事件适配器
     * @author feng 2016-3-22
     */
    var EventDispatcher = (function () {
        /**
         * 构建事件适配器
         * @param target		事件适配主体
         */
        function EventDispatcher(target) {
            if (target === void 0) { target = null; }
            this._target = target;
            if (this._target == null)
                this._target = this;
            this._eventListeners = {};
        }
        EventDispatcher.prototype.addEventListener = function (type, listener, priority, useWeakReference) {
            if (priority === void 0) { priority = 0; }
            if (useWeakReference === void 0) { useWeakReference = false; }
            if (listener == null)
                return;
            var listeners = this._eventListeners[type];
            if (listeners == null)
                listeners = this._eventListeners[type] = [];
            var index = listeners.indexOf(listener);
            if (index == -1) {
                listeners.push(listener);
            }
        };
        EventDispatcher.prototype.removeEventListener = function (type, listener) {
            if (this._eventListeners) {
                var listeners = this._eventListeners[type];
                var index = listeners.indexOf(listener);
                listeners.splice(index, 1);
            }
        };
        EventDispatcher.prototype.removeEventListeners = function (type) {
            if (type === void 0) { type = null; }
            if (type && this._eventListeners)
                delete this._eventListeners[type];
            else
                this._eventListeners = {};
        };
        /**
         * @inheritDoc
         */
        EventDispatcher.prototype.dispatchEvent = function (event) {
            var _this = this;
            //停止事件流
            if (!event || event.stopsPropagation)
                return false;
            //设置目标
            if (!event.target)
                event.setTarget(this._target);
            //处理当前事件(目标阶段)
            var listeners = this._eventListeners[event.type];
            if (!event.stopsImmediatePropagation) {
                listeners.forEach(function (listener) {
                    //设置当前目标
                    event.setCurrentTarget(_this._target);
                    listener(event);
                });
            }
            //事件冒泡(冒泡阶段)
            if (event.bubbles && this.parentDispatcher) {
                this.parentDispatcher.dispatchEvent(event);
            }
            return event.stopsPropagation;
        };
        EventDispatcher.prototype.hasEventListener = function (type) {
            var listeners = this._eventListeners ? this._eventListeners[type] : null;
            for (var key in listeners) {
                return true;
            }
            return false;
        };
        /**
         * 该功能暂未实现
         * @param type
         * @return
         */
        EventDispatcher.prototype.willTrigger = function (type) {
            // TODO Auto Generated method stub
            return false;
        };
        Object.defineProperty(EventDispatcher.prototype, "parentDispatcher", {
            /**
             * 父事件适配器
             */
            get: function () {
                return this._target[EventDispatcher.BUBBLE_PROPERTY];
            },
            enumerable: true,
            configurable: true
        });
        /** 冒泡属性名称为“parent” */
        EventDispatcher.BUBBLE_PROPERTY = "parent";
        return EventDispatcher;
    }());
    feng3d.EventDispatcher = EventDispatcher;
})(feng3d || (feng3d = {}));
var feng3dBeat;
(function (feng3dBeat) {
    /**
     *
     * @author cdz 2015-10-31
     */
    var HeartBeatEvent = (function (_super) {
        __extends(HeartBeatEvent, _super);
        function HeartBeatEvent(type, data, bubbles, cancelable) {
            if (data === void 0) { data = null; }
            if (bubbles === void 0) { bubbles = false; }
            if (cancelable === void 0) { cancelable = false; }
            _super.call(this, type, data, bubbles, cancelable);
        }
        /** 渲染心跳 */
        HeartBeatEvent.RENDER_BEAT = "renderBeat";
        /** 逻辑心跳 */
        HeartBeatEvent.LOGIC_BEAT = "logicBeat";
        /** 资源解析心跳 */
        HeartBeatEvent.RESOURCE_PARSE_BEAT = "resourceParseBeat";
        /** 物理心跳 */
        HeartBeatEvent.PHYSICS_BEAT = "physicsBeat";
        /** 鼠标检测心跳 */
        HeartBeatEvent.MOUSE_CHECK_BEAT = "MouseCheckBeat";
        return HeartBeatEvent;
    }(Event));
    feng3dBeat.HeartBeatEvent = HeartBeatEvent;
})(feng3dBeat || (feng3dBeat = {}));
var feng3d;
(function (feng3d) {
    /**
     * 组件事件
     * @author feng 2015-12-2
     */
    var ComponentEvent = (function (_super) {
        __extends(ComponentEvent, _super);
        function ComponentEvent() {
            _super.apply(this, arguments);
        }
        /**
         * 添加子组件事件
         */
        ComponentEvent.ADDED_COMPONET = "addedComponet";
        /**
         * 被组件容器添加事件
         */
        ComponentEvent.BE_ADDED_COMPONET = "beAddedComponet";
        /**
         * 移除子组件事件
         */
        ComponentEvent.REMOVED_COMPONET = "removedComponet";
        /**
         * 被容器删除事件
         */
        ComponentEvent.BE_REMOVED_COMPONET = "beRemovedComponet";
        return ComponentEvent;
    }(feng3d.Event));
    feng3d.ComponentEvent = ComponentEvent;
    null, bubbles;
    boolean = false, cancelable;
    boolean = false;
    {
        _super.call(this, type, data, bubbles, cancelable);
    }
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 错误事件
     * <p>为了与flash.events.ErrorEvent区分添加前缀F</p>
     * @author feng 2015-12-7
     */
    var FErrorEvent = (function (_super) {
        __extends(FErrorEvent, _super);
        function FErrorEvent() {
            _super.apply(this, arguments);
        }
        /**
         * 错误事件
         */
        FErrorEvent.ERROR_EVENT = "errorEvent";
        return FErrorEvent;
    }(feng3d.ComponentEvent));
    feng3d.FErrorEvent = FErrorEvent;
    null, bubbles;
    boolean = false, cancelable;
    boolean = false;
    {
        _super.call(this, type, data, bubbles, cancelable);
    }
})(feng3d || (feng3d = {}));
var feng3dBeat;
(function (feng3dBeat) {
    /**
     *
     * @author cdz 2015-10-31
     */
    var HeartBeatModuleEvent = (function (_super) {
        __extends(HeartBeatModuleEvent, _super);
        function HeartBeatModuleEvent() {
            _super.apply(this, arguments);
        }
        /** 注册心跳类型 */
        HeartBeatModuleEvent.REGISTER_BEAT_TYPE = "registerBeatType";
        /** 注销心跳类型 */
        HeartBeatModuleEvent.UNREGISTER_BEAT_TYPE = "unregisterBeatType";
        /** 暂停一个心跳类型 */
        HeartBeatModuleEvent.SUSPEND_ONE_BEAT = "suspendOneBeat";
        /** 恢复心跳类型 */
        HeartBeatModuleEvent.RESUME_ONE_BEAT = "resumeOneBeat";
        /** 停止所有心跳 */
        HeartBeatModuleEvent.SUSPEND_All_BEAT = "suspendAllBeat";
        /** 停止所有心跳 */
        HeartBeatModuleEvent.RESUME_ALL_BEAT = "resumeAllBeat";
        return HeartBeatModuleEvent;
    }(Event));
    feng3dBeat.HeartBeatModuleEvent = HeartBeatModuleEvent;
    null, bubbles;
    boolean = false, cancelable;
    boolean = false;
    {
        _super.call(this, type, data, bubbles, cancelable);
    }
})(feng3dBeat || (feng3dBeat = {}));
var feng3d;
(function (feng3d) {
    /**
     * 加载事件
     * @author feng 2014-7-25
     */
    var LoadModuleEvent = (function (_super) {
        __extends(LoadModuleEvent, _super);
        /**
         * 创建一个加载事件。
         * @param data					加载事件数据
         * @param type 					事件的类型，可以作为 Event.type 访问。
         * @param bubbles 				确定 Event 对象是否参与事件流的冒泡阶段。默认值为 false。
         * @param cancelable 			确定是否可以取消 Event 对象。默认值为 false。
         */
        function LoadModuleEvent(type, data, bubbles, cancelable) {
            if (bubbles === void 0) { bubbles = false; }
            if (cancelable === void 0) { cancelable = false; }
            _super.call(this, type, data, bubbles, cancelable);
        }
        Object.defineProperty(LoadModuleEvent.prototype, "loadEventData", {
            /**
             * 加载事件数据
             */
            get: function () {
                return data;
            },
            enumerable: true,
            configurable: true
        });
        /** 加载资源 */
        LoadModuleEvent.LOAD_RESOURCE = "loadResource";
        return LoadModuleEvent;
    }(feng3d.Event));
    feng3d.LoadModuleEvent = LoadModuleEvent;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 任务模块事件
     * @author feng 2015-10-29
     */
    var TaskModuleEvent = (function (_super) {
        __extends(TaskModuleEvent, _super);
        function TaskModuleEvent() {
            _super.apply(this, arguments);
        }
        /** 派发任务 */
        TaskModuleEvent.DISPATCH_TASK = "dispatchTask";
        /** 注册任务集合类型 */
        TaskModuleEvent.REGISTER_TASKCOLLECTIONTYPE = "registerTaskCollectionType";
        return TaskModuleEvent;
    }(feng3d.Event));
    feng3d.TaskModuleEvent = TaskModuleEvent;
    null, bubbles;
    boolean = false, cancelable;
    boolean = false;
    {
        _super.call(this, type, data, bubbles, cancelable);
    }
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 加载url事件
     * @author feng 2015-10-22
     */
    var LoadUrlEvent = (function (_super) {
        __extends(LoadUrlEvent, _super);
        /**
         * 创建一个加载事件。
         * @param data					加载事件数据
         * @param type 					事件的类型，可以作为 Event.type 访问。
         * @param bubbles 				确定 Event 对象是否参与事件流的冒泡阶段。默认值为 false。
         * @param cancelable 			确定是否可以取消 Event 对象。默认值为 false。
         */
        function LoadUrlEvent(type, data, bubbles, cancelable) {
            if (data === void 0) { data = null; }
            if (bubbles === void 0) { bubbles = false; }
            if (cancelable === void 0) { cancelable = false; }
            _super.call(this, type, data, bubbles, cancelable);
        }
        Object.defineProperty(LoadUrlEvent.prototype, "loadTaskItem", {
            /**
             * 加载事件数据
             */
            get: function () {
                return data;
            },
            enumerable: true,
            configurable: true
        });
        /** 单项资源加载完成 */
        LoadUrlEvent.LOAD_SINGLE_COMPLETE = "loadSingleComplete";
        /** 资源加载完成 */
        LoadUrlEvent.LOAD_COMPLETE = "loadComplete";
        return LoadUrlEvent;
    }(feng3d.Event));
    feng3d.LoadUrlEvent = LoadUrlEvent;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 任务事件
     * @author feng 2014-7-24
     */
    var TaskEvent = (function (_super) {
        __extends(TaskEvent, _super);
        function TaskEvent() {
            _super.apply(this, arguments);
        }
        /** 完成任务 */
        TaskEvent.COMPLETED = "completed";
        /** 完成一个任务单元 */
        TaskEvent.COMPLETEDITEM = "completedItem";
        return TaskEvent;
    }(feng3d.Event));
    feng3d.TaskEvent = TaskEvent;
    null, bubbles;
    boolean = false, cancelable;
    boolean = false;
    {
        _super.call(this, type, data, bubbles, cancelable);
    }
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * Dispatched to notify changes in an animation state's state.
     */
    var AnimationStateEvent = (function (_super) {
        __extends(AnimationStateEvent, _super);
        /**
         * Create a new <code>AnimatonStateEvent</code>
         *
         * @param type The event type.
         * @param animator The animation state object that is the subject of this event.
         * @param animationNode The animation node inside the animation state from which the event originated.
         */
        function AnimationStateEvent(type, animator, animationState, animationNode) {
            _super.call(this, type, false, false);
            this._animator = animator;
            this._animationState = animationState;
            this._animationNode = animationNode;
        }
        Object.defineProperty(AnimationStateEvent.prototype, "animator", {
            /**
             * The animator object that is the subject of this event.
             */
            get: function () {
                return _animator;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AnimationStateEvent.prototype, "animationState", {
            /**
             * The animation state object that is the subject of this event.
             */
            get: function () {
                return _animationState;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AnimationStateEvent.prototype, "animationNode", {
            /**
             * The animation node inside the animation state from which the event originated.
             */
            get: function () {
                return _animationNode;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Clones the event.
         *
         * @return An exact duplicate of the current object.
         */
        AnimationStateEvent.prototype.clone = function () {
            return new AnimationStateEvent(this.type, this._animator, this._animationState, this._animationNode);
        };
        /**
         * Dispatched when a non-looping clip node inside an animation state reaches the end of its timeline.
         */
        AnimationStateEvent.PLAYBACK_COMPLETE = "playbackComplete";
        AnimationStateEvent.TRANSITION_COMPLETE = "transitionComplete";
        return AnimationStateEvent;
    }(feng3d.Event));
    feng3d.AnimationStateEvent = AnimationStateEvent;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 动画事件
     * @author feng 2014-5-27
     */
    var AnimatorEvent = (function (_super) {
        __extends(AnimatorEvent, _super);
        function AnimatorEvent() {
            _super.apply(this, arguments);
        }
        /** 开始播放动画 */
        AnimatorEvent.START = "start";
        /** 继续播放动画 */
        AnimatorEvent.PLAY = "play";
        /** 停止播放动画 */
        AnimatorEvent.STOP = "stop";
        /** 周期完成 */
        AnimatorEvent.CYCLE_COMPLETE = "cycle_complete";
        return AnimatorEvent;
    }(feng3d.Event));
    feng3d.AnimatorEvent = AnimatorEvent;
    null, bubbles;
    boolean = false;
    {
        _super.call(this, type, data, bubbles);
    }
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * Dispatched whenever a ressource (asset) is parsed and created completly.
     */
    var AssetEvent = (function (_super) {
        __extends(AssetEvent, _super);
        function AssetEvent(type, asset, prevName) {
            if (asset === void 0) { asset = null; }
            if (prevName === void 0) { prevName = null; }
            _super.call(this, type);
            this._asset = asset;
            this._prevName = prevName || (this._asset ? this._asset.namedAsset.name : null);
        }
        Object.defineProperty(AssetEvent.prototype, "asset", {
            get: function () {
                return _asset;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AssetEvent.prototype, "assetPrevName", {
            get: function () {
                return _prevName;
            },
            enumerable: true,
            configurable: true
        });
        AssetEvent.ASSET_COMPLETE = "assetComplete";
        AssetEvent.ENTITY_COMPLETE = "entityComplete";
        AssetEvent.SKYBOX_COMPLETE = "skyboxComplete";
        AssetEvent.CAMERA_COMPLETE = "cameraComplete";
        AssetEvent.MESH_COMPLETE = "meshComplete";
        AssetEvent.GEOMETRY_COMPLETE = "geometryComplete";
        AssetEvent.SKELETON_COMPLETE = "skeletonComplete";
        AssetEvent.SKELETON_POSE_COMPLETE = "skeletonPoseComplete";
        AssetEvent.CONTAINER_COMPLETE = "containerComplete";
        AssetEvent.TEXTURE_COMPLETE = "textureComplete";
        AssetEvent.TEXTURE_PROJECTOR_COMPLETE = "textureProjectorComplete";
        AssetEvent.MATERIAL_COMPLETE = "materialComplete";
        AssetEvent.ANIMATOR_COMPLETE = "animatorComplete";
        AssetEvent.ANIMATION_SET_COMPLETE = "animationSetComplete";
        AssetEvent.ANIMATION_STATE_COMPLETE = "animationStateComplete";
        AssetEvent.ANIMATION_NODE_COMPLETE = "animationNodeComplete";
        AssetEvent.STATE_TRANSITION_COMPLETE = "stateTransitionComplete";
        AssetEvent.SEGMENT_SET_COMPLETE = "segmentSetComplete";
        AssetEvent.LIGHT_COMPLETE = "lightComplete";
        AssetEvent.LIGHTPICKER_COMPLETE = "lightPickerComplete";
        AssetEvent.EFFECTMETHOD_COMPLETE = "effectMethodComplete";
        AssetEvent.SHADOWMAPMETHOD_COMPLETE = "shadowMapMethodComplete";
        AssetEvent.ASSET_RENAME = 'assetRename';
        AssetEvent.ASSET_CONFLICT_RESOLVED = 'assetConflictResolved';
        AssetEvent.TEXTURE_SIZE_ERROR = 'textureSizeError';
        return AssetEvent;
    }(feng3d.Event));
    feng3d.AssetEvent = AssetEvent;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 摄像机事件
     * @author feng 2014-10-14
     */
    var CameraEvent = (function (_super) {
        __extends(CameraEvent, _super);
        function CameraEvent(type, camera, bubbles) {
            if (camera === void 0) { camera = null; }
            if (bubbles === void 0) { bubbles = false; }
            _super.call(this, type, this.data, bubbles);
        }
        Object.defineProperty(CameraEvent.prototype, "camera", {
            get: function () {
                return data;
            },
            enumerable: true,
            configurable: true
        });
        CameraEvent.LENS_CHANGED = "lensChanged";
        return CameraEvent;
    }(feng3d.Event));
    feng3d.CameraEvent = CameraEvent;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     *
     * @author feng 2014-9-10
     */
    var Container3DEvent = (function (_super) {
        __extends(Container3DEvent, _super);
        function Container3DEvent() {
            _super.apply(this, arguments);
        }
        return Container3DEvent;
    }(feng3d.Event));
    feng3d.Container3DEvent = Container3DEvent;
    null, bubbles;
    boolean = false;
    {
        _super.call(this, type, data, bubbles);
    }
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 3D环境缓冲拥有者事件
     * @author feng 2015-7-18
     */
    var Context3DBufferOwnerEvent = (function (_super) {
        __extends(Context3DBufferOwnerEvent, _super);
        function Context3DBufferOwnerEvent() {
            _super.apply(this, arguments);
        }
        /**
         * 添加3D环境缓冲事件
         */
        Context3DBufferOwnerEvent.ADD_CONTEXT3DBUFFER = "addContext3DBuffer";
        /**
         * 移除3D环境缓冲事件
         */
        Context3DBufferOwnerEvent.REMOVE_CONTEXT3DBUFFER = "removeContext3DBuffer";
        /**
         * 添加子项3D环境缓冲拥有者事件
         */
        Context3DBufferOwnerEvent.ADDCHILD_CONTEXT3DBUFFEROWNER = "addChildContext3DBufferOwner";
        /**
         * 移除子项3D环境缓冲拥有者事件
         */
        Context3DBufferOwnerEvent.REMOVECHILD_CONTEXT3DBUFFEROWNER = "removeChildContext3DBufferOwner";
        return Context3DBufferOwnerEvent;
    }(feng3d.Event));
    feng3d.Context3DBufferOwnerEvent = Context3DBufferOwnerEvent;
    null, bubbles;
    boolean = false, cancelable;
    boolean = false;
    {
        _super.call(this, type, data, bubbles, cancelable);
    }
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * Fagal函数事件
     * @author feng 2015-8-8
     */
    var FagalMathEvent = (function (_super) {
        __extends(FagalMathEvent, _super);
        /**
         * 创建一个作为参数传递给事件侦听器的 Event 对象.
         * @param type 					事件的类型，可以作为 Event.type 访问。
         * @param code					fagal代码
         * @param bubbles 				确定 Event 对象是否参与事件流的冒泡阶段。默认值为 false。
         * @param cancelable 			确定是否可以取消 Event 对象。默认值为 false。
         */
        function FagalMathEvent(type, code, bubbles, cancelable) {
            if (bubbles === void 0) { bubbles = false; }
            if (cancelable === void 0) { cancelable = false; }
            _super.call(this, type, code, bubbles, cancelable);
        }
        Object.defineProperty(FagalMathEvent.prototype, "code", {
            /**
             * fagal代码
             */
            get: function () {
                return data;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Fagal函数追加代码事件
         */
        FagalMathEvent.FAGALMATHEVENT_APPEND = "fagalMathEventAppend";
        return FagalMathEvent;
    }(feng3d.Event));
    feng3d.FagalMathEvent = FagalMathEvent;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 几何体组件事件
     * @author feng 2015-12-8
     */
    var GeometryComponentEvent = (function (_super) {
        __extends(GeometryComponentEvent, _super);
        function GeometryComponentEvent() {
            _super.apply(this, arguments);
        }
        /**
         * 获取几何体顶点数据
         */
        GeometryComponentEvent.GET_VA_DATA = "getVAData";
        /**
         * 改变几何体顶点数据事件
         */
        GeometryComponentEvent.CHANGED_VA_DATA = "changedVAData";
        /**
         * 改变顶点索引数据事件
         */
        GeometryComponentEvent.CHANGED_INDEX_DATA = "changedIndexData";
        return GeometryComponentEvent;
    }(feng3d.Event));
    feng3d.GeometryComponentEvent = GeometryComponentEvent;
    null, bubbles;
    boolean = false, cancelable;
    boolean = false;
    {
        _super.call(this, type, data, bubbles, cancelable);
    }
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 几何体事件
     * @author feng 2014-5-15
     */
    var GeometryEvent = (function (_super) {
        __extends(GeometryEvent, _super);
        function GeometryEvent(type, subGeometry, bubbles, cancelable) {
            if (subGeometry === void 0) { subGeometry = null; }
            if (bubbles === void 0) { bubbles = false; }
            if (cancelable === void 0) { cancelable = false; }
            _super.call(this, type, subGeometry, bubbles, cancelable);
            this._subGeometry = subGeometry;
        }
        Object.defineProperty(GeometryEvent.prototype, "subGeometry", {
            get: function () {
                return _subGeometry;
            },
            enumerable: true,
            configurable: true
        });
        /** 添加子几何体 */
        GeometryEvent.SUB_GEOMETRY_ADDED = "SubGeometryAdded";
        /** 溢出子几何体 */
        GeometryEvent.SUB_GEOMETRY_REMOVED = "SubGeometryRemoved";
        /** 几何体外形发生改变 */
        GeometryEvent.SHAPE_CHANGE = "shapeChange";
        return GeometryEvent;
    }(feng3d.Event));
    feng3d.GeometryEvent = GeometryEvent;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 镜头事件
     * @author feng 2014-10-14
     */
    var LensEvent = (function (_super) {
        __extends(LensEvent, _super);
        function LensEvent(type, lens, bubbles, cancelable) {
            if (lens === void 0) { lens = null; }
            if (bubbles === void 0) { bubbles = false; }
            if (cancelable === void 0) { cancelable = false; }
            _super.call(this, type, this.data, bubbles, cancelable);
        }
        Object.defineProperty(LensEvent.prototype, "lens", {
            get: function () {
                return data;
            },
            enumerable: true,
            configurable: true
        });
        LensEvent.MATRIX_CHANGED = "matrixChanged";
        return LensEvent;
    }(feng3d.Event));
    feng3d.LensEvent = LensEvent;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     *
     * @author feng 2015-5-28
     */
    var LightEvent = (function (_super) {
        __extends(LightEvent, _super);
        function LightEvent() {
            _super.apply(this, arguments);
        }
        LightEvent.CASTS_SHADOW_CHANGE = "castsShadowChange";
        return LightEvent;
    }(feng3d.Event));
    feng3d.LightEvent = LightEvent;
    null, bubbles;
    boolean = false, cancelable;
    boolean = false;
    {
        _super.call(this, type, data, bubbles, cancelable);
    }
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 材质事件
     * @author feng 2014-9-9
     */
    var MaterialEvent = (function (_super) {
        __extends(MaterialEvent, _super);
        function MaterialEvent() {
            _super.apply(this, arguments);
        }
        /** 添加pass */
        MaterialEvent.PASS_ADDED = "passAdded";
        /** 移除pass */
        MaterialEvent.PASS_REMOVED = "passRemoved";
        return MaterialEvent;
    }(feng3d.Event));
    feng3d.MaterialEvent = MaterialEvent;
    null, bubbles;
    boolean = false;
    {
        _super.call(this, type, data, bubbles);
    }
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 网格事件
     * @author feng 2015-3-20
     */
    var MeshEvent = (function (_super) {
        __extends(MeshEvent, _super);
        function MeshEvent() {
            _super.apply(this, arguments);
        }
        /**
         * 材质发生变化
         */
        MeshEvent.MATERIAL_CHANGE = "materialChange";
        return MeshEvent;
    }(feng3d.Event));
    feng3d.MeshEvent = MeshEvent;
    null, bubbles;
    boolean = false, cancelable;
    boolean = false;
    {
        _super.call(this, type, data, bubbles, cancelable);
    }
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 3d鼠标事件
     * @author feng 2014-4-29
     * @see flash.events.MouseEvent
     */
    var MouseEvent3D = (function (_super) {
        __extends(MouseEvent3D, _super);
        function MouseEvent3D() {
            _super.apply(this, arguments);
        }
        /**
         * 单击
         */
        MouseEvent3D.CLICK = "click3d";
        /**
         * 鼠标移人对象
         */
        MouseEvent3D.MOUSE_OVER = "mouseOver3d";
        /**
         * 鼠标移出对象
         */
        MouseEvent3D.MOUSE_OUT = "mouseOut3d";
        /**
         * 鼠标在对象上移动
         */
        MouseEvent3D.MOUSE_MOVE = "mouseMove3d";
        /**
         * 鼠标在对象上双击
         */
        MouseEvent3D.DOUBLE_CLICK = "doubleClick3d";
        /**
         * 鼠标在对象上按下
         */
        MouseEvent3D.MOUSE_DOWN = "mouseDown3d";
        /**
         * 鼠标在对象上弹起
         */
        MouseEvent3D.MOUSE_UP = "mouseUp3d";
        /**
         * 鼠标在对象上滚轮滚动
         */
        MouseEvent3D.MOUSE_WHEEL = "mouseWheel3d";
        return MouseEvent3D;
    }(feng3d.Event));
    feng3d.MouseEvent3D = MouseEvent3D;
    null, bubbles;
    boolean = true, cancelable;
    boolean = false;
    {
        _super.call(this, type, data, bubbles, cancelable);
    }
    clone();
    feng3d.Event;
    {
        var cl = _super.clone.call(this);
        cl.object = this.object;
        cl.collider = cl.collider;
        return cl;
    }
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 解析事件
     * @author feng 2014-5-16
     */
    var ParserEvent = (function (_super) {
        __extends(ParserEvent, _super);
        function ParserEvent(type, message) {
            if (message === void 0) { message = ''; }
            _super.call(this, type);
            _message = message;
        }
        Object.defineProperty(ParserEvent.prototype, "message", {
            /**
             * Additional human-readable message. Usually supplied for PARSE_ERROR events.
             */
            get: function () {
                return _message;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Dispatched when parsing of an asset completed.
         */
        ParserEvent.PARSE_COMPLETE = 'parseComplete';
        /**
         * Dispatched when an error occurs while parsing the data (e.g. because it's
         * incorrectly formatted.)
         */
        ParserEvent.PARSE_ERROR = 'parseError';
        /**
         * Dispatched when a parser is ready to have dependencies retrieved and resolved.
         * This is an internal event that should rarely (if ever) be listened for by
         * external classes.
         */
        ParserEvent.READY_FOR_DEPENDENCIES = 'readyForDependencies';
        return ParserEvent;
    }(feng3d.Event));
    feng3d.ParserEvent = ParserEvent;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 渲染函数事件
     * @author feng 2014-7-1
     */
    var ShadingMethodEvent = (function (_super) {
        __extends(ShadingMethodEvent, _super);
        function ShadingMethodEvent() {
            _super.apply(this, arguments);
        }
        /** 渲染函数失效 */
        ShadingMethodEvent.SHADER_INVALIDATED = "ShaderInvalidated";
        return ShadingMethodEvent;
    }(feng3d.Event));
    feng3d.ShadingMethodEvent = ShadingMethodEvent;
    null, bubbles;
    boolean = false, cancelable;
    boolean = false;
    {
        _super.call(this, type, data, bubbles, cancelable);
    }
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 3D对象事件(3D状态发生改变、位置、旋转、缩放)
     * @author feng 2014-3-31
     */
    var Transform3DEvent = (function (_super) {
        __extends(Transform3DEvent, _super);
        /**
         * 创建3D对象事件
         * @param type			事件类型
         * @param element3D		发出事件的3D元素
         */
        function Transform3DEvent(type, element3D, bubbles, cancelable) {
            if (bubbles === void 0) { bubbles = false; }
            if (cancelable === void 0) { cancelable = false; }
            _super.call(this, type, element3D, bubbles, cancelable);
        }
        Object.defineProperty(Transform3DEvent.prototype, "element3D", {
            /**
             * 发出事件的3D元素
             */
            get: function () {
                return data;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 平移
         */
        Transform3DEvent.POSITION_CHANGED = "positionChanged";
        /**
         * 旋转
         */
        Transform3DEvent.ROTATION_CHANGED = "rotationChanged";
        /**
         * 缩放
         */
        Transform3DEvent.SCALE_CHANGED = "scaleChanged";
        /**
         * 变换
         */
        Transform3DEvent.TRANSFORM_CHANGED = "transformChanged";
        /**
         * 变换已更新
         */
        Transform3DEvent.TRANSFORM_UPDATED = "transformUpdated";
        /**
         * 场景变换矩阵发生变化
         */
        Transform3DEvent.SCENETRANSFORM_CHANGED = "scenetransformChanged";
        return Transform3DEvent;
    }(feng3d.Event));
    feng3d.Transform3DEvent = Transform3DEvent;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 被添加到组件容器后触发
     */
    [feng3d.Event(name = "beAddedComponet", type = "me.feng.component.event.ComponentEvent")][feng3d.Event(name = "beRemovedComponet", type = "me.feng.component.event.ComponentEvent")][feng3d.Event(name = "addedComponet", type = "me.feng.component.event.ComponentEvent")][feng3d.Event(name = "removedComponet", type = "me.feng.component.event.ComponentEvent")];
    /**
     * 组件容器（集合）
     * @author feng 2015-5-6
     */
    var Component = (function (_super) {
        __extends(Component, _super);
        /**
         * 创建一个组件容器
         */
        function Component() {
            _super.call(this);
            /**
             * 组件列表
             */
            this.components = []; //我并不喜欢使用vector，这使得我不得不去处理越界的问题，繁琐！此处重新修改为Array！
        }
        Object.defineProperty(Component.prototype, "componentName", {
            /**
             * 组件名称
             */
            get: function () {
                _componentName || ;
                feng3d.ClassUtils.getDefaultName(this);
                return _componentName;
            },
            set: function (value) {
                _componentName = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Component.prototype, "numComponents", {
            /**
             * 子组件个数
             */
            get: function () {
                return components.length;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 添加组件
         * @param com 被添加组件
         */
        Component.prototype.addComponent = function (com) {
            feng3d.assert(com != this, "子项与父项不能相同");
            if (this.hasComponent(com)) {
                this.setComponentIndex(com, this.components.length - 1);
                return;
            }
            this.addComponentAt(com, this.components.length);
        };
        /**
         * 添加组件到指定位置
         * @param component		被添加的组件
         * @param index			插入的位置
         */
        Component.prototype.addComponentAt = function (component, index) {
            feng3d.assert(component != this, "子项与父项不能相同");
            feng3d.assert(index >= 0 && index <= this.numComponents, "给出索引超出范围");
            if (this.hasComponent(component)) {
                index = Math.min(index, this.components.length - 1);
                this.setComponentIndex(component, index);
                return;
            }
            this.components.splice(index, 0, component);
            var addedComponentEventVO = new feng3d.AddedComponentEventVO(this, component);
            var addedComponentEvent = new feng3d.ComponentEvent(feng3d.ComponentEvent.ADDED_COMPONET, addedComponentEventVO);
            this.dispatchEvent(addedComponentEvent);
            var beAddedComponentEvent = new feng3d.ComponentEvent(feng3d.ComponentEvent.BE_ADDED_COMPONET, addedComponentEventVO);
            component.dispatchEvent(beAddedComponentEvent);
        };
        /**
         * 移除组件
         * @param com 被移除组件
         */
        Component.prototype.removeComponent = function (com) {
            feng3d.assert(this.hasComponent(com), "只能移除在容器中的组件");
            var index = this.getComponentIndex(com);
            this.removeComponentAt(index);
        };
        /**
         * 移除组件
         * @param index		要删除的 Component 的子索引。
         */
        Component.prototype.removeComponentAt = function (index) {
            feng3d.assert(index >= 0 && index < this.numComponents, "给出索引超出范围");
            var removeComponent = this.components.splice(index, 1)[0];
            return removeComponent;
        };
        /**
         * 获取组件在容器的索引位置
         * @param com			查询的组件
         * @return				组件在容器的索引位置
         */
        Component.prototype.getComponentIndex = function (com) {
            feng3d.assert(this.components.indexOf(com) != -1, "组件不在容器中");
            var index = this.components.indexOf(com);
            return index;
        };
        /**
         * 设置子组件的位置
         * @param com				子组件
         * @param index				位置索引
         */
        Component.prototype.setComponentIndex = function (com, index) {
            feng3d.assert(index >= 0 && index < this.numComponents, "给出索引超出范围");
            var oldIndex = this.components.indexOf(com);
            feng3d.assert(oldIndex >= 0 && oldIndex < this.numComponents, "子组件不在容器内");
            this.components.splice(oldIndex, 1);
            this.components.splice(index, 0, com);
        };
        /**
         * 获取指定位置索引的子组件
         * @param index			位置索引
         * @return				子组件
         */
        Component.prototype.getComponentAt = ;
        Component.prototype. = function () {
            feng3d.assert(index < this.numComponents, "给出索引超出范围");
            return this.components[index];
        };
        /**
         * 根据组件名称获取组件
         * <p>注意：此处比较的是componentName而非name</p>
         * @param componentName		组件名称
         * @return 					获取到的组件
         */
        Component.prototype.getComponentByName = ;
        Component.prototype. = function () {
            var filterResult = this.getComponentsByName(componentName);
            return filterResult[0];
        };
        /**
         * 获取与给出组件名称相同的所有组件
         * <p>注意：此处比较的是componentName而非name</p>
         * @param componentName		组件名称
         * @return 					获取到的组件
         */
        Component.prototype.getComponentsByName = function (componentName) {
            var filterResult = this.components.filter(function (item) {
                var args = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    args[_i - 1] = arguments[_i];
                }
                return item.componentName == componentName;
            });
            return filterResult;
        };
        /**
         * 根据类定义获取组件
         * <p>如果存在多个则返回第一个</p>
         * @param cls				类定义
         * @return
         */
        Component.prototype.getComponentByClass = ;
        Component.prototype. = function () {
            var component = this.getComponentsByClass(cls)[0];
            return component;
        };
        /**
         * 根据类定义查找组件
         * @param cls		类定义
         * @return			返回与给出类定义一致的组件
         */
        Component.prototype.getComponentsByClass = function (cls) {
            var filterResult = this.components.filter(function (item) {
                var args = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    args[_i - 1] = arguments[_i];
                }
                return feng3d.ClassUtils.isSameClass(item, cls);
            });
            return filterResult;
        };
        /**
         * 根据类定义获取或创建组件
         * <p>当不存在该类型对象时创建一个该组件并且添加到容器中</p>
         * @param cls
         * @return
         */
        Component.prototype.getOrCreateComponentByClass = ;
        Component.prototype. = function () {
            var component = this.getComponentByClass(cls);
            if (component == null) {
                component = new cls();
                this.addComponent(component);
            }
            return component;
        };
        /**
         * 判断是否拥有组件
         * @param com	被检测的组件
         * @return		true：拥有该组件；false：不拥有该组件。
         */
        Component.prototype.hasComponent = function (com) {
            return this.components.indexOf(com) != -1;
        };
        /**
         * 交换子组件位置
         * @param index1		第一个子组件的索引位置
         * @param index2		第二个子组件的索引位置
         */
        Component.prototype.swapComponentsAt = function (index1, index2) {
            feng3d.assert(index1 >= 0 && index1 < this.numComponents, "第一个子组件的索引位置超出范围");
            feng3d.assert(index2 >= 0 && index2 < this.numComponents, "第二个子组件的索引位置超出范围");
            var temp = this.components[index1];
            this.components[index1] = this.components[index2];
            this.components[index2] = temp;
        };
        /**
         * 交换子组件位置
         * @param com1		第一个子组件
         * @param com2		第二个子组件
         */
        Component.prototype.swapComponents = function (com1, com2) {
            feng3d.assert(this.hasComponent(com1), "第一个子组件不在容器中");
            feng3d.assert(this.hasComponent(com2), "第二个子组件不在容器中");
            this.swapComponentsAt(this.getComponentIndex(com1), this.getComponentIndex(com2));
        };
        /**
         * 派发子组件事件
         * <p>事件广播给子组件</p>
         * @param event
         */
        Component.prototype.dispatchChildrenEvent = function (event) {
            this.components.forEach(function (item) {
                var args = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    args[_i - 1] = arguments[_i];
                }
                item.dispatchEvent(event);
            });
        };
        return Component;
    }(feng3d.EventDispatcher));
    feng3d.Component = Component;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 唯一类型组件
     * <p>不允许容器内存在两个相同类型的子组件</p>
     * @author feng 2015-12-2
     */
    var UniqueClassComponent = (function (_super) {
        __extends(UniqueClassComponent, _super);
        function UniqueClassComponent() {
            _super.call(this);
            this.addEventListener(feng3d.ComponentEvent.BE_ADDED_COMPONET, this.onBeAddedComponet);
            this.addEventListener(feng3d.ComponentEvent.BE_REMOVED_COMPONET, this.onBeRemovedComponet);
        }
        /**
         * 处理被添加事件
         * @param event
         */
        UniqueClassComponent.prototype.onBeAddedComponet = function (event) {
            var addedComponentEventVO = event.data;
            feng3d.assert(addedComponentEventVO.child == this);
            addedComponentEventVO.container.addEventListener(feng3d.ComponentEvent.ADDED_COMPONET, this.onAddedComponetContainer);
            this.checkUniqueName(addedComponentEventVO.container);
        };
        /**
         * 处理被移除事件
         * @param event
         */
        UniqueClassComponent.prototype.onBeRemovedComponet = function (event) {
            var removedComponentEventVO = event.data;
            feng3d.assert(removedComponentEventVO.child == this);
            removedComponentEventVO.container.removeEventListener(feng3d.ComponentEvent.ADDED_COMPONET, this.onAddedComponetContainer);
        };
        /**
         * 处理添加组件事件
         * @param event
         */
        UniqueClassComponent.prototype.onAddedComponetContainer = function (event) {
            var addedComponentEventVO = event.data;
            this.checkUniqueName(addedComponentEventVO.container);
        };
        /**
         * 检查子组件中类型是否唯一
         * @param container
         */
        UniqueClassComponent.prototype.checkUniqueName = function (container) {
            var nameDic = {};
            for (var i = 0; i < container.numComponents; i++) {
                var component = container.getComponentAt(i);
                var classDefine = getQualifiedClassName(component);
                if (nameDic[classDefine]) {
                    throwEvent(new Error("存在多个子组件拥有相同的类型"));
                }
                nameDic[classDefine] = true;
            }
        };
        return UniqueClassComponent;
    }(feng3d.Component));
    feng3d.UniqueClassComponent = UniqueClassComponent;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 唯一名称组件
     * <p>不允许容器内存在两个名称相同的子组件</p>
     * @author feng 2015-12-2
     */
    var UniqueNameComponent = (function (_super) {
        __extends(UniqueNameComponent, _super);
        function UniqueNameComponent() {
            _super.call(this);
            this.addEventListener(feng3d.ComponentEvent.BE_ADDED_COMPONET, this.onBeAddedComponet);
            this.addEventListener(feng3d.ComponentEvent.BE_REMOVED_COMPONET, this.onBeRemovedComponet);
        }
        /**
         * 处理被添加事件
         * @param event
         */
        UniqueNameComponent.prototype.onBeAddedComponet = function (event) {
            var addedComponentEventVO = event.data;
            addedComponentEventVO.container.addEventListener(feng3d.ComponentEvent.ADDED_COMPONET, this.onAddedComponetContainer);
            this.checkUniqueName(addedComponentEventVO.container);
        };
        /**
         * 处理被移除事件
         * @param event
         */
        UniqueNameComponent.prototype.onBeRemovedComponet = function (event) {
            var removedComponentEventVO = event.data;
            removedComponentEventVO.container.removeEventListener(feng3d.ComponentEvent.ADDED_COMPONET, this.onAddedComponetContainer);
        };
        /**
         * 处理添加组件事件
         * @param event
         */
        UniqueNameComponent.prototype.onAddedComponetContainer = function (event) {
            var addedComponentEventVO = event.data;
            this.checkUniqueName(addedComponentEventVO.container);
        };
        /**
         * 检查子组件中名称是否唯一
         * @param container
         */
        UniqueNameComponent.prototype.checkUniqueName = function (container) {
            var nameDic = {};
            for (var i = 0; i < container.numComponents; i++) {
                var component = container.getComponentAt(i);
                if (nameDic[component.componentName]) {
                    throwEvent(new Error("存在多个子组件拥有相同的名称"));
                }
                nameDic[component.componentName] = true;
            }
        };
        return UniqueNameComponent;
    }(feng3d.Component));
    feng3d.UniqueNameComponent = UniqueNameComponent;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 动画节点基类
     * @author feng 2014-5-20
     */
    var AnimationNodeBase = (function (_super) {
        __extends(AnimationNodeBase, _super);
        /**
         * 创建一个动画节点基类
         */
        function AnimationNodeBase() {
            _super.call(this);
            this._namedAsset = new feng3d.NamedAsset(this, feng3d.AssetType.ANIMATION_NODE);
            this.context3DBufferOwner = new feng3d.Context3DBufferOwner();
            this.initBuffers();
        }
        Object.defineProperty(AnimationNodeBase.prototype, "stateClass", {
            /**
             * 状态类
             */
            get: function () {
                return _stateClass;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 初始化Context3d缓存
         */
        AnimationNodeBase.prototype.initBuffers = function () {
        };
        Object.defineProperty(AnimationNodeBase.prototype, "_", {
            /**
             * Fagal编号中心
             */
            get: function () {
                return FagalIdCenter.instance;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AnimationNodeBase.prototype, "namedAsset", {
            get: function () {
                return _namedAsset;
            },
            enumerable: true,
            configurable: true
        });
        return AnimationNodeBase;
    }(feng3d.Component));
    feng3d.AnimationNodeBase = AnimationNodeBase;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 动画剪辑节点基类(用于控制动画播放，包含每帧持续时间，是否循环播放等)
     * @author feng 2014-5-20
     */
    var AnimationClipNodeBase = (function (_super) {
        __extends(AnimationClipNodeBase, _super);
        /**
         * 创建一个动画剪辑节点基类
         */
        function AnimationClipNodeBase() {
            _super.call(this);
            this._looping = true;
            this._totalDuration = 0;
            this._stitchDirty = true;
            this._stitchFinalFrame = false;
            this._numFrames = 0;
            this._durations = new number[]();
            this._totalDelta = new Vector3D();
            /** 是否稳定帧率 */
            this.fixedFrameRate = true;
        }
        Object.defineProperty(AnimationClipNodeBase.prototype, "durations", {
            /**
             * 持续时间列表（ms）
             */
            get: function () {
                return _durations;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AnimationClipNodeBase.prototype, "totalDelta", {
            /**
             * 总坐标偏移量
             */
            get: function () {
                if (_stitchDirty)
                    updateStitch();
                return _totalDelta;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AnimationClipNodeBase.prototype, "looping", {
            /**
             * 是否循环播放
             */
            get: function () {
                return _looping;
            },
            set: function (value) {
                if (_looping == value)
                    return;
                _looping = value;
                _stitchDirty = true;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AnimationClipNodeBase.prototype, "stitchFinalFrame", {
            /**
             * 是否过渡结束帧
             */
            get: function () {
                return _stitchFinalFrame;
            },
            set: function (value) {
                if (_stitchFinalFrame == value)
                    return;
                _stitchFinalFrame = value;
                _stitchDirty = true;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AnimationClipNodeBase.prototype, "totalDuration", {
            /**
             * 总持续时间
             */
            get: function () {
                if (_stitchDirty)
                    updateStitch();
                return _totalDuration;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AnimationClipNodeBase.prototype, "lastFrame", {
            /**
             * 最后帧数
             */
            get: function () {
                if (_stitchDirty)
                    updateStitch();
                return _lastFrame;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 更新动画播放控制状态
         */
        AnimationClipNodeBase.prototype.updateStitch = function () {
            this._stitchDirty = false;
            this._lastFrame = (this._looping && this._stitchFinalFrame) ? this._numFrames : this._numFrames - 1;
            this._totalDuration = 0;
            this._totalDelta.x = 0;
            this._totalDelta.y = 0;
            this._totalDelta.z = 0;
        };
        return AnimationClipNodeBase;
    }(feng3d.AnimationNodeBase));
    feng3d.AnimationClipNodeBase = AnimationClipNodeBase;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 骨骼动画节点（一般用于一个动画的帧列表）
     * 包含基于时间的动画数据作为单独的骨架构成。
     * @author feng 2014-5-20
     */
    var SkeletonClipNode = (function (_super) {
        __extends(SkeletonClipNode, _super);
        /**
         * 创建骨骼动画节点
         */
        function SkeletonClipNode() {
            this._frames = new feng3d.SkeletonPose[]();
            _stateClass = feng3d.SkeletonClipState;
        }
        Object.defineProperty(SkeletonClipNode.prototype, "frames", {
            /**
             * 骨骼姿势动画帧列表
             */
            get: function () {
                return _frames;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 添加帧到动画
         * @param skeletonPose 骨骼姿势
         * @param duration 持续时间
         */
        SkeletonClipNode.prototype.addFrame = function (skeletonPose, duration) {
            this._frames.push(skeletonPose);
            _durations.push(duration);
            _totalDuration += duration;
            _numFrames = _durations.length;
            _stitchDirty = true;
        };
        /**
         * @inheritDoc
         */
        SkeletonClipNode.prototype.updateStitch = function () {
            _super.prototype.updateStitch.call(this);
            var i = _numFrames - 1;
            var p1, p2, delta;
            while (i--) {
                _totalDuration += _durations[i];
                p1 = this._frames[i].jointPoses[0].translation;
                p2 = this._frames[i + 1].jointPoses[0].translation;
                delta = p2.subtract(p1);
                _totalDelta.x += delta.x;
                _totalDelta.y += delta.y;
                _totalDelta.z += delta.z;
            }
            if (_stitchFinalFrame && _looping) {
                _totalDuration += _durations[_numFrames - 1];
                if (_numFrames > 1) {
                    p1 = this._frames[0].jointPoses[0].translation;
                    p2 = this._frames[1].jointPoses[0].translation;
                    delta = p2.subtract(p1);
                    _totalDelta.x += delta.x;
                    _totalDelta.y += delta.y;
                    _totalDelta.z += delta.z;
                }
            }
        };
        return SkeletonClipNode;
    }(feng3d.AnimationClipNodeBase));
    feng3d.SkeletonClipNode = SkeletonClipNode;
})(feng3d || (feng3d = {}));
var feng3dSheet;
(function (feng3dSheet) {
    /**
     * sprite动画剪辑节点
     * @author feng 2015-9-18
     */
    var SpriteSheetClipNode = (function (_super) {
        __extends(SpriteSheetClipNode, _super);
        /**
         * 创建<code>SpriteSheetClipNode</code>实例.
         */
        function SpriteSheetClipNode() {
            this._frames = new feng3dSheet.SpriteSheetAnimationFrame[]();
            _stateClass = feng3dSheet.SpriteSheetAnimationState;
        }
        Object.defineProperty(SpriteSheetClipNode.prototype, "frames", {
            /**
             * 帧列表
             */
            get: function () {
                return _frames;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 添加帧到动画节点
         * @param spriteSheetAnimationFrame				sprite动画帧
         * @param duration								间隔时间
         */
        SpriteSheetClipNode.prototype.addFrame = function (spriteSheetAnimationFrame, duration) {
            this._frames.push(spriteSheetAnimationFrame);
            _durations.push(duration);
            _numFrames = _durations.length;
            _stitchDirty = false;
        };
        return SpriteSheetClipNode;
    }(AnimationClipNodeBase));
    feng3dSheet.SpriteSheetClipNode = SpriteSheetClipNode;
})(feng3dSheet || (feng3dSheet = {}));
var feng3d;
(function (feng3d) {
    /**
     * A uv animation node containing time-based animation data as individual uv animation frames.
     */
    /**
     * UV动画剪辑节点
     * @author feng 2014-5-20
     */
    var UVClipNode = (function (_super) {
        __extends(UVClipNode, _super);
        /**
         * 创建<code>UVClipNode</code>实例
         */
        function UVClipNode() {
            this._frames = new feng3d.UVAnimationFrame[]();
            _stateClass = feng3d.UVClipState;
        }
        Object.defineProperty(UVClipNode.prototype, "frames", {
            /**
             * 帧数据列表
             */
            get: function () {
                return _frames;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 添加帧
         * @param uvFrame				UV动画帧
         * @param duration				间隔时间
         */
        UVClipNode.prototype.addFrame = function (uvFrame, duration) {
            this._frames.push(uvFrame);
            _durations.push(duration);
            _numFrames = _durations.length;
            _stitchDirty = true;
        };
        /**
         * @inheritDoc
         */
        UVClipNode.prototype.updateStitch = function () {
            _super.prototype.updateStitch.call(this);
            var i;
            if (_durations.length > 0) {
                i = _numFrames - 1;
                while (i--)
                    _totalDuration += _durations[i];
                if (_stitchFinalFrame || !_looping)
                    _totalDuration += _durations[_numFrames - 1];
            }
        };
        return UVClipNode;
    }(feng3d.AnimationClipNodeBase));
    feng3d.UVClipNode = UVClipNode;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 顶点动画剪辑节点
     * @author feng 2014-5-30
     */
    var VertexClipNode = (function (_super) {
        __extends(VertexClipNode, _super);
        /**
         * 创建一个顶点动画剪辑节点
         */
        function VertexClipNode() {
            this._frames = new feng3d.Geometry[]();
            this._translations = new Vector3D[]();
            _stateClass = feng3d.VertexClipState;
        }
        Object.defineProperty(VertexClipNode.prototype, "frames", {
            /**
             * 帧数据列表
             */
            get: function () {
                return _frames;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 添加顶点动画帧
         * @param geometry 几何体
         * @param duration 持续时间
         * @param translation 偏移量
         */
        VertexClipNode.prototype.addFrame = function (geometry, duration, translation) {
            if (translation === void 0) { translation = null; }
            this._frames.push(geometry);
            _durations.push(duration);
            this._translations.push(translation || new Vector3D());
            _numFrames = _durations.length;
            _stitchDirty = true;
        };
        /**
         * @inheritDoc
         */
        VertexClipNode.prototype.updateStitch = function () {
            _super.prototype.updateStitch.call(this);
            var i = _numFrames - 1;
            var p1, p2, delta;
            while (i--) {
                _totalDuration += _durations[i];
                p1 = this._translations[i];
                p2 = this._translations[i + 1];
                delta = p2.subtract(p1);
                _totalDelta.x += delta.x;
                _totalDelta.y += delta.y;
                _totalDelta.z += delta.z;
            }
            if (_stitchFinalFrame && _looping) {
                _totalDuration += _durations[_numFrames - 1];
                if (_numFrames > 1) {
                    p1 = this._translations[0];
                    p2 = this._translations[1];
                    delta = p2.subtract(p1);
                    _totalDelta.x += delta.x;
                    _totalDelta.y += delta.y;
                    _totalDelta.z += delta.z;
                }
            }
        };
        return VertexClipNode;
    }(feng3d.AnimationClipNodeBase));
    feng3d.VertexClipNode = VertexClipNode;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 粒子节点
     * @author feng 2014-11-13
     */
    var ParticleNodeBase = (function (_super) {
        __extends(ParticleNodeBase, _super);
        /**
         * 创建一个粒子节点
         * @param animationName		节点名称
         * @param mode				模式
         * @param dataLength		数据长度
         * @param priority			优先级
         */
        function ParticleNodeBase(animationName, mode, dataLength, priority) {
            if (priority === void 0) { priority = 1; }
            this._dataLength = 3;
            this.name = animationName + MODES[mode];
            this._mode = mode;
            this._priority = priority;
            this._dataLength = dataLength;
            this._oneData = new number[](this._dataLength, true);
            _super.call(this);
            feng3d.AbstractClassError.check(this);
        }
        Object.defineProperty(ParticleNodeBase.prototype, "vaId", {
            /**
             * 顶点数据编号
             */
            get: function () {
                throw new feng3d.AbstractMethodError();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ParticleNodeBase.prototype, "vaLen", {
            /**
             * 顶点数据长度
             */
            get: function () {
                throw new feng3d.AbstractMethodError();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ParticleNodeBase.prototype, "priority", {
            /**
             * 优先级
             */
            get: function () {
                return _priority;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ParticleNodeBase.prototype, "dataLength", {
            /**
             * 数据长度
             */
            get: function () {
                return _dataLength;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ParticleNodeBase.prototype, "oneData", {
            /**
             * 单个粒子数据
             */
            get: function () {
                return _oneData;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ParticleNodeBase.prototype, "mode", {
            /**
             * 粒子属性模式
             */
            get: function () {
                return _mode;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 创建单个粒子属性
         */
        ParticleNodeBase.prototype.generatePropertyOfOneParticle = function (param) {
        };
        /**
         * 设置粒子渲染参数
         * @param particleShaderParam 粒子渲染参数
         */
        ParticleNodeBase.prototype.processAnimationSetting = function (shaderParam) {
            throw new Error("必须设置对应的渲染参数");
        };
        /**
         * 设置渲染状态
         * @param stage3DProxy			显卡代理
         * @param renderable			渲染实体
         * @param camera				摄像机
         */
        ParticleNodeBase.prototype.setRenderState = function (renderable, camera) {
        };
        /** 模式列表 */
        ParticleNodeBase.MODES = {
            0: GLOBAL,
            1: LOCAL_STATIC,
            2: LOCAL_DYNAMIC //
        };
        //模式名称
        ParticleNodeBase.GLOBAL = 'Global';
        ParticleNodeBase.LOCAL_STATIC = 'LocalStatic';
        ParticleNodeBase.LOCAL_DYNAMIC = 'LocalDynamic';
        return ParticleNodeBase;
    }(feng3d.AnimationNodeBase));
    feng3d.ParticleNodeBase = ParticleNodeBase;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 广告牌节点
     * @author feng 2014-11-13
     */
    var ParticleBillboardNode = (function (_super) {
        __extends(ParticleBillboardNode, _super);
        /**
         * 创建一个广告牌节点
         * @param billboardAxis
         */
        function ParticleBillboardNode(billboardAxis) {
            if (billboardAxis === void 0) { billboardAxis = null; }
            _super.call(this, "ParticleBillboard", feng3d.ParticlePropertiesMode.GLOBAL, 0, 4);
            this._matrix = new Matrix3D;
            this.billboardAxis = billboardAxis;
        }
        /**
         * @inheritDoc
         */
        ParticleBillboardNode.prototype.initBuffers = function () {
            _super.prototype.initBuffers.call(this);
            this.context3DBufferOwner.mapContext3DBuffer(this._.particleBillboard_vc_matrix, this.updateBillboardMatrixBuffer);
        };
        ParticleBillboardNode.prototype.updateBillboardMatrixBuffer = function (billboardMatrixBuffer) {
            billboardMatrixBuffer.update(this._matrix, true);
        };
        /**
         * @inheritDoc
         */
        ParticleBillboardNode.prototype.setRenderState = function (renderable, camera) {
            var comps;
            if (this._billboardAxis) {
                var pos = renderable.sourceEntity.sceneTransform.position;
                var look = camera.sceneTransform.position.subtract(pos);
                var right = look.crossProduct(this._billboardAxis);
                right.normalize();
                look = this._billboardAxis.crossProduct(right);
                look.normalize();
                //create a quick inverse projection matrix
                this._matrix.copyFrom(renderable.sourceEntity.sceneTransform);
                comps = feng3d.Matrix3DUtils.decompose(this._matrix, Orientation3D.AXIS_ANGLE);
                this._matrix.copyColumnFrom(0, right);
                this._matrix.copyColumnFrom(1, this._billboardAxis);
                this._matrix.copyColumnFrom(2, look);
                this._matrix.copyColumnFrom(3, pos);
                this._matrix.appendRotation(-comps[1].w * feng3d.MathConsts.RADIANS_TO_DEGREES, comps[1]);
            }
            else {
                //create a quick inverse projection matrix
                this._matrix.copyFrom(renderable.sourceEntity.sceneTransform);
                this._matrix.append(camera.inverseSceneTransform);
                //decompose using axis angle rotations
                comps = feng3d.Matrix3DUtils.decompose(this._matrix, Orientation3D.AXIS_ANGLE);
                //recreate the matrix with just the rotation data
                this._matrix.identity();
                this._matrix.appendRotation(-comps[1].w * feng3d.MathConsts.RADIANS_TO_DEGREES, comps[1]);
            }
            this.context3DBufferOwner.markBufferDirty(this._.particleBillboard_vc_matrix);
        };
        Object.defineProperty(ParticleBillboardNode.prototype, "billboardAxis", {
            /**
             * 广告牌轴线
             */
            get: function () {
                return _billboardAxis;
            },
            set: function (value) {
                _billboardAxis = value ? value.clone() : null;
                if (_billboardAxis)
                    _billboardAxis.normalize();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        ParticleBillboardNode.prototype.processAnimationSetting = function (shaderParams) {
            var particleShaderParams = shaderParams.getOrCreateComponentByClass(feng3d.ParticleShaderParams);
            particleShaderParams.changePosition++;
            particleShaderParams[this.name] = true;
        };
        return ParticleBillboardNode;
    }(feng3d.ParticleNodeBase));
    feng3d.ParticleBillboardNode = ParticleBillboardNode;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 粒子颜色节点
     * @author feng 2015-1-20
     */
    var ParticleColorNode = (function (_super) {
        __extends(ParticleColorNode, _super);
        /**
         * 创建一个粒子颜色节点
         * @param mode					属性模式
         * @param usesMultiplier		是否使用Multiplier数据对渲染中颜色进行变换
         * @param usesOffset			是否使用offset数据对渲染中颜色进行变换
         * @param usesCycle
         * @param usesPhase
         * @param startColor			开始颜色数据
         * @param endColor				结束颜色数据
         * @param cycleDuration
         * @param cyclePhase
         */
        function ParticleColorNode(mode, usesMultiplier, usesOffset, usesCycle, usesPhase, startColor, endColor, cycleDuration, cyclePhase) {
            if (usesMultiplier === void 0) { usesMultiplier = true; }
            if (usesOffset === void 0) { usesOffset = true; }
            if (usesCycle === void 0) { usesCycle = false; }
            if (usesPhase === void 0) { usesPhase = false; }
            if (startColor === void 0) { startColor = null; }
            if (endColor === void 0) { endColor = null; }
            if (cycleDuration === void 0) { cycleDuration = 1; }
            if (cyclePhase === void 0) { cyclePhase = 0; }
            this._usesMultiplier = usesMultiplier;
            this._usesOffset = usesOffset;
            this._startColor = startColor || new ColorTransform();
            this._endColor = endColor || new ColorTransform();
            _super.call(this, "ParticleColor", mode, (this._usesMultiplier && this._usesOffset) ? 16 : 8, feng3d.ParticleAnimationSet.COLOR_PRIORITY);
            this.updateColorData();
        }
        /**
         * @inheritDoc
         */
        ParticleColorNode.prototype.initBuffers = function () {
            _super.prototype.initBuffers.call(this);
            if (this.mode == feng3d.ParticlePropertiesMode.GLOBAL) {
                this.context3DBufferOwner.mapContext3DBuffer(this._.particleStartColorMultiplier_vc_vector, this.updateStartColorMultiplierConstBuffer);
                this.context3DBufferOwner.mapContext3DBuffer(this._.particleDeltaColorMultiplier_vc_vector, this.updateDeltaColorMultiplierConstBuffer);
                this.context3DBufferOwner.mapContext3DBuffer(this._.particleStartColorOffset_vc_vector, this.updateStartColorOffsetConstBuffer);
                this.context3DBufferOwner.mapContext3DBuffer(this._.particleDeltaColorOffset_vc_vector, this.updateDeltaColorOffsetConstBuffer);
            }
        };
        ParticleColorNode.prototype.updateStartColorMultiplierConstBuffer = function (vcVectorBuffer) {
            vcVectorBuffer.update(this._startMultiplierData);
        };
        ParticleColorNode.prototype.updateDeltaColorMultiplierConstBuffer = function (vcVectorBuffer) {
            vcVectorBuffer.update(this._deltaMultiplierData);
        };
        ParticleColorNode.prototype.updateStartColorOffsetConstBuffer = function (vcVectorBuffer) {
            vcVectorBuffer.update(this._startOffsetData);
        };
        ParticleColorNode.prototype.updateDeltaColorOffsetConstBuffer = function (vcVectorBuffer) {
            vcVectorBuffer.update(this._deltaOffsetData);
        };
        /**
         * @inheritDoc
         */
        ParticleColorNode.prototype.generatePropertyOfOneParticle = function (param) {
            var startColor = param[COLOR_START_COLORTRANSFORM];
            if (!startColor)
                throw (new Error("there is no " + COLOR_START_COLORTRANSFORM + " in param!"));
            var endColor = param[COLOR_END_COLORTRANSFORM];
            if (!endColor)
                throw (new Error("there is no " + COLOR_END_COLORTRANSFORM + " in param!"));
            var i;
            //multiplier
            if (this._usesMultiplier) {
                _oneData[i++] = startColor.redMultiplier;
                _oneData[i++] = startColor.greenMultiplier;
                _oneData[i++] = startColor.blueMultiplier;
                _oneData[i++] = startColor.alphaMultiplier;
                _oneData[i++] = endColor.redMultiplier - startColor.redMultiplier;
                _oneData[i++] = endColor.greenMultiplier - startColor.greenMultiplier;
                _oneData[i++] = endColor.blueMultiplier - startColor.blueMultiplier;
                _oneData[i++] = endColor.alphaMultiplier - startColor.alphaMultiplier;
            }
            //offset
            if (this._usesOffset) {
                _oneData[i++] = startColor.redOffset / 255;
                _oneData[i++] = startColor.greenOffset / 255;
                _oneData[i++] = startColor.blueOffset / 255;
                _oneData[i++] = startColor.alphaOffset / 255;
                _oneData[i++] = (endColor.redOffset - startColor.redOffset) / 255;
                _oneData[i++] = (endColor.greenOffset - startColor.greenOffset) / 255;
                _oneData[i++] = (endColor.blueOffset - startColor.blueOffset) / 255;
                _oneData[i++] = (endColor.alphaOffset - startColor.alphaOffset) / 255;
            }
        };
        /**
         * 更新颜色数据
         */
        ParticleColorNode.prototype.updateColorData = function () {
            if (this.mode == feng3d.ParticlePropertiesMode.GLOBAL) {
                if (this._usesMultiplier) {
                    this._startMultiplierData = number[]([this._startColor.redMultiplier, this._startColor.greenMultiplier, this._startColor.blueMultiplier, this._startColor.alphaMultiplier]);
                    this._deltaMultiplierData = number[]([(this._endColor.redMultiplier - this._startColor.redMultiplier), (this._endColor.greenMultiplier - this._startColor.greenMultiplier), (this._endColor.blueMultiplier - this._startColor.blueMultiplier), (this._endColor.alphaMultiplier - this._startColor.alphaMultiplier)]);
                }
                if (this._usesOffset) {
                    this._startOffsetData = number[]([this._startColor.redOffset / 255, this._startColor.greenOffset / 255, this._startColor.blueOffset / 255, this._startColor.alphaOffset / 255]);
                    this._deltaOffsetData = number[]([(this._endColor.redOffset - this._startColor.redOffset) / 255, (this._endColor.greenOffset - this._startColor.greenOffset) / 255, (this._endColor.blueOffset - this._startColor.blueOffset) / 255, (this._endColor.alphaOffset - this._startColor.alphaOffset) / 255]);
                }
            }
        };
        /**
         * @inheritDoc
         */
        ParticleColorNode.prototype.processAnimationSetting = function (shaderParams) {
            var particleShaderParams = shaderParams.getOrCreateComponentByClass(feng3d.ParticleShaderParams);
            particleShaderParams.changeColor++;
            particleShaderParams[this.name] = true;
        };
        /**
         * 开始颜色属性
         */
        ParticleColorNode.COLOR_START_COLORTRANSFORM = "ColorStartColorTransform";
        /**
         * 结束颜色属性
         */
        ParticleColorNode.COLOR_END_COLORTRANSFORM = "ColorEndColorTransform";
        return ParticleColorNode;
    }(feng3d.ParticleNodeBase));
    feng3d.ParticleColorNode = ParticleColorNode;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 粒子缩放节点
     * @author feng 2015-1-15
     */
    var ParticleScaleNode = (function (_super) {
        __extends(ParticleScaleNode, _super);
        /**
         * 创建一个粒子缩放节点
         * @param mode				模式
         * @param usesCycle
         * @param usesPhase
         * @param minScale			最小缩放
         * @param maxScale			最大缩放
         * @param cycleDuration
         * @param cyclePhase
         */
        function ParticleScaleNode(mode, usesCycle, usesPhase, minScale, maxScale, cycleDuration, cyclePhase) {
            if (minScale === void 0) { minScale = 1; }
            if (maxScale === void 0) { maxScale = 1; }
            if (cycleDuration === void 0) { cycleDuration = 1; }
            if (cyclePhase === void 0) { cyclePhase = 0; }
            var len = 2;
            if (usesCycle)
                len++;
            if (usesPhase)
                len++;
            _super.call(this, "ParticleScale", mode, len, 3);
            this._minScale = minScale;
            this._maxScale = maxScale;
            this.updateScaleData();
        }
        Object.defineProperty(ParticleScaleNode.prototype, "minScale", {
            /**
             * 最小缩放
             */
            get: function () {
                return _minScale;
            },
            set: function (value) {
                _minScale = value;
                updateScaleData();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ParticleScaleNode.prototype, "maxScale", {
            /**
             * 最大缩放
             */
            get: function () {
                return _maxScale;
            },
            set: function (value) {
                _maxScale = value;
                updateScaleData();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        ParticleScaleNode.prototype.initBuffers = function () {
            _super.prototype.initBuffers.call(this);
            if (this.mode == feng3d.ParticlePropertiesMode.GLOBAL)
                this.context3DBufferOwner.mapContext3DBuffer(this._.particleScale_vc_vector, this.updateVelocityConstBuffer);
        };
        ParticleScaleNode.prototype.updateVelocityConstBuffer = function (velocityConstBuffer) {
            velocityConstBuffer.update(this._scaleData);
        };
        ParticleScaleNode.prototype.updateScaleData = function () {
            if (this.mode == feng3d.ParticlePropertiesMode.GLOBAL) {
                this._scaleData = number[]([this._minScale, this._maxScale - this._minScale, 0, 0]);
            }
        };
        /**
         * @inheritDoc
         */
        ParticleScaleNode.prototype.generatePropertyOfOneParticle = function (param) {
            var scale = param[SCALE_VECTOR3D];
            if (!scale)
                throw (new Error("there is no " + SCALE_VECTOR3D + " in param!"));
            _oneData[0] = scale.x;
            _oneData[1] = scale.y - scale.x;
        };
        /**
         * @inheritDoc
         */
        ParticleScaleNode.prototype.processAnimationSetting = function (shaderParams) {
            var particleShaderParams = shaderParams.getOrCreateComponentByClass(feng3d.ParticleShaderParams);
            particleShaderParams.changePosition++;
            particleShaderParams[this.name] = true;
        };
        /**
         * 缩放属性名
         */
        ParticleScaleNode.SCALE_VECTOR3D = "ScaleVector3D";
        return ParticleScaleNode;
    }(feng3d.ParticleNodeBase));
    feng3d.ParticleScaleNode = ParticleScaleNode;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 粒子时间节点
     * @author feng 2014-11-17
     */
    var ParticleTimeNode = (function (_super) {
        __extends(ParticleTimeNode, _super);
        /**
         * 创建一个粒子时间节点
         * @param usesDuration	是否持续
         * @param usesLooping	是否延时
         * @param usesDelay		是否循环
         */
        function ParticleTimeNode() {
            _super.call(this, "ParticleTime", feng3d.ParticlePropertiesMode.LOCAL_STATIC, 4, 0);
        }
        Object.defineProperty(ParticleTimeNode.prototype, "vaId", {
            /**
             * @inheritDoc
             */
            get: function () {
                return _.particleTime_va_4;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ParticleTimeNode.prototype, "vaLen", {
            /**
             * @inheritDoc
             */
            get: function () {
                return 4;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        ParticleTimeNode.prototype.generatePropertyOfOneParticle = function (param) {
            _oneData[0] = param.startTime;
            _oneData[1] = param.duration;
            _oneData[2] = param.delay + param.duration;
            _oneData[3] = 1 / param.duration;
        };
        /**
         * @inheritDoc
         */
        ParticleTimeNode.prototype.processAnimationSetting = function (shaderParams) {
            var particleShaderParams = shaderParams.getOrCreateComponentByClass(feng3d.ParticleShaderParams);
            particleShaderParams[this.name] = true;
        };
        return ParticleTimeNode;
    }(feng3d.ParticleNodeBase));
    feng3d.ParticleTimeNode = ParticleTimeNode;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 粒子速度节点
     * @author feng 2014-11-13
     */
    var ParticleVelocityNode = (function (_super) {
        __extends(ParticleVelocityNode, _super);
        /**
         * 创建一个粒子速度节点
         * @param mode		模式
         * @param velocity	粒子速度
         */
        function ParticleVelocityNode(mode, velocity) {
            if (velocity === void 0) { velocity = null; }
            _super.call(this, "ParticleVelocity", mode, 3);
            /** 粒子速度 */
            this._velocity = number[]([1, 1, 1, 0]);
            if (velocity) {
                this._velocity[0] = velocity.x;
                this._velocity[1] = velocity.y;
                this._velocity[2] = velocity.z;
            }
            else {
                this._velocity[0] = 0;
                this._velocity[1] = 0;
                this._velocity[2] = 0;
            }
        }
        Object.defineProperty(ParticleVelocityNode.prototype, "vaId", {
            /**
             * @inheritDoc
             */
            get: function () {
                return _.particleVelocity_va_3;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ParticleVelocityNode.prototype, "vaLen", {
            /**
             * @inheritDoc
             */
            get: function () {
                return 3;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        ParticleVelocityNode.prototype.initBuffers = function () {
            _super.prototype.initBuffers.call(this);
            if (this.mode == feng3d.ParticlePropertiesMode.GLOBAL)
                this.context3DBufferOwner.mapContext3DBuffer(this._.particleVelocity_vc_vector, this.updateVelocityConstBuffer);
        };
        ParticleVelocityNode.prototype.updateVelocityConstBuffer = function (velocityConstBuffer) {
            velocityConstBuffer.update(this._velocity);
        };
        /**
         * @inheritDoc
         */
        ParticleVelocityNode.prototype.generatePropertyOfOneParticle = function (param) {
            var _tempVelocity = param[VELOCITY_VECTOR3D];
            if (!_tempVelocity)
                throw new Error("there is no " + VELOCITY_VECTOR3D + " in param!");
            _oneData[0] = _tempVelocity.x;
            _oneData[1] = _tempVelocity.y;
            _oneData[2] = _tempVelocity.z;
        };
        /**
         * @inheritDoc
         */
        ParticleVelocityNode.prototype.processAnimationSetting = function (shaderParams) {
            var particleShaderParams = shaderParams.getOrCreateComponentByClass(feng3d.ParticleShaderParams);
            particleShaderParams.changePosition++;
            particleShaderParams[this.name] = true;
        };
        /**
         * 粒子的速度属性
         */
        ParticleVelocityNode.VELOCITY_VECTOR3D = "VelocityVector3D";
        return ParticleVelocityNode;
    }(feng3d.ParticleNodeBase));
    feng3d.ParticleVelocityNode = ParticleVelocityNode;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 两个骨骼动画节点间进行线性插值得出骨骼姿势
     * @author feng 2014-5-20
     */
    var SkeletonBinaryLERPNode = (function (_super) {
        __extends(SkeletonBinaryLERPNode, _super);
        /**
         * 创建<code>SkeletonBinaryLERPNode</code>对象
         */
        function SkeletonBinaryLERPNode() {
            _stateClass = feng3d.SkeletonBinaryLERPState;
        }
        /**
         * @inheritDoc
         */
        SkeletonBinaryLERPNode.prototype.getAnimationState = function (animator) {
            return animator.getAnimationState(this);
        };
        return SkeletonBinaryLERPNode;
    }(feng3d.AnimationNodeBase));
    feng3d.SkeletonBinaryLERPNode = SkeletonBinaryLERPNode;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 淡入淡出变换节点
     * @author feng 2014-5-20
     */
    var CrossfadeTransitionNode = (function (_super) {
        __extends(CrossfadeTransitionNode, _super);
        /**
         * 创建<code>CrossfadeTransitionNode</code>实例
         */
        function CrossfadeTransitionNode() {
            _stateClass = feng3d.CrossfadeTransitionState;
        }
        return CrossfadeTransitionNode;
    }(feng3d.SkeletonBinaryLERPNode));
    feng3d.CrossfadeTransitionNode = CrossfadeTransitionNode;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 动画集合基类
     * @author feng 2014-5-20
     */
    var AnimationSetBase = (function (_super) {
        __extends(AnimationSetBase, _super);
        /**
         * 创建一个动画集合基类
         */
        function AnimationSetBase() {
            _super.call(this);
            /** 动画节点列表 */
            this._animations = new feng3d.AnimationNodeBase[]();
            /** 动画名称列表 */
            this._animationNames = new string[]();
            /** 动画字典 */
            this._animationDictionary = new Dictionary(true);
            this._namedAsset = new feng3d.NamedAsset(this, feng3d.AssetType.ANIMATION_SET);
            feng3d.AbstractClassError.check(this);
            this.context3DBufferOwner = new feng3d.Context3DBufferOwner();
            this.initBuffers();
        }
        /**
         * 初始化Context3d缓存
         */
        AnimationSetBase.prototype.initBuffers = function () {
        };
        Object.defineProperty(AnimationSetBase.prototype, "_", {
            /**
             * Fagal编号中心
             */
            get: function () {
                return FagalIdCenter.instance;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AnimationSetBase.prototype, "usesCPU", {
            /**
             * 是否使用CPU
             */
            get: function () {
                return _usesCPU;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AnimationSetBase.prototype, "animations", {
            /**
             * Returns a vector of animation state objects that make up the contents of the animation data set.
             */
            get: function () {
                return _animations;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 添加动画
         * @param node 动画节点
         */
        AnimationSetBase.prototype.addAnimation = function (node) {
            if (this._animationDictionary[node.name])
                throw new feng3d.AnimationSetError("root node animationName '" + node.name + "' already exists in the set");
            this._animationDictionary[node.name] = node;
            this._animations.push(node);
            this._animationNames.push(node.name);
        };
        /**
         * 获取动画节点
         * @param name 动画名称
         * @return 动画节点
         */
        AnimationSetBase.prototype.getAnimation = function (animationName) {
            return this._animationDictionary[animationName];
        };
        /**
         * 是否有某动画
         * @param name 动画名称
         */
        AnimationSetBase.prototype.hasAnimation = function (animationName) {
            return this._animationDictionary[animationName] != null;
        };
        /**
         * 重置使用GPU
         */
        AnimationSetBase.prototype.resetGPUCompatibility = function () {
            this._usesCPU = false;
        };
        /**
         * 取消使用GPU
         */
        AnimationSetBase.prototype.cancelGPUCompatibility = function () {
            this._usesCPU = true;
        };
        /**
         * 激活
         * @param shaderParams	渲染参数
         * @param stage3DProxy	3d舞台代理
         * @param pass			渲染通道
         * @throws	me.feng.error.AbstractMethodError
         */
        AnimationSetBase.prototype.activate = function (shaderParams, pass) {
            throw new feng3d.AbstractMethodError();
        };
        Object.defineProperty(AnimationSetBase.prototype, "namedAsset", {
            get: function () {
                return _namedAsset;
            },
            enumerable: true,
            configurable: true
        });
        return AnimationSetBase;
    }(feng3d.Component));
    feng3d.AnimationSetBase = AnimationSetBase;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 粒子动画set
     * @author feng 2014-11-13
     */
    var ParticleAnimationSet = (function (_super) {
        __extends(ParticleAnimationSet, _super);
        /**
         * 创建一个粒子动画集合
         * @param usesDuration	是否持续
         * @param usesLooping	是否循环
         * @param usesDelay		是否延时
         */
        function ParticleAnimationSet(usesDuration, usesLooping, usesDelay) {
            if (usesDuration === void 0) { usesDuration = false; }
            if (usesLooping === void 0) { usesLooping = false; }
            if (usesDelay === void 0) { usesDelay = false; }
            this._particleNodes = new feng3d.ParticleNodeBase[]();
            this._localStaticNodes = new feng3d.ParticleNodeBase[]();
            /** 动画节点列表 */
            this._effects = new feng3d.ParticleNodeBase[]();
            /** 动画名称列表 */
            this._effectNames = new string[]();
            /** 动画字典 */
            this._effectDictionary = new Dictionary(true);
            this._usesDuration = false;
            this._usesLooping = false;
            this._usesDelay = false;
            this._usesDuration = usesDuration;
            this._usesLooping = usesLooping;
            this._usesDelay = usesDelay;
            //自动添加一个粒子的时间节点
            this.addParticleEffect(this._timeNode = new feng3d.ParticleTimeNode());
        }
        Object.defineProperty(ParticleAnimationSet.prototype, "particleNodes", {
            /**
             * 粒子节点列表
             */
            get: function () {
                return _particleNodes;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 添加粒子特效
         * @param node
         */
        ParticleAnimationSet.prototype.addParticleEffect = function (node) {
            var i;
            if (node.mode == feng3d.ParticlePropertiesMode.LOCAL_STATIC) {
                this._localStaticNodes.push(node);
            }
            for (i = this._particleNodes.length - 1; i >= 0; i--) {
                if (this._particleNodes[i].priority <= node.priority)
                    break;
            }
            this._particleNodes.splice(i + 1, 0, node);
            this._effectDictionary[node.name] = node;
            this._effects.push(node);
            this.context3DBufferOwner.addChildBufferOwner(node.context3DBufferOwner);
            this._effectNames.push(node.name);
        };
        /**
         * @inheritDoc
         */
        ParticleAnimationSet.prototype.activate = function (shaderParams, pass) {
            var particleShaderParams = shaderParams.getOrCreateComponentByClass(feng3d.ParticleShaderParams);
            particleShaderParams.usesDuration = this._usesDuration;
            particleShaderParams.usesLooping = this._usesLooping;
            particleShaderParams.usesDelay = this._usesDelay;
            for (var i = 0; i < this._effects.length; i++) {
                this._effects[i].processAnimationSetting(shaderParams);
            }
            var animationShaderParams = shaderParams.getOrCreateComponentByClass(feng3d.AnimationShaderParams);
            animationShaderParams.animationType = feng3d.AnimationType.PARTICLE;
        };
        /**
         * 生成粒子动画数据
         * @param mesh
         */
        ParticleAnimationSet.prototype.generateAnimationSubGeometries = function (mesh) {
            if (this.initParticleFunc == null)
                throw (new Error("no this.initParticleFunc set"));
            var geometry = mesh.geometry;
            if (!geometry)
                throw (new Error("Particle animation can only be performed on a ParticleGeometry object"));
            var i;
            var particleSubGeometry;
            var subGeometry;
            var localNode;
            var subMesh;
            //注册顶点数据
            for (each(subMesh in mesh.subMeshes); {
                particleSubGeometry: particleSubGeometry,
                //遍历静态本地节点
                for: each(localNode in this._localStaticNodes) }; {
                particleSubGeometry: .mapVABuffer(localNode.vaId, localNode.vaLen)
            })
                particleSubGeometry.numVertices = subMesh.subGeometry.numVertices;
            subMesh.animationSubGeometry = particleSubGeometry;
        };
        /**
         * 颜色优先级
         */
        ParticleAnimationSet.COLOR_PRIORITY = 18;
        return ParticleAnimationSet;
    }(feng3d.AnimationSetBase));
    feng3d.ParticleAnimationSet = ParticleAnimationSet;
    //粒子数据
    var particles = geometry.particles;
    //粒子数量
    var numParticles = geometry.numParticles;
    //粒子属性
    var particleProperties = new feng3d.ParticleProperties();
    var particle;
    var counterForVertex;
    var counterForOneData;
    var oneData;
    var numVertices;
    var vertexOffset;
    //设置默认数据
    particleProperties.total = numParticles;
    particleProperties.startTime = 0;
    particleProperties.duration = 1000;
    particleProperties.delay = 0.1;
    i = 0;
    while (i < numParticles) {
        particleProperties.index = i;
        particle = particles[i];
        //调用函数初始化粒子属性
        this.initParticleFunc(particleProperties);
        //创建本地节点粒子属性
        for (each(localNode in this._localStaticNodes); localNode.generatePropertyOfOneParticle(particleProperties); )
            for (each(subMesh in mesh.subMeshes); {
                if: function (subMesh, subGeometry) {
                    if (subGeometry === void 0) { subGeometry =  == particle.subGeometry; }
                    particleSubGeometry = subMesh.animationSubGeometry;
                    break;
                }
            }; numVertices = particle.numVertices)
                ;
        //遍历静态本地节点
        for (each(localNode in this._localStaticNodes); {
            oneData: oneData,
            /** 粒子所在子几何体的顶点位置 */
            var: startVertexIndex, number: number,
            var: vaData, number: particleSubGeometry.getVAData(localNode.vaId),
            var: vaLen, number: number,
            //收集该粒子的每个顶点数据
            for: function () { }, var: j, number: number, j: function () { } }++;) {
            vertexOffset = (startVertexIndex + j) * vaLen;
            for (counterForOneData = 0; counterForOneData < vaLen; counterForOneData++)
                vaData[vertexOffset + counterForOneData] = oneData[counterForOneData];
        }
    }
    //下一个粒子
    i++;
})(feng3d || (feng3d = {}));
setRenderState(renderable, IRenderable, camera, Camera3D);
{
    for (var i = 0; i < this._particleNodes.length; i++) {
        this._particleNodes[i].setRenderState(renderable, camera);
    }
}
var feng3d;
(function (feng3d) {
    /**
     * 骨骼动画集合
     * @author feng 2014-5-20
     */
    var SkeletonAnimationSet = (function (_super) {
        __extends(SkeletonAnimationSet, _super);
        /**
         * 创建一个骨骼动画集合
         * @param jointsPerVertex 每个顶点关联关节的数量
         */
        function SkeletonAnimationSet(jointsPerVertex) {
            if (jointsPerVertex === void 0) { jointsPerVertex = 4; }
            this._jointsPerVertex = jointsPerVertex;
        }
        Object.defineProperty(SkeletonAnimationSet.prototype, "jointsPerVertex", {
            /**
             * 每个顶点关联关节的数量
             */
            get: function () {
                return _jointsPerVertex;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        SkeletonAnimationSet.prototype.activate = function (shaderParams, pass) {
            var animationShaderParams = shaderParams.getOrCreateComponentByClass(feng3d.AnimationShaderParams);
            animationShaderParams.numJoints = this._numJoints;
            animationShaderParams.jointsPerVertex = this._jointsPerVertex;
            if (this.usesCPU)
                animationShaderParams.animationType = feng3d.AnimationType.SKELETON_CPU;
            else
                animationShaderParams.animationType = feng3d.AnimationType.SKELETON_GPU;
        };
        Object.defineProperty(SkeletonAnimationSet.prototype, "numJoints", {
            /**
             * 设置关节数量
             */
            set: function (value) {
                _numJoints = value;
            },
            enumerable: true,
            configurable: true
        });
        return SkeletonAnimationSet;
    }(feng3d.AnimationSetBase));
    feng3d.SkeletonAnimationSet = SkeletonAnimationSet;
})(feng3d || (feng3d = {}));
var feng3dSheet;
(function (feng3dSheet) {
    /**
     * sprite动画集合
     * @author feng 2015-9-18
     */
    var SpriteSheetAnimationSet = (function (_super) {
        __extends(SpriteSheetAnimationSet, _super);
        function SpriteSheetAnimationSet() {
            _super.apply(this, arguments);
        }
        return SpriteSheetAnimationSet;
    }(AnimationSetBase));
    feng3dSheet.SpriteSheetAnimationSet = SpriteSheetAnimationSet;
    /**
     * 创建sprite动画集合
     */
    function SpriteSheetAnimationSet() {
    }
    activate(shaderParams, ShaderParams, pass, MaterialPassBase);
    {
        var animationShaderParams = shaderParams.getOrCreateComponentByClass(AnimationShaderParams);
        animationShaderParams.useSpriteSheetAnimation++;
    }
})(feng3dSheet || (feng3dSheet = {}));
var feng3d;
(function (feng3d) {
    /**
     * UV动画集合
     * @author feng 2014-5-20
     */
    var UVAnimationSet = (function (_super) {
        __extends(UVAnimationSet, _super);
        /**
         * 创建UV动画集合实例
         */
        function UVAnimationSet() {
        }
        /**
         * @inheritDoc
         */
        UVAnimationSet.prototype.activate = function (shaderParams, pass) {
            var animationShaderParams = shaderParams.getOrCreateComponentByClass(feng3d.AnimationShaderParams);
            animationShaderParams.useUVAnimation++;
        };
        return UVAnimationSet;
    }(feng3d.AnimationSetBase));
    feng3d.UVAnimationSet = UVAnimationSet;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 顶点动画集合
     * @author feng 2014-5-30
     */
    var VertexAnimationSet = (function (_super) {
        __extends(VertexAnimationSet, _super);
        /**
         * 创建一个顶点动画集合
         * @param numPoses		姿势数量
         */
        function VertexAnimationSet(numPoses) {
            if (numPoses === void 0) { numPoses = 2; }
            _super.call(this);
            this._numPoses = numPoses;
        }
        Object.defineProperty(VertexAnimationSet.prototype, "numPoses", {
            /**
             * 姿势数量
             */
            get: function () {
                return _numPoses;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        VertexAnimationSet.prototype.activate = function (shaderParams, pass) {
            var animationShaderParams = shaderParams.getOrCreateComponentByClass(feng3d.AnimationShaderParams);
            if (this.usesCPU)
                animationShaderParams.animationType = feng3d.AnimationType.VERTEX_CPU;
            else
                animationShaderParams.animationType = feng3d.AnimationType.VERTEX_GPU;
        };
        return VertexAnimationSet;
    }(feng3d.AnimationSetBase));
    feng3d.VertexAnimationSet = VertexAnimationSet;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 当开始播放动画时触发
     * @eventType me.feng3d.events.AnimatorEvent
     */
    [feng3d.Event(name = "start", type = "me.feng3d.events.AnimatorEvent")][feng3d.Event(name = "stop", type = "me.feng3d.events.AnimatorEvent")][feng3d.Event(name = "cycle_complete", type = "me.feng3d.events.AnimatorEvent")];
    /**
     * 动画基类
     * @author feng 2014-5-27
     */
    var AnimatorBase = (function (_super) {
        __extends(AnimatorBase, _super);
        /**
         * 创建一个动画基类
         * @param animationSet
         */
        function AnimatorBase(animationSet) {
            /** 动画驱动器 */
            this._broadcaster = new Sprite();
            this._autoUpdate = true;
            /** 播放速度 */
            this._playbackSpeed = 1;
            this._owners = new feng3d.Mesh[]();
            this._animationStates = new Dictionary(true);
            /**
             * 是否更新位置
             * @see me.feng3d.animators.base.states.IAnimationState#positionDelta
             */
            this.updatePosition = true;
            this._namedAsset = new feng3d.NamedAsset(this, feng3d.AssetType.ANIMATOR);
            this.context3DBufferOwner = new feng3d.Context3DBufferOwner();
            this._animationSet = animationSet;
            this.initBuffers();
        }
        /**
         * 初始化Context3d缓存
         */
        AnimatorBase.prototype.initBuffers = function () {
        };
        Object.defineProperty(AnimatorBase.prototype, "_", {
            /**
             * Fagal编号中心
             */
            get: function () {
                return FagalIdCenter.instance;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 获取动画状态
         * @param node		动画节点
         * @return			动画状态
         */
        AnimatorBase.prototype.getAnimationState = function (node) {
            var className = node.stateClass;
            return this._animationStates[node] || ;
            new className(this, node);
        };
        /**
         * 根据名字获取动画状态
         * @param name			动作名称
         * @return				动画状态
         */
        AnimatorBase.prototype.getAnimationStateByName = function (name) {
            return this.getAnimationState(this._animationSet.getAnimation(name));
        };
        Object.defineProperty(AnimatorBase.prototype, "absoluteTime", {
            /**
             * 绝对时间（游戏时间）
             * @see #time
             * @see #playbackSpeed
             */
            get: function () {
                return _absoluteTime;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AnimatorBase.prototype, "animationSet", {
            /**
             * 动画设置
             */
            get: function () {
                return _animationSet;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AnimatorBase.prototype, "activeState", {
            /**
             * 活动的动画状态
             */
            get: function () {
                return _activeState;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AnimatorBase.prototype, "activeAnimation", {
            /**
             * 活动的动画节点
             */
            get: function () {
                return _animationSet.getAnimation(_activeAnimationName);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AnimatorBase.prototype, "activeAnimationName", {
            /**
             * 活动的动作名
             */
            get: function () {
                return _activeAnimationName;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AnimatorBase.prototype, "autoUpdate", {
            /**
             * 是否自动更新，当值为true时，动画将会随时间播放
             * @see #time
             * @see #update()
             */
            get: function () {
                return _autoUpdate;
            },
            set: function (value) {
                if (_autoUpdate == value)
                    return;
                _autoUpdate = value;
                if (_autoUpdate)
                    start();
                else
                    stop();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AnimatorBase.prototype, "time", {
            /**
             * 动画时间
             */
            get: function () {
                return _time;
            },
            set: function (value) {
                if (_time == value)
                    return;
                update(value);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 设置当前活动状态的动画剪辑的播放进度(0,1)
         * @param	播放进度。 0：动画起点，1：动画终点。
         */
        AnimatorBase.prototype.phase = function (value) {
            this._activeState.phase(value);
        };
        Object.defineProperty(AnimatorBase.prototype, "playbackSpeed", {
            /**
             * The amount by which passed time should be scaled. Used to slow down or speed up animations. Defaults to 1.
             */
            /**
             * 播放速度
             * <p>默认为1，表示正常速度</p>
             */
            get: function () {
                return _playbackSpeed;
            },
            set: function (value) {
                _playbackSpeed = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 开始动画，当自动更新为true时有效
         * @see #autoUpdate
         */
        AnimatorBase.prototype.start = function () {
            if (this._isPlaying || !this._autoUpdate)
                return;
            this._time = this._absoluteTime = getTimer();
            this._isPlaying = true;
            if (!this._broadcaster.hasEventListener(feng3d.Event.ENTER_FRAME))
                this._broadcaster.addEventListener(feng3d.Event.ENTER_FRAME, this.onEnterFrame);
            if (!this.hasEventListener(feng3d.AnimatorEvent.START))
                return;
            this.dispatchEvent(new feng3d.AnimatorEvent(feng3d.AnimatorEvent.START, this));
        };
        /**
         * 暂停播放动画
         * @see #time
         * @see #update()
         */
        AnimatorBase.prototype.stop = function () {
            if (!this._isPlaying)
                return;
            this._isPlaying = false;
            if (this._broadcaster.hasEventListener(feng3d.Event.ENTER_FRAME))
                this._broadcaster.removeEventListener(feng3d.Event.ENTER_FRAME, this.onEnterFrame);
            if (!this.hasEventListener(feng3d.AnimatorEvent.STOP))
                return;
            this.dispatchEvent(new feng3d.AnimatorEvent(feng3d.AnimatorEvent.STOP, this));
        };
        /**
         * 更新动画
         * @param time			动画时间
         *
         * @see #stop()
         * @see #autoUpdate
         */
        AnimatorBase.prototype.update = function (time) {
            var dt = (time - this._time) * this.playbackSpeed;
            this.updateDeltaTime(dt);
            this._time = time;
        };
        /**
         * 重置动画
         * @param name			动画名称
         * @param offset		动画时间偏移
         */
        AnimatorBase.prototype.reset = function (name, offset) {
            if (offset === void 0) { offset = 0; }
            this.getAnimationState(this._animationSet.getAnimation(name)).offset(offset + this._absoluteTime);
        };
        /**
         * 添加应用动画的网格
         * @private
         */
        AnimatorBase.prototype.addOwner = function (mesh) {
            this._owners.push(mesh);
        };
        /**
         * 移除应用动画的网格
         * @private
         */
        AnimatorBase.prototype.removeOwner = function (mesh) {
            this._owners.splice(this._owners.indexOf(mesh), 1);
        };
        /**
         * 更新偏移时间
         * @private
         */
        AnimatorBase.prototype.updateDeltaTime = function (dt) {
            this._absoluteTime += dt;
            this._activeState.update(this._absoluteTime);
            if (this.updatePosition)
                this.applyPositionDelta();
        };
        /**
         * 自动更新动画时帧更新事件
         */
        AnimatorBase.prototype.onEnterFrame = function (event) {
            if (event === void 0) { event = null; }
            this.update(getTimer());
        };
        /**
         * 应用位置偏移量
         */
        AnimatorBase.prototype.applyPositionDelta = function () {
            var delta = this._activeState.positionDelta;
            var dist = delta.length;
            var len;
            if (dist > 0) {
                len = this._owners.length;
                for (var i = 0; i < len; ++i)
                    this._owners[i].transform3D.translateLocal(delta, dist);
            }
        };
        /**
         * 派发动画播放完成一周期事件
         * @private
         */
        AnimatorBase.prototype.dispatchCycleEvent = function () {
            if (this.hasEventListener(feng3d.AnimatorEvent.CYCLE_COMPLETE))
                this.dispatchEvent(new feng3d.AnimatorEvent(feng3d.AnimatorEvent.CYCLE_COMPLETE, this));
        };
        /**
         * @inheritDoc
         */
        AnimatorBase.prototype.setRenderState = function (renderable, camera) {
            throw new feng3d.AbstractMethodError();
        };
        Object.defineProperty(AnimatorBase.prototype, "namedAsset", {
            get: function () {
                return _namedAsset;
            },
            enumerable: true,
            configurable: true
        });
        return AnimatorBase;
    }(feng3d.Component));
    feng3d.AnimatorBase = AnimatorBase;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 粒子动画
     * @author feng 2014-11-13
     */
    var ParticleAnimator = (function (_super) {
        __extends(ParticleAnimator, _super);
        /**
         * 创建粒子动画
         * @param particleAnimationSet 粒子动画集合
         */
        function ParticleAnimator(particleAnimationSet) {
            _super.call(this, particleAnimationSet);
            this._animationParticleStates = new feng3d.ParticleStateBase[];
            this._timeParticleStates = new feng3d.ParticleStateBase[];
            /** 常量数据 */
            this.vertexZeroConst = number[]([0, 1, 2, 0]);
            /** 时间常数（粒子当前时间） */
            this.timeConstData = new number[](4);
            this._particleAnimationSet = particleAnimationSet;
            this.context3DBufferOwner.addChildBufferOwner(this._particleAnimationSet.context3DBufferOwner);
        }
        /**
         * @inheritDoc
         */
        ParticleAnimator.prototype.initBuffers = function () {
            _super.prototype.initBuffers.call(this);
            this.context3DBufferOwner.mapContext3DBuffer(this._.particleCommon_vc_vector, this.updateParticleConstDataBuffer);
            this.context3DBufferOwner.mapContext3DBuffer(this._.particleTime_vc_vector, this.updateTimeConstBuffer);
        };
        ParticleAnimator.prototype.updateTimeConstBuffer = function (timeConstBuffer) {
            timeConstBuffer.update(this.timeConstData);
        };
        ParticleAnimator.prototype.updateParticleConstDataBuffer = function (particleConstDataBuffer) {
            particleConstDataBuffer.update(this.vertexZeroConst);
        };
        /**
         * @inheritDoc
         */
        ParticleAnimator.prototype.setRenderState = function (renderable, camera) {
            var subMesh = feng3d.MeshRenderable(renderable).subMesh;
            if (!subMesh)
                throw (new Error("Must be subMesh"));
            if (!subMesh.animationSubGeometry)
                this._particleAnimationSet.generateAnimationSubGeometries(subMesh.parentMesh);
            this.timeConstData[0] = this.timeConstData[1] = this.timeConstData[2] = this.timeConstData[3] = this.time / 1000;
            this._particleAnimationSet.setRenderState(renderable, camera);
        };
        /**
         * @inheritDoc
         */
        ParticleAnimator.prototype.start = function () {
            _super.prototype.start.call(this);
            for (each(); ; )
                var state;
             in this._timeParticleStates;
            state.offset(_absoluteTime);
        };
        /**
         * @inheritDoc
         */
        ParticleAnimator.prototype.updateDeltaTime = function (dt) {
            _absoluteTime += dt;
            for (each(); ; )
                var state;
             in this._timeParticleStates;
            state.update(_absoluteTime);
        };
        return ParticleAnimator;
    }(feng3d.AnimatorBase));
    feng3d.ParticleAnimator = ParticleAnimator;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 骨骼动画
     * @author feng 2014-5-27
     */
    var SkeletonAnimator = (function (_super) {
        __extends(SkeletonAnimator, _super);
        /**
         * 创建一个骨骼动画类
         * @param animationSet 动画集合
         * @param skeleton 骨骼
         * @param forceCPU 是否强行使用cpu
         */
        function SkeletonAnimator(animationSet, skeleton, forceCPU) {
            if (forceCPU === void 0) { forceCPU = false; }
            _super.call(this, animationSet);
            this._globalMatrices = new number[]();
            this._globalPose = new feng3d.SkeletonPose();
            this._animationStates = {};
            this._skeleton = skeleton;
            this._forceCPU = forceCPU;
            this._jointsPerVertex = animationSet.jointsPerVertex;
            if (this._forceCPU || this._jointsPerVertex > 4)
                _animationSet.cancelGPUCompatibility();
            animationSet.numJoints = this._skeleton.numJoints;
            this._numJoints = this._skeleton.numJoints;
            this._globalMatrices.length = this._numJoints * 12;
            this._globalMatrices.fixed = true;
            //初始化骨骼变换矩阵
            var j;
            for (var i = 0; i < this._numJoints; ++i) {
                this._globalMatrices[j++] = 1;
                this._globalMatrices[j++] = 0;
                this._globalMatrices[j++] = 0;
                this._globalMatrices[j++] = 0;
                this._globalMatrices[j++] = 0;
                this._globalMatrices[j++] = 1;
                this._globalMatrices[j++] = 0;
                this._globalMatrices[j++] = 0;
                this._globalMatrices[j++] = 0;
                this._globalMatrices[j++] = 0;
                this._globalMatrices[j++] = 1;
                this._globalMatrices[j++] = 0;
            }
        }
        Object.defineProperty(SkeletonAnimator.prototype, "globalMatrices", {
            /**
             * 当前骨骼姿势的全局矩阵
             * @see #globalPose
             */
            get: function () {
                if (_globalPropertiesDirty)
                    updateGlobalProperties();
                return _globalMatrices;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SkeletonAnimator.prototype, "globalPose", {
            /**
             * 当前全局骨骼姿势
             */
            get: function () {
                if (_globalPropertiesDirty)
                    updateGlobalProperties();
                return _globalPose;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SkeletonAnimator.prototype, "skeleton", {
            /**
             * 骨骼
             */
            get: function () {
                return _skeleton;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SkeletonAnimator.prototype, "forceCPU", {
            /**
             * 是否强行使用cpu
             */
            get: function () {
                return _forceCPU;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        SkeletonAnimator.prototype.initBuffers = function () {
            _super.prototype.initBuffers.call(this);
            this.context3DBufferOwner.mapContext3DBuffer(this._.globalmatrices_vc_vector, this.updateGlobalmatricesBuffer);
        };
        SkeletonAnimator.prototype.updateGlobalmatricesBuffer = function (globalmatricesBuffer) {
            globalmatricesBuffer.update(this._globalMatrices);
        };
        /**
         * 播放动画
         * @param name 动作名称
         * @param offset 偏移量
         */
        SkeletonAnimator.prototype.play = function (name, transition, offset) {
            if (transition === void 0) { transition = null; }
            if (offset === void 0) { offset = NaN; }
            if (_activeAnimationName != name) {
                _activeAnimationName = name;
                if (!_animationSet.hasAnimation(name))
                    throw new Error("Animation root node " + name + " not found!");
                if (transition && _activeNode) {
                    //setup the transition
                    _activeNode = transition.getAnimationNode(this, _activeNode, _animationSet.getAnimation(name), _absoluteTime);
                    _activeNode.addEventListener(feng3d.AnimationStateEvent.TRANSITION_COMPLETE, this.onTransitionComplete);
                }
                else
                    _activeNode = _animationSet.getAnimation(name);
                _activeState = this.getAnimationState(_activeNode);
                if (this.updatePosition) {
                    //this.update straight away to this.reset position deltas
                    _activeState.update(_absoluteTime);
                    _activeState.positionDelta;
                }
                this._activeSkeletonState = _activeState;
            }
            this.start();
            //使用时间偏移量处理特殊情况
            if (!isNaN(offset))
                this.reset(name, offset);
        };
        /**
         * @inheritDoc
         */
        SkeletonAnimator.prototype.setRenderState = function (renderable, camera) {
            //检查全局变换矩阵
            if (this._globalPropertiesDirty)
                this.updateGlobalProperties();
            var subGeometry = feng3d.MeshRenderable(renderable).subMesh.subGeometry;
            if (_animationSet.usesCPU) {
                var subGeomAnimState = this._animationStates[subGeometry] || ;
                new SubGeomAnimationState(subGeometry);
                //检查动画数据
                if (subGeomAnimState.dirty) {
                    this.morphGeometry(subGeomAnimState, subGeometry);
                    subGeomAnimState.dirty = false;
                }
                //更新动画数据到几何体
                var skinnedGeom = subGeometry.getOrCreateComponentByClass(feng3d.SkinnedSubGeometry);
                skinnedGeom.updateAnimatedData(subGeomAnimState.animatedVertexData);
            }
        };
        /**
         * @inheritDoc
         */
        SkeletonAnimator.prototype.updateDeltaTime = function (dt) {
            _super.prototype.updateDeltaTime.call(this, dt);
            this.context3DBufferOwner.markBufferDirty(this._.globalmatrices_vc_vector);
            //invalidate pose matrices
            this._globalPropertiesDirty = true;
            for (var key in this._animationStates)
                SubGeomAnimationState(this._animationStates[key]).dirty = true;
        };
        /**
         * 更新骨骼全局变换矩阵
         */
        SkeletonAnimator.prototype.updateGlobalProperties = function () {
            this._globalPropertiesDirty = false;
            //获取全局骨骼姿势
            this.localToGlobalPose(this._activeSkeletonState.getSkeletonPose(this._skeleton), this._globalPose, this._skeleton);
            //姿势变换矩阵
            //矩阵偏移量
            var mtxOffset;
            var globalPoses = this._globalPose.jointPoses;
            var raw;
            var ox, oy, oz, ow;
            var xy2, xz2, xw2;
            var yz2, yw2, zw2;
            var n11, n12, n13;
            var n21, n22, n23;
            var n31, n32, n33;
            var m11, m12, m13, m14;
            var m21, m22, m23, m24;
            var m31, m32, m33, m34;
            var joints = this._skeleton.joints;
            var pose;
            var quat;
            var vec;
            var t;
            //遍历每个关节
            for (var i = 0; i < this._numJoints; ++i) {
                //读取关节全局姿势数据
                pose = globalPoses[i];
                quat = pose.orientation;
                vec = pose.translation;
                ox = quat.x;
                oy = quat.y;
                oz = quat.z;
                ow = quat.w;
                //计算关节的全局变换矩阵
                xy2 = (t = 2.0 * ox) * oy;
                xz2 = t * oz;
                xw2 = t * ow;
                yz2 = (t = 2.0 * oy) * oz;
                yw2 = t * ow;
                zw2 = 2.0 * oz * ow;
                yz2 = 2.0 * oy * oz;
                yw2 = 2.0 * oy * ow;
                zw2 = 2.0 * oz * ow;
                ox *= ox;
                oy *= oy;
                oz *= oz;
                ow *= ow;
                //保存关节的全局变换矩阵
                n11 = (t = ox - oy) - oz + ow;
                n12 = xy2 - zw2;
                n13 = xz2 + yw2;
                n21 = xy2 + zw2;
                n22 = -t - oz + ow;
                n23 = yz2 - xw2;
                n31 = xz2 - yw2;
                n32 = yz2 + xw2;
                n33 = -ox - oy + oz + ow;
                //初始状态 下关节的 逆矩阵
                raw = joints[i].inverseBindPose;
                m11 = raw[0];
                m12 = raw[4];
                m13 = raw[8];
                m14 = raw[12];
                m21 = raw[1];
                m22 = raw[5];
                m23 = raw[9];
                m24 = raw[13];
                m31 = raw[2];
                m32 = raw[6];
                m33 = raw[10];
                m34 = raw[14];
                //计算关节全局变换矩阵(通过初始状态 关节逆矩阵与全局变换矩阵 计算 当前状态的关节矩阵)
                this._globalMatrices[number(mtxOffset)] = n11 * m11 + n12 * m21 + n13 * m31;
                this._globalMatrices[number(mtxOffset + 1)] = n11 * m12 + n12 * m22 + n13 * m32;
                this._globalMatrices[number(mtxOffset + 2)] = n11 * m13 + n12 * m23 + n13 * m33;
                this._globalMatrices[number(mtxOffset + 3)] = n11 * m14 + n12 * m24 + n13 * m34 + vec.x;
                this._globalMatrices[number(mtxOffset + 4)] = n21 * m11 + n22 * m21 + n23 * m31;
                this._globalMatrices[number(mtxOffset + 5)] = n21 * m12 + n22 * m22 + n23 * m32;
                this._globalMatrices[number(mtxOffset + 6)] = n21 * m13 + n22 * m23 + n23 * m33;
                this._globalMatrices[number(mtxOffset + 7)] = n21 * m14 + n22 * m24 + n23 * m34 + vec.y;
                this._globalMatrices[number(mtxOffset + 8)] = n31 * m11 + n32 * m21 + n33 * m31;
                this._globalMatrices[number(mtxOffset + 9)] = n31 * m12 + n32 * m22 + n33 * m32;
                this._globalMatrices[number(mtxOffset + 10)] = n31 * m13 + n32 * m23 + n33 * m33;
                this._globalMatrices[number(mtxOffset + 11)] = n31 * m14 + n32 * m24 + n33 * m34 + vec.z;
                //跳到下个矩阵位置
                mtxOffset = number(mtxOffset + 12);
            }
        };
        /**
         * 几何体变形
         * @param state 动画几何体数据
         * @param subGeom 蒙皮几何体
         */
        SkeletonAnimator.prototype.morphGeometry = function (state, subGeom) {
            var skinnedGeom = subGeom.getOrCreateComponentByClass(feng3d.SkinnedSubGeometry);
            //几何体顶点数据
            var vertexData = subGeom.vertexPositionData;
            //动画顶点数据（目标数据）
            var targetData = state.animatedVertexData;
            var jointIndices = skinnedGeom.jointIndexData;
            var jointWeights = skinnedGeom.jointWeightsData;
            var index;
            var j, k;
            var vx, vy, vz;
            var len = vertexData.length;
            var weight;
            var vertX, vertY, vertZ;
            var m11, m12, m13, m14;
            var m21, m22, m23, m24;
            var m31, m32, m33, m34;
            //计算每个顶点的坐标，法线、切线
            while (index < len) {
                //提取原始顶点坐标、法线、切线数据
                vertX = vertexData[index];
                vertY = vertexData[number(index + 1)];
                vertZ = vertexData[number(index + 2)];
                vx = 0;
                vy = 0;
                vz = 0;
                k = 0;
                //遍历与该顶点相关的关节权重
                while (k < this._jointsPerVertex) {
                    weight = jointWeights[j];
                    if (weight > 0) {
                        //读取该关节的全局变换矩阵
                        var mtxOffset = number(jointIndices[j++]) << 2;
                        m11 = this._globalMatrices[mtxOffset];
                        m12 = this._globalMatrices[number(mtxOffset + 1)];
                        m13 = this._globalMatrices[number(mtxOffset + 2)];
                        m14 = this._globalMatrices[number(mtxOffset + 3)];
                        m21 = this._globalMatrices[number(mtxOffset + 4)];
                        m22 = this._globalMatrices[number(mtxOffset + 5)];
                        m23 = this._globalMatrices[number(mtxOffset + 6)];
                        m24 = this._globalMatrices[number(mtxOffset + 7)];
                        m31 = this._globalMatrices[number(mtxOffset + 8)];
                        m32 = this._globalMatrices[number(mtxOffset + 9)];
                        m33 = this._globalMatrices[number(mtxOffset + 10)];
                        m34 = this._globalMatrices[number(mtxOffset + 11)];
                        //根据关节的全局变换矩阵与对应权重计算出对该坐标的影响值
                        vx += weight * (m11 * vertX + m12 * vertY + m13 * vertZ + m14);
                        vy += weight * (m21 * vertX + m22 * vertY + m23 * vertZ + m24);
                        vz += weight * (m31 * vertX + m32 * vertY + m33 * vertZ + m34);
                        ++k;
                    }
                    else {
                        j += number(this._jointsPerVertex - k);
                        k = this._jointsPerVertex;
                    }
                }
                //保存最终计算得出的坐标、法线、切线数据
                targetData[index] = vx;
                targetData[number(index + 1)] = vy;
                targetData[number(index + 2)] = vz;
                //跳到下个顶点的起始位置
                index = number(index + subGeom.vertexPositionStride);
            }
        };
        /**
         * 本地转换到全局姿势
         * @param sourcePose 原姿势
         * @param targetPose 目标姿势
         * @param skeleton 骨骼
         */
        SkeletonAnimator.prototype.localToGlobalPose = function (sourcePose, targetPose, skeleton) {
            var globalPoses = targetPose.jointPoses;
            var globalJointPose;
            var joints = skeleton.joints;
            var len = sourcePose.numJointPoses;
            var jointPoses = sourcePose.jointPoses;
            var parentIndex;
            var joint;
            var parentPose;
            var pose;
            var or;
            var tr;
            var gTra;
            var gOri;
            var x1, y1, z1, w1;
            var x2, y2, z2, w2;
            var x3, y3, z3;
            //初始化全局骨骼姿势长度
            if (globalPoses.length != len)
                globalPoses.length = len;
            for (var i = 0; i < len; ++i) {
                //初始化单个全局骨骼姿势
                globalJointPose = globalPoses[i] || ;
                new feng3d.JointPose();
                joint = joints[i];
                parentIndex = joint.parentIndex;
                pose = jointPoses[i];
                //世界方向偏移
                gOri = globalJointPose.orientation;
                //全局位置偏移
                gTra = globalJointPose.translation;
                //计算全局骨骼的 方向偏移与位置偏移
                if (parentIndex < 0) {
                    //处理跟骨骼(直接赋值)
                    tr = pose.translation;
                    or = pose.orientation;
                    gOri.x = or.x;
                    gOri.y = or.y;
                    gOri.z = or.z;
                    gOri.w = or.w;
                    gTra.x = tr.x;
                    gTra.y = tr.y;
                    gTra.z = tr.z;
                }
                else {
                    //处理其他骨骼
                    //找到父骨骼全局姿势
                    parentPose = globalPoses[parentIndex];
                    or = parentPose.orientation;
                    tr = pose.translation;
                    //提取父姿势的世界方向数据
                    x2 = or.x;
                    y2 = or.y;
                    z2 = or.z;
                    w2 = or.w;
                    //提取当前姿势相对父姿势的位置数据
                    x3 = tr.x;
                    y3 = tr.y;
                    z3 = tr.z;
                    //计算当前姿势相对父姿势在全局中的位置偏移方向(有点没搞懂，我只能这么说如果一定要我来计算的话，我一定能做出来)
                    w1 = -x2 * x3 - y2 * y3 - z2 * z3;
                    x1 = w2 * x3 + y2 * z3 - z2 * y3;
                    y1 = w2 * y3 - x2 * z3 + z2 * x3;
                    z1 = w2 * z3 + x2 * y3 - y2 * x3;
                    //计算当前骨骼全局姿势的位置数据（父姿势的世界坐标加上当前姿势相对父姿势转换为全局的坐标变化量）
                    tr = parentPose.translation;
                    gTra.x = -w1 * x2 + x1 * w2 - y1 * z2 + z1 * y2 + tr.x;
                    gTra.y = -w1 * y2 + x1 * z2 + y1 * w2 - z1 * x2 + tr.y;
                    gTra.z = -w1 * z2 - x1 * y2 + y1 * x2 + z1 * w2 + tr.z;
                    //提取父姿势的世界方向数据
                    x1 = or.x;
                    y1 = or.y;
                    z1 = or.z;
                    w1 = or.w;
                    //提取当前姿势相对父姿势的方向数据
                    or = pose.orientation;
                    x2 = or.x;
                    y2 = or.y;
                    z2 = or.z;
                    w2 = or.w;
                    //根据父姿势的世界方向数据与当前姿势的方向数据计算当前姿势的世界方向数据
                    gOri.w = w1 * w2 - x1 * x2 - y1 * y2 - z1 * z2;
                    gOri.x = w1 * x2 + x1 * w2 + y1 * z2 - z1 * y2;
                    gOri.y = w1 * y2 - x1 * z2 + y1 * w2 + z1 * x2;
                    gOri.z = w1 * z2 + x1 * y2 - y1 * x2 + z1 * w2;
                }
            }
        };
        /**
         * 处理动画变换完成时间
         */
        SkeletonAnimator.prototype.onTransitionComplete = function (event) {
            if (event.type == feng3d.AnimationStateEvent.TRANSITION_COMPLETE) {
                event.animationNode.removeEventListener(feng3d.AnimationStateEvent.TRANSITION_COMPLETE, this.onTransitionComplete);
                if (_activeState == event.animationState) {
                    _activeNode = _animationSet.getAnimation(_activeAnimationName);
                    _activeState = this.getAnimationState(_activeNode);
                    this._activeSkeletonState = _activeState;
                }
            }
        };
        return SkeletonAnimator;
    }(feng3d.AnimatorBase));
    feng3d.SkeletonAnimator = SkeletonAnimator;
})(feng3d || (feng3d = {}));
/**
 * 动画状态几何体数据
 */
var SubGeomAnimationState = (function () {
    function SubGeomAnimationState() {
        this.dirty = true;
    }
    /**
     * 创建一个动画当前状态的数据类(用来保存动画顶点数据)
     */
    SubGeomAnimationState.prototype.SubGeomAnimationState = function (subGeom) {
        this.animatedVertexData = subGeom.vertexPositionData.concat();
    };
    return SubGeomAnimationState;
}());
var feng3dSheet;
(function (feng3dSheet) {
    /**
     * sprite动画
     * @author feng 2014-5-27
     */
    var SpriteSheetAnimator = (function (_super) {
        __extends(SpriteSheetAnimator, _super);
        /**
         * 创建sprite动画实例
         * @param spriteSheetAnimationSet			sprite动画集合
         */
        function SpriteSheetAnimator(spriteSheetAnimationSet) {
            _super.call(this, spriteSheetAnimationSet);
            this._vectorFrame = new number[](4, true);
            this._frame = new feng3dSheet.SpriteSheetAnimationFrame();
            this._fps = 10;
            this._ms = 100;
            this._spriteSheetAnimationSet = spriteSheetAnimationSet;
        }
        Object.defineProperty(SpriteSheetAnimator.prototype, "fps", {
            /**
             * 帧率
             */
            get: function () {
                return _fps;
            },
            set: function (val) {
                _ms = 1000 / val;
                _fps = val;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SpriteSheetAnimator.prototype, "reverse", {
            /**
             * 是否反向
             */
            get: function () {
                return _reverse;
            },
            set: function (b) {
                _reverse = b;
                _specsDirty = true;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SpriteSheetAnimator.prototype, "backAndForth", {
            /**
             * 改变播放方向
             */
            get: function () {
                return _backAndForth;
            },
            set: function (b) {
                _backAndForth = b;
                _specsDirty = true;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 跳到某帧播放（起始帧为1）
         * @param frameNumber			帧编号
         */
        SpriteSheetAnimator.prototype.gotoAndPlay = function (frameNumber) {
            this.gotoFrame(frameNumber, true);
        };
        /**
         * 跳到某帧停止（起始帧为1）
         * @param frameNumber			帧编号
         */
        SpriteSheetAnimator.prototype.gotoAndStop = function (frameNumber) {
            this.gotoFrame(frameNumber, false);
        };
        Object.defineProperty(SpriteSheetAnimator.prototype, "currentFrameNumber", {
            /**
             * 当前帧编号
             */
            get: function () {
                return feng3dSheet.SpriteSheetAnimationState(_activeState).currentFrameNumber;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SpriteSheetAnimator.prototype, "totalFrames", {
            /**
             * 总帧数
             */
            get: function () {
                return feng3dSheet.SpriteSheetAnimationState(_activeState).totalFrames;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        SpriteSheetAnimator.prototype.initBuffers = function () {
            _super.prototype.initBuffers.call(this);
            this.context3DBufferOwner.mapContext3DBuffer(this._.spriteSheetVectorFrame_vc_vector, this.updateVectorFrameBuffer);
        };
        SpriteSheetAnimator.prototype.updateVectorFrameBuffer = function (vcVectorBuffer) {
            vcVectorBuffer.update(this._vectorFrame);
        };
        /**
         * @inheritDoc
         */
        SpriteSheetAnimator.prototype.setRenderState = function (renderable, camera) {
            var material = renderable.material;
            if (!material || !material)
                is;
            TextureMaterial;
            return;
            var subMesh = MeshRenderable(renderable).subMesh;
            if (!subMesh)
                return;
            //because textures are already uploaded, we can't offset the uv's yet
            var swapped;
            if (material)
                is;
            SpriteSheetMaterial && this._mapDirty;
            swapped = SpriteSheetMaterial(material).swap(this._frame.mapID);
            if (!swapped) {
                this._vectorFrame[0] = this._frame.offsetU;
                this._vectorFrame[1] = this._frame.offsetV;
                this._vectorFrame[2] = this._frame.scaleU;
                this._vectorFrame[3] = this._frame.scaleV;
            }
        };
        /**
         * @inheritDoc
         */
        SpriteSheetAnimator.prototype.play = function (name, transition, offset) {
            if (transition === void 0) { transition = null; }
            if (offset === void 0) { offset = NaN; }
            transition = transition;
            offset = offset;
            if (_activeAnimationName == name)
                return;
            _activeAnimationName = name;
            if (!_animationSet.hasAnimation(name))
                throw new Error("Animation root node " + name + " not found!");
            _activeNode = _animationSet.getAnimation(name);
            _activeState = this.getAnimationState(_activeNode);
            this._frame = feng3dSheet.SpriteSheetAnimationState(_activeState).currentFrameData;
            this._activeSpriteSheetState = _activeState;
            this.start();
        };
        /**
         * @inheritDoc
         */
        SpriteSheetAnimator.prototype.updateDeltaTime = function (dt) {
            if (this._specsDirty) {
                feng3dSheet.SpriteSheetAnimationState(this._activeSpriteSheetState).reverse = this._reverse;
                feng3dSheet.SpriteSheetAnimationState(this._activeSpriteSheetState).backAndForth = this._backAndForth;
                this._specsDirty = false;
            }
            _absoluteTime += dt;
            var now = getTimer();
            if ((now - this._lastTime) > this._ms) {
                this._mapDirty = true;
                this._activeSpriteSheetState.update(_absoluteTime);
                this._frame = feng3dSheet.SpriteSheetAnimationState(this._activeSpriteSheetState).currentFrameData;
                this._lastTime = now;
            }
            else
                this._mapDirty = false;
        };
        /**
         * 克隆
         */
        SpriteSheetAnimator.prototype.clone = function () {
            return new SpriteSheetAnimator(this._spriteSheetAnimationSet);
        };
        /**
         * 跳转某帧
         * @param frameNumber			帧编号
         * @param doPlay				是否播放
         */
        SpriteSheetAnimator.prototype.gotoFrame = function (frameNumber, doPlay) {
            if (!_activeState)
                return;
            feng3dSheet.SpriteSheetAnimationState(_activeState).currentFrameNumber = (frameNumber == 0) ? frameNumber : frameNumber - 1;
            var currentMapID = this._frame.mapID;
            this._frame = feng3dSheet.SpriteSheetAnimationState(this._activeSpriteSheetState).currentFrameData;
            if (doPlay)
                this.start();
            else {
                if (currentMapID != this._frame.mapID) {
                    this._mapDirty = true;
                    setTimeout(this.stop, this._fps);
                }
                else
                    this.stop();
            }
        };
        return SpriteSheetAnimator;
    }(AnimatorBase));
    feng3dSheet.SpriteSheetAnimator = SpriteSheetAnimator;
})(feng3dSheet || (feng3dSheet = {}));
var feng3d;
(function (feng3d) {
    /**
     * UV动画
     * @author feng 2014-5-27
     */
    var UVAnimator = (function (_super) {
        __extends(UVAnimator, _super);
        /**
         * 创建<code>UVAnimator</code>实例
         * @param uvAnimationSet			UV动画集合
         */
        function UVAnimator(uvAnimationSet) {
            _super.call(this, uvAnimationSet);
            this._matrix2d = number[]([1, 0, 0, 0, 1, 0, 0, 0]);
            this._translate = number[]([0, 0, 0.5, 0.5]);
            this._deltaFrame = new feng3d.UVAnimationFrame();
            this._rotationIncrease = 1;
            this._uvTransform = new Matrix();
            this._uvAnimationSet = uvAnimationSet;
        }
        Object.defineProperty(UVAnimator.prototype, "autoRotation", {
            /**
             * 是否自动旋转
             */
            get: function () {
                return _autoRotation;
            },
            set: function (b) {
                _autoRotation = b;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UVAnimator.prototype, "rotationIncrease", {
            /**
             * 旋转增量（当autoRotation = true生效）
             */
            get: function () {
                return _rotationIncrease;
            },
            set: function (value) {
                _rotationIncrease = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UVAnimator.prototype, "autoTranslate", {
            /**
             * 是否自动转换
             */
            get: function () {
                return _autoTranslate;
            },
            set: function (b) {
                _autoTranslate = b;
                if (b && !_translateIncrease)
                    _translateIncrease = number[]([0, 0]);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 设置转换值
         * @param u
         * @param v
         */
        UVAnimator.prototype.setTranslateIncrease = function (u, v) {
            if (!this._translateIncrease)
                this._translateIncrease = number[]([0, 0]);
            this._translateIncrease[0] = u;
            this._translateIncrease[1] = v;
        };
        Object.defineProperty(UVAnimator.prototype, "translateIncrease", {
            /**
             * 转换值
             */
            get: function () {
                return _translateIncrease;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        UVAnimator.prototype.initBuffers = function () {
            _super.prototype.initBuffers.call(this);
            this.context3DBufferOwner.mapContext3DBuffer(this._.uvAnimatorTranslate_vc_vector, this.updateTranslateBuffer);
            this.context3DBufferOwner.mapContext3DBuffer(this._.uvAnimatorMatrix2d_vc_vector, this.updateMatrix2dBuffer);
        };
        UVAnimator.prototype.updateTranslateBuffer = function (buffer) {
            buffer.update(this._translate);
        };
        UVAnimator.prototype.updateMatrix2dBuffer = function (buffer) {
            buffer.update(this._matrix2d);
        };
        /**
         * @inheritDoc
         */
        UVAnimator.prototype.setRenderState = function (renderable, camera) {
            var material = renderable.material;
            var subMesh = feng3d.MeshRenderable(renderable).subMesh;
            if (!material || !subMesh)
                return;
            if (this.autoTranslate) {
                this._deltaFrame.offsetU += this._translateIncrease[0];
                this._deltaFrame.offsetV += this._translateIncrease[1];
            }
            this._translate[0] = this._deltaFrame.offsetU;
            this._translate[1] = this._deltaFrame.offsetV;
            this._uvTransform.identity();
            if (this._autoRotation)
                this._deltaFrame.rotation += this._rotationIncrease;
            if (this._deltaFrame.rotation != 0)
                this._uvTransform.rotate(this._deltaFrame.rotation * feng3d.MathConsts.DEGREES_TO_RADIANS);
            if (this._deltaFrame.scaleU != 1 || this._deltaFrame.scaleV != 1)
                this._uvTransform.scale(this._deltaFrame.scaleU, this._deltaFrame.scaleV);
            this._matrix2d[0] = this._uvTransform.a;
            this._matrix2d[1] = this._uvTransform.b;
            this._matrix2d[3] = this._uvTransform.tx;
            this._matrix2d[4] = this._uvTransform.c;
            this._matrix2d[5] = this._uvTransform.d;
            this._matrix2d[7] = this._uvTransform.ty;
        };
        /**
         * @inheritDoc
         */
        UVAnimator.prototype.play = function (name, transition, offset) {
            if (transition === void 0) { transition = null; }
            if (offset === void 0) { offset = NaN; }
            transition = transition;
            offset = offset;
            if (_activeAnimationName == name)
                return;
            _activeAnimationName = name;
            if (!_animationSet.hasAnimation(name))
                throw new Error("Animation root node " + name + " not found!");
            _activeNode = _animationSet.getAnimation(name);
            _activeState = this.getAnimationState(_activeNode);
            this._activeUVState = _activeState;
            this.start();
        };
        /**
         * @inheritDoc
         */
        UVAnimator.prototype.updateDeltaTime = function (dt) {
            _absoluteTime += dt;
            this._activeUVState.update(_absoluteTime);
            var currentUVFrame = this._activeUVState.currentUVFrame;
            var nextUVFrame = this._activeUVState.nextUVFrame;
            var blendWeight = this._activeUVState.blendWeight;
            if (currentUVFrame && nextUVFrame) {
                this._deltaFrame.offsetU = currentUVFrame.offsetU + blendWeight * (nextUVFrame.offsetU - currentUVFrame.offsetU);
                this._deltaFrame.offsetV = currentUVFrame.offsetV + blendWeight * (nextUVFrame.offsetV - currentUVFrame.offsetV);
                this._deltaFrame.scaleU = currentUVFrame.scaleU + blendWeight * (nextUVFrame.scaleU - currentUVFrame.scaleU);
                this._deltaFrame.scaleV = currentUVFrame.scaleV + blendWeight * (nextUVFrame.scaleV - currentUVFrame.scaleV);
                this._deltaFrame.rotation = currentUVFrame.rotation + blendWeight * (nextUVFrame.rotation - currentUVFrame.rotation);
            }
        };
        /**
         * @inheritDoc
         */
        UVAnimator.prototype.clone = function () {
            return new UVAnimator(this._uvAnimationSet);
        };
        return UVAnimator;
    }(feng3d.AnimatorBase));
    feng3d.UVAnimator = UVAnimator;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 顶点动画
     * @author feng 2014-5-13
     */
    var VertexAnimator = (function (_super) {
        __extends(VertexAnimator, _super);
        /**
         * 创建一个顶点动画
         * @param vertexAnimationSet 顶点动画集合
         */
        function VertexAnimator(vertexAnimationSet) {
            _super.call(this, vertexAnimationSet);
            this._weights = number[]([1, 0, 0, 0]);
            this._poses = new feng3d.Geometry[]();
            this._vertexAnimationSet = vertexAnimationSet;
            this._numPoses = vertexAnimationSet.numPoses;
        }
        /**
         * @inheritDoc
         */
        VertexAnimator.prototype.initBuffers = function () {
            _super.prototype.initBuffers.call(this);
            this.context3DBufferOwner.mapContext3DBuffer(this._.weights_vc_vector, this.updateWeightsBuffer);
        };
        VertexAnimator.prototype.updateWeightsBuffer = function (weightsBuffer) {
            weightsBuffer.update(this._weights);
        };
        /**
         * 播放动画
         * @param name 动作名称
         * @param offset 时间偏移量
         */
        VertexAnimator.prototype.play = function (name, transition, offset) {
            if (transition === void 0) { transition = null; }
            if (offset === void 0) { offset = NaN; }
            if (_activeAnimationName != name) {
                _activeAnimationName = name;
                if (!this._vertexAnimationSet.hasAnimation(name))
                    throw new Error("Animation root node " + name + " not found!");
                //获取活动的骨骼状态
                _activeNode = this._vertexAnimationSet.getAnimation(name);
                _activeState = this.getAnimationState(_activeNode);
                if (this.updatePosition) {
                    //this.update straight away to this.reset position deltas
                    _activeState.update(_absoluteTime);
                    _activeState.positionDelta;
                }
                this._activeVertexState = _activeState;
            }
            this.start();
            //使用时间偏移量处理特殊情况
            if (!isNaN(offset))
                this.reset(name, offset);
        };
        /**
         * @inheritDoc
         */
        VertexAnimator.prototype.updateDeltaTime = function (dt) {
            _super.prototype.updateDeltaTime.call(this, dt);
            this._poses[number(0)] = this._activeVertexState.currentGeometry;
            this._poses[number(1)] = this._activeVertexState.nextGeometry;
            this._weights[number(0)] = 1 - (this._weights[number(1)] = this._activeVertexState.blendWeight);
        };
        /**
         * @inheritDoc
         */
        VertexAnimator.prototype.setRenderState = function (renderable, camera) {
            //没有姿势时，使用默认姿势
            if (!this._poses.length) {
                this.setNullPose(renderable);
                return;
            }
            // this type of animation can only be SubMesh
            var subMesh = feng3d.MeshRenderable(renderable).subMesh;
            var subGeom = subMesh.subGeometry;
            var vertexSubGeom = subGeom.getOrCreateComponentByClass(feng3d.VertexSubGeometry);
            //				//获取默认姿势几何体数据
            subGeom = this._poses[0].subGeometries[subMesh._index] || subMesh.subGeometry;
            vertexSubGeom.updateVertexData0(subGeom.vertexPositionData.concat());
            subGeom = this._poses[1].subGeometries[subMesh._index] || subMesh.subGeometry;
            vertexSubGeom.updateVertexData1(subGeom.vertexPositionData.concat());
        };
        /**
         * 设置空姿势
         * @param renderable		渲染对象
         */
        VertexAnimator.prototype.setNullPose = function (renderable) {
            var subMesh = feng3d.MeshRenderable(renderable).subMesh;
            var subGeom = subMesh.subGeometry;
        };
        VertexAnimator.prototype.addOwner = function (mesh) {
            var geometry = mesh.geometry;
            var i;
            var subGeometry;
            for (i = 0; i < geometry.subGeometries.length; i++) {
                subGeometry = geometry.subGeometries[i];
                subGeometry.getOrCreateComponentByClass(feng3d.VertexSubGeometry);
            }
            _super.prototype.addOwner.call(this, mesh);
        };
        return VertexAnimator;
    }(feng3d.AnimatorBase));
    feng3d.VertexAnimator = VertexAnimator;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 骨骼数据
     * @author feng 2014-5-20
     */
    var Skeleton = (function (_super) {
        __extends(Skeleton, _super);
        function Skeleton() {
            this._namedAsset = new feng3d.NamedAsset(this, feng3d.AssetType.SKELETON);
            this.joints = new feng3d.SkeletonJoint[]();
        }
        Object.defineProperty(Skeleton.prototype, "numJoints", {
            get: function () {
                return joints.length;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Skeleton.prototype, "namedAsset", {
            get: function () {
                return _namedAsset;
            },
            enumerable: true,
            configurable: true
        });
        return Skeleton;
    }(feng3d.Component));
    feng3d.Skeleton = Skeleton;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 骨骼pose
     * @author feng 2014-5-20
     */
    var SkeletonPose = (function (_super) {
        __extends(SkeletonPose, _super);
        function SkeletonPose() {
            this._namedAsset = new feng3d.NamedAsset(this, feng3d.AssetType.SKELETON_POSE);
            this.jointPoses = new feng3d.JointPose[]();
        }
        Object.defineProperty(SkeletonPose.prototype, "numJointPoses", {
            get: function () {
                return jointPoses.length;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SkeletonPose.prototype, "namedAsset", {
            get: function () {
                return _namedAsset;
            },
            enumerable: true,
            configurable: true
        });
        return SkeletonPose;
    }(feng3d.Component));
    feng3d.SkeletonPose = SkeletonPose;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 子几何体组件
     * @author feng 2015-12-10
     */
    var SubGeometryComponent = (function (_super) {
        __extends(SubGeometryComponent, _super);
        function SubGeometryComponent() {
            _super.call(this);
            this.addEventListener(feng3d.ComponentEvent.BE_ADDED_COMPONET, this.onBeAddedComponet);
            this.addEventListener(feng3d.ComponentEvent.BE_REMOVED_COMPONET, this.onBeRemovedComponet);
        }
        Object.defineProperty(SubGeometryComponent.prototype, "subGeometry", {
            get: function () {
                return _subGeometry;
            },
            set: function (value) {
                _subGeometry = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 处理被添加事件
         * @param event
         */
        SubGeometryComponent.prototype.onBeAddedComponet = function (event) {
            var addedComponentEventVO = event.data;
            this.subGeometry = addedComponentEventVO.container;
        };
        /**
         * 处理被移除事件
         * @param event
         */
        SubGeometryComponent.prototype.onBeRemovedComponet = function (event) {
            var removedComponentEventVO = event.data;
            this.subGeometry = null;
        };
        Object.defineProperty(SubGeometryComponent.prototype, "_", {
            /**
             * Fagal编号中心
             */
            get: function () {
                return FagalIdCenter.instance;
            },
            enumerable: true,
            configurable: true
        });
        return SubGeometryComponent;
    }(feng3d.Component));
    feng3d.SubGeometryComponent = SubGeometryComponent;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 自动生成顶点法线数据
     * @author feng 2015-12-8
     */
    var AutoDeriveVertexNormals = (function (_super) {
        __extends(AutoDeriveVertexNormals, _super);
        function AutoDeriveVertexNormals() {
            /** 面法线脏标记 */
            this._faceNormalsDirty = true;
            /** 是否使用面权重 */
            this._useFaceWeights = false;
            this.dataTypeId = _.normal_va_3;
            _super.call(this);
        }
        Object.defineProperty(AutoDeriveVertexNormals.prototype, "subGeometry", {
            set: function (value) {
                if (_subGeometry != null) {
                    _subGeometry.removeEventListener(feng3d.GeometryComponentEvent.GET_VA_DATA, onGetVAData);
                    _subGeometry.removeEventListener(feng3d.GeometryComponentEvent.CHANGED_VA_DATA, onChangedVAData);
                    _subGeometry.removeEventListener(feng3d.GeometryComponentEvent.CHANGED_INDEX_DATA, onChangedIndexData);
                }
                _subGeometry = value;
                if (_subGeometry != null) {
                    _subGeometry.addEventListener(feng3d.GeometryComponentEvent.GET_VA_DATA, onGetVAData);
                    _subGeometry.addEventListener(feng3d.GeometryComponentEvent.CHANGED_VA_DATA, onChangedVAData);
                    _subGeometry.addEventListener(feng3d.GeometryComponentEvent.CHANGED_INDEX_DATA, onChangedIndexData);
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 处理被添加事件
         * @param event
         */
        AutoDeriveVertexNormals.prototype.onBeAddedComponet = function (event) {
            _super.prototype.onBeAddedComponet.call(this, event);
            this.needGenerate = true;
            this.subGeometry.invalidVAData(this.dataTypeId);
        };
        AutoDeriveVertexNormals.prototype.onGetVAData = function (event) {
            if (event.data != this.dataTypeId)
                return;
            if (!this.needGenerate)
                return;
            this.target = this.updateVertexNormals(this.target);
            this.subGeometry.setVAData(this.dataTypeId, this.target);
            this.needGenerate = false;
        };
        AutoDeriveVertexNormals.prototype.onChangedVAData = function (event) {
            if (event.data == _.position_va_3) {
                this.needGenerate = true;
                //标记面法线脏数据
                this._faceNormalsDirty = true;
                this.subGeometry.invalidVAData(this.dataTypeId);
            }
        };
        AutoDeriveVertexNormals.prototype.onChangedIndexData = function (event) {
            this._faceNormalsDirty = true;
            this.subGeometry.invalidVAData(this.dataTypeId);
        };
        Object.defineProperty(AutoDeriveVertexNormals.prototype, "faceNormals", {
            /** 面法线 */
            get: function () {
                if (_faceNormalsDirty)
                    updateFaceNormals();
                return _faceNormals;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AutoDeriveVertexNormals.prototype, "useFaceWeights", {
            /**
             * Indicates whether or not to take the size of faces into account when auto-deriving vertex normals and tangents.
             */
            get: function () {
                return _useFaceWeights;
            },
            set: function (value) {
                _useFaceWeights = value;
                subGeometry.invalidVAData(dataTypeId);
                _faceNormalsDirty = true;
            },
            enumerable: true,
            configurable: true
        });
        /** 更新面法线数据 */
        AutoDeriveVertexNormals.prototype.updateFaceNormals = function () {
            var i, j, k;
            var index;
            var _indices = this.subGeometry.indices;
            var len = _indices.length;
            var x1, x2, x3;
            var y1, y2, y3;
            var z1, z2, z3;
            var dx1, dy1, dz1;
            var dx2, dy2, dz2;
            var cx, cy, cz;
            var d;
            var vertices = this.subGeometry.getVAData(_.position_va_3);
            var posStride = 3;
            var posOffset = 0;
            this._faceNormals || ;
            new number[](len, true);
            if (this._useFaceWeights)
                this._faceWeights || ;
            new number[](len / 3, true);
            while (i < len) {
                index = posOffset + _indices[i++] * posStride;
                x1 = vertices[index];
                y1 = vertices[index + 1];
                z1 = vertices[index + 2];
                index = posOffset + _indices[i++] * posStride;
                x2 = vertices[index];
                y2 = vertices[index + 1];
                z2 = vertices[index + 2];
                index = posOffset + _indices[i++] * posStride;
                x3 = vertices[index];
                y3 = vertices[index + 1];
                z3 = vertices[index + 2];
                dx1 = x3 - x1;
                dy1 = y3 - y1;
                dz1 = z3 - z1;
                dx2 = x2 - x1;
                dy2 = y2 - y1;
                dz2 = z2 - z1;
                cx = dz1 * dy2 - dy1 * dz2;
                cy = dx1 * dz2 - dz1 * dx2;
                cz = dy1 * dx2 - dx1 * dy2;
                d = Math.sqrt(cx * cx + cy * cy + cz * cz);
                // length of cross product = 2*triangle area
                if (this._useFaceWeights) {
                    var w = d * 10000;
                    if (w < 1)
                        w = 1;
                    this._faceWeights[k++] = w;
                }
                d = 1 / d;
                this._faceNormals[j++] = cx * d;
                this._faceNormals[j++] = cy * d;
                this._faceNormals[j++] = cz * d;
            }
            this._faceNormalsDirty = false;
        };
        /**
         * 更新顶点法线数据
         * @param target 顶点法线数据
         * @return 顶点法线数据
         */
        AutoDeriveVertexNormals.prototype.updateVertexNormals = function (target) {
            if (this._faceNormalsDirty)
                this.updateFaceNormals();
            var v1;
            var f1 = 0, f2 = 1, f3 = 2;
            var lenV = this.subGeometry.numVertices * 3;
            var normalStride = 3;
            var normalOffset = 0;
            target || ;
            new number[](lenV, true);
            v1 = normalOffset;
            while (v1 < lenV) {
                target[v1] = 0.0;
                target[v1 + 1] = 0.0;
                target[v1 + 2] = 0.0;
                v1 += normalStride;
            }
            var i, k;
            var _indices = this.subGeometry.indices;
            var lenI = _indices.length;
            var index;
            var weight;
            while (i < lenI) {
                weight = this._useFaceWeights ? this._faceWeights[k++] : 1;
                index = normalOffset + _indices[i++] * normalStride;
                target[index++] += this._faceNormals[f1] * weight;
                target[index++] += this._faceNormals[f2] * weight;
                target[index] += this._faceNormals[f3] * weight;
                index = normalOffset + _indices[i++] * normalStride;
                target[index++] += this._faceNormals[f1] * weight;
                target[index++] += this._faceNormals[f2] * weight;
                target[index] += this._faceNormals[f3] * weight;
                index = normalOffset + _indices[i++] * normalStride;
                target[index++] += this._faceNormals[f1] * weight;
                target[index++] += this._faceNormals[f2] * weight;
                target[index] += this._faceNormals[f3] * weight;
                f1 += 3;
                f2 += 3;
                f3 += 3;
            }
            v1 = normalOffset;
            while (v1 < lenV) {
                var vx = target[v1];
                var vy = target[v1 + 1];
                var vz = target[v1 + 2];
                var d = 1.0 / Math.sqrt(vx * vx + vy * vy + vz * vz);
                target[v1] = vx * d;
                target[v1 + 1] = vy * d;
                target[v1 + 2] = vz * d;
                v1 += normalStride;
            }
            return target;
        };
        return AutoDeriveVertexNormals;
    }(feng3d.SubGeometryComponent));
    feng3d.AutoDeriveVertexNormals = AutoDeriveVertexNormals;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 自动生成切线组件
     * @author feng 2014-12-19
     */
    var AutoDeriveVertexTangents = (function (_super) {
        __extends(AutoDeriveVertexTangents, _super);
        function AutoDeriveVertexTangents() {
            /** 面切线脏标记 */
            this._faceTangentsDirty = true;
            /** 是否使用面权重 */
            this._useFaceWeights = false;
            this.dataTypeId = _.tangent_va_3;
            _super.call(this);
        }
        Object.defineProperty(AutoDeriveVertexTangents.prototype, "subGeometry", {
            set: function (value) {
                if (_subGeometry != null) {
                    _subGeometry.removeEventListener(feng3d.GeometryComponentEvent.GET_VA_DATA, onGetVAData);
                    _subGeometry.removeEventListener(feng3d.GeometryComponentEvent.CHANGED_VA_DATA, onChangedVAData);
                    _subGeometry.removeEventListener(feng3d.GeometryComponentEvent.CHANGED_INDEX_DATA, onChangedIndexData);
                }
                _subGeometry = value;
                if (_subGeometry != null) {
                    _subGeometry.addEventListener(feng3d.GeometryComponentEvent.GET_VA_DATA, onGetVAData);
                    _subGeometry.addEventListener(feng3d.GeometryComponentEvent.CHANGED_VA_DATA, onChangedVAData);
                    _subGeometry.addEventListener(feng3d.GeometryComponentEvent.CHANGED_INDEX_DATA, onChangedIndexData);
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 处理被添加事件
         * @param event
         */
        AutoDeriveVertexTangents.prototype.onBeAddedComponet = function (event) {
            _super.prototype.onBeAddedComponet.call(this, event);
            this.needGenerate = true;
            this.subGeometry.invalidVAData(this.dataTypeId);
        };
        AutoDeriveVertexTangents.prototype.onGetVAData = function (event) {
            if (event.data != this.dataTypeId)
                return;
            if (!this.needGenerate)
                return;
            this.target = this.updateVertexTangents(this.target);
            this.subGeometry.setVAData(this.dataTypeId, this.target);
            this.needGenerate = false;
        };
        AutoDeriveVertexTangents.prototype.onChangedVAData = function (event) {
            if (event.data == _.position_va_3) {
                this.needGenerate = true;
                //标记面切线脏数据
                this._faceTangentsDirty = true;
                this.subGeometry.invalidVAData(_.tangent_va_3);
            }
        };
        AutoDeriveVertexTangents.prototype.onChangedIndexData = function (event) {
            this._faceTangentsDirty = true;
            this.subGeometry.invalidVAData(_.tangent_va_3);
        };
        Object.defineProperty(AutoDeriveVertexTangents.prototype, "faceTangents", {
            /** 面切线 */
            get: function () {
                if (_faceTangentsDirty)
                    updateFaceTangents();
                return _faceTangents;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AutoDeriveVertexTangents.prototype, "useFaceWeights", {
            /**
             * Indicates whether or not to take the size of faces into account when auto-deriving vertex normals and tangents.
             */
            get: function () {
                return _useFaceWeights;
            },
            set: function (value) {
                _useFaceWeights = value;
                subGeometry.invalidVAData(_.tangent_va_3);
            },
            enumerable: true,
            configurable: true
        });
        /** 更新面切线数据 */
        AutoDeriveVertexTangents.prototype.updateFaceTangents = function () {
            var i;
            var index1, index2, index3;
            var _indices = this.subGeometry.indices;
            var len = _indices.length;
            var ui, vi;
            var v0;
            var dv1, dv2;
            var denom;
            var x0, y0, z0;
            var dx1, dy1, dz1;
            var dx2, dy2, dz2;
            var cx, cy, cz;
            var vertices = this.subGeometry.getVAData(_.position_va_3);
            var uvs = this.subGeometry.getVAData(_.uv_va_2);
            var posStride = this.subGeometry.getVALen(_.position_va_3);
            var posOffset = 0;
            var texStride = this.subGeometry.getVALen(_.uv_va_2);
            var texOffset = 0;
            this._faceTangents || ;
            new number[](_indices.length, true);
            while (i < len) {
                index1 = _indices[i];
                index2 = _indices[i + 1];
                index3 = _indices[i + 2];
                ui = texOffset + index1 * texStride + 1;
                v0 = uvs[ui];
                ui = texOffset + index2 * texStride + 1;
                dv1 = uvs[ui] - v0;
                ui = texOffset + index3 * texStride + 1;
                dv2 = uvs[ui] - v0;
                vi = posOffset + index1 * posStride;
                x0 = vertices[vi];
                y0 = vertices[number(vi + 1)];
                z0 = vertices[number(vi + 2)];
                vi = posOffset + index2 * posStride;
                dx1 = vertices[number(vi)] - x0;
                dy1 = vertices[number(vi + 1)] - y0;
                dz1 = vertices[number(vi + 2)] - z0;
                vi = posOffset + index3 * posStride;
                dx2 = vertices[number(vi)] - x0;
                dy2 = vertices[number(vi + 1)] - y0;
                dz2 = vertices[number(vi + 2)] - z0;
                cx = dv2 * dx1 - dv1 * dx2;
                cy = dv2 * dy1 - dv1 * dy2;
                cz = dv2 * dz1 - dv1 * dz2;
                denom = 1 / Math.sqrt(cx * cx + cy * cy + cz * cz);
                this._faceTangents[i++] = denom * cx;
                this._faceTangents[i++] = denom * cy;
                this._faceTangents[i++] = denom * cz;
            }
            this._faceTangentsDirty = false;
        };
        /**
         * 更新顶点切线数据
         * @param target 顶点切线数据
         * @return 顶点切线数据
         */
        AutoDeriveVertexTangents.prototype.updateVertexTangents = function (target) {
            if (this._faceTangentsDirty)
                this.updateFaceTangents();
            var i;
            var lenV = this.subGeometry.numVertices * 3;
            var tangentStride = 3;
            var tangentOffset = 0;
            target || ;
            new number[](lenV, true);
            i = tangentOffset;
            while (i < lenV) {
                target[i] = 0.0;
                target[i + 1] = 0.0;
                target[i + 2] = 0.0;
                i += tangentStride;
            }
            var k;
            var _indices = this.subGeometry.indices;
            var lenI = _indices.length;
            var index;
            var weight;
            var f1 = 0, f2 = 1, f3 = 2;
            i = 0;
            while (i < lenI) {
                weight = this._useFaceWeights ? this._faceWeights[k++] : 1;
                index = tangentOffset + _indices[i++] * tangentStride;
                target[index++] += this._faceTangents[f1] * weight;
                target[index++] += this._faceTangents[f2] * weight;
                target[index] += this._faceTangents[f3] * weight;
                index = tangentOffset + _indices[i++] * tangentStride;
                target[index++] += this._faceTangents[f1] * weight;
                target[index++] += this._faceTangents[f2] * weight;
                target[index] += this._faceTangents[f3] * weight;
                index = tangentOffset + _indices[i++] * tangentStride;
                target[index++] += this._faceTangents[f1] * weight;
                target[index++] += this._faceTangents[f2] * weight;
                target[index] += this._faceTangents[f3] * weight;
                f1 += 3;
                f2 += 3;
                f3 += 3;
            }
            i = tangentOffset;
            while (i < lenV) {
                var vx = target[i];
                var vy = target[i + 1];
                var vz = target[i + 2];
                var d = 1.0 / Math.sqrt(vx * vx + vy * vy + vz * vz);
                target[i] = vx * d;
                target[i + 1] = vy * d;
                target[i + 2] = vz * d;
                i += tangentStride;
            }
            return target;
        };
        return AutoDeriveVertexTangents;
    }(feng3d.SubGeometryComponent));
    feng3d.AutoDeriveVertexTangents = AutoDeriveVertexTangents;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 自动生成虚拟UV
     * @author feng 2015-12-8
     */
    var AutoGenerateDummyUVs = (function (_super) {
        __extends(AutoGenerateDummyUVs, _super);
        function AutoGenerateDummyUVs() {
            this.dataTypeId = _.uv_va_2;
            _super.call(this);
        }
        Object.defineProperty(AutoGenerateDummyUVs.prototype, "subGeometry", {
            set: function (value) {
                if (_subGeometry != null) {
                    _subGeometry.removeEventListener(feng3d.GeometryComponentEvent.GET_VA_DATA, onGetVAData);
                    _subGeometry.removeEventListener(feng3d.GeometryComponentEvent.CHANGED_VA_DATA, onChangedVAData);
                }
                _subGeometry = value;
                if (_subGeometry != null) {
                    _subGeometry.addEventListener(feng3d.GeometryComponentEvent.GET_VA_DATA, onGetVAData);
                    _subGeometry.addEventListener(feng3d.GeometryComponentEvent.CHANGED_VA_DATA, onChangedVAData);
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 处理被添加事件
         * @param event
         */
        AutoGenerateDummyUVs.prototype.onBeAddedComponet = function (event) {
            _super.prototype.onBeAddedComponet.call(this, event);
            this.needGenerate = true;
            this.subGeometry.invalidVAData(this.dataTypeId);
        };
        AutoGenerateDummyUVs.prototype.onGetVAData = function (event) {
            if (event.data != this.dataTypeId)
                return;
            if (!this.needGenerate)
                return;
            this.target = this.updateDummyUVs(this.target);
            this.subGeometry.setVAData(this.dataTypeId, this.target);
            this.needGenerate = false;
        };
        /**
         * 更新虚拟uv
         * @param target 虚拟uv(输出)
         * @return 虚拟uv
         */
        AutoGenerateDummyUVs.prototype.updateDummyUVs = function (target) {
            var idx, uvIdx;
            var stride = 2;
            var len = this.subGeometry.numVertices * stride;
            if (!target)
                target = new number[]();
            target.fixed = false;
            target.length = len;
            target.fixed = true;
            idx = 0;
            uvIdx = 0;
            while (idx < len) {
                target[idx++] = uvIdx * .5;
                target[idx++] = 1.0 - (uvIdx & 1);
                if (++uvIdx == 3)
                    uvIdx = 0;
            }
            return target;
        };
        AutoGenerateDummyUVs.prototype.onChangedVAData = function (event) {
            if (event.data == _.position_va_3) {
                this.needGenerate = true;
            }
        };
        return AutoGenerateDummyUVs;
    }(feng3d.SubGeometryComponent));
    feng3d.AutoGenerateDummyUVs = AutoGenerateDummyUVs;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 蒙皮子网格
     * 提供了关节 索引数据与权重数据
     */
    var SkinnedSubGeometry = (function (_super) {
        __extends(SkinnedSubGeometry, _super);
        /**
         * 创建蒙皮子网格
         */
        function SkinnedSubGeometry(jointsPerVertex) {
            this._jointsPerVertex = jointsPerVertex;
            _super.call(this);
        }
        /**
         * 处理被添加事件
         * @param event
         */
        SkinnedSubGeometry.prototype.onBeAddedComponet = function (event) {
            _super.prototype.onBeAddedComponet.call(this, event);
            subGeometry.mapVABuffer(_.animated_va_3, 3);
            subGeometry.mapVABuffer(_.jointweights_va_x, this._jointsPerVertex);
            subGeometry.mapVABuffer(_.jointindex_va_x, this._jointsPerVertex);
        };
        /**
         * 更新动画顶点数据
         */
        SkinnedSubGeometry.prototype.updateAnimatedData = function (value) {
            subGeometry.setVAData(_.animated_va_3, value);
        };
        Object.defineProperty(SkinnedSubGeometry.prototype, "jointWeightsData", {
            /**
             * 关节权重数据
             */
            get: function () {
                var data = subGeometry.getVAData(_.jointweights_va_x);
                return data;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SkinnedSubGeometry.prototype, "jointIndexData", {
            /**
             * 关节索引数据
             */
            get: function () {
                var data = subGeometry.getVAData(_.jointindex_va_x);
                return data;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 更新关节权重数据
         */
        SkinnedSubGeometry.prototype.updateJointWeightsData = function (value) {
            subGeometry.setVAData(_.jointweights_va_x, value);
        };
        /**
         * 更新关节索引数据
         */
        SkinnedSubGeometry.prototype.updateJointIndexData = function (value) {
            subGeometry.setVAData(_.jointindex_va_x, value);
        };
        return SkinnedSubGeometry;
    }(feng3d.SubGeometryComponent));
    feng3d.SkinnedSubGeometry = SkinnedSubGeometry;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 子几何体形变组件
     * @author feng 2015-12-10
     */
    var SubGeometryTransformation = (function (_super) {
        __extends(SubGeometryTransformation, _super);
        function SubGeometryTransformation() {
            _super.call(this);
            this._scaleU = 1;
            this._scaleV = 1;
        }
        Object.defineProperty(SubGeometryTransformation.prototype, "scaleU", {
            get: function () {
                return _scaleU;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SubGeometryTransformation.prototype, "scaleV", {
            get: function () {
                return _scaleV;
            },
            enumerable: true,
            configurable: true
        });
        SubGeometryTransformation.prototype.scaleUV = function (scaleU, scaleV) {
            if (scaleU === void 0) { scaleU = 1; }
            if (scaleV === void 0) { scaleV = 1; }
            var stride = subGeometry.getVALen(_.uv_va_2);
            var uvs = subGeometry.UVData;
            var len = uvs.length;
            var ratioU = scaleU / this._scaleU;
            var ratioV = scaleV / this._scaleV;
            for (var i = 0; i < len; i += stride) {
                uvs[i] *= ratioU;
                uvs[i + 1] *= ratioV;
            }
            this._scaleU = scaleU;
            this._scaleV = scaleV;
            subGeometry.setVAData(_.uv_va_2, uvs);
        };
        /**
         * 缩放网格尺寸
         */
        SubGeometryTransformation.prototype.scale = function (scale) {
            var vertices = subGeometry.getVAData(_.position_va_3);
            var len = vertices.length;
            var stride = subGeometry.getVALen(_.position_va_3);
            for (var i = 0; i < len; i += stride) {
                vertices[i] *= scale;
                vertices[i + 1] *= scale;
                vertices[i + 2] *= scale;
            }
            subGeometry.setVAData(_.position_va_3, vertices);
        };
        /**
         * 应用变换矩阵
         * @param transform 变换矩阵
         */
        SubGeometryTransformation.prototype.applyTransformation = function (transform) {
            var vertices = subGeometry.vertexPositionData;
            var normals = subGeometry.vertexNormalData;
            var tangents = subGeometry.vertexTangentData;
            var posStride = subGeometry.vertexPositionStride;
            var normalStride = subGeometry.vertexNormalStride;
            var tangentStride = subGeometry.vertexTangentStride;
            var len = vertices.length / posStride;
            var i, i1, i2;
            var vector = new Vector3D();
            var bakeNormals = normals != null;
            var bakeTangents = tangents != null;
            var invTranspose;
            if (bakeNormals || bakeTangents) {
                invTranspose = transform.clone();
                invTranspose.invert();
                invTranspose.transpose();
            }
            var vi0 = 0;
            var ni0 = 0;
            var ti0 = 0;
            for (i = 0; i < len; ++i) {
                i1 = vi0 + 1;
                i2 = vi0 + 2;
                // bake position
                vector.x = vertices[vi0];
                vector.y = vertices[i1];
                vector.z = vertices[i2];
                vector = transform.transformVector(vector);
                vertices[vi0] = vector.x;
                vertices[i1] = vector.y;
                vertices[i2] = vector.z;
                vi0 += posStride;
                // bake normal
                if (bakeNormals) {
                    i1 = ni0 + 1;
                    i2 = ni0 + 2;
                    vector.x = normals[ni0];
                    vector.y = normals[i1];
                    vector.z = normals[i2];
                    vector = invTranspose.deltaTransformVector(vector);
                    vector.normalize();
                    normals[ni0] = vector.x;
                    normals[i1] = vector.y;
                    normals[i2] = vector.z;
                    ni0 += normalStride;
                }
                // bake tangent
                if (bakeTangents) {
                    i1 = ti0 + 1;
                    i2 = ti0 + 2;
                    vector.x = tangents[ti0];
                    vector.y = tangents[i1];
                    vector.z = tangents[i2];
                    vector = invTranspose.deltaTransformVector(vector);
                    vector.normalize();
                    tangents[ti0] = vector.x;
                    tangents[i1] = vector.y;
                    tangents[i2] = vector.z;
                    ti0 += tangentStride;
                }
            }
            subGeometry.setVAData(_.position_va_3, vertices);
            subGeometry.setVAData(_.normal_va_3, normals);
            subGeometry.setVAData(_.tangent_va_3, tangents);
        };
        return SubGeometryTransformation;
    }(feng3d.SubGeometryComponent));
    feng3d.SubGeometryTransformation = SubGeometryTransformation;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 顶点动画 子网格
     * @author feng 2014-8-28
     */
    var VertexSubGeometry = (function (_super) {
        __extends(VertexSubGeometry, _super);
        function VertexSubGeometry() {
            _super.call(this);
        }
        /**
         * 处理被添加事件
         * @param event
         */
        VertexSubGeometry.prototype.onBeAddedComponet = function (event) {
            _super.prototype.onBeAddedComponet.call(this, event);
            subGeometry.mapVABuffer(_.position0_va_3, 3);
            subGeometry.mapVABuffer(_.position1_va_3, 3);
            this.updateVertexData0(subGeometry.vertexPositionData.concat());
            this.updateVertexData1(subGeometry.vertexPositionData.concat());
        };
        VertexSubGeometry.prototype.updateVertexData0 = function (vertices) {
            subGeometry.updateVertexPositionData(vertices);
            subGeometry.setVAData(_.position0_va_3, vertices);
        };
        VertexSubGeometry.prototype.updateVertexData1 = function (vertices) {
            subGeometry.setVAData(_.position1_va_3, vertices);
        };
        return VertexSubGeometry;
    }(feng3d.SubGeometryComponent));
    feng3d.VertexSubGeometry = VertexSubGeometry;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 3d容器变换组件
     * @author feng 2016-3-9
     */
    var ContainerTransform3D = (function (_super) {
        __extends(ContainerTransform3D, _super);
        /**
         * 创建一个3d容器变换组件
         */
        function ContainerTransform3D() {
            this.addEventListener(feng3d.ComponentEvent.BE_ADDED_COMPONET, this.onBeAddedComponet);
        }
        /**
         * 处理组件被添加事件
         * @param event
         */
        ContainerTransform3D.prototype.onBeAddedComponet = function (event) {
            var data = event.data;
            this.objectContainer3D = data.container;
            this.objectContainer3D.transform3D.addEventListener(feng3d.Transform3DEvent.TRANSFORM_CHANGED, this.onContainer3DTranformChange);
        };
        /**
         * 处理容器变换事件
         * @param event
         */
        ContainerTransform3D.prototype.onContainer3DTranformChange = function (event) {
            var len = this.objectContainer3D.numChildren;
            for (var i = 0; i < len; i++) {
                var transform3D = this.objectContainer3D.getChildAt(i).transform3D;
                transform3D.invalidateTransform();
            }
        };
        return ContainerTransform3D;
    }(feng3d.Component));
    feng3d.ContainerTransform3D = ContainerTransform3D;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 位移时抛出
     */
    [feng3d.Event(name = "positionChanged", type = "me.feng3d.events.Transform3DEvent")][feng3d.Event(name = "rotationChanged", type = "me.feng3d.events.Transform3DEvent")][feng3d.Event(name = "scaleChanged", type = "me.feng3d.events.Transform3DEvent")][feng3d.Event(name = "transformChanged", type = "me.feng3d.events.Transform3DEvent")][feng3d.Event(name = "transformUpdated", type = "me.feng3d.events.Transform3DEvent")];
    /**
     * 3D元素<br/><br/>
     *
     * 主要功能:
     * <ul>
     *     <li>管理3D元素的位置、旋转、缩放状态</li>
     * </ul>
     * @author feng 2014-3-31
     */
    var Element3D = (function (_super) {
        __extends(Element3D, _super);
        function Element3D() {
            this._smallestNumber = 0.0000000000000000000001;
            this._transformDirty = true;
            this._eulers = new Vector3D();
            this._transform = new Matrix3D();
            this._x = 0;
            this._y = 0;
            this._z = 0;
            this._rotationX = 0;
            this._rotationY = 0;
            this._rotationZ = 0;
            this._scaleX = 1;
            this._scaleY = 1;
            this._scaleZ = 1;
            this._pivotPoint = new Vector3D();
            this._pivotZero = true;
            this._pos = new Vector3D();
            this._rot = new Vector3D();
            this._sca = new Vector3D();
            // Cached vector of transformation components used when
            // recomposing the this.transform matrix in this.updateTransform()
            this._transformComponents = new Vector3D[](3, true);
            this._transformComponents[0] = this._pos;
            this._transformComponents[1] = this._rot;
            this._transformComponents[2] = this._sca;
            this._transform.identity();
        }
        Object.defineProperty(Element3D.prototype, "x", {
            /**
             * 相对父容器的X坐标
             */
            get: function () {
                return _x;
            },
            set: function (val) {
                if (_x == val)
                    return;
                _x = val;
                invalidatePosition();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Element3D.prototype, "y", {
            /**
             * 相对父容器的Y坐标
             */
            get: function () {
                return _y;
            },
            set: function (val) {
                if (_y == val)
                    return;
                _y = val;
                invalidatePosition();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Element3D.prototype, "z", {
            /**
             * 相对父容器的Z坐标
             */
            get: function () {
                return _z;
            },
            set: function (val) {
                if (_z == val)
                    return;
                _z = val;
                invalidatePosition();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Element3D.prototype, "rotationX", {
            /**
             * 绕X轴旋转角度
             */
            get: function () {
                return _rotationX * feng3d.MathConsts.RADIANS_TO_DEGREES;
            },
            set: function (val) {
                if (rotationX == val)
                    return;
                _rotationX = val * feng3d.MathConsts.DEGREES_TO_RADIANS;
                invalidateRotation();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Element3D.prototype, "rotationY", {
            /**
             * 绕Y轴旋转角度
             */
            get: function () {
                return _rotationY * feng3d.MathConsts.RADIANS_TO_DEGREES;
            },
            set: function (val) {
                if (rotationY == val)
                    return;
                _rotationY = val * feng3d.MathConsts.DEGREES_TO_RADIANS;
                invalidateRotation();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Element3D.prototype, "rotationZ", {
            /**
             * 绕Z轴旋转角度
             */
            get: function () {
                return _rotationZ * feng3d.MathConsts.RADIANS_TO_DEGREES;
            },
            set: function (val) {
                if (rotationZ == val)
                    return;
                _rotationZ = val * feng3d.MathConsts.DEGREES_TO_RADIANS;
                invalidateRotation();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Element3D.prototype, "scaleX", {
            /**
             * X轴旋方向缩放
             */
            get: function () {
                return _scaleX;
            },
            set: function (val) {
                if (_scaleX == val)
                    return;
                _scaleX = val;
                invalidateScale();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Element3D.prototype, "scaleY", {
            /**
             * Y轴旋方向缩放
             */
            get: function () {
                return _scaleY;
            },
            set: function (val) {
                if (_scaleY == val)
                    return;
                _scaleY = val;
                invalidateScale();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Element3D.prototype, "scaleZ", {
            /**
             * Z轴旋方向缩放
             */
            get: function () {
                return _scaleZ;
            },
            set: function (val) {
                if (_scaleZ == val)
                    return;
                _scaleZ = val;
                invalidateScale();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Element3D.prototype, "eulers", {
            /**
             * 欧拉角
             * <ul>
             *     <li>使用Vector3D对象表示 相对x、y、z轴上的旋转角度</li>
             * </ul>
             */
            get: function () {
                _eulers.x = _rotationX * feng3d.MathConsts.RADIANS_TO_DEGREES;
                _eulers.y = _rotationY * feng3d.MathConsts.RADIANS_TO_DEGREES;
                _eulers.z = _rotationZ * feng3d.MathConsts.RADIANS_TO_DEGREES;
                return _eulers;
            },
            set: function (value) {
                _rotationX = value.x * feng3d.MathConsts.DEGREES_TO_RADIANS;
                _rotationY = value.y * feng3d.MathConsts.DEGREES_TO_RADIANS;
                _rotationZ = value.z * feng3d.MathConsts.DEGREES_TO_RADIANS;
                invalidateRotation();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Element3D.prototype, "transform", {
            /**
             * 3d元素变换矩阵
             */
            get: function () {
                if (_transformDirty)
                    updateTransform();
                return _transform;
            },
            set: function (val) {
                //ridiculous matrix error
                var raw = feng3d.Matrix3DUtils.RAW_DATA_CONTAINER;
                val.copyRawDataTo(raw);
                if (!raw[number(0)]) {
                    raw[number(0)] = _smallestNumber;
                    val.copyRawDataFrom(raw);
                }
                var elements = feng3d.Matrix3DUtils.decompose(val);
                var vec;
                vec = elements[0];
                if (_x != vec.x || _y != vec.y || _z != vec.z) {
                    _x = vec.x;
                    _y = vec.y;
                    _z = vec.z;
                    invalidatePosition();
                }
                vec = elements[1];
                if (_rotationX != vec.x || _rotationY != vec.y || _rotationZ != vec.z) {
                    _rotationX = vec.x;
                    _rotationY = vec.y;
                    _rotationZ = vec.z;
                    invalidateRotation();
                }
                vec = elements[2];
                if (_scaleX != vec.x || _scaleY != vec.y || _scaleZ != vec.z) {
                    _scaleX = vec.x;
                    _scaleY = vec.y;
                    _scaleZ = vec.z;
                    invalidateScale();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Element3D.prototype, "pivotPoint", {
            /**
             * 中心点坐标（本地对象旋转点）
             */
            get: function () {
                return _pivotPoint;
            },
            set: function (pivot) {
                if (!_pivotPoint)
                    _pivotPoint = new Vector3D();
                _pivotPoint.x = pivot.x;
                _pivotPoint.y = pivot.y;
                _pivotPoint.z = pivot.z;
                invalidatePivot();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Element3D.prototype, "position", {
            /**
             * 获取在父容器中的坐标
             */
            get: function () {
                transform.copyColumnTo(3, _pos);
                return _pos.clone();
            },
            set: function (value) {
                _x = value.x;
                _y = value.y;
                _z = value.z;
                invalidatePosition();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 使位置数据无效
         */
        Element3D.prototype.invalidatePosition = function () {
            if (this._positionDirty)
                return;
            this._positionDirty = true;
            this.invalidateTransform();
            if (this._listenToPositionChanged)
                this.notifyPositionChanged();
        };
        /**
         * 发出平移事件
         */
        Element3D.prototype.notifyPositionChanged = function () {
            if (!this._positionChanged)
                this._positionChanged = new feng3d.Transform3DEvent(feng3d.Transform3DEvent.POSITION_CHANGED, this);
            this.dispatchEvent(this._positionChanged);
        };
        /**
         * 使变换矩阵失效
         */
        Element3D.prototype.invalidateTransform = function () {
            this._transformDirty = true;
            if (this._listenToTransformChanged)
                this.notifyTransformChanged();
        };
        /**
         * 发出状态改变消息
         */
        Element3D.prototype.notifyTransformChanged = function () {
            if (!this._transformChanged)
                this._transformChanged = new feng3d.Transform3DEvent(feng3d.Transform3DEvent.TRANSFORM_CHANGED, this);
            this.dispatchEvent(this._transformChanged);
        };
        /**
         * 更新变换矩阵
         */
        Element3D.prototype.updateTransform = function () {
            this._pos.x = this._x;
            this._pos.y = this._y;
            this._pos.z = this._z;
            this._rot.x = this._rotationX;
            this._rot.y = this._rotationY;
            this._rot.z = this._rotationZ;
            if (!this._pivotZero) {
                this._sca.x = 1;
                this._sca.y = 1;
                this._sca.z = 1;
                this._transform.recompose(this._transformComponents);
                this._transform.appendTranslation(this._pivotPoint.x, this._pivotPoint.y, this._pivotPoint.z);
                this._transform.prependTranslation(-this._pivotPoint.x, -this._pivotPoint.y, -this._pivotPoint.z);
                this._transform.prependScale(this._scaleX, this._scaleY, this._scaleZ);
                this._sca.x = this._scaleX;
                this._sca.y = this._scaleY;
                this._sca.z = this._scaleZ;
            }
            else {
                this._sca.x = this._scaleX;
                this._sca.y = this._scaleY;
                this._sca.z = this._scaleZ;
                this._transform.recompose(this._transformComponents);
            }
            this._transformDirty = false;
            this._positionDirty = false;
            this._rotationDirty = false;
            this._scaleDirty = false;
            this.dispatchEvent(new feng3d.Transform3DEvent(feng3d.Transform3DEvent.TRANSFORM_UPDATED, this));
        };
        /**
         * 使中心点无效
         */
        Element3D.prototype.invalidatePivot = function () {
            this._pivotZero = (this._pivotPoint.x == 0) && (this._pivotPoint.y == 0) && (this._pivotPoint.z == 0);
            this.invalidateTransform();
        };
        /**
         * 监听事件
         * @param type 事件类型
         * @param listener 回调函数
         */
        Element3D.prototype.addEventListener = function (type, listener, useCapture, priority, useWeakReference) {
            if (useCapture === void 0) { useCapture = false; }
            if (priority === void 0) { priority = 0; }
            if (useWeakReference === void 0) { useWeakReference = false; }
            _super.prototype.addEventListener.call(this, type, listener, useCapture, priority, useWeakReference);
            switch (type) {
                case feng3d.Transform3DEvent.POSITION_CHANGED:
                    this._listenToPositionChanged = true;
                    break;
                case feng3d.Transform3DEvent.ROTATION_CHANGED:
                    this._listenToRotationChanged = true;
                    break;
                case feng3d.Transform3DEvent.SCALE_CHANGED:
                    this._listenToRotationChanged = true;
                    break;
                case feng3d.Transform3DEvent.TRANSFORM_CHANGED:
                    this._listenToTransformChanged = true;
                    break;
            }
        };
        /**
         * 移除事件
         * @param type 事件类型
         * @param listener 回调函数
         */
        Element3D.prototype.removeEventListener = function (type, listener, useCapture) {
            if (useCapture === void 0) { useCapture = false; }
            _super.prototype.removeEventListener.call(this, type, listener, useCapture);
            if (this.hasEventListener(type))
                return;
            switch (type) {
                case feng3d.Transform3DEvent.POSITION_CHANGED:
                    this._listenToPositionChanged = false;
                    break;
                case feng3d.Transform3DEvent.ROTATION_CHANGED:
                    this._listenToRotationChanged = false;
                    break;
                case feng3d.Transform3DEvent.SCALE_CHANGED:
                    this._listenToScaleChanged = false;
                    break;
                case feng3d.Transform3DEvent.TRANSFORM_CHANGED:
                    this._listenToTransformChanged = false;
                    break;
            }
        };
        /**
         * 使旋转角度无效
         */
        Element3D.prototype.invalidateRotation = function () {
            if (this._rotationDirty)
                return;
            this._rotationDirty = true;
            this.invalidateTransform();
            if (this._listenToRotationChanged)
                this.notifyRotationChanged();
        };
        /**
         * 抛出旋转事件
         */
        Element3D.prototype.notifyRotationChanged = function () {
            if (!this._rotationChanged)
                this._rotationChanged = new feng3d.Transform3DEvent(feng3d.Transform3DEvent.ROTATION_CHANGED, this);
            this.dispatchEvent(this._rotationChanged);
        };
        /**
         * 使缩放无效
         */
        Element3D.prototype.invalidateScale = function () {
            if (this._scaleDirty)
                return;
            this._scaleDirty = true;
            this.invalidateTransform();
            if (this._listenToScaleChanged)
                this.notifyScaleChanged();
        };
        /**
         * 抛出缩放事件
         */
        Element3D.prototype.notifyScaleChanged = function () {
            if (!this._scaleChanged)
                this._scaleChanged = new feng3d.Transform3DEvent(feng3d.Transform3DEvent.SCALE_CHANGED, this);
            this.dispatchEvent(this._scaleChanged);
        };
        return Element3D;
    }(feng3d.Component));
    feng3d.Element3D = Element3D;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 3D元素状态变换<br/><br/>
     *
     * 主要功能:
     * <ul>
     *     <li>处理3d元素的平移、旋转、缩放等操作</li>
     * </ul>
     *
     * @author feng 2014-3-31
     */
    var Transform3D = (function (_super) {
        __extends(Transform3D, _super);
        /**
         * 创建3D元素状态变换实例
         */
        function Transform3D() {
            _super.call(this);
        }
        Object.defineProperty(Transform3D.prototype, "forwardVector", {
            /**
             * 前方单位向量
             * <ul>
             * 		<li>自身的Z轴方向</li>
             * </ul>
             */
            get: function () {
                return feng3d.Matrix3DUtils.getForward(transform);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Transform3D.prototype, "rightVector", {
            /**
             * 右方单位向量
             * <ul>
             * 		<li>自身的X轴方向</li>
             * </ul>
             */
            get: function () {
                return feng3d.Matrix3DUtils.getRight(transform);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Transform3D.prototype, "upVector", {
            /**
             * 上方单位向量
             * <ul>
             * 		<li>自身的Y轴方向</li>
             * </ul>
             */
            get: function () {
                return feng3d.Matrix3DUtils.getUp(transform);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Transform3D.prototype, "backVector", {
            /**
             * 后方单位向量
             * <ul>
             * 		<li>自身的Z轴负方向</li>
             * </ul>
             */
            get: function () {
                var director = feng3d.Matrix3DUtils.getForward(transform);
                director.negate();
                return director;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Transform3D.prototype, "leftVector", {
            /**
             * 左方单位向量
             * <ul>
             * 		<li>自身的X轴负方向</li>
             * </ul>
             */
            get: function () {
                var director = feng3d.Matrix3DUtils.getRight(transform);
                director.negate();
                return director;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Transform3D.prototype, "downVector", {
            /**
             * 下方单位向量
             * <ul>
             * 		<li>自身的Y轴负方向</li>
             * </ul>
             */
            get: function () {
                var director = feng3d.Matrix3DUtils.getUp(transform);
                director.negate();
                return director;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 等比缩放
         * @param value 缩放比例
         */
        Transform3D.prototype.scale = function (value) {
            _scaleX *= value;
            _scaleY *= value;
            _scaleZ *= value;
            invalidateScale();
        };
        /**
         * 向前（Z轴方向）位移
         * @param distance 位移距离
         */
        Transform3D.prototype.moveForward = function (distance) {
            this.translateLocal(Vector3D.Z_AXIS, distance);
        };
        /**
         * 向后（Z轴负方向）位移
         * @param distance 位移距离
         */
        Transform3D.prototype.moveBackward = function (distance) {
            this.translateLocal(Vector3D.Z_AXIS, -distance);
        };
        /**
         * 向左（X轴负方向）位移
         * @param distance 位移距离
         */
        Transform3D.prototype.moveLeft = function (distance) {
            this.translateLocal(Vector3D.X_AXIS, -distance);
        };
        /**
         * 向右（X轴方向）位移
         * @param distance 位移距离
         */
        Transform3D.prototype.moveRight = function (distance) {
            this.translateLocal(Vector3D.X_AXIS, distance);
        };
        /**
         * 向上（Y轴方向）位移
         * @param distance 位移距离
         */
        Transform3D.prototype.moveUp = function (distance) {
            this.translateLocal(Vector3D.Y_AXIS, distance);
        };
        /**
         * 向下（Y轴负方向）位移
         * @param distance 位移距离
         */
        Transform3D.prototype.moveDown = function (distance) {
            this.translateLocal(Vector3D.Y_AXIS, -distance);
        };
        /**
         * 直接移到空间的某个位置
         * @param newX x坐标
         * @param newY y坐标
         * @param newZ z坐标
         */
        Transform3D.prototype.moveTo = function (newX, newY, newZ) {
            if (_x == newX && _y == newY && _z == newZ)
                return;
            _x = newX;
            _y = newY;
            _z = newZ;
            invalidatePosition();
        };
        /**
         * 移动中心点（旋转点）
         * @param dx X轴方向位移
         * @param dy Y轴方向位移
         * @param dz Z轴方向位移
         */
        Transform3D.prototype.movePivot = function (dx, dy, dz) {
            if (!_pivotPoint)
                _pivotPoint = new Vector3D();
            _pivotPoint.x += dx;
            _pivotPoint.y += dy;
            _pivotPoint.z += dz;
            invalidatePivot();
        };
        /**
         * 在自定义轴上位移
         * @param axis 自定义轴
         * @param distance 位移距离
         */
        Transform3D.prototype.translate = function (axis, distance) {
            var x = axis.x;
            this.y;
            number = axis.y, this.z;
            number = axis.z;
            var len = distance / Math.sqrt(x * x + this.y * this.y + this.z * this.z);
            _x += x * len;
            _y += this.y * len;
            _z += this.z * len;
            invalidatePosition();
        };
        /**
         * 在自定义轴上位移<br/>
         *
         * 注意：
         * <ul>
         * 		<li>没太理解 与 translate的区别</li>
         * </ul>
         * @param axis 自定义轴
         * @param distance 位移距离
         */
        Transform3D.prototype.translateLocal = function (axis, distance) {
            var len = distance / axis.length;
            this.transform.prependTranslation(axis.x * len, axis.y * len, axis.z * len);
            _transform.copyColumnTo(3, _pos);
            _x = _pos.x;
            _y = _pos.y;
            _z = _pos.z;
            invalidatePosition();
        };
        /**
         * 绕X轴旋转
         * @param angle 旋转角度
         */
        Transform3D.prototype.pitch = function (angle) {
            this.rotate(Vector3D.X_AXIS, angle);
        };
        /**
         * 绕Y轴旋转
         * @param angle 旋转角度
         */
        Transform3D.prototype.yaw = function (angle) {
            this.rotate(Vector3D.Y_AXIS, angle);
        };
        /**
         * 绕Z轴旋转
         * @param angle 旋转角度
         */
        Transform3D.prototype.roll = function (angle) {
            this.rotate(Vector3D.Z_AXIS, angle);
        };
        /**
         * 直接修改欧拉角
         * @param ax X轴旋转角度
         * @param ay Y轴旋转角度
         * @param az Z轴旋转角度
         */
        Transform3D.prototype.rotateTo = function (ax, ay, az) {
            _rotationX = ax * feng3d.MathConsts.DEGREES_TO_RADIANS;
            _rotationY = ay * feng3d.MathConsts.DEGREES_TO_RADIANS;
            _rotationZ = az * feng3d.MathConsts.DEGREES_TO_RADIANS;
            invalidateRotation();
        };
        /**
         * 绕所给轴旋转
         * @param axis 任意轴
         * @param angle 旋转角度
         */
        Transform3D.prototype.rotate = function (axis, angle) {
            var m = new Matrix3D();
            m.prependRotation(angle, axis);
            var vec = m.decompose()[1];
            _rotationX += vec.x;
            _rotationY += vec.y;
            _rotationZ += vec.z;
            invalidateRotation();
        };
        /**
         * 观察目标
         * <ul>
         * 		<li>旋转至朝向给出的点</li>
         * </ul>
         * @param target 	目标点
         * @param upAxis 	旋转后向上方向（并非绝对向上），默认为null，当值为null时会以Y轴为向上方向计算
         */
        Transform3D.prototype.lookAt = function (target, upAxis) {
            if (upAxis === void 0) { upAxis = null; }
            var tempAxeX;
            var tempAxeY;
            var tempAxeZ;
            if (!tempAxeX)
                tempAxeX = new Vector3D();
            if (!tempAxeY)
                tempAxeY = new Vector3D();
            if (!tempAxeZ)
                tempAxeZ = new Vector3D();
            //旋转后的X轴
            var xAxis = tempAxeX;
            //旋转后的Y轴
            var yAxis = tempAxeY;
            //旋转后的Z轴
            var zAxis = tempAxeZ;
            var raw;
            //向上方向默认值为Y轴
            upAxis || ;
            Vector3D.Y_AXIS;
            if (_transformDirty) {
                updateTransform();
            }
            //物体与目标点在相同位置时，稍作偏移
            if (new Vector3D(_x, _y, _z).subtract(target).length == 0) {
                _z = target.z + 0.1;
            }
            //获得Z轴
            zAxis.x = target.x - _x;
            zAxis.y = target.y - _y;
            zAxis.z = target.z - _z;
            zAxis.normalize();
            //向上方向与Z轴 叉乘 得到X轴
            xAxis.x = upAxis.y * zAxis.z - upAxis.z * zAxis.y;
            xAxis.y = upAxis.z * zAxis.x - upAxis.x * zAxis.z;
            xAxis.z = upAxis.x * zAxis.y - upAxis.y * zAxis.x;
            xAxis.normalize();
            if (xAxis.length < .05) {
                xAxis.x = upAxis.y;
                xAxis.y = upAxis.x;
                xAxis.z = 0;
                xAxis.normalize();
            }
            //Z轴叉乘X轴 得到 Y轴，Z与X为标准化向量，得到的Y轴也将是标准化向量
            yAxis.x = zAxis.y * xAxis.z - zAxis.z * xAxis.y;
            yAxis.y = zAxis.z * xAxis.x - zAxis.x * xAxis.z;
            yAxis.z = zAxis.x * xAxis.y - zAxis.y * xAxis.x;
            raw = feng3d.Matrix3DUtils.RAW_DATA_CONTAINER;
            //根据XYZ轴计算变换矩阵
            raw[number(0)] = _scaleX * xAxis.x;
            raw[number(1)] = _scaleX * xAxis.y;
            raw[number(2)] = _scaleX * xAxis.z;
            raw[number(3)] = 0;
            raw[number(4)] = _scaleY * yAxis.x;
            raw[number(5)] = _scaleY * yAxis.y;
            raw[number(6)] = _scaleY * yAxis.z;
            raw[number(7)] = 0;
            raw[number(8)] = _scaleZ * zAxis.x;
            raw[number(9)] = _scaleZ * zAxis.y;
            raw[number(10)] = _scaleZ * zAxis.z;
            raw[number(11)] = 0;
            raw[number(12)] = _x;
            raw[number(13)] = _y;
            raw[number(14)] = _z;
            raw[number(15)] = 1;
            _transform.copyRawDataFrom(raw);
            this.transform = this.transform;
            if (zAxis.z < 0) {
                this.rotationY = (180 - this.rotationY);
                this.rotationX -= 180;
                this.rotationZ -= 180;
            }
        };
        return Transform3D;
    }(feng3d.Element3D));
    feng3d.Transform3D = Transform3D;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 可渲染对象基类
     * @author feng 2015-5-27
     */
    var Renderable = (function (_super) {
        __extends(Renderable, _super);
        /**
         * 创建一个可渲染对象基类
         */
        function Renderable() {
            this._context3dCache = new feng3d.Context3DCache();
        }
        Object.defineProperty(Renderable.prototype, "_", {
            /**
             * Fagal编号中心
             */
            get: function () {
                return FagalIdCenter.instance;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Renderable.prototype, "context3dCache", {
            /**
             * @inheritDoc
             */
            get: function () {
                return _context3dCache;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Renderable.prototype, "mouseEnabled", {
            /**
             * @inheritDoc
             */
            get: function () {
                throw new feng3d.AbstractMethodError();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Renderable.prototype, "numTriangles", {
            /**
             * @inheritDoc
             */
            get: function () {
                throw new feng3d.AbstractMethodError();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Renderable.prototype, "sourceEntity", {
            /**
             * @inheritDoc
             */
            get: function () {
                throw new feng3d.AbstractMethodError();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Renderable.prototype, "material", {
            /**
             * @inheritDoc
             */
            get: function () {
                throw new feng3d.AbstractMethodError();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Renderable.prototype, "animator", {
            /**
             * @inheritDoc
             */
            get: function () {
                throw new feng3d.AbstractMethodError();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Renderable.prototype, "castsShadows", {
            /**
             * @inheritDoc
             */
            get: function () {
                throw new feng3d.AbstractMethodError();
            },
            enumerable: true,
            configurable: true
        });
        return Renderable;
    }(feng3d.Component));
    feng3d.Renderable = Renderable;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 可渲染对象基类
     * @author feng 2015-5-27
     */
    var MeshRenderable = (function (_super) {
        __extends(MeshRenderable, _super);
        /**
         * 创建一个可渲染对象基类
         */
        function MeshRenderable(subMesh) {
            _super.call(this);
            this.subMesh = subMesh;
            _context3dCache.addChildBufferOwner(subMesh.context3DBufferOwner);
        }
        Object.defineProperty(MeshRenderable.prototype, "mouseEnabled", {
            /**
             * @inheritDoc
             */
            get: function () {
                return subMesh.mouseEnabled;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MeshRenderable.prototype, "numTriangles", {
            /**
             * @inheritDoc
             */
            get: function () {
                return subMesh.numTriangles;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MeshRenderable.prototype, "sourceEntity", {
            /**
             * @inheritDoc
             */
            get: function () {
                return subMesh.sourceEntity;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MeshRenderable.prototype, "material", {
            /**
             * @inheritDoc
             */
            get: function () {
                return subMesh.material;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MeshRenderable.prototype, "animator", {
            /**
             * @inheritDoc
             */
            get: function () {
                return subMesh.animator;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MeshRenderable.prototype, "castsShadows", {
            /**
             * @inheritDoc
             */
            get: function () {
                return subMesh.castsShadows;
            },
            enumerable: true,
            configurable: true
        });
        return MeshRenderable;
    }(feng3d.Renderable));
    feng3d.MeshRenderable = MeshRenderable;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     *
     * @author feng 2015-12-30
     */
    var SegmentRenderable = (function (_super) {
        __extends(SegmentRenderable, _super);
        /**
         * 创建一个可渲染对象基类
         */
        function SegmentRenderable(subMesh) {
            _super.call(this);
            this.segmentSet = subMesh;
            //			_context3dCache.addChildBufferOwner(subMesh.context3DBufferOwner);
        }
        Object.defineProperty(SegmentRenderable.prototype, "mouseEnabled", {
            /**
             * @inheritDoc
             */
            get: function () {
                return segmentSet.mouseEnabled;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SegmentRenderable.prototype, "numTriangles", {
            /**
             * @inheritDoc
             */
            get: function () {
                return segmentSet.numTriangles;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SegmentRenderable.prototype, "sourceEntity", {
            /**
             * @inheritDoc
             */
            get: function () {
                return segmentSet.sourceEntity;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SegmentRenderable.prototype, "material", {
            /**
             * @inheritDoc
             */
            get: function () {
                return segmentSet.material;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SegmentRenderable.prototype, "animator", {
            /**
             * @inheritDoc
             */
            get: function () {
                return segmentSet.animator;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SegmentRenderable.prototype, "castsShadows", {
            /**
             * @inheritDoc
             */
            get: function () {
                return segmentSet.castsShadows;
            },
            enumerable: true,
            configurable: true
        });
        return SegmentRenderable;
    }(feng3d.Renderable));
    feng3d.SegmentRenderable = SegmentRenderable;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 子网格，可渲染对象
     */
    var SubMesh = (function (_super) {
        __extends(SubMesh, _super);
        /**
         * 创建一个子网格
         * @param subGeometry 子几何体
         * @param parentMesh 父网格
         * @param material 材质
         */
        function SubMesh(subGeometry, parentMesh, material) {
            if (material === void 0) { material = null; }
            this.context3DBufferOwner = new feng3d.Context3DBufferOwner();
            this.renderableBase = new feng3d.MeshRenderable(this);
            this._parentMesh = parentMesh;
            this.subGeometry = subGeometry;
            this.material = material;
            this._parentMesh.addEventListener(feng3d.MeshEvent.MATERIAL_CHANGE, this.onMaterialChange);
        }
        Object.defineProperty(SubMesh.prototype, "material", {
            /**
             * 渲染材质
             */
            get: function () {
                if (_materialDirty)
                    updateMaterial();
                return _material;
            },
            set: function (value) {
                _materialSelf = value;
                _materialDirty = true;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SubMesh.prototype, "materialSelf", {
            /**
             * 自身材质
             */
            get: function () {
                return _materialSelf;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 更新材质
         */
        SubMesh.prototype.updateMaterial = function () {
            var value = this._materialSelf ? this._materialSelf : this._parentMesh.material;
            if (value == this._material)
                return;
            if (this._material) {
                this._material.removeOwner(this.renderableBase);
            }
            this._material = value;
            if (this._material) {
                this._material.addOwner(this.renderableBase);
            }
        };
        Object.defineProperty(SubMesh.prototype, "sourceEntity", {
            /**
             * 所属实体
             */
            get: function () {
                return _parentMesh;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SubMesh.prototype, "subGeometry", {
            /**
             * 子网格
             */
            get: function () {
                return _subGeometry;
            },
            set: function (value) {
                if (_subGeometry) {
                    context3DBufferOwner.removeChildBufferOwner(_subGeometry.context3DBufferOwner);
                }
                _subGeometry = value;
                if (_subGeometry) {
                    context3DBufferOwner.addChildBufferOwner(_subGeometry.context3DBufferOwner);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SubMesh.prototype, "animationSubGeometry", {
            /**
             * 动画顶点数据(例如粒子特效的时间、位置偏移、速度等等)
             */
            get: function () {
                return _animationSubGeometry;
            },
            set: function (value) {
                if (_animationSubGeometry) {
                    context3DBufferOwner.removeChildBufferOwner(_animationSubGeometry.context3DBufferOwner);
                }
                _animationSubGeometry = value;
                if (_animationSubGeometry) {
                    context3DBufferOwner.addChildBufferOwner(_animationSubGeometry.context3DBufferOwner);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SubMesh.prototype, "animator", {
            /**
             * @inheritDoc
             */
            get: function () {
                return _animator;
            },
            set: function (value) {
                if (_animator) {
                    context3DBufferOwner.removeChildBufferOwner(_animator.context3DBufferOwner);
                    material.animationSet = null;
                }
                _animator = value;
                if (_animator) {
                    context3DBufferOwner.addChildBufferOwner(_animator.context3DBufferOwner);
                    material.animationSet = _animator.animationSet;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SubMesh.prototype, "parentMesh", {
            /**
             * 父网格
             */
            get: function () {
                return _parentMesh;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SubMesh.prototype, "castsShadows", {
            get: function () {
                return _parentMesh.castsShadows;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SubMesh.prototype, "mouseEnabled", {
            /**
             * @inheritDoc
             */
            get: function () {
                return _parentMesh.mouseEnabled || _parentMesh.ancestorsAllowMouseEnabled;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SubMesh.prototype, "numTriangles", {
            /**
             * @inheritDoc
             */
            get: function () {
                return _subGeometry.numTriangles;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 处理材质变化事件
         */
        SubMesh.prototype.onMaterialChange = function (event) {
            this._materialDirty = true;
        };
        /**
         * 销毁
         */
        SubMesh.prototype.dispose = function () {
            this.material = null;
        };
        return SubMesh;
    }(feng3d.Component));
    feng3d.SubMesh = SubMesh;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 添加3D环境缓冲事件
     */
    [feng3d.Event(name = "addContext3DBuffer", type = "me.feng3d.events.Context3DBufferOwnerEvent")][feng3d.Event(name = "removeContext3DBuffer", type = "me.feng3d.events.Context3DBufferOwnerEvent")][feng3d.Event(name = "addChildContext3DBufferOwner", type = "me.feng3d.events.Context3DBufferOwnerEvent")][feng3d.Event(name = "removeChildContext3DBufferOwner", type = "me.feng3d.events.Context3DBufferOwnerEvent")];
    /**
     * Context3D缓存拥有者
     * @author feng 2014-11-26
     */
    var Context3DBufferOwner = (function (_super) {
        __extends(Context3DBufferOwner, _super);
        /**
         * 创建Context3D缓存拥有者
         */
        function Context3DBufferOwner() {
            /**
             * 所有缓冲列表是否有效
             */
            this.bufferInvalid = true;
            this.childrenBufferOwner = new Context3DBufferOwner[]();
            this.initBuffers();
        }
        Object.defineProperty(Context3DBufferOwner.prototype, "_", {
            /**
             * Fagal编号中心
             */
            get: function () {
                return FagalIdCenter.instance;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Context3DBufferOwner.prototype, "bufferDic", {
            /**
             * @inheritDoc
             */
            get: function () {
                return _bufferDic || ;
                { }
                ;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Context3DBufferOwner.prototype, "bufferList", {
            /**
             * @inheritDoc
             */
            get: function () {
                return _bufferList || ;
                new feng3d.Context3DBuffer[]();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 初始化Context3d缓存
         */
        Context3DBufferOwner.prototype.initBuffers = function () {
        };
        /**
         * 添加子项缓存拥有者
         * @param childBufferOwner
         */
        Context3DBufferOwner.prototype.addChildBufferOwner = function (childBufferOwner) {
            var index = this.childrenBufferOwner.indexOf(childBufferOwner);
            feng3d.assert(index == -1, "不能重复添加子项缓存拥有者");
            this.childrenBufferOwner.push(childBufferOwner);
            //添加事件
            childBufferOwner.addEventListener(feng3d.Context3DBufferOwnerEvent.ADD_CONTEXT3DBUFFER, this.bubbleDispatchEvent);
            childBufferOwner.addEventListener(feng3d.Context3DBufferOwnerEvent.REMOVE_CONTEXT3DBUFFER, this.bubbleDispatchEvent);
            childBufferOwner.addEventListener(feng3d.Context3DBufferOwnerEvent.ADDCHILD_CONTEXT3DBUFFEROWNER, this.bubbleDispatchEvent);
            childBufferOwner.addEventListener(feng3d.Context3DBufferOwnerEvent.REMOVECHILD_CONTEXT3DBUFFEROWNER, this.bubbleDispatchEvent);
            //派发添加子项缓冲拥有者事件
            this.dispatchEvent(new feng3d.Context3DBufferOwnerEvent(feng3d.Context3DBufferOwnerEvent.ADDCHILD_CONTEXT3DBUFFEROWNER, childBufferOwner));
        };
        /**
         * 移除子项缓存拥有者
         * @param childBufferOwner
         */
        Context3DBufferOwner.prototype.removeChildBufferOwner = function (childBufferOwner) {
            var index = this.childrenBufferOwner.indexOf(childBufferOwner);
            feng3d.assert(index != -1, "无法移除不存在的子项缓存拥有者");
            this.childrenBufferOwner.splice(index, 1);
            //移除事件
            childBufferOwner.removeEventListener(feng3d.Context3DBufferOwnerEvent.ADD_CONTEXT3DBUFFER, this.bubbleDispatchEvent);
            childBufferOwner.removeEventListener(feng3d.Context3DBufferOwnerEvent.REMOVE_CONTEXT3DBUFFER, this.bubbleDispatchEvent);
            childBufferOwner.removeEventListener(feng3d.Context3DBufferOwnerEvent.ADDCHILD_CONTEXT3DBUFFEROWNER, this.bubbleDispatchEvent);
            childBufferOwner.removeEventListener(feng3d.Context3DBufferOwnerEvent.REMOVECHILD_CONTEXT3DBUFFEROWNER, this.bubbleDispatchEvent);
            //派发添加子项缓冲拥有者事件
            this.dispatchEvent(new feng3d.Context3DBufferOwnerEvent(feng3d.Context3DBufferOwnerEvent.REMOVECHILD_CONTEXT3DBUFFEROWNER, childBufferOwner));
        };
        /**
         * 向上冒泡
         */
        Context3DBufferOwner.prototype.bubbleDispatchEvent = function (event) {
            this.bufferInvalid = true;
            this.dispatchEvent(event);
        };
        /**
         * 标记Context3d缓存脏了
         * @param dataTypeId
         */
        Context3DBufferOwner.prototype.markBufferDirty = function (dataTypeId) {
            var context3DBuffer = this.bufferDic[dataTypeId];
            context3DBuffer.invalid();
        };
        /**
         * @inheritDoc
         */
        Context3DBufferOwner.prototype.mapContext3DBuffer = function (dataTypeId, updateFunc) {
            var bufferCls = feng3d.Context3DBufferTypeManager.getBufferClass(dataTypeId);
            var context3DBuffer = new bufferCls(dataTypeId, updateFunc);
            this.bufferDic[dataTypeId] = context3DBuffer;
            this.bufferList.push(context3DBuffer);
            this.dispatchEvent(new feng3d.Context3DBufferOwnerEvent(feng3d.Context3DBufferOwnerEvent.ADD_CONTEXT3DBUFFER, context3DBuffer));
            return context3DBuffer;
        };
        /**
         * @inheritDoc
         */
        Context3DBufferOwner.prototype.getAllBufferList = function () {
            if (this.bufferInvalid) {
                //收集本拥有者缓冲列表
                this.allBufferList = this.bufferList.concat();
                var childAllBufferList;
                //遍历子项拥有者收集缓冲列表
                for (var i = 0; i < this.childrenBufferOwner.length; i++) {
                    childAllBufferList = this.childrenBufferOwner[i].getAllBufferList();
                    this.allBufferList = this.allBufferList.concat(childAllBufferList);
                }
                this.bufferInvalid = false;
            }
            return this.allBufferList;
        };
        return Context3DBufferOwner;
    }(feng3d.Component));
    feng3d.Context3DBufferOwner = Context3DBufferOwner;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 几何体
     * @author feng 2014-3-17
     */
    var Geometry = (function (_super) {
        __extends(Geometry, _super);
        function Geometry() {
            this._namedAsset = new feng3d.NamedAsset(this, feng3d.AssetType.GEOMETRY);
            this._subGeometries = new feng3d.SubGeometry[]();
        }
        Object.defineProperty(Geometry.prototype, "subGeometries", {
            get: function () {
                return _subGeometries;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Geometry.prototype, "numVertices", {
            /**
             * 顶点个数
             */
            get: function () {
                var _numVertices;
                for (var i = 0; i < _subGeometries.length; i++) {
                    _numVertices += _subGeometries[i].numVertices;
                }
                return _numVertices;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 应用变换矩阵
         * @param transform 变换矩阵
         */
        Geometry.prototype.applyTransformation = function (transform) {
            var len = this._subGeometries.length;
            for (var i = 0; i < len; ++i)
                this._subGeometries[i].applyTransformation(transform);
        };
        /**
         * 添加子几何体
         * @param subGeometry 子几何体
         */
        Geometry.prototype.addSubGeometry = function (subGeometry) {
            this._subGeometries.push(subGeometry);
            subGeometry.parent = this;
            this.dispatchEvent(new feng3d.GeometryEvent(feng3d.GeometryEvent.SUB_GEOMETRY_ADDED, subGeometry));
        };
        /**
         * 移除子几何体
         * @param subGeometry 子几何体
         */
        Geometry.prototype.removeSubGeometry = function (subGeometry) {
            this._subGeometries.splice(this._subGeometries.indexOf(subGeometry), 1);
            subGeometry.parent = null;
            this.dispatchEvent(new feng3d.GeometryEvent(feng3d.GeometryEvent.SUB_GEOMETRY_REMOVED, subGeometry));
        };
        Geometry.prototype.removeAllSubGeometry = function () {
            for (var i = this._subGeometries.length - 1; i >= 0; i--) {
                this.removeSubGeometry(this._subGeometries[i]);
            }
        };
        Geometry.prototype.clone = function () {
            var cls = getDefinitionByName(getQualifiedClassName(this));
            var clone = new cls();
            var len = this._subGeometries.length;
            for (var i = 0; i < len; ++i)
                clone.addSubGeometry(this._subGeometries[i].clone());
            return clone;
        };
        /**
         * 缩放几何体
         * @param scale 缩放系数
         */
        Geometry.prototype.scale = function (scale) {
            var numSubGeoms = this._subGeometries.length;
            for (var i = 0; i < numSubGeoms; ++i) {
                var subGeometryTransformation = this._subGeometries[i].getOrCreateComponentByClass(feng3d.SubGeometryTransformation);
                subGeometryTransformation.scale(scale);
            }
        };
        /**
         * 缩放uv
         * @param scaleU u缩放系数
         * @param scaleV v缩放系数
         */
        Geometry.prototype.scaleUV = function (scaleU, scaleV) {
            if (scaleU === void 0) { scaleU = 1; }
            if (scaleV === void 0) { scaleV = 1; }
            var numSubGeoms = this._subGeometries.length;
            for (var i = 0; i < numSubGeoms; ++i) {
                var subGeometryTransformation = this._subGeometries[i].getOrCreateComponentByClass(feng3d.SubGeometryTransformation);
                subGeometryTransformation.scaleUV(scaleU, scaleV);
            }
        };
        Geometry.prototype.dispose = function () {
            var numSubGeoms = this._subGeometries.length;
            for (var i = 0; i < numSubGeoms; ++i) {
                var subGeom = this._subGeometries[0];
                this.removeSubGeometry(subGeom);
                subGeom.dispose();
            }
        };
        Object.defineProperty(Geometry.prototype, "namedAsset", {
            get: function () {
                return _namedAsset;
            },
            enumerable: true,
            configurable: true
        });
        return Geometry;
    }(feng3d.Component));
    feng3d.Geometry = Geometry;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 粒子几何体
     */
    var ParticleGeometry = (function (_super) {
        __extends(ParticleGeometry, _super);
        function ParticleGeometry() {
            _super.call(this);
        }
        ParticleGeometry.prototype.clone = function () {
            var particleGeometry = _super.prototype.clone.call(this);
            particleGeometry.particles = this.particles;
            particleGeometry.numParticles = this.numParticles;
            return particleGeometry;
        };
        return ParticleGeometry;
    }(feng3d.Geometry));
    feng3d.ParticleGeometry = ParticleGeometry;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     *
     * @author feng 2015-12-30
     */
    var SegmentGeometry = (function (_super) {
        __extends(SegmentGeometry, _super);
        function SegmentGeometry() {
            _super.call(this);
            this._segments = new feng3d.Segment[]();
        }
        /**
         * 添加线段
         * @param segment		线段数据
         */
        SegmentGeometry.prototype.addSegment = function (segment, needUpdateGeometry) {
            if (needUpdateGeometry === void 0) { needUpdateGeometry = true; }
            this._segments.push(segment);
            if (needUpdateGeometry) {
                this.updateGeometry();
            }
        };
        SegmentGeometry.prototype.updateGeometry = function () {
            removeAllSubGeometry();
            var _segmentSubGeometry = feng3d.SegmentUtils.getSegmentSubGeometrys(this._segments);
            this.addSubGeometry(_segmentSubGeometry);
        };
        /**
         * 获取线段数据
         * @param index 		线段索引
         * @return				线段数据
         */
        SegmentGeometry.prototype.getSegment = function (index) {
            if (index < this._segments.length)
                return this._segments[index];
            return null;
        };
        /**
         * 移除所有线段
         */
        SegmentGeometry.prototype.removeAllSegments = function () {
            this.segments.length = 0;
            removeAllSubGeometry();
        };
        Object.defineProperty(SegmentGeometry.prototype, "segments", {
            /**
             * 线段列表
             */
            get: function () {
                return _segments;
            },
            enumerable: true,
            configurable: true
        });
        return SegmentGeometry;
    }(feng3d.Geometry));
    feng3d.SegmentGeometry = SegmentGeometry;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 基础网格
     * @author feng 2014-10-11
     */
    var PrimitiveBase = (function (_super) {
        __extends(PrimitiveBase, _super);
        function PrimitiveBase() {
            this._geomDirty = true;
            this._uvDirty = true;
            this._subGeometry = new feng3d.SubGeometry();
            this.addSubGeometry(this._subGeometry);
            feng3d.AbstractClassError.check(this);
        }
        Object.defineProperty(PrimitiveBase.prototype, "subGeometries", {
            /**
             * @inheritDoc
             */
            get: function () {
                if (_geomDirty)
                    updateGeometry();
                if (_uvDirty)
                    updateUVs();
                return _super.prototype.subGeometries;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        PrimitiveBase.prototype.clone = function () {
            if (this._geomDirty)
                this.updateGeometry();
            if (this._uvDirty)
                this.updateUVs();
            return _super.prototype.clone.call(this);
        };
        /**
         * @inheritDoc
         */
        PrimitiveBase.prototype.scale = function (scale) {
            if (this._geomDirty)
                this.updateGeometry();
            _super.prototype.scale.call(this, scale);
        };
        /**
         * @inheritDoc
         */
        PrimitiveBase.prototype.scaleUV = function (scaleU, scaleV) {
            if (scaleU === void 0) { scaleU = 1; }
            if (scaleV === void 0) { scaleV = 1; }
            if (this._uvDirty)
                this.updateUVs();
            _super.prototype.scaleUV.call(this, scaleU, scaleV);
        };
        /**
         * @inheritDoc
         */
        PrimitiveBase.prototype.applyTransformation = function (transform) {
            if (this._geomDirty)
                this.updateGeometry();
            _super.prototype.applyTransformation.call(this, transform);
        };
        /**
         * 创建几何体
         */
        PrimitiveBase.prototype.buildGeometry = function (target) {
            throw new feng3d.AbstractMethodError();
        };
        /**
         * 创建uv
         */
        PrimitiveBase.prototype.buildUVs = function (target) {
            throw new feng3d.AbstractMethodError();
        };
        /**
         * 几何体失效
         */
        PrimitiveBase.prototype.invalidateGeometry = function () {
            this._geomDirty = true;
        };
        /**
         * uv失效
         */
        PrimitiveBase.prototype.invalidateUVs = function () {
            this._uvDirty = true;
        };
        /**
         * 更新几何体
         */
        PrimitiveBase.prototype.updateGeometry = function () {
            this.buildGeometry(this._subGeometry);
            this._geomDirty = false;
        };
        /**
         * 更新uv
         */
        PrimitiveBase.prototype.updateUVs = function () {
            this.buildUVs(this._subGeometry);
            this._uvDirty = false;
        };
        return PrimitiveBase;
    }(feng3d.Geometry));
    feng3d.PrimitiveBase = PrimitiveBase;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * A Cube primitive mesh.
     */
    var CubeGeometry = (function (_super) {
        __extends(CubeGeometry, _super);
        /**
         * Creates a new Cube object.
         * @param width The size of the cube along its X-axis.
         * @param height The size of the cube along its Y-axis.
         * @param depth The size of the cube along its Z-axis.
         * @param segmentsW The number of segments that make up the cube along the X-axis.
         * @param segmentsH The number of segments that make up the cube along the Y-axis.
         * @param segmentsD The number of segments that make up the cube along the Z-axis.
         * @param tile6 The type of uv mapping to use. When true, a texture will be subdivided in a 2x3 grid, each used for a single face. When false, the entire image is mapped on each face.
         */
        function CubeGeometry(width, height, depth, segmentsW, segmentsH, segmentsD, tile6) {
            if (width === void 0) { width = 100; }
            if (height === void 0) { height = 100; }
            if (depth === void 0) { depth = 100; }
            if (segmentsW === void 0) { segmentsW = 1; }
            if (segmentsH === void 0) { segmentsH = 1; }
            if (segmentsD === void 0) { segmentsD = 1; }
            if (tile6 === void 0) { tile6 = true; }
            _super.call(this);
            /**
             * @inheritDoc
             */
            this.override = function buildGeometry(target) {
                var vertexPositionData;
                var vertexNormalData;
                var vertexTangentData;
                var indices;
                var tl, tr, bl, br;
                var i, j, inc = 0;
                var hw, hh, hd; // halves
                var dw, dh, dd; // deltas
                var outer_pos;
                var numVerts = ((this._segmentsW + 1) * (this._segmentsH + 1) + (this._segmentsW + 1) * (this._segmentsD + 1) + (this._segmentsH + 1) * (this._segmentsD + 1)) * 2;
                var vertexPositionStride = target.vertexPositionStride;
                var vertexNormalStride = target.vertexNormalStride;
                var vertexTangentStride = target.vertexTangentStride;
                if (numVerts == target.numVertices) {
                    vertexPositionData = target.vertexPositionData;
                    vertexNormalData = target.vertexNormalData;
                    vertexTangentData = target.vertexTangentData;
                    indices = target.indexData || new number[]((this._segmentsW * this._segmentsH + this._segmentsW * this._segmentsD + this._segmentsH * this._segmentsD) * 12, true);
                }
                else {
                    vertexPositionData = new number[](numVerts * vertexPositionStride, true);
                    vertexNormalData = new number[](numVerts * vertexNormalStride, true);
                    vertexTangentData = new number[](numVerts * vertexTangentStride, true);
                    indices = new number[]((this._segmentsW * this._segmentsH + this._segmentsW * this._segmentsD + this._segmentsH * this._segmentsD) * 12, true);
                    invalidateUVs();
                }
                // Indices
                var positionIndex = 0;
                var normalIndex = 0;
                var tangentIndex = 0;
                var fidx = 0;
                // half cube dimensions
                hw = this._width / 2;
                hh = this._height / 2;
                hd = this._depth / 2;
                // Segment dimensions
                dw = this._width / this._segmentsW;
                dh = this._height / this._segmentsH;
                dd = this._depth / this._segmentsD;
                for (i = 0; i <= this._segmentsW; i++) {
                    outer_pos = -hw + i * dw;
                    for (j = 0; j <= this._segmentsH; j++) {
                        // front
                        vertexPositionData[positionIndex++] = outer_pos;
                        vertexPositionData[positionIndex++] = -hh + j * dh;
                        vertexPositionData[positionIndex++] = -hd;
                        vertexNormalData[normalIndex++] = 0;
                        vertexNormalData[normalIndex++] = 0;
                        vertexNormalData[normalIndex++] = -1;
                        vertexTangentData[tangentIndex++] = 1;
                        vertexTangentData[tangentIndex++] = 0;
                        vertexTangentData[tangentIndex++] = 0;
                        // back
                        vertexPositionData[positionIndex++] = outer_pos;
                        vertexPositionData[positionIndex++] = -hh + j * dh;
                        vertexPositionData[positionIndex++] = hd;
                        vertexNormalData[normalIndex++] = 0;
                        vertexNormalData[normalIndex++] = 0;
                        vertexNormalData[normalIndex++] = 1;
                        vertexTangentData[tangentIndex++] = -1;
                        vertexTangentData[tangentIndex++] = 0;
                        vertexTangentData[tangentIndex++] = 0;
                        if (i && j) {
                            tl = 2 * ((i - 1) * (this._segmentsH + 1) + (j - 1));
                            tr = 2 * (i * (this._segmentsH + 1) + (j - 1));
                            bl = tl + 2;
                            br = tr + 2;
                            indices[fidx++] = tl;
                            indices[fidx++] = bl;
                            indices[fidx++] = br;
                            indices[fidx++] = tl;
                            indices[fidx++] = br;
                            indices[fidx++] = tr;
                            indices[fidx++] = tr + 1;
                            indices[fidx++] = br + 1;
                            indices[fidx++] = bl + 1;
                            indices[fidx++] = tr + 1;
                            indices[fidx++] = bl + 1;
                            indices[fidx++] = tl + 1;
                        }
                    }
                }
                inc += 2 * (this._segmentsW + 1) * (this._segmentsH + 1);
                for (i = 0; i <= this._segmentsW; i++) {
                    outer_pos = -hw + i * dw;
                    for (j = 0; j <= this._segmentsD; j++) {
                        // top
                        vertexPositionData[positionIndex++] = outer_pos;
                        vertexPositionData[positionIndex++] = hh;
                        vertexPositionData[positionIndex++] = -hd + j * dd;
                        vertexNormalData[normalIndex++] = 0;
                        vertexNormalData[normalIndex++] = 1;
                        vertexNormalData[normalIndex++] = 0;
                        vertexTangentData[tangentIndex++] = 1;
                        vertexTangentData[tangentIndex++] = 0;
                        vertexTangentData[tangentIndex++] = 0;
                        // bottom
                        vertexPositionData[positionIndex++] = outer_pos;
                        vertexPositionData[positionIndex++] = -hh;
                        vertexPositionData[positionIndex++] = -hd + j * dd;
                        vertexNormalData[normalIndex++] = 0;
                        vertexNormalData[normalIndex++] = -1;
                        vertexNormalData[normalIndex++] = 0;
                        vertexTangentData[tangentIndex++] = 1;
                        vertexTangentData[tangentIndex++] = 0;
                        vertexTangentData[tangentIndex++] = 0;
                        if (i && j) {
                            tl = inc + 2 * ((i - 1) * (this._segmentsD + 1) + (j - 1));
                            tr = inc + 2 * (i * (this._segmentsD + 1) + (j - 1));
                            bl = tl + 2;
                            br = tr + 2;
                            indices[fidx++] = tl;
                            indices[fidx++] = bl;
                            indices[fidx++] = br;
                            indices[fidx++] = tl;
                            indices[fidx++] = br;
                            indices[fidx++] = tr;
                            indices[fidx++] = tr + 1;
                            indices[fidx++] = br + 1;
                            indices[fidx++] = bl + 1;
                            indices[fidx++] = tr + 1;
                            indices[fidx++] = bl + 1;
                            indices[fidx++] = tl + 1;
                        }
                    }
                }
                inc += 2 * (this._segmentsW + 1) * (this._segmentsD + 1);
                for (i = 0; i <= this._segmentsD; i++) {
                    outer_pos = hd - i * dd;
                    for (j = 0; j <= this._segmentsH; j++) {
                        // left
                        vertexPositionData[positionIndex++] = -hw;
                        vertexPositionData[positionIndex++] = -hh + j * dh;
                        vertexPositionData[positionIndex++] = outer_pos;
                        vertexNormalData[normalIndex++] = -1;
                        vertexNormalData[normalIndex++] = 0;
                        vertexNormalData[normalIndex++] = 0;
                        vertexTangentData[tangentIndex++] = 0;
                        vertexTangentData[tangentIndex++] = 0;
                        vertexTangentData[tangentIndex++] = -1;
                        // right
                        vertexPositionData[positionIndex++] = hw;
                        vertexPositionData[positionIndex++] = -hh + j * dh;
                        vertexPositionData[positionIndex++] = outer_pos;
                        vertexNormalData[normalIndex++] = 1;
                        vertexNormalData[normalIndex++] = 0;
                        vertexNormalData[normalIndex++] = 0;
                        vertexTangentData[tangentIndex++] = 0;
                        vertexTangentData[tangentIndex++] = 0;
                        vertexTangentData[tangentIndex++] = 1;
                        if (i && j) {
                            tl = inc + 2 * ((i - 1) * (this._segmentsH + 1) + (j - 1));
                            tr = inc + 2 * (i * (this._segmentsH + 1) + (j - 1));
                            bl = tl + 2;
                            br = tr + 2;
                            indices[fidx++] = tl;
                            indices[fidx++] = bl;
                            indices[fidx++] = br;
                            indices[fidx++] = tl;
                            indices[fidx++] = br;
                            indices[fidx++] = tr;
                            indices[fidx++] = tr + 1;
                            indices[fidx++] = br + 1;
                            indices[fidx++] = bl + 1;
                            indices[fidx++] = tr + 1;
                            indices[fidx++] = bl + 1;
                            indices[fidx++] = tl + 1;
                        }
                    }
                }
                target.numVertices = numVerts;
                target.updateVertexPositionData(vertexPositionData);
                target.updateVertexNormalData(vertexNormalData);
                target.updateVertexTangentData(vertexTangentData);
                target.updateIndexData(indices);
            };
            this._width = width;
            this._height = height;
            this._depth = depth;
            this._segmentsW = segmentsW;
            this._segmentsH = segmentsH;
            this._segmentsD = segmentsD;
            this._tile6 = tile6;
        }
        Object.defineProperty(CubeGeometry.prototype, "width", {
            /**
             * The size of the cube along its X-axis.
             */
            get: function () {
                return _width;
            },
            set: function (value) {
                _width = value;
                invalidateGeometry();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CubeGeometry.prototype, "height", {
            /**
             * The size of the cube along its Y-axis.
             */
            get: function () {
                return _height;
            },
            set: function (value) {
                _height = value;
                invalidateGeometry();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CubeGeometry.prototype, "depth", {
            /**
             * The size of the cube along its Z-axis.
             */
            get: function () {
                return _depth;
            },
            set: function (value) {
                _depth = value;
                invalidateGeometry();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CubeGeometry.prototype, "tile6", {
            /**
             * The type of uv mapping to use. When false, the entire image is mapped on each face.
             * When true, a texture will be subdivided in a 3x2 grid, each used for a single face.
             * Reading the tiles from left to right, top to bottom they represent the faces of the
             * cube in the following order: bottom, top, back, left, front, right. This creates
             * several shared edges (between the top, front, left and right faces) which simplifies
             * texture painting.
             */
            get: function () {
                return _tile6;
            },
            set: function (value) {
                _tile6 = value;
                invalidateUVs();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CubeGeometry.prototype, "segmentsW", {
            /**
             * The number of segments that make up the cube along the X-axis. Defaults to 1.
             */
            get: function () {
                return _segmentsW;
            },
            set: function (value) {
                _segmentsW = value;
                invalidateGeometry();
                invalidateUVs();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CubeGeometry.prototype, "segmentsH", {
            /**
             * The number of segments that make up the cube along the Y-axis. Defaults to 1.
             */
            get: function () {
                return _segmentsH;
            },
            set: function (value) {
                _segmentsH = value;
                invalidateGeometry();
                invalidateUVs();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CubeGeometry.prototype, "segmentsD", {
            /**
             * The number of segments that make up the cube along the Z-axis. Defaults to 1.
             */
            get: function () {
                return _segmentsD;
            },
            set: function (value) {
                _segmentsD = value;
                invalidateGeometry();
                invalidateUVs();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        CubeGeometry.prototype.buildUVs = function (target) {
            var i, j, uidx;
            var data;
            var u_tile_dim, v_tile_dim;
            var u_tile_step, v_tile_step;
            var tl0u, tl0v;
            var tl1u, tl1v;
            var du, dv;
            var stride = target.UVStride;
            var numUvs = ((this._segmentsW + 1) * (this._segmentsH + 1) + (this._segmentsW + 1) * (this._segmentsD + 1) + (this._segmentsH + 1) * (this._segmentsD + 1)) * 2 * stride;
            var skip = stride - 2;
            data = target.UVData;
            if (data == null || numUvs != data.length) {
                data = new number[](numUvs, true);
                invalidateGeometry();
            }
            if (this._tile6) {
                u_tile_dim = u_tile_step = 1 / 3;
                v_tile_dim = v_tile_step = 1 / 2;
            }
            else {
                u_tile_dim = v_tile_dim = 1;
                u_tile_step = v_tile_step = 0;
            }
            // Create planes two and two, the same way that they were
            // constructed in the this.buildGeometry() function. First calculate
            // the top-left UV coordinate for both planes, and then loop
            // over the points, calculating the UVs from these numbers.
            // When this.tile6 is true, the layout is as follows:
            //       .-----.-----.-----. (1,1)
            //       | Bot |  T  | Bak |
            //       |-----+-----+-----|
            //       |  L  |  F  |  R  |
            // (0,0)'-----'-----'-----'
            uidx = 0;
            // FRONT / BACK
            tl0u = 1 * u_tile_step;
            tl0v = 1 * v_tile_step;
            tl1u = 2 * u_tile_step;
            tl1v = 0 * v_tile_step;
            du = u_tile_dim / this._segmentsW;
            dv = v_tile_dim / this._segmentsH;
            for (i = 0; i <= this._segmentsW; i++) {
                for (j = 0; j <= this._segmentsH; j++) {
                    data[uidx++] = tl0u + i * du;
                    data[uidx++] = tl0v + (v_tile_dim - j * dv);
                    uidx += skip;
                    data[uidx++] = tl1u + (u_tile_dim - i * du);
                    data[uidx++] = tl1v + (v_tile_dim - j * dv);
                    uidx += skip;
                }
            }
            // TOP / BOTTOM
            tl0u = 1 * u_tile_step;
            tl0v = 0 * v_tile_step;
            tl1u = 0 * u_tile_step;
            tl1v = 0 * v_tile_step;
            du = u_tile_dim / this._segmentsW;
            dv = v_tile_dim / this._segmentsD;
            for (i = 0; i <= this._segmentsW; i++) {
                for (j = 0; j <= this._segmentsD; j++) {
                    data[uidx++] = tl0u + i * du;
                    data[uidx++] = tl0v + (v_tile_dim - j * dv);
                    uidx += skip;
                    data[uidx++] = tl1u + i * du;
                    data[uidx++] = tl1v + j * dv;
                    uidx += skip;
                }
            }
            // LEFT / RIGHT
            tl0u = 0 * u_tile_step;
            tl0v = 1 * v_tile_step;
            tl1u = 2 * u_tile_step;
            tl1v = 1 * v_tile_step;
            du = u_tile_dim / this._segmentsD;
            dv = v_tile_dim / this._segmentsH;
            for (i = 0; i <= this._segmentsD; i++) {
                for (j = 0; j <= this._segmentsH; j++) {
                    data[uidx++] = tl0u + i * du;
                    data[uidx++] = tl0v + (v_tile_dim - j * dv);
                    uidx += skip;
                    data[uidx++] = tl1u + (u_tile_dim - i * du);
                    data[uidx++] = tl1v + (v_tile_dim - j * dv);
                    uidx += skip;
                }
            }
            target.updateUVData(data);
        };
        return CubeGeometry;
    }(feng3d.PrimitiveBase));
    feng3d.CubeGeometry = CubeGeometry;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 平面网格（四边形）
     * @author feng 2014-4-15
     */
    var PlaneGeometry = (function (_super) {
        __extends(PlaneGeometry, _super);
        /**
         * 创建一个平面
         * @param width 宽度
         * @param height 高度
         * @param segmentsW 横向分割数
         * @param segmentsH 纵向分割数
         * @param yUp 正面朝向 true:Y+ false:Z+
         * @param doubleSided 是否双面
         */
        function PlaneGeometry(width, height, segmentsW, segmentsH, yUp, doubleSided) {
            if (width === void 0) { width = 100; }
            if (height === void 0) { height = 100; }
            if (segmentsW === void 0) { segmentsW = 1; }
            if (segmentsH === void 0) { segmentsH = 1; }
            if (yUp === void 0) { yUp = true; }
            if (doubleSided === void 0) { doubleSided = false; }
            _super.call(this);
            /**
             * @inheritDoc
             */
            this.override = function buildGeometry(target) {
                var vertexPositionData;
                var vertexNormalData;
                var vertexTangentData;
                var indices;
                var x, y;
                var numIndices;
                var base;
                var tw = this._segmentsW + 1;
                var numVertices = (this._segmentsH + 1) * tw;
                var vertexPositionStride = target.vertexPositionStride;
                var vertexNormalStride = target.vertexNormalStride;
                var vertexTangentStride = target.vertexTangentStride;
                if (this._doubleSided)
                    numVertices *= 2;
                numIndices = this._segmentsH * this._segmentsW * 6;
                if (this._doubleSided)
                    numIndices <<= 1;
                if (numVertices == target.numVertices) {
                    vertexPositionData = target.vertexPositionData;
                    vertexNormalData = target.vertexNormalData;
                    vertexTangentData = target.vertexTangentData;
                    indices = target.indexData || new number[](numIndices, true);
                }
                else {
                    vertexPositionData = new number[](numVertices * vertexPositionStride, true);
                    vertexNormalData = new number[](numVertices * vertexNormalStride, true);
                    vertexTangentData = new number[](numVertices * vertexTangentStride, true);
                    indices = new number[](numIndices, true);
                    invalidateUVs();
                }
                target.numVertices = numVertices;
                numIndices = 0;
                var positionIndex = 0;
                var normalIndex = 0;
                var tangentIndex = 0;
                for (var yi = 0; yi <= this._segmentsH; ++yi) {
                    for (var xi = 0; xi <= this._segmentsW; ++xi) {
                        x = (xi / this._segmentsW - .5) * this._width;
                        y = (yi / this._segmentsH - .5) * this._height;
                        //设置坐标数据
                        vertexPositionData[positionIndex++] = x;
                        if (this._yUp) {
                            vertexPositionData[positionIndex++] = 0;
                            vertexPositionData[positionIndex++] = y;
                        }
                        else {
                            vertexPositionData[positionIndex++] = y;
                            vertexPositionData[positionIndex++] = 0;
                        }
                        //设置法线数据
                        vertexNormalData[normalIndex++] = 0;
                        if (this._yUp) {
                            vertexNormalData[normalIndex++] = 1;
                            vertexNormalData[normalIndex++] = 0;
                        }
                        else {
                            vertexNormalData[normalIndex++] = 0;
                            vertexNormalData[normalIndex++] = -1;
                        }
                        vertexTangentData[tangentIndex++] = 1;
                        vertexTangentData[tangentIndex++] = 0;
                        vertexTangentData[tangentIndex++] = 0;
                        //复制反面数据
                        if (this._doubleSided) {
                            for (var i = 0; i < 3; ++i) {
                                vertexPositionData[positionIndex] = vertexPositionData[positionIndex - vertexPositionStride];
                                ++positionIndex;
                            }
                            for (i = 0; i < 3; ++i) {
                                vertexPositionData[normalIndex] = -vertexPositionData[normalIndex - vertexNormalStride];
                                ++normalIndex;
                            }
                            for (i = 0; i < 3; ++i) {
                                vertexTangentData[tangentIndex] = -vertexTangentData[tangentIndex - vertexTangentStride];
                                ++tangentIndex;
                            }
                        }
                        //生成索引数据
                        if (xi != this._segmentsW && yi != this._segmentsH) {
                            base = xi + yi * tw;
                            var mult = this._doubleSided ? 2 : 1;
                            indices[numIndices++] = base * mult;
                            indices[numIndices++] = (base + tw) * mult;
                            indices[numIndices++] = (base + tw + 1) * mult;
                            indices[numIndices++] = base * mult;
                            indices[numIndices++] = (base + tw + 1) * mult;
                            indices[numIndices++] = (base + 1) * mult;
                            //设置反面索引数据
                            if (this._doubleSided) {
                                indices[numIndices++] = (base + tw + 1) * mult + 1;
                                indices[numIndices++] = (base + tw) * mult + 1;
                                indices[numIndices++] = base * mult + 1;
                                indices[numIndices++] = (base + 1) * mult + 1;
                                indices[numIndices++] = (base + tw + 1) * mult + 1;
                                indices[numIndices++] = base * mult + 1;
                            }
                        }
                    }
                }
                target.updateVertexPositionData(vertexPositionData);
                target.updateVertexNormalData(vertexNormalData);
                target.updateVertexTangentData(vertexTangentData);
                target.updateIndexData(indices);
            };
            this._segmentsW = segmentsW;
            this._segmentsH = segmentsH;
            this._yUp = yUp;
            this._width = width;
            this._height = height;
            this._doubleSided = doubleSided;
        }
        Object.defineProperty(PlaneGeometry.prototype, "segmentsW", {
            /**
             * 横向分割数
             */
            get: function () {
                return _segmentsW;
            },
            set: function (value) {
                _segmentsW = value;
                invalidateGeometry();
                invalidateUVs();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PlaneGeometry.prototype, "segmentsH", {
            /**
             * 纵向分割数
             */
            get: function () {
                return _segmentsH;
            },
            set: function (value) {
                _segmentsH = value;
                invalidateGeometry();
                invalidateUVs();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PlaneGeometry.prototype, "yUp", {
            /**
             * 正面朝向 true:Y+ false:Z+
             */
            get: function () {
                return _yUp;
            },
            set: function (value) {
                _yUp = value;
                invalidateGeometry();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PlaneGeometry.prototype, "doubleSided", {
            /**
             * 是否双面
             */
            get: function () {
                return _doubleSided;
            },
            set: function (value) {
                _doubleSided = value;
                invalidateGeometry();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PlaneGeometry.prototype, "width", {
            /**
             * 宽度
             */
            get: function () {
                return _width;
            },
            set: function (value) {
                _width = value;
                invalidateGeometry();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PlaneGeometry.prototype, "height", {
            /**
             * 高度
             */
            get: function () {
                return _height;
            },
            set: function (value) {
                _height = value;
                invalidateGeometry();
            },
            enumerable: true,
            configurable: true
        });
        PlaneGeometry.prototype.buildUVs = function (target) {
            var data;
            var stride = target.UVStride;
            var numUvs = (this._segmentsH + 1) * (this._segmentsW + 1) * stride;
            if (this._doubleSided)
                numUvs *= 2;
            data = target.UVData;
            if (data == null || numUvs != data.length) {
                data = new number[](numUvs, true);
                invalidateGeometry();
            }
            var index = 0;
            for (var yi = 0; yi <= this._segmentsH; ++yi) {
                for (var xi = 0; xi <= this._segmentsW; ++xi) {
                    data[index++] = xi / this._segmentsW;
                    data[index++] = 1 - yi / this._segmentsH;
                    if (this._doubleSided) {
                        data[index++] = xi / this._segmentsW;
                        data[index++] = 1 - yi / this._segmentsH;
                    }
                }
            }
            target.updateUVData(data);
        };
        return PlaneGeometry;
    }(feng3d.PrimitiveBase));
    feng3d.PlaneGeometry = PlaneGeometry;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 球体网格
     */
    var SphereGeometry = (function (_super) {
        __extends(SphereGeometry, _super);
        /**
         * 创建一个球体
         * @param radius 半径
         * @param segmentsW 横向分割数，默认值16
         * @param segmentsH 纵向分割数，默认值12
         * @param yUp 球体朝向 true:Y+ false:Z+
         */
        function SphereGeometry(radius, segmentsW, segmentsH, yUp) {
            if (radius === void 0) { radius = 50; }
            if (segmentsW === void 0) { segmentsW = 16; }
            if (segmentsH === void 0) { segmentsH = 12; }
            if (yUp === void 0) { yUp = true; }
            _super.call(this);
            /**
             * @inheritDoc
             */
            this.override = function buildGeometry(target) {
                var vertexPositionData;
                var vertexNormalData;
                var vertexTangentData;
                var indices;
                var i, j, triIndex;
                var numVerts = (this._segmentsH + 1) * (this._segmentsW + 1);
                var vertexPositionStride = target.vertexPositionStride;
                var vertexNormalStride = target.vertexNormalStride;
                var vertexTangentStride = target.vertexTangentStride;
                if (numVerts == target.numVertices) {
                    vertexPositionData = target.vertexPositionData;
                    vertexNormalData = target.vertexNormalData;
                    vertexTangentData = target.vertexTangentData;
                    indices = target.indexData || new number[]((this._segmentsH - 1) * this._segmentsW * 6, true);
                }
                else {
                    vertexPositionData = new number[](numVerts * vertexPositionStride, true);
                    vertexNormalData = new number[](numVerts * vertexNormalStride, true);
                    vertexTangentData = new number[](numVerts * vertexTangentStride, true);
                    indices = new number[]((this._segmentsH - 1) * this._segmentsW * 6, true);
                    invalidateGeometry();
                }
                var startPositionIndex;
                var startNormalIndex;
                var positionIndex = 0;
                var normalIndex = 0;
                var tangentIndex = 0;
                var comp1, comp2, t1, t2;
                for (j = 0; j <= this._segmentsH; ++j) {
                    startPositionIndex = positionIndex;
                    startNormalIndex = normalIndex;
                    var horangle = Math.PI * j / this._segmentsH;
                    var z = -this._radius * Math.cos(horangle);
                    var ringradius = this._radius * Math.sin(horangle);
                    for (i = 0; i <= this._segmentsW; ++i) {
                        var verangle = 2 * Math.PI * i / this._segmentsW;
                        var x = ringradius * Math.cos(verangle);
                        var y = ringradius * Math.sin(verangle);
                        var normLen = 1 / Math.sqrt(x * x + y * y + z * z);
                        var tanLen = Math.sqrt(y * y + x * x);
                        if (this._yUp) {
                            t1 = 0;
                            t2 = tanLen > .007 ? x / tanLen : 0;
                            comp1 = -z;
                            comp2 = y;
                        }
                        else {
                            t1 = tanLen > .007 ? x / tanLen : 0;
                            t2 = 0;
                            comp1 = y;
                            comp2 = z;
                        }
                        if (i == this._segmentsW) {
                            vertexPositionData[positionIndex++] = vertexPositionData[startPositionIndex];
                            vertexPositionData[positionIndex++] = vertexPositionData[startPositionIndex + 1];
                            vertexPositionData[positionIndex++] = vertexPositionData[startPositionIndex + 2];
                            vertexNormalData[normalIndex++] = vertexNormalData[startNormalIndex] + (x * normLen) * .5;
                            vertexNormalData[normalIndex++] = vertexNormalData[startNormalIndex + 1] + (comp1 * normLen) * .5;
                            vertexNormalData[normalIndex++] = vertexNormalData[startNormalIndex + 2] + (comp2 * normLen) * .5;
                            vertexTangentData[tangentIndex++] = tanLen > .007 ? -y / tanLen : 1;
                            vertexTangentData[tangentIndex++] = t1;
                            vertexTangentData[tangentIndex++] = t2;
                        }
                        else {
                            vertexPositionData[positionIndex++] = x;
                            vertexPositionData[positionIndex++] = comp1;
                            vertexPositionData[positionIndex++] = comp2;
                            vertexNormalData[normalIndex++] = x * normLen;
                            vertexNormalData[normalIndex++] = comp1 * normLen;
                            vertexNormalData[normalIndex++] = comp2 * normLen;
                            vertexTangentData[tangentIndex++] = tanLen > .007 ? -y / tanLen : 1;
                            vertexTangentData[tangentIndex++] = t1;
                            vertexTangentData[tangentIndex++] = t2;
                        }
                        if (i > 0 && j > 0) {
                            var a = (this._segmentsW + 1) * j + i;
                            var b = (this._segmentsW + 1) * j + i - 1;
                            var c = (this._segmentsW + 1) * (j - 1) + i - 1;
                            var d = (this._segmentsW + 1) * (j - 1) + i;
                            if (j == this._segmentsH) {
                                indices[triIndex++] = a;
                                indices[triIndex++] = c;
                                indices[triIndex++] = d;
                            }
                            else if (j == 1) {
                                indices[triIndex++] = a;
                                indices[triIndex++] = b;
                                indices[triIndex++] = c;
                            }
                            else {
                                indices[triIndex++] = a;
                                indices[triIndex++] = b;
                                indices[triIndex++] = c;
                                indices[triIndex++] = a;
                                indices[triIndex++] = c;
                                indices[triIndex++] = d;
                            }
                        }
                    }
                }
                target.numVertices = numVerts;
                target.updateVertexPositionData(vertexPositionData);
                target.updateVertexNormalData(vertexNormalData);
                target.updateVertexTangentData(vertexTangentData);
                target.updateIndexData(indices);
            };
            /**
             * @inheritDoc
             */
            this.override = function buildUVs(target) {
                var i, j;
                var stride = target.UVStride;
                var numUvs = (this._segmentsH + 1) * (this._segmentsW + 1) * stride;
                var data;
                var skip = stride - 2;
                data = target.UVData;
                if (data == null || numUvs != data.length) {
                    data = new number[](numUvs, true);
                    invalidateGeometry();
                }
                var index = 0;
                for (j = 0; j <= this._segmentsH; ++j) {
                    for (i = 0; i <= this._segmentsW; ++i) {
                        data[index++] = i / this._segmentsW;
                        data[index++] = j / this._segmentsH;
                        index += skip;
                    }
                }
                target.updateUVData(data);
            };
            this._radius = radius;
            this._segmentsW = segmentsW;
            this._segmentsH = segmentsH;
            this._yUp = yUp;
        }
        Object.defineProperty(SphereGeometry.prototype, "radius", {
            /**
             * 半径
             */
            get: function () {
                return _radius;
            },
            set: function (value) {
                _radius = value;
                invalidateGeometry();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SphereGeometry.prototype, "segmentsW", {
            /**
             * 横向分割数，默认值16
             */
            get: function () {
                return _segmentsW;
            },
            set: function (value) {
                _segmentsW = value;
                invalidateGeometry();
                invalidateUVs();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SphereGeometry.prototype, "segmentsH", {
            /**
             * 纵向分割数，默认值12
             */
            get: function () {
                return _segmentsH;
            },
            set: function (value) {
                _segmentsH = value;
                invalidateGeometry();
                invalidateUVs();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SphereGeometry.prototype, "yUp", {
            /**
             * 球体朝向 true:Y+ false:Z+
             */
            get: function () {
                return _yUp;
            },
            set: function (value) {
                _yUp = value;
                invalidateGeometry();
            },
            enumerable: true,
            configurable: true
        });
        return SphereGeometry;
    }(feng3d.PrimitiveBase));
    feng3d.SphereGeometry = SphereGeometry;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 圆环几何体
     */
    var TorusGeometry = (function (_super) {
        __extends(TorusGeometry, _super);
        /**
         * 创建<code>Torus</code>实例
         * @param radius						圆环半径
         * @param tuebRadius					管道半径
         * @param segmentsR						横向段数
         * @param segmentsT						纵向段数
         * @param yUp							Y轴是否朝上
         */
        function TorusGeometry(radius, tubeRadius, segmentsR, segmentsT, yUp) {
            if (radius === void 0) { radius = 50; }
            if (tubeRadius === void 0) { tubeRadius = 50; }
            if (segmentsR === void 0) { segmentsR = 16; }
            if (segmentsT === void 0) { segmentsT = 8; }
            if (yUp === void 0) { yUp = true; }
            _super.call(this);
            /**
             * @inheritDoc
             */
            this.override = function buildGeometry(target) {
                var i, j;
                var x, y, z, nx, ny, nz, revolutionAngleR, revolutionAngleT;
                var numTriangles;
                // reset utility variables
                this._numVertices = 0;
                this._vertexIndex = 0;
                this._currentTriangleIndex = 0;
                this.vertexPositionStride = target.vertexPositionStride;
                this.vertexNormalStride = target.vertexNormalStride;
                this.vertexTangentStride = target.vertexTangentStride;
                // evaluate target number of vertices, triangles and indices
                this._numVertices = (this._segmentsT + 1) * (this._segmentsR + 1); // this.segmentsT + 1 because of closure, this.segmentsR + 1 because of closure
                numTriangles = this._segmentsT * this._segmentsR * 2; // each level has segmentR quads, each of 2 triangles
                // need to initialize raw arrays or can be reused?
                if (this._numVertices == target.numVertices) {
                    this.vertexPositionData = target.vertexPositionData;
                    this.vertexNormalData = target.vertexNormalData;
                    this.vertexTangentData = target.vertexTangentData;
                    this._rawIndices = target.indexData || new number[](numTriangles * 3, true);
                }
                else {
                    this.vertexPositionData = new number[](this._numVertices * this.vertexPositionStride, true);
                    this.vertexNormalData = new number[](this._numVertices * this.vertexNormalStride, true);
                    this.vertexTangentData = new number[](this._numVertices * this.vertexTangentStride, true);
                    this._rawIndices = new number[](numTriangles * 3, true);
                    invalidateUVs();
                }
                // evaluate revolution steps
                var revolutionAngleDeltaR = 2 * Math.PI / this._segmentsR;
                var revolutionAngleDeltaT = 2 * Math.PI / this._segmentsT;
                var comp1, comp2;
                var t1, t2, n1, n2;
                var startPositionIndex;
                // surface
                var a, b, c, d, length;
                for (j = 0; j <= this._segmentsT; ++j) {
                    startPositionIndex = j * (this._segmentsR + 1) * this.vertexPositionStride;
                    for (i = 0; i <= this._segmentsR; ++i) {
                        this._vertexIndex = j * (this._segmentsR + 1) + i;
                        // revolution vertex
                        revolutionAngleR = i * revolutionAngleDeltaR;
                        revolutionAngleT = j * revolutionAngleDeltaT;
                        length = Math.cos(revolutionAngleT);
                        nx = length * Math.cos(revolutionAngleR);
                        ny = length * Math.sin(revolutionAngleR);
                        nz = Math.sin(revolutionAngleT);
                        x = this._radius * Math.cos(revolutionAngleR) + this._tubeRadius * nx;
                        y = this._radius * Math.sin(revolutionAngleR) + this._tubeRadius * ny;
                        z = (j == this._segmentsT) ? 0 : this._tubeRadius * nz;
                        if (this._yUp) {
                            n1 = -nz;
                            n2 = ny;
                            t1 = 0;
                            t2 = (length ? nx / length : x / this._radius);
                            comp1 = -z;
                            comp2 = y;
                        }
                        else {
                            n1 = ny;
                            n2 = nz;
                            t1 = (length ? nx / length : x / this._radius);
                            t2 = 0;
                            comp1 = y;
                            comp2 = z;
                        }
                        if (i == this._segmentsR) {
                            this.addVertex(this._vertexIndex, x, this.vertexPositionData[startPositionIndex + 1], this.vertexPositionData[startPositionIndex + 2], nx, n1, n2, -(length ? ny / length : y / this._radius), t1, t2);
                        }
                        else {
                            this.addVertex(this._vertexIndex, x, comp1, comp2, nx, n1, n2, -(length ? ny / length : y / this._radius), t1, t2);
                        }
                        // close triangle
                        if (i > 0 && j > 0) {
                            a = this._vertexIndex; // current
                            b = this._vertexIndex - 1; // previous
                            c = b - this._segmentsR - 1; // previous of last level
                            d = a - this._segmentsR - 1; // current of last level
                            this.addTriangleClockWise(this._currentTriangleIndex++, a, b, c);
                            this.addTriangleClockWise(this._currentTriangleIndex++, a, c, d);
                        }
                    }
                }
                target.numVertices = this._numVertices;
                target.updateVertexPositionData(this.vertexPositionData);
                target.updateVertexNormalData(this.vertexNormalData);
                target.updateVertexTangentData(this.vertexTangentData);
                target.updateIndexData(this._rawIndices);
            };
            /**
             * @inheritDoc
             */
            this.override = function buildUVs(target) {
                var i, j;
                var data;
                var stride = target.UVStride;
                // evaluate num uvs
                var numUvs = this._numVertices * stride;
                // need to initialize raw array or can be reused?
                data = target.UVData;
                if (data == null || numUvs != data.length) {
                    data = new number[](numUvs, true);
                }
                // current uv component index
                var currentUvCompIndex = 0;
                var index = 0;
                // surface
                for (j = 0; j <= this._segmentsT; ++j) {
                    for (i = 0; i <= this._segmentsR; ++i) {
                        index = j * (this._segmentsR + 1) + i;
                        // revolution vertex
                        data[index * stride] = i / this._segmentsR;
                        data[index * stride + 1] = j / this._segmentsT;
                    }
                }
                // build real data from raw data
                target.updateUVData(data);
            };
            this._radius = radius;
            this._tubeRadius = tubeRadius;
            this._segmentsR = segmentsR;
            this._segmentsT = segmentsT;
            this._yUp = yUp;
        }
        /**
         * 添加顶点数据
         */
        TorusGeometry.prototype.addVertex = function (vertexIndex, px, py, pz, nx, ny, nz, tx, ty, tz) {
            this.vertexPositionData[vertexIndex * this.vertexPositionStride] = px;
            this.vertexPositionData[vertexIndex * this.vertexPositionStride + 1] = py;
            this.vertexPositionData[vertexIndex * this.vertexPositionStride + 2] = pz;
            this.vertexNormalData[vertexIndex * this.vertexNormalStride] = nx;
            this.vertexNormalData[vertexIndex * this.vertexNormalStride + 1] = ny;
            this.vertexNormalData[vertexIndex * this.vertexNormalStride + 2] = nz;
            this.vertexTangentData[vertexIndex * this.vertexTangentStride] = tx;
            this.vertexTangentData[vertexIndex * this.vertexTangentStride + 1] = ty;
            this.vertexTangentData[vertexIndex * this.vertexTangentStride + 2] = tz;
        };
        /**
         * 添加三角形索引数据
         * @param currentTriangleIndex		当前三角形索引
         * @param cwVertexIndex0			索引0
         * @param cwVertexIndex1			索引1
         * @param cwVertexIndex2			索引2
         */
        TorusGeometry.prototype.addTriangleClockWise = function (currentTriangleIndex, cwVertexIndex0, cwVertexIndex1, cwVertexIndex2) {
            this._rawIndices[currentTriangleIndex * 3] = cwVertexIndex0;
            this._rawIndices[currentTriangleIndex * 3 + 1] = cwVertexIndex1;
            this._rawIndices[currentTriangleIndex * 3 + 2] = cwVertexIndex2;
        };
        Object.defineProperty(TorusGeometry.prototype, "radius", {
            /**
             * 圆环半径
             */
            get: function () {
                return _radius;
            },
            set: function (value) {
                _radius = value;
                invalidateGeometry();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TorusGeometry.prototype, "tubeRadius", {
            /**
             * 管子半径
             */
            get: function () {
                return _tubeRadius;
            },
            set: function (value) {
                _tubeRadius = value;
                invalidateGeometry();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TorusGeometry.prototype, "segmentsR", {
            /**
             * 横向段数
             */
            get: function () {
                return _segmentsR;
            },
            set: function (value) {
                _segmentsR = value;
                invalidateGeometry();
                invalidateUVs();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TorusGeometry.prototype, "segmentsT", {
            /**
             * 纵向段数
             */
            get: function () {
                return _segmentsT;
            },
            set: function (value) {
                _segmentsT = value;
                invalidateGeometry();
                invalidateUVs();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TorusGeometry.prototype, "yUp", {
            /**
             * Y轴是否朝上
             */
            get: function () {
                return _yUp;
            },
            set: function (value) {
                _yUp = value;
                invalidateGeometry();
            },
            enumerable: true,
            configurable: true
        });
        return TorusGeometry;
    }(feng3d.PrimitiveBase));
    feng3d.TorusGeometry = TorusGeometry;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 3D对象<br/><br/>
     * 主要功能:
     * <ul>
     *     <li>能够被addChild添加到3d场景中</li>
     *     <li>维护场景变换矩阵sceneTransform、inverseSceneTransform</li>
     *     <li>维护父对象parent</li>
     * </ul>
     *
     * @author feng
     */
    var Object3D = (function (_super) {
        __extends(Object3D, _super);
        /**
         * 创建3D对象
         */
        function Object3D() {
            _super.call(this);
            this._sceneTransform = new Matrix3D();
            this._sceneTransformDirty = true;
            this._inverseSceneTransform = new Matrix3D();
            this._inverseSceneTransformDirty = true;
            this._scenePosition = new Vector3D();
            this._scenePositionDirty = true;
            this._visible = true;
            this._zOffset = 0;
            this.transform3D = new feng3d.Transform3D();
        }
        Object.defineProperty(Object3D.prototype, "transform3D", {
            get: function () {
                return _transform3D;
            },
            set: function (value) {
                if (transform3D != null) {
                    transform3D.removeEventListener(feng3d.Transform3DEvent.TRANSFORM_CHANGED, onTransformChanged);
                    transform3D.removeEventListener(feng3d.Transform3DEvent.POSITION_CHANGED, onPositionChanged);
                }
                _transform3D = value;
                transform3D.addEventListener(feng3d.Transform3DEvent.TRANSFORM_CHANGED, onTransformChanged);
                transform3D.addEventListener(feng3d.Transform3DEvent.POSITION_CHANGED, onPositionChanged);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "scene", {
            /**
             * 场景
             */
            get: function () {
                return _scene;
            },
            set: function (value) {
                if (_scene != value) {
                    if (_scene)
                        _scene.removedObject3d(this);
                    _scene = value;
                    if (_scene)
                        _scene.addedObject3d(this);
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 克隆3D对象
         */
        Object3D.prototype.clone = function () {
            var clone = new Object3D();
            clone.transform3D = new feng3d.Transform3D();
            clone.transform3D.pivotPoint = this.transform3D.pivotPoint;
            clone.transform3D.transform = this.transform3D.transform;
            return clone;
        };
        Object.defineProperty(Object3D.prototype, "inverseSceneTransform", {
            /**
             * 场景变换逆矩阵，场景空间转模型空间
             */
            get: function () {
                if (_inverseSceneTransformDirty) {
                    _inverseSceneTransform.copyFrom(sceneTransform);
                    _inverseSceneTransform.invert();
                    _inverseSceneTransformDirty = false;
                }
                return _inverseSceneTransform;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "sceneTransform", {
            /**
             * 场景变换矩阵，模型空间转场景空间
             */
            get: function () {
                if (_sceneTransformDirty)
                    updateSceneTransform();
                return _sceneTransform;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 更新场景变换矩阵
         */
        Object3D.prototype.updateSceneTransform = function () {
            if (this._parent && !this._parent._isRoot) {
                this._sceneTransform.copyFrom(this._parent.sceneTransform);
                this._sceneTransform.prepend(this.transform3D.transform);
            }
            else
                this._sceneTransform.copyFrom(this.transform3D.transform);
            this._sceneTransformDirty = false;
        };
        /**
         * 使变换矩阵失效，场景变换矩阵也将失效
         */
        Object3D.prototype.onTransformChanged = function (event) {
            this.notifySceneTransformChange();
        };
        /**
         * 场景变化失效
         */
        Object3D.prototype.invalidateSceneTransform = function () {
            this._sceneTransformDirty = true;
            this._inverseSceneTransformDirty = true;
            this._scenePositionDirty = true;
        };
        /**
         * 通知场景变换改变
         */
        Object3D.prototype.notifySceneTransformChange = function () {
            if (this._sceneTransformDirty)
                return;
            //处理场景变换事件
            if (this._listenToSceneTransformChanged) {
                if (!this._sceneTransformChanged)
                    this._sceneTransformChanged = new feng3d.Transform3DEvent(feng3d.Transform3DEvent.SCENETRANSFORM_CHANGED, this.transform3D);
                this.dispatchEvent(this._sceneTransformChanged);
            }
            this.invalidateSceneTransform();
        };
        Object.defineProperty(Object3D.prototype, "parent", {
            /**
             * 父容器
             */
            get: function () {
                return _parent;
            },
            set: function (value) {
                if (_parent != null)
                    _parent.removeChild(this);
                _parent = value;
                transform3D.invalidateTransform();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "scenePosition", {
            /**
             * 获取场景坐标
             */
            get: function () {
                if (_scenePositionDirty) {
                    sceneTransform.copyColumnTo(3, _scenePosition);
                    _scenePositionDirty = false;
                }
                return _scenePosition;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 本地坐标转换为世界坐标
         * @param localVector3D 本地坐标
         * @return
         */
        Object3D.prototype.positionLocalToGlobal = function (localPosition) {
            var globalPosition = this.sceneTransform.transformVector(localPosition);
            return globalPosition;
        };
        /**
         * 世界坐标转换为本地坐标
         * @param globalPosition 世界坐标
         * @return
         */
        Object3D.prototype.positionGlobalToLocal = function (globalPosition) {
            var localPosition = this.inverseSceneTransform.transformVector(globalPosition);
            return localPosition;
        };
        /**
         * 本地方向转换为世界方向
         * @param localDirection 本地方向
         * @return
         */
        Object3D.prototype.directionLocalToGlobal = function (localDirection) {
            var globalDirection = this.sceneTransform.deltaTransformVector(localDirection);
            feng3d.Matrix3DUtils.deltaTransformVector(this.sceneTransform, localDirection, globalDirection);
            return globalDirection;
        };
        /**
         * 世界方向转换为本地方向
         * @param globalDirection 世界方向
         * @return
         */
        Object3D.prototype.directionGlobalToLocal = function (globalDirection) {
            var localDirection = this.inverseSceneTransform.deltaTransformVector(globalDirection);
            feng3d.Matrix3DUtils.deltaTransformVector(this.inverseSceneTransform, globalDirection, localDirection);
            return localDirection;
        };
        /**
         * @inheritDoc
         */
        Object3D.prototype.dispatchEvent = function (event) {
            if (event)
                is;
            feng3d.MouseEvent3D && this.parent && !this.parent.ancestorsAllowMouseEnabled;
            {
                if (this.parent) {
                    return this.parent.dispatchEvent(event);
                }
                return false;
            }
            return _super.prototype.dispatchEvent.call(this, event);
        };
        Object.defineProperty(Object3D.prototype, "visible", {
            /**
             * 是否可见
             */
            get: function () {
                return _visible;
            },
            set: function (value) {
                _visible = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "sceneVisible", {
            /**
             * 是否在场景上可见
             */
            get: function () {
                //从这里开始一直找父容器到场景了，且visible全为true则为场景上可见
                return visible && (scene != null) && ((parent));
                is;
                feng3d.Scene3D;
                true;
                (parent ? parent.sceneVisible : false);
                ;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        Object3D.prototype.addEventListener = function (type, listener, useCapture, priority, useWeakReference) {
            if (useCapture === void 0) { useCapture = false; }
            if (priority === void 0) { priority = 0; }
            if (useWeakReference === void 0) { useWeakReference = false; }
            _super.prototype.addEventListener.call(this, type, listener, useCapture, priority, useWeakReference);
            switch (type) {
                case feng3d.Transform3DEvent.SCENETRANSFORM_CHANGED:
                    this._listenToSceneTransformChanged = true;
                    break;
            }
        };
        /**
         * @inheritDoc
         */
        Object3D.prototype.removeEventListener = function (type, listener, useCapture) {
            if (useCapture === void 0) { useCapture = false; }
            _super.prototype.removeEventListener.call(this, type, listener);
            if (this.hasEventListener(type))
                return;
            switch (type) {
                case feng3d.Transform3DEvent.SCENETRANSFORM_CHANGED:
                    this._listenToSceneTransformChanged = false;
                    break;
            }
        };
        Object.defineProperty(Object3D.prototype, "partition", {
            /**
             * 空间分区
             */
            get: function () {
                return _explicitPartition;
            },
            set: function (value) {
                _explicitPartition = value;
                implicitPartition = value ? value : (_parent ? _parent.implicitPartition : null);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "implicitPartition", {
            /**
             * 隐式空间分区
             */
            get: function () {
                return _implicitPartition;
            },
            set: function (value) {
                if (value == _implicitPartition)
                    return;
                _implicitPartition = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "zOffset", {
            /**
             * Z偏移值
             */
            get: function () {
                return _zOffset;
            },
            set: function (value) {
                _zOffset = value;
            },
            enumerable: true,
            configurable: true
        });
        Object3D.prototype.onPositionChanged = function (event) {
            this.notifySceneTransformChange();
        };
        Object.defineProperty(Object3D.prototype, "minX", {
            /**
             * The minimum extremum of the object along the X-axis.
             */
            get: function () {
                return 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "minY", {
            /**
             * The minimum extremum of the object along the Y-axis.
             */
            get: function () {
                return 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "minZ", {
            /**
             * The minimum extremum of the object along the Z-axis.
             */
            get: function () {
                return 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "maxX", {
            /**
             * The maximum extremum of the object along the X-axis.
             */
            get: function () {
                return 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "maxY", {
            /**
             * The maximum extremum of the object along the Y-axis.
             */
            get: function () {
                return 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "maxZ", {
            /**
             * The maximum extremum of the object along the Z-axis.
             */
            get: function () {
                return 0;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Cleans up any resources used by the current object.
         */
        Object3D.prototype.dispose = function () {
        };
        return Object3D;
    }(feng3d.Component));
    feng3d.Object3D = Object3D;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 当鼠标点击时触发
     * @eventType me.feng3d.events.MouseEvent3D
     */
    [feng3d.Event(name = "click3d", type = "me.feng3d.events.MouseEvent3D")][feng3d.Event(name = "mouseOver3d", type = "me.feng3d.events.MouseEvent3D")][feng3d.Event(name = "mouseOut3d", type = "me.feng3d.events.MouseEvent3D")][feng3d.Event(name = "mouseMove3d", type = "me.feng3d.events.MouseEvent3D")][feng3d.Event(name = "doubleClick3d", type = "me.feng3d.events.MouseEvent3D")][feng3d.Event(name = "mouseDown3d", type = "me.feng3d.events.MouseEvent3D")][feng3d.Event(name = "mouseUp3d", type = "me.feng3d.events.MouseEvent3D")][feng3d.Event(name = "mouseWheel3d", type = "me.feng3d.events.MouseEvent3D")];
    /**
     * InteractiveObject3D 类是用户可以使用鼠标、键盘或其他用户输入设备与之交互的所有显示对象的抽象基类。
     * @see		flash.display.InteractiveObject
     * @author 	warden_feng 2014-5-5
     */
    var InteractiveObject3D = (function (_super) {
        __extends(InteractiveObject3D, _super);
        /**
         * 调用新的 InteractiveObject3D() 构造函数会引发 ArgumentError 异常。
         * @throws	me.feng.error.AbstractClassError
         */
        function InteractiveObject3D() {
            _super.call(this);
            this._mouseEnabled = false;
            feng3d.AbstractClassError.check(this);
        }
        Object.defineProperty(InteractiveObject3D.prototype, "mouseEnabled", {
            /**
             * 是否开启鼠标事件
             */
            get: function () {
                return _mouseEnabled;
            },
            set: function (value) {
                _mouseEnabled = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        InteractiveObject3D.prototype.dispatchEvent = function (event) {
            //处理3D鼠标事件禁用
            if (event)
                is;
            feng3d.MouseEvent3D && !this.mouseEnabled;
            {
                if (this.parent) {
                    return this.parent.dispatchEvent(event);
                }
                return false;
            }
            return _super.prototype.dispatchEvent.call(this, event);
        };
        return InteractiveObject3D;
    }(feng3d.Object3D));
    feng3d.InteractiveObject3D = InteractiveObject3D;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 3d对象容器
     * @author feng 2014-3-21
     */
    var Container3D = (function (_super) {
        __extends(Container3D, _super);
        function Container3D() {
            _super.call(this);
            /** 容器内对象列表 */
            this._children = new feng3d.Object3D[]();
            this._mouseChildren = true;
            /** 是否给根容器 */
            this._isRoot = false;
            this._namedAsset = new feng3d.NamedAsset(this, feng3d.AssetType.CONTAINER);
            this.addComponent(new feng3d.ContainerTransform3D());
        }
        /**
         * 添加子对象
         * @param child		子对象
         * @return			新增的子对象
         */
        Container3D.prototype.addChild = function (child) {
            if (!child._explicitPartition)
                child.implicitPartition = _implicitPartition;
            child.parent = this;
            child.scene = this.scene;
            this._children.push(child);
            return child;
        };
        /**
         * 移出指定索引的子对象
         * @param childIndex	子对象索引
         * @return				被移除对象
         */
        Container3D.prototype.removeChildAt = function (childIndex) {
            var child = this.getChildAt(childIndex);
            this.removeChildInternal(childIndex, child);
            return child;
        };
        /**
         * 移除子对象
         * @param child		子对象
         */
        Container3D.prototype.removeChild = function (child) {
            var childIndex = this._children.indexOf(child);
            if (childIndex != -1) {
                this.removeChildInternal(childIndex, child);
            }
        };
        /**
         * 移除所有子对象
         */
        Container3D.prototype.removeAllChild = function () {
            for (var i = this._children.length - 1; i >= 0; i--) {
                this.removeChildAt(i);
            }
        };
        /**
         * 内部移除子对象
         * @param childIndex	移除子对象所在索引
         * @param child			移除子对象
         */
        Container3D.prototype.removeChildInternal = function (childIndex, child) {
            this._children.splice(childIndex, 1);
            child.parent = null;
            child.scene = null;
        };
        Object.defineProperty(Container3D.prototype, "scene", {
            set: function (scene) {
                _super.prototype.scene = scene;
                var len = _children.length;
                for (var i = 0; i < len; i++) {
                    _children[i].scene = scene;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Container3D.prototype, "numChildren", {
            /**
             * 子对象个数
             */
            get: function () {
                return _children.length;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 获取子对象
         * @param index
         * @return
         */
        Container3D.prototype.getChildAt = function (index) {
            return this._children[index];
        };
        /**
         * 是否包含该对象
         * @param child
         * @return
         */
        Container3D.prototype.contains = function (child) {
            return this._children.indexOf(child) >= 0;
        };
        Object.defineProperty(Container3D.prototype, "mouseChildren", {
            /**
             * 确定对象的子级是否支持鼠标或用户输入设备。
             */
            get: function () {
                return _mouseChildren;
            },
            set: function (value) {
                _mouseChildren = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Container3D.prototype, "ancestorsAllowMouseEnabled", {
            /**
             * 祖先是否允许鼠标事件
             */
            get: function () {
                return mouseChildren && (parent ? parent.ancestorsAllowMouseEnabled : true);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Container3D.prototype, "implicitPartition", {
            /**
             * @inheritDoc
             */
            set: function (value) {
                if (value == _implicitPartition)
                    return;
                _implicitPartition = value;
                var i;
                var len = _children.length;
                var child;
                while (i < len) {
                    child = _children[i];
                    i++;
                    if (!child._explicitPartition)
                        child.implicitPartition = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Container3D.prototype, "minX", {
            /**
             * The minimum extremum of the object along the X-axis.
             */
            get: function () {
                var i;
                var len = _children.length;
                var min = number.POSITIVE_INFINITY;
                var m;
                while (i < len) {
                    var child = _children[i++];
                    m = child.minX + child.transform3D.x;
                    if (m < min)
                        min = m;
                }
                return min;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Container3D.prototype, "minY", {
            /**
             * The minimum extremum of the object along the Y-axis.
             */
            get: function () {
                var i;
                var len = _children.length;
                var min = number.POSITIVE_INFINITY;
                var m;
                while (i < len) {
                    var child = _children[i++];
                    m = child.minY + child.transform3D.y;
                    if (m < min)
                        min = m;
                }
                return min;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Container3D.prototype, "minZ", {
            /**
             * The minimum extremum of the object along the Z-axis.
             */
            get: function () {
                var i;
                var len = _children.length;
                var min = number.POSITIVE_INFINITY;
                var m;
                while (i < len) {
                    var child = _children[i++];
                    m = child.minZ + child.transform3D.z;
                    if (m < min)
                        min = m;
                }
                return min;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Container3D.prototype, "maxX", {
            /**
             * The maximum extremum of the object along the X-axis.
             */
            get: function () {
                // todo: this isn't right, doesn't take into account transforms
                var i;
                var len = _children.length;
                var max = number.NEGATIVE_INFINITY;
                var m;
                while (i < len) {
                    var child = _children[i++];
                    m = child.maxX + child.transform3D.x;
                    if (m > max)
                        max = m;
                }
                return max;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Container3D.prototype, "maxY", {
            /**
             * The maximum extremum of the object along the Y-axis.
             */
            get: function () {
                var i;
                var len = _children.length;
                var max = number.NEGATIVE_INFINITY;
                var m;
                while (i < len) {
                    var child = _children[i++];
                    m = child.maxY + child.transform3D.y;
                    if (m > max)
                        max = m;
                }
                return max;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Container3D.prototype, "maxZ", {
            /**
             * The maximum extremum of the object along the Z-axis.
             */
            get: function () {
                var i;
                var len = _children.length;
                var max = number.NEGATIVE_INFINITY;
                var m;
                while (i < len) {
                    var child = _children[i++];
                    m = child.maxZ + child.transform3D.z;
                    if (m > max)
                        max = m;
                }
                return max;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        Container3D.prototype.dispose = function () {
            if (this.parent)
                this.parent.removeChild(this);
        };
        Object.defineProperty(Container3D.prototype, "namedAsset", {
            get: function () {
                return _namedAsset;
            },
            enumerable: true,
            configurable: true
        });
        return Container3D;
    }(feng3d.InteractiveObject3D));
    feng3d.Container3D = Container3D;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 3d场景
     * @author feng 2014-3-17
     */
    var Scene3D = (function (_super) {
        __extends(Scene3D, _super);
        /**
         * 创建一个3d场景
         */
        function Scene3D() {
            this._isRoot = true;
            this._scene = this;
            this._entityDic = {};
            this._displayEntityDic = {};
            this._mouseCollisionEntitys = new feng3d.Entity[]();
            this._partitions = new feng3d.Partition3D[]();
            this.partition = new feng3d.Partition3D(new feng3d.NodeBase());
        }
        Object.defineProperty(Scene3D.prototype, "displayEntityDic", {
            /** 显示实体字典 */
            get: function () {
                return _displayEntityDic;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 添加对象到场景
         * @param object3D		3d对象
         */
        Scene3D.prototype.addedObject3d = function (object3D) {
            if (object3D)
                is;
            feng3d.Entity;
            {
                this._entityDic[object3D.name] = object3D;
                if (object3D.visible) {
                    this._displayEntityDic[object3D.name] = object3D;
                }
            }
        };
        /**
         * 从场景中移除对象
         * @param object3D	3d对象
         */
        Scene3D.prototype.removedObject3d = function (object3D) {
            delete this._entityDic[object3D.name];
            delete this._displayEntityDic[object3D.name];
        };
        /**
         * 收集需要检测鼠标碰撞的实体
         */
        Scene3D.prototype.collectMouseCollisionEntitys = function () {
            this._mouseCollisionEntitys.length = 0;
            //3d对象堆栈
            var mouseCollisionStack = new feng3d.Object3D[]();
            mouseCollisionStack.push(this);
            var object3D;
            var entity;
            var container3D;
            //遍历堆栈中需要检测鼠标碰撞的实体
            while (mouseCollisionStack.length > 0) {
                object3D = mouseCollisionStack.pop();
                if (!object3D.visible)
                    continue;
                entity = object3D;
                container3D = object3D;
                //收集需要检测鼠标碰撞的实体到检测列表
                if (entity && entity.mouseEnabled) {
                    this._mouseCollisionEntitys.push(object3D);
                }
                //收集容器内子对象到堆栈
                if (container3D && container3D.mouseChildren) {
                    var len = container3D.numChildren;
                    for (var i = 0; i < len; i++) {
                        mouseCollisionStack.push(container3D.getChildAt(i));
                    }
                }
            }
        };
        Object.defineProperty(Scene3D.prototype, "mouseCollisionEntitys", {
            /**
             * 需要检测鼠标碰撞的实体
             */
            get: function () {
                return _mouseCollisionEntitys;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 横穿分区
         * @param traverser 横越者
         */
        Scene3D.prototype.traversePartitions = function (traverser) {
            var i;
            var len = this._partitions.length;
            traverser.scene = this;
            while (i < len) {
                this._partitions[i].traverse(traverser);
                i = i + 1;
            }
        };
        /**
         * 注销实体
         * @param entity	实体
         */
        Scene3D.prototype.unregisterEntity = function (entity) {
            entity.implicitPartition.removeEntity(entity);
        };
        /**
         * 注册实体
         * @param entity		实体
         */
        Scene3D.prototype.registerEntity = function (entity) {
            var partition = entity.implicitPartition;
            this.addPartitionUnique(partition);
            partition.markForUpdate(entity);
        };
        /**
         * 添加分区，如果不在列表中
         * @param partition		分区
         */
        Scene3D.prototype.addPartitionUnique = function (partition) {
            if (this._partitions.indexOf(partition) == -1)
                this._partitions.push(partition);
        };
        /**
         * 注册分区
         * @param entity	注册分区的实体
         */
        Scene3D.prototype.registerPartition = function (entity) {
            this.addPartitionUnique(entity.implicitPartition);
        };
        /**
         * 注销分区
         * @param entity	注销分区的实体
         */
        Scene3D.prototype.unregisterPartition = function (entity) {
            // todo: wait... is this even correct?
            // shouldn't we check the number of children in this.implicitPartition and remove this.partition if 0?
            entity.implicitPartition.removeEntity(entity);
        };
        return Scene3D;
    }(feng3d.Container3D));
    feng3d.Scene3D = Scene3D;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * Entity为所有场景绘制对象提供一个基类，表示存在场景中。可以被entityCollector收集。
     * @author feng 2014-3-24
     */
    var Entity = (function (_super) {
        __extends(Entity, _super);
        /**
         * 创建一个实体，该类为虚类
         */
        function Entity() {
            _super.call(this);
            this._boundsIsShown = false;
            this._boundsInvalid = true;
            this._worldBoundsInvalid = true;
            this._bounds = this.getDefaultBoundingVolume();
            this._worldBounds = this.getDefaultBoundingVolume();
            feng3d.AbstractClassError.check(this);
        }
        Object.defineProperty(Entity.prototype, "showBounds", {
            /**
             * 是否显示边界
             */
            get: function () {
                return _showBounds;
            },
            set: function (value) {
                if (value == _showBounds)
                    return;
                _showBounds = value;
                if (_showBounds)
                    addBounds();
                else
                    removeBounds();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 添加边界
         */
        Entity.prototype.addBounds = function () {
            if (!this._boundsIsShown) {
                this._boundsIsShown = true;
                this.addChild(this.bounds.boundingRenderable);
            }
        };
        /**
         * 移除边界
         */
        Entity.prototype.removeBounds = function () {
            if (this._boundsIsShown) {
                this._boundsIsShown = false;
                this.removeChild(this._bounds.boundingRenderable);
                this._bounds.disposeRenderable();
            }
        };
        Object.defineProperty(Entity.prototype, "minX", {
            /**
             * @inheritDoc
             */
            get: function () {
                if (_boundsInvalid)
                    updateBounds();
                return _bounds.min.x;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Entity.prototype, "minY", {
            /**
             * @inheritDoc
             */
            get: function () {
                if (_boundsInvalid)
                    updateBounds();
                return _bounds.min.y;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Entity.prototype, "minZ", {
            /**
             * @inheritDoc
             */
            get: function () {
                if (_boundsInvalid)
                    updateBounds();
                return _bounds.min.z;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Entity.prototype, "maxX", {
            /**
             * @inheritDoc
             */
            get: function () {
                if (_boundsInvalid)
                    updateBounds();
                return _bounds.max.x;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Entity.prototype, "maxY", {
            /**
             * @inheritDoc
             */
            get: function () {
                if (_boundsInvalid)
                    updateBounds();
                return _bounds.max.y;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Entity.prototype, "maxZ", {
            /**
             * @inheritDoc
             */
            get: function () {
                if (_boundsInvalid)
                    updateBounds();
                return _bounds.max.z;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Entity.prototype, "bounds", {
            /**
             * 边界
             */
            get: function () {
                if (_boundsInvalid)
                    updateBounds();
                return _bounds;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        Entity.prototype.invalidateSceneTransform = function () {
            _super.prototype.invalidateSceneTransform.call(this);
            this._worldBoundsInvalid = true;
        };
        /**
         * 边界失效
         */
        Entity.prototype.invalidateBounds = function () {
            this._boundsInvalid = true;
        };
        /**
         * 获取默认边界（默认盒子边界）
         * @return
         */
        Entity.prototype.getDefaultBoundingVolume = function () {
            return new feng3d.AxisAlignedBoundingBox();
        };
        /**
         * 更新边界
         */
        Entity.prototype.updateBounds = function () {
            throw new feng3d.AbstractMethodError();
        };
        Object.defineProperty(Entity.prototype, "pickingCollisionVO", {
            /**
             * 获取碰撞数据
             */
            get: function () {
                if (!_pickingCollisionVO)
                    _pickingCollisionVO = new feng3d.PickingCollisionVO(this);
                return _pickingCollisionVO;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 判断射线是否穿过实体
         * @param ray3D
         * @return
         */
        Entity.prototype.isIntersectingRay = function (ray3D) {
            if (!this.pickingCollisionVO.localNormal)
                this.pickingCollisionVO.localNormal = new Vector3D();
            //转换到当前实体坐标系空间
            var localRay = this.pickingCollisionVO.localRay;
            feng3d.Matrix3DUtils.updateLocalRay(this.inverseSceneTransform, ray3D, localRay);
            //检测射线与边界的碰撞
            var rayEntryDistance = this.bounds.rayIntersection(localRay, this.pickingCollisionVO.localNormal);
            if (rayEntryDistance < 0)
                return false;
            //保存碰撞数据
            this.pickingCollisionVO.rayEntryDistance = rayEntryDistance;
            this.pickingCollisionVO.ray3D = ray3D;
            this.pickingCollisionVO.rayOriginIsInsideBounds = rayEntryDistance == 0;
            return true;
        };
        Object.defineProperty(Entity.prototype, "pickingCollider", {
            /**
             * 获取采集的碰撞
             */
            get: function () {
                return _pickingCollider;
            },
            set: function (value) {
                _pickingCollider = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 碰撞前设置碰撞状态
         * @param shortestCollisionDistance 最短碰撞距离
         * @param findClosest 是否寻找最优碰撞
         * @return
         */
        Entity.prototype.collidesBefore = function (shortestCollisionDistance, findClosest) {
            return true;
        };
        Object.defineProperty(Entity.prototype, "implicitPartition", {
            /**
             * @inheritDoc
             */
            set: function (value) {
                if (value == _implicitPartition)
                    return;
                if (_implicitPartition)
                    notifyPartitionUnassigned();
                _super.prototype.implicitPartition = value;
                notifyPartitionAssigned();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 通知场景一个新分区已分配
         */
        Entity.prototype.notifyPartitionAssigned = function () {
            if (this._scene)
                this._scene.registerPartition(this);
        };
        /**
         * 通知场景一个分区取消分配
         */
        Entity.prototype.notifyPartitionUnassigned = function () {
            if (this._scene)
                this._scene.unregisterPartition(this);
        };
        Object.defineProperty(Entity.prototype, "scene", {
            /**
             * @inheritDoc
             */
            set: function (value) {
                if (value == _scene)
                    return;
                if (_scene)
                    _scene.unregisterEntity(this);
                if (value)
                    value.registerEntity(this);
                _super.prototype.scene = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 获取实体分区节点
         */
        Entity.prototype.getEntityPartitionNode = function () {
            return this._partitionNode || ;
            this.createEntityPartitionNode();
        };
        /**
         * 创建实体分区节点，该函数为虚函数，需要子类重写。
         */
        Entity.prototype.createEntityPartitionNode = function () {
            throw new feng3d.AbstractMethodError();
        };
        /**
         * 内部更新
         */
        Entity.prototype.internalUpdate = function () {
            if (this._controller)
                this._controller.update();
        };
        Object.defineProperty(Entity.prototype, "worldBounds", {
            /**
             * 世界边界
             */
            get: function () {
                if (_worldBoundsInvalid)
                    updateWorldBounds();
                return _worldBounds;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 更新世界边界
         */
        Entity.prototype.updateWorldBounds = function () {
            this._worldBounds.transformFrom(this.bounds, this.sceneTransform);
            this._worldBoundsInvalid = false;
        };
        /**
         * The transformation matrix that transforms from model to world space, adapted with any special operations needed to render.
         * For example, assuring certain alignedness which is not inherent in the scene transform. By default, this would
         * return the scene transform.
         */
        Entity.prototype.getRenderSceneTransform = function (camera) {
            return this.sceneTransform;
        };
        return Entity;
    }(feng3d.Container3D));
    feng3d.Entity = Entity;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 摄像机
     * @author feng 2014-3-17
     */
    var Camera3D = (function (_super) {
        __extends(Camera3D, _super);
        /**
         * 创建一个摄像机
         * @param lens 摄像机镜头
         */
        function Camera3D(lens) {
            if (lens === void 0) { lens = null; }
            _super.call(this);
            this._viewProjection = new Matrix3D();
            this._viewProjectionDirty = true;
            this._frustumPlanesDirty = true;
            _namedAsset._assetType = feng3d.AssetType.CAMERA;
            this._lens = lens || new feng3d.PerspectiveLens();
            this._lens.addEventListener(feng3d.LensEvent.MATRIX_CHANGED, this.onLensMatrixChanged);
            //setup default frustum planes
            this._frustumPlanes = new feng3d.Plane3D[](6, true);
            for (var i = 0; i < 6; ++i)
                this._frustumPlanes[i] = new feng3d.Plane3D();
            this.transform3D.z = -1000;
        }
        /**
         * 处理镜头变化事件
         */
        Camera3D.prototype.onLensMatrixChanged = function (event) {
            this._viewProjectionDirty = true;
            this._frustumPlanesDirty = true;
            this.dispatchEvent(event);
        };
        /**
         * @inheritDoc
         */
        Camera3D.prototype.invalidateSceneTransform = function () {
            _super.prototype.invalidateSceneTransform.call(this);
            this._viewProjectionDirty = true;
            this._frustumPlanesDirty = true;
        };
        /**
         * @inheritDoc
         */
        Camera3D.prototype.createEntityPartitionNode = function () {
            return new feng3d.CameraNode(this);
        };
        Object.defineProperty(Camera3D.prototype, "lens", {
            /**
             * 镜头
             */
            get: function () {
                return _lens;
            },
            set: function (value) {
                if (_lens == value)
                    return;
                if (!value)
                    throw new Error("Lens cannot be null!");
                _lens.removeEventListener(feng3d.LensEvent.MATRIX_CHANGED, onLensMatrixChanged);
                _lens = value;
                _lens.addEventListener(feng3d.LensEvent.MATRIX_CHANGED, onLensMatrixChanged);
                dispatchEvent(new feng3d.CameraEvent(feng3d.CameraEvent.LENS_CHANGED, this));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Camera3D.prototype, "viewProjection", {
            /**
             * 场景投影矩阵，世界空间转投影空间
             */
            get: function () {
                if (_viewProjectionDirty) {
                    //场景空间转摄像机空间
                    _viewProjection.copyFrom(inverseSceneTransform);
                    //+摄像机空间转投影空间 = 场景空间转投影空间
                    _viewProjection.append(_lens.matrix);
                    _viewProjectionDirty = false;
                }
                return _viewProjection;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Camera3D.prototype, "frustumPlanes", {
            /**
             * 视锥体面
             */
            get: function () {
                if (_frustumPlanesDirty)
                    updateFrustum();
                return _frustumPlanes;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 更新视锥体6个面，平面均朝向视锥体内部
         * @see http://www.linuxgraphics.cn/graphics/opengl_view_frustum_culling.html
         */
        Camera3D.prototype.updateFrustum = function () {
            var a, b, c;
            //var d :number;
            var c11, c12, c13, c14;
            var c21, c22, c23, c24;
            var c31, c32, c33, c34;
            var c41, c42, c43, c44;
            var p;
            var raw = feng3d.Matrix3DUtils.RAW_DATA_CONTAINER;
            //长度倒数
            var invLen;
            this.viewProjection.copyRawDataTo(raw);
            c11 = raw[number(0)];
            c12 = raw[number(4)];
            c13 = raw[number(8)];
            c14 = raw[number(12)];
            c21 = raw[number(1)];
            c22 = raw[number(5)];
            c23 = raw[number(9)];
            c24 = raw[number(13)];
            c31 = raw[number(2)];
            c32 = raw[number(6)];
            c33 = raw[number(10)];
            c34 = raw[number(14)];
            c41 = raw[number(3)];
            c42 = raw[number(7)];
            c43 = raw[number(11)];
            c44 = raw[number(15)];
            // left plane
            p = this._frustumPlanes[0];
            a = c41 + c11;
            b = c42 + c12;
            c = c43 + c13;
            invLen = 1 / Math.sqrt(a * a + b * b + c * c);
            p.a = a * invLen;
            p.b = b * invLen;
            p.c = c * invLen;
            p.d = -(c44 + c14) * invLen;
            // right plane
            p = this._frustumPlanes[1];
            a = c41 - c11;
            b = c42 - c12;
            c = c43 - c13;
            invLen = 1 / Math.sqrt(a * a + b * b + c * c);
            p.a = a * invLen;
            p.b = b * invLen;
            p.c = c * invLen;
            p.d = (c14 - c44) * invLen;
            // bottom
            p = this._frustumPlanes[2];
            a = c41 + c21;
            b = c42 + c22;
            c = c43 + c23;
            invLen = 1 / Math.sqrt(a * a + b * b + c * c);
            p.a = a * invLen;
            p.b = b * invLen;
            p.c = c * invLen;
            p.d = -(c44 + c24) * invLen;
            // top
            p = this._frustumPlanes[3];
            a = c41 - c21;
            b = c42 - c22;
            c = c43 - c23;
            invLen = 1 / Math.sqrt(a * a + b * b + c * c);
            p.a = a * invLen;
            p.b = b * invLen;
            p.c = c * invLen;
            p.d = (c24 - c44) * invLen;
            // near
            p = this._frustumPlanes[4];
            a = c31;
            b = c32;
            c = c33;
            invLen = 1 / Math.sqrt(a * a + b * b + c * c);
            p.a = a * invLen;
            p.b = b * invLen;
            p.c = c * invLen;
            p.d = -c34 * invLen;
            // far
            p = this._frustumPlanes[5];
            a = c41 - c31;
            b = c42 - c32;
            c = c43 - c33;
            invLen = 1 / Math.sqrt(a * a + b * b + c * c);
            p.a = a * invLen;
            p.b = b * invLen;
            p.c = c * invLen;
            p.d = (c34 - c44) * invLen;
            this._frustumPlanesDirty = false;
        };
        /**
         * 屏幕坐标投影到场景坐标
         * @param nX 屏幕坐标X -1（左） -> 1（右）
         * @param nY 屏幕坐标Y -1（上） -> 1（下）
         * @param sZ 到屏幕的距离
         * @param v 场景坐标（输出）
         * @return 场景坐标
         */
        Camera3D.prototype.unproject = function (nX, nY, sZ, v) {
            if (v === void 0) { v = null; }
            return feng3d.Matrix3DUtils.transformVector(this.sceneTransform, this.lens.unproject(nX, nY, sZ, v), v);
        };
        /**
         * 场景坐标投影到屏幕坐标
         * @param point3d 场景坐标
         * @param v 屏幕坐标（输出）
         * @return 屏幕坐标
         */
        Camera3D.prototype.project = function (point3d, v) {
            if (v === void 0) { v = null; }
            return this.lens.project(feng3d.Matrix3DUtils.transformVector(this.inverseSceneTransform, point3d, v), v);
        };
        /**
         * @inheritDoc
         */
        Camera3D.prototype.getDefaultBoundingVolume = function () {
            return new feng3d.NullBounds();
        };
        return Camera3D;
    }(feng3d.Entity));
    feng3d.Camera3D = Camera3D;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 材质发生变化时抛出
     */
    [feng3d.Event(name = "materialChange", type = "me.feng3d.events.MeshEvent")];
    /**
     * 网格
     * @author feng 2014-4-9
     */
    var Mesh = (function (_super) {
        __extends(Mesh, _super);
        /**
         * 新建网格
         * @param geometry 几何体
         * @param material 材质
         */
        function Mesh(geometry, material) {
            if (geometry === void 0) { geometry = null; }
            if (material === void 0) { material = null; }
            _super.call(this);
            this._castsShadows = true;
            _namedAsset._assetType = feng3d.AssetType.MESH;
            this._subMeshes = new feng3d.SubMesh[]();
            this.geometry = geometry || new feng3d.Geometry();
            this.material = material || feng3d.DefaultMaterialManager.getDefaultMaterial();
        }
        Object.defineProperty(Mesh.prototype, "geometry", {
            /** 几何形状 */
            get: function () {
                return _geometry;
            },
            set: function (value) {
                var i;
                if (_geometry) {
                    _geometry.removeEventListener(feng3d.GeometryEvent.SHAPE_CHANGE, onGeometryBoundsInvalid);
                    _geometry.removeEventListener(feng3d.GeometryEvent.SUB_GEOMETRY_ADDED, onSubGeometryAdded);
                    _geometry.removeEventListener(feng3d.GeometryEvent.SUB_GEOMETRY_REMOVED, onSubGeometryRemoved);
                    for (i = 0; i < _subMeshes.length; ++i)
                        _subMeshes[i].dispose();
                    _subMeshes.length = 0;
                }
                _geometry = value;
                if (_geometry) {
                    _geometry.addEventListener(feng3d.GeometryEvent.SHAPE_CHANGE, onGeometryBoundsInvalid);
                    _geometry.addEventListener(feng3d.GeometryEvent.SUB_GEOMETRY_ADDED, onSubGeometryAdded);
                    _geometry.addEventListener(feng3d.GeometryEvent.SUB_GEOMETRY_REMOVED, onSubGeometryRemoved);
                    var subGeoms = _geometry.subGeometries;
                    for (i = 0; i < subGeoms.length; ++i)
                        addSubMesh(subGeoms[i]);
                }
                invalidateBounds();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Mesh.prototype, "material", {
            /**
             * 渲染材质
             */
            get: function () {
                return _materialSelf;
            },
            set: function (value) {
                if (value == _materialSelf)
                    return;
                if (_materialSelf)
                    _materialSelf.removeOwner(this);
                _materialSelf = value;
                if (_materialSelf)
                    _materialSelf.addOwner(this);
                dispatchEvent(new feng3d.MeshEvent(feng3d.MeshEvent.MATERIAL_CHANGE));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Mesh.prototype, "materialSelf", {
            /**
             * 自身材质
             */
            get: function () {
                return _materialSelf;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Mesh.prototype, "sourceEntity", {
            /**
             * 源实体
             */
            get: function () {
                return this;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        Mesh.prototype.updateBounds = function () {
            _bounds.fromGeometry(this.geometry);
            _boundsInvalid = false;
        };
        /**
         * @inheritDoc
         */
        Mesh.prototype.collidesBefore = function (shortestCollisionDistance, findClosest) {
            this._pickingCollider.setLocalRay(this._pickingCollisionVO.localRay);
            this._pickingCollisionVO.renderable = null;
            var len = this._subMeshes.length;
            for (var i = 0; i < len; ++i) {
                var subMesh = this._subMeshes[i];
                //var ignoreFacesLookingAway:boolean = _material ? !_material.bothSides : true;
                if (this._pickingCollider.testSubMeshCollision(subMesh, this._pickingCollisionVO, shortestCollisionDistance)) {
                    shortestCollisionDistance = this._pickingCollisionVO.rayEntryDistance;
                    this._pickingCollisionVO.renderable = subMesh.renderableBase;
                    if (!findClosest)
                        return true;
                }
            }
            return this._pickingCollisionVO.renderable != null;
        };
        Object.defineProperty(Mesh.prototype, "animator", {
            /**
             * @inheritDoc
             */
            get: function () {
                return _animator;
            },
            set: function (value) {
                if (_animator)
                    _animator.removeOwner(this);
                _animator = value;
                var i;
                for (i = 0; i < subMeshes.length; i++) {
                    var subMesh = subMeshes[i];
                    subMesh.animator = _animator;
                }
                if (_animator)
                    _animator.addOwner(this);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Mesh.prototype, "subMeshes", {
            /**
             * 子网格列表
             */
            get: function () {
                return _subMeshes;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 添加子网格包装子几何体
         * @param subGeometry		被添加的子几何体
         */
        Mesh.prototype.addSubMesh = function (subGeometry) {
            var subMesh = new feng3d.SubMesh(subGeometry, this, null);
            var len = this._subMeshes.length;
            subMesh._index = len;
            this._subMeshes[len] = subMesh;
            invalidateBounds();
        };
        /**
         * 处理几何体边界变化事件
         */
        Mesh.prototype.onGeometryBoundsInvalid = function (event) {
            invalidateBounds();
        };
        /**
         * 处理子几何体添加事件
         */
        Mesh.prototype.onSubGeometryAdded = function (event) {
            this.addSubMesh(event.subGeometry);
            invalidateBounds();
        };
        /**
         * 处理子几何体移除事件
         */
        Mesh.prototype.onSubGeometryRemoved = function (event) {
            var subMesh;
            var subGeom = event.subGeometry;
            var len = this._subMeshes.length;
            var i;
            for (i = 0; i < len; ++i) {
                subMesh = this._subMeshes[i];
                if (subMesh.subGeometry == subGeom) {
                    subMesh.dispose();
                    this._subMeshes.splice(i, 1);
                    break;
                }
            }
            --len;
            for (; i < len; ++i)
                this._subMeshes[i]._index = i;
            invalidateBounds();
        };
        Object.defineProperty(Mesh.prototype, "castsShadows", {
            /**
             * 是否捕获阴影
             */
            get: function () {
                return _castsShadows;
            },
            set: function (value) {
                _castsShadows = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        Mesh.prototype.createEntityPartitionNode = function () {
            return new feng3d.MeshNode(this);
        };
        return Mesh;
    }(feng3d.Entity));
    feng3d.Mesh = Mesh;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 高度地形
     * @author feng 2014-7-16
     */
    var Elevation = (function (_super) {
        __extends(Elevation, _super);
        /**
         * 创建高度地形 拥有segmentsW*segmentsH个顶点
         * @param    material	地形纹理
         * @param    heightMap	高度图
         * @param    width	地形宽度
         * @param    height	地形高度
         * @param    depth	地形深度
         * @param    segmentsW	x轴上网格段数
         * @param    segmentsH	y轴上网格段数
         * @param    maxElevation	最大地形高度
         * @param    minElevation	最小地形高度
         * @param    smoothMap	是否平滑
         */
        function Elevation(material, heightMap, width, height, depth, segmentsW, segmentsH, maxElevation, minElevation) {
            if (width === void 0) { width = 1000; }
            if (height === void 0) { height = 100; }
            if (depth === void 0) { depth = 1000; }
            if (segmentsW === void 0) { segmentsW = 30; }
            if (segmentsH === void 0) { segmentsH = 30; }
            if (maxElevation === void 0) { maxElevation = 255; }
            if (minElevation === void 0) { minElevation = 0; }
            this._geomDirty = true;
            this._uvDirty = true;
            this._subGeometry = new feng3d.SubGeometry();
            _super.call(this, new feng3d.Geometry(), material);
            this.geometry.addSubGeometry(this._subGeometry);
            this._heightMap = heightMap;
            this._segmentsW = segmentsW;
            this._segmentsH = segmentsH;
            this._width = width;
            this._height = height;
            this._depth = depth;
            this._maxElevation = maxElevation;
            this._minElevation = minElevation;
            this._subGeometry.numVertices = (this._segmentsH + 1) * (this._segmentsW + 1);
            this.buildUVs();
            this.buildGeometry();
        }
        /**
         * 创建顶点坐标
         */
        Elevation.prototype.buildGeometry = function () {
            var vertices;
            var indices;
            var x, z;
            var numInds;
            var base;
            //一排顶点数据
            var tw = this._segmentsW + 1;
            //总顶点数量
            var numVerts = (this._segmentsH + 1) * tw;
            //一个格子所占高度图X轴像素数
            var uDiv = (this._heightMap.width - 1) / this._segmentsW;
            //一个格子所占高度图Y轴像素数
            var vDiv = (this._heightMap.height - 1) / this._segmentsH;
            var u, v;
            var y;
            vertices = this._subGeometry.vertexPositionData || new number[](numVerts * 3, true);
            indices = this._subGeometry.indexData || new number[](this._segmentsH * this._segmentsW * 6, true);
            numVerts = 0;
            var col;
            for (var zi = 0; zi <= this._segmentsH; ++zi) {
                for (var xi = 0; xi <= this._segmentsW; ++xi) {
                    //顶点坐标
                    x = (xi / this._segmentsW - .5) * this._width;
                    z = (zi / this._segmentsH - .5) * this._depth;
                    //格子对应高度图uv坐标
                    u = xi * uDiv;
                    v = (this._segmentsH - zi) * vDiv;
                    //获取颜色值
                    col = this._heightMap.getPixel(u, v) & 0xff;
                    //计算高度值
                    y = (col > this._maxElevation) ? (this._maxElevation / 0xff) * this._height : ((col < this._minElevation) ? (this._minElevation / 0xff) * this._height : (col / 0xff) * this._height);
                    //保存顶点坐标
                    vertices[numVerts++] = x;
                    vertices[numVerts++] = y;
                    vertices[numVerts++] = z;
                    if (xi != this._segmentsW && zi != this._segmentsH) {
                        //增加 一个顶点同时 生成一个格子或两个三角形
                        base = xi + zi * tw;
                        indices[numInds++] = base;
                        indices[numInds++] = base + tw;
                        indices[numInds++] = base + tw + 1;
                        indices[numInds++] = base;
                        indices[numInds++] = base + tw + 1;
                        indices[numInds++] = base + 1;
                    }
                }
            }
            this._subGeometry.updateVertexPositionData(vertices);
            this._subGeometry.updateIndexData(indices);
        };
        /**
         * 创建uv坐标
         */
        Elevation.prototype.buildUVs = function () {
            var uvs = new number[]();
            var numUvs = (this._segmentsH + 1) * (this._segmentsW + 1) * 2;
            uvs = this._subGeometry.UVData;
            if (uvs == null || numUvs != uvs.length)
                uvs = new number[](numUvs, true);
            numUvs = 0;
            //计算每个顶点的uv坐标
            for (var yi = 0; yi <= this._segmentsH; ++yi) {
                for (var xi = 0; xi <= this._segmentsW; ++xi) {
                    uvs[numUvs++] = xi / this._segmentsW;
                    uvs[numUvs++] = 1 - yi / this._segmentsH;
                }
            }
            this._subGeometry.updateUVData(uvs);
        };
        /**
         * 获取位置在（x，z）处的高度y值
         * @param x x坐标
         * @param z z坐标
         * @return 高度
         */
        Elevation.prototype.getHeightAt = function (x, z) {
            //得到高度图中的值
            var u = (x / this._width + .5) * (this._heightMap.width - 1);
            var v = (-z / this._depth + .5) * (this._heightMap.height - 1);
            var col = this._heightMap.getPixel(u, v) & 0xff;
            var h;
            if (col > this._maxElevation) {
                h = (this._maxElevation / 0xff) * this._height;
            }
            else if (col < this._minElevation) {
                h = (this._minElevation / 0xff) * this._height;
            }
            else {
                h = (col / 0xff) * this._height;
            }
            return h;
        };
        return Elevation;
    }(feng3d.Mesh));
    feng3d.Elevation = Elevation;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 线段集合
     * @author feng 2014-4-9
     */
    var SegmentSet = (function (_super) {
        __extends(SegmentSet, _super);
        /**
         * 创建一个线段集合
         */
        function SegmentSet() {
            _super.call(this);
            this.geometry = this.segmentGeometry = new feng3d.SegmentGeometry();
            this.material = new feng3d.SegmentMaterial();
        }
        /**
         * 添加线段
         * @param segment		线段数据
         */
        SegmentSet.prototype.addSegment = function (segment, needUpdateGeometry) {
            if (needUpdateGeometry === void 0) { needUpdateGeometry = true; }
            this.segmentGeometry.addSegment(segment, needUpdateGeometry);
        };
        Object.defineProperty(SegmentSet.prototype, "context3dCache", {
            /**
             * @inheritDoc
             */
            get: function () {
                return null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SegmentSet.prototype, "numTriangles", {
            /**
             * @inheritDoc
             */
            get: function () {
                return _numIndices / 3;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SegmentSet.prototype, "castsShadows", {
            /**
             * 线段不会投射阴影，始终为false
             */
            get: function () {
                return false;
            },
            enumerable: true,
            configurable: true
        });
        return SegmentSet;
    }(feng3d.Mesh));
    feng3d.SegmentSet = SegmentSet;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 坐标系,三叉戟
     * @param length 长度
     * @param showLetters 显示字母
     */
    var Trident = (function (_super) {
        __extends(Trident, _super);
        function Trident(length, showLetters) {
            if (length === void 0) { length = 100; }
            if (showLetters === void 0) { showLetters = true; }
            this.buildTrident(Math.abs((length == 0) ? 10 : length), showLetters);
        }
        Trident.prototype.buildTrident = function (length, showLetters) {
            var scaleH = length / 10;
            var scaleW = length / 20;
            var scl1 = scaleW * 1.5;
            var scl2 = scaleH * 3;
            var scl3 = scaleH * 2;
            var scl4 = scaleH * 3.4;
            var cross = length + (scl3) + (((length + scl4) - (length + scl3)) / 3 * 2);
            var arr = [
                [new Vector3D(), new Vector3D(length, 0, 0), 0x880000, 0xff0000, 1],
                //X
                [new Vector3D(length + scl2, scl1, 0), new Vector3D(length + scl3, -scl1, 0), 0xff0000, 0xff0000, 1],
                [new Vector3D(length + scl3, scl1, 0), new Vector3D(length + scl2, -scl1, 0), 0xff0000, 0xff0000, 1],
                [new Vector3D(), new Vector3D(0, length, 0), 0x008800, 0x00ff00, 1],
                //Y
                [new Vector3D(-scaleW * 1.2, length + scl4, 0), new Vector3D(0, cross, 0), 0x00ff00, 0x00ff00, 1],
                [new Vector3D(scaleW * 1.2, length + scl4, 0), new Vector3D(0, cross, 0), 0x00ff00, 0x00ff00, 1],
                [new Vector3D(0, cross, 0), new Vector3D(0, length + scl3, 0), 0x00ff00, 0x00ff00, 1],
                [new Vector3D(), new Vector3D(0, 0, length), 0x000088, 0x0000ff, 1],
                //Z
                [new Vector3D(0, scl1, length + scl2), new Vector3D(0, scl1, length + scl3), 0x0000ff, 0x0000ff, 1],
                [new Vector3D(0, -scl1, length + scl2), new Vector3D(0, -scl1, length + scl3), 0x0000ff, 0x0000ff, 1],
                [new Vector3D(0, -scl1, length + scl3), new Vector3D(0, scl1, length + scl2), 0x0000ff, 0x0000ff, 1],
            ];
            var segmentX;
            for (var i = 0; i < arr.length; i++) {
                segmentX = new feng3d.Segment(arr[i][0], arr[i][1], arr[i][2], arr[i][3], arr[i][4]);
                segmentGeometry.addSegment(segmentX);
            }
        };
        return Trident;
    }(feng3d.SegmentSet));
    feng3d.Trident = Trident;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 线框基元基类
     * @author feng 2014-4-27
     */
    var WireframePrimitiveBase = (function (_super) {
        __extends(WireframePrimitiveBase, _super);
        /**
         * @param color 线框颜色
         * @param thickness 线框厚度
         */
        function WireframePrimitiveBase(color, thickness) {
            if (color === void 0) { color = 0xffffff; }
            if (thickness === void 0) { thickness = 1; }
            this._color = 0xffffff;
            this._thickness = 1;
            if (thickness <= 0)
                thickness = 1;
            this.color = color;
            this.thickness = thickness;
            feng3d.AbstractClassError.check(this);
        }
        Object.defineProperty(WireframePrimitiveBase.prototype, "color", {
            /** 线框颜色 */
            get: function () {
                return _color;
            },
            set: function (value) {
                _color = value;
                for (each(); ; )
                    var segment;
                 in segmentGeometry.segments;
                {
                    segment.startColor = segment.endColor = value;
                }
                segmentGeometry.updateGeometry();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WireframePrimitiveBase.prototype, "thickness", {
            /** 线条粗细值 */
            get: function () {
                return _thickness;
            },
            set: function (value) {
                _thickness = value;
                for (each(); ; )
                    var segment;
                 in segmentGeometry.segments;
                {
                    segment.thickness = segment.thickness = value;
                }
                segmentGeometry.updateGeometry();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 更新线条
         * @param index 线段编号
         * @param v0 线段起点
         * @param v1 线段终点
         */
        WireframePrimitiveBase.prototype.updateOrAddSegment = function (index, v0, v1) {
            var segment;
            if ((segment = segmentGeometry.getSegment(index)) != null) {
                segment.start = v0;
                segment.end = v1;
            }
            else {
                segmentGeometry.addSegment(new feng3d.Segment(v0.clone(), v1.clone(), this._color, this._color, this._thickness));
            }
        };
        return WireframePrimitiveBase;
    }(feng3d.SegmentSet));
    feng3d.WireframePrimitiveBase = WireframePrimitiveBase;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 线框立方体
     * @author feng 2014-4-27
     */
    var WireframeCube = (function (_super) {
        __extends(WireframeCube, _super);
        /**
         * @param width X轴方向宽度
         * @param height Y轴方向高度
         * @param depth Z轴方向深度
         * @param color 线条颜色
         * @param thickness 线条厚度
         */
        function WireframeCube(width, height, depth, color, thickness) {
            if (width === void 0) { width = 100; }
            if (height === void 0) { height = 100; }
            if (depth === void 0) { depth = 100; }
            if (color === void 0) { color = 0xFFFFFF; }
            if (thickness === void 0) { thickness = 1; }
            _super.call(this, color, thickness);
            this._cubeWidth = width;
            this._cubeHeight = height;
            this._cubeDepth = depth;
            this.buildGeometry();
        }
        Object.defineProperty(WireframeCube.prototype, "cubeWidth", {
            /**
             * The size of the cube along its X-axis.
             */
            get: function () {
                return _cubeWidth;
            },
            set: function (value) {
                _cubeWidth = value;
                buildGeometry();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WireframeCube.prototype, "cubeHeight", {
            /**
             * The size of the cube along its Y-axis.
             */
            get: function () {
                return _cubeHeight;
            },
            set: function (value) {
                if (value <= 0)
                    throw new Error("Value needs to be greater than 0");
                _cubeHeight = value;
                buildGeometry();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WireframeCube.prototype, "cubeDepth", {
            /**
             * The size of the cube along its Z-axis.
             */
            get: function () {
                return _cubeDepth;
            },
            set: function (value) {
                _cubeDepth = value;
                buildGeometry();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        WireframeCube.prototype.buildGeometry = function () {
            segmentGeometry.removeAllSegments();
            var v0 = new Vector3D();
            var v1 = new Vector3D();
            var hw = this._cubeWidth * .5;
            var hh = this._cubeHeight * .5;
            var hd = this._cubeDepth * .5;
            v0.x = -hw;
            v0.y = hh;
            v0.z = -hd;
            v1.x = -hw;
            v1.y = -hh;
            v1.z = -hd;
            updateOrAddSegment(0, v0, v1);
            v0.z = hd;
            v1.z = hd;
            updateOrAddSegment(1, v0, v1);
            v0.x = hw;
            v1.x = hw;
            updateOrAddSegment(2, v0, v1);
            v0.z = -hd;
            v1.z = -hd;
            updateOrAddSegment(3, v0, v1);
            v0.x = -hw;
            v0.y = -hh;
            v0.z = -hd;
            v1.x = hw;
            v1.y = -hh;
            v1.z = -hd;
            updateOrAddSegment(4, v0, v1);
            v0.y = hh;
            v1.y = hh;
            updateOrAddSegment(5, v0, v1);
            v0.z = hd;
            v1.z = hd;
            updateOrAddSegment(6, v0, v1);
            v0.y = -hh;
            v1.y = -hh;
            updateOrAddSegment(7, v0, v1);
            v0.x = -hw;
            v0.y = -hh;
            v0.z = -hd;
            v1.x = -hw;
            v1.y = -hh;
            v1.z = hd;
            updateOrAddSegment(8, v0, v1);
            v0.y = hh;
            v1.y = hh;
            updateOrAddSegment(9, v0, v1);
            v0.x = hw;
            v1.x = hw;
            updateOrAddSegment(10, v0, v1);
            v0.y = -hh;
            v1.y = -hh;
            updateOrAddSegment(11, v0, v1);
        };
        return WireframeCube;
    }(feng3d.WireframePrimitiveBase));
    feng3d.WireframeCube = WireframeCube;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
    * 线框几何体
     * @author feng 2014-5-8
     */
    var WireframeGeometry = (function (_super) {
        __extends(WireframeGeometry, _super);
        /**
         * 创建几何体线框
         * @param geometry 几何体
         * @param color 线条颜色
         * @param thickness 线条粗细
         */
        function WireframeGeometry(color, thickness) {
            if (color === void 0) { color = 0xffffff; }
            if (thickness === void 0) { thickness = 1; }
            _super.call(this, color, thickness);
            this._drawGeometry = new feng3d.Geometry();
        }
        Object.defineProperty(WireframeGeometry.prototype, "drawGeometry", {
            get: function () {
                return _drawGeometry;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 绘制几何体线框
         */
        WireframeGeometry.prototype.setDrawGeometry = function (value) {
            this._drawGeometry = value;
            this.buildGeometry();
        };
        WireframeGeometry.prototype.buildGeometry = function () {
            segmentGeometry.removeAllSegments();
            if (this.drawGeometry == null)
                return;
            //避免重复绘制同一条线段
            var segmentDic = {};
            var subGeometries = this.drawGeometry.subGeometries;
            var subGeometry;
            for (var j = 0; j < subGeometries.length; j++) {
                subGeometry = subGeometries[j];
                //顶点索引
                var _vertexIndices = subGeometry.indexData;
                //顶点位置
                var _vertices = subGeometry.vertexPositionData;
                var numTriangle = _vertexIndices.length / 3;
                var indexA;
                var indexB;
                var indexC;
                var posA;
                var posB;
                var posC;
                var segmentIndex = 0;
                for (var i = 0; i < numTriangle; i++) {
                    indexA = _vertexIndices[i * 3];
                    indexB = _vertexIndices[i * 3 + 1];
                    indexC = _vertexIndices[i * 3 + 2];
                    posA = new Vector3D(_vertices[indexA * 3], _vertices[indexA * 3 + 1], _vertices[indexA * 3 + 2]);
                    posB = new Vector3D(_vertices[indexB * 3], _vertices[indexB * 3 + 1], _vertices[indexB * 3 + 2]);
                    posC = new Vector3D(_vertices[indexC * 3], _vertices[indexC * 3 + 1], _vertices[indexC * 3 + 2]);
                    //线段AB
                    if (!segmentDic[posA.toString() + "-" + posB.toString()]) {
                        updateOrAddSegment(++segmentIndex, posA, posB);
                        segmentDic[posA.toString() + "-" + posB.toString()] = segmentDic[posB.toString() + "-" + posA.toString()] = true;
                    }
                    //线段BC
                    if (!segmentDic[posB.toString() + "-" + posC.toString()]) {
                        updateOrAddSegment(++segmentIndex, posB, posC);
                        segmentDic[posB.toString() + "-" + posC.toString()] = segmentDic[posC.toString() + "-" + posB.toString()] = true;
                    }
                    //线段CA
                    if (!segmentDic[posC.toString() + "-" + posA.toString()]) {
                        updateOrAddSegment(++segmentIndex, posC, posA);
                        segmentDic[posC.toString() + "-" + posA.toString()] = segmentDic[posA.toString() + "-" + posC.toString()] = true;
                    }
                }
            }
        };
        return WireframeGeometry;
    }(feng3d.WireframePrimitiveBase));
    feng3d.WireframeGeometry = WireframeGeometry;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * A WireframePlane primitive mesh.
     */
    var WireframePlane = (function (_super) {
        __extends(WireframePlane, _super);
        /**
         * Creates a new WireframePlane object.
         * @param width The size of the cube along its X-axis.
         * @param height The size of the cube along its Y-axis.
         * @param segmentsW The number of segments that make up the cube along the X-axis.
         * @param segmentsH The number of segments that make up the cube along the Y-axis.
         * @param color The colour of the wireframe lines
         * @param thickness The thickness of the wireframe lines
         * @param orientation The orientaion in which the plane lies.
         */
        function WireframePlane(width, height, segmentsW, segmentsH, color, thickness, orientation) {
            if (segmentsW === void 0) { segmentsW = 10; }
            if (segmentsH === void 0) { segmentsH = 10; }
            if (color === void 0) { color = 0xFFFFFF; }
            if (thickness === void 0) { thickness = 1; }
            if (orientation === void 0) { orientation = "yz"; }
            _super.call(this, color, thickness);
            this._width = width;
            this._height = height;
            this._segmentsW = segmentsW;
            this._segmentsH = segmentsH;
            this._orientation = orientation;
            this.buildGeometry();
        }
        Object.defineProperty(WireframePlane.prototype, "orientation", {
            /**
             * The orientaion in which the plane lies.
             */
            get: function () {
                return _orientation;
            },
            set: function (value) {
                _orientation = value;
                buildGeometry();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WireframePlane.prototype, "width", {
            /**
             * The size of the cube along its X-axis.
             */
            get: function () {
                return _width;
            },
            set: function (value) {
                _width = value;
                buildGeometry();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WireframePlane.prototype, "height", {
            /**
             * The size of the cube along its Y-axis.
             */
            get: function () {
                return _height;
            },
            set: function (value) {
                if (value <= 0)
                    throw new Error("Value needs to be greater than 0");
                _height = value;
                buildGeometry();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WireframePlane.prototype, "segmentsW", {
            /**
             * The number of segments that make up the plane along the X-axis.
             */
            get: function () {
                return _segmentsW;
            },
            set: function (value) {
                _segmentsW = value;
                buildGeometry();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WireframePlane.prototype, "segmentsH", {
            /**
             * The number of segments that make up the plane along the Y-axis.
             */
            get: function () {
                return _segmentsH;
            },
            set: function (value) {
                _segmentsH = value;
                buildGeometry();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        WireframePlane.prototype.buildGeometry = function () {
            segmentGeometry.removeAllSegments();
            var v0 = new Vector3D();
            var v1 = new Vector3D();
            var hw = this._width * .5;
            var hh = this._height * .5;
            var index;
            var ws, hs;
            if (this._orientation == ORIENTATION_XY) {
                v0.y = hh;
                v0.z = 0;
                v1.y = -hh;
                v1.z = 0;
                for (ws = 0; ws <= this._segmentsW; ++ws) {
                    v0.x = v1.x = (ws / this._segmentsW - .5) * this._width;
                    updateOrAddSegment(index++, v0, v1);
                }
                v0.x = -hw;
                v1.x = hw;
                for (hs = 0; hs <= this._segmentsH; ++hs) {
                    v0.y = v1.y = (hs / this._segmentsH - .5) * this._height;
                    updateOrAddSegment(index++, v0, v1);
                }
            }
            else if (this._orientation == ORIENTATION_XZ) {
                v0.z = hh;
                v0.y = 0;
                v1.z = -hh;
                v1.y = 0;
                for (ws = 0; ws <= this._segmentsW; ++ws) {
                    v0.x = v1.x = (ws / this._segmentsW - .5) * this._width;
                    updateOrAddSegment(index++, v0, v1);
                }
                v0.x = -hw;
                v1.x = hw;
                for (hs = 0; hs <= this._segmentsH; ++hs) {
                    v0.z = v1.z = (hs / this._segmentsH - .5) * this._height;
                    updateOrAddSegment(index++, v0, v1);
                }
            }
            else if (this._orientation == ORIENTATION_YZ) {
                v0.y = hh;
                v0.x = 0;
                v1.y = -hh;
                v1.x = 0;
                for (ws = 0; ws <= this._segmentsW; ++ws) {
                    v0.z = v1.z = (ws / this._segmentsW - .5) * this._width;
                    updateOrAddSegment(index++, v0, v1);
                }
                v0.z = hw;
                v1.z = -hw;
                for (hs = 0; hs <= this._segmentsH; ++hs) {
                    v0.y = v1.y = (hs / this._segmentsH - .5) * this._height;
                    updateOrAddSegment(index++, v0, v1);
                }
            }
        };
        WireframePlane.ORIENTATION_YZ = "yz";
        WireframePlane.ORIENTATION_XY = "xy";
        WireframePlane.ORIENTATION_XZ = "xz";
        return WireframePlane;
    }(feng3d.WireframePrimitiveBase));
    feng3d.WireframePlane = WireframePlane;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 球体线框
     * @author feng 2015-3-21
     */
    var WireframeSphere = (function (_super) {
        __extends(WireframeSphere, _super);
        /**
         * 创建一个球体线框对象
         * @param radius			球体半径
         * @param segmentsW			球体的横向分割数
         * @param segmentsH			球体的纵向分割数
         * @param color				线框颜色
         * @param thickness			线条粗细
         */
        function WireframeSphere(radius, segmentsW, segmentsH, color, thickness) {
            if (radius === void 0) { radius = 50; }
            if (segmentsW === void 0) { segmentsW = 16; }
            if (segmentsH === void 0) { segmentsH = 12; }
            if (color === void 0) { color = 0xFFFFFF; }
            if (thickness === void 0) { thickness = 1; }
            _super.call(this, color, thickness);
            this._radius = radius;
            this._segmentsW = segmentsW;
            this._segmentsH = segmentsH;
            this.buildGeometry();
        }
        /**
         * @inheritDoc
         */
        WireframeSphere.prototype.buildGeometry = function () {
            segmentGeometry.removeAllSegments();
            var vertices = new number[]();
            var v0 = new Vector3D();
            var v1 = new Vector3D();
            var i, j;
            var numVerts = 0;
            var index;
            for (j = 0; j <= this._segmentsH; ++j) {
                var horangle = Math.PI * j / this._segmentsH;
                var z = -this._radius * Math.cos(horangle);
                var ringradius = this._radius * Math.sin(horangle);
                for (i = 0; i <= this._segmentsW; ++i) {
                    var verangle = 2 * Math.PI * i / this._segmentsW;
                    var x = ringradius * Math.cos(verangle);
                    var y = ringradius * Math.sin(verangle);
                    vertices[numVerts++] = x;
                    vertices[numVerts++] = -z;
                    vertices[numVerts++] = y;
                }
            }
            for (j = 1; j <= this._segmentsH; ++j) {
                for (i = 1; i <= this._segmentsW; ++i) {
                    var a = ((this._segmentsW + 1) * j + i) * 3;
                    var b = ((this._segmentsW + 1) * j + i - 1) * 3;
                    var c = ((this._segmentsW + 1) * (j - 1) + i - 1) * 3;
                    var d = ((this._segmentsW + 1) * (j - 1) + i) * 3;
                    if (j == this._segmentsH) {
                        v0.x = vertices[c];
                        v0.y = vertices[c + 1];
                        v0.z = vertices[c + 2];
                        v1.x = vertices[d];
                        v1.y = vertices[d + 1];
                        v1.z = vertices[d + 2];
                        updateOrAddSegment(index++, v0, v1);
                        v0.x = vertices[a];
                        v0.y = vertices[a + 1];
                        v0.z = vertices[a + 2];
                        updateOrAddSegment(index++, v0, v1);
                    }
                    else if (j == 1) {
                        v1.x = vertices[b];
                        v1.y = vertices[b + 1];
                        v1.z = vertices[b + 2];
                        v0.x = vertices[c];
                        v0.y = vertices[c + 1];
                        v0.z = vertices[c + 2];
                        updateOrAddSegment(index++, v0, v1);
                    }
                    else {
                        v1.x = vertices[b];
                        v1.y = vertices[b + 1];
                        v1.z = vertices[b + 2];
                        v0.x = vertices[c];
                        v0.y = vertices[c + 1];
                        v0.z = vertices[c + 2];
                        updateOrAddSegment(index++, v0, v1);
                        v1.x = vertices[d];
                        v1.y = vertices[d + 1];
                        v1.z = vertices[d + 2];
                        updateOrAddSegment(index++, v0, v1);
                    }
                }
            }
        };
        return WireframeSphere;
    }(feng3d.WireframePrimitiveBase));
    feng3d.WireframeSphere = WireframeSphere;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 天空盒类用于渲染的场景中的天空。
     * 总是被认为是静态的,在无穷远处,并且总是集中在相机的位置和大小符合在相机的视锥体,
     * 确保天空盒总是尽可能大而不被裁剪。
     * @author feng 2014-7-11
     */
    var SkyBox = (function (_super) {
        __extends(SkyBox, _super);
        /**
         * 创建天空盒实例
         * @param cubeMap		立方体贴图
         */
        function SkyBox(cubeMap) {
            _super.call(this);
            _namedAsset._assetType = feng3d.AssetType.SKYBOX;
            this.material = new feng3d.SkyBoxMaterial(cubeMap);
            this.subGeometry = new feng3d.SubGeometry();
            this.geometry.addSubGeometry(this.subGeometry);
            this.buildGeometry();
        }
        /**
         * 创建天空盒 顶点与索引数据
         */
        SkyBox.prototype.buildGeometry = function () {
            this.subGeometry.numVertices = 8;
            //八个顶点，32个number
            var vertexData = new  < number > [
                -1, 1, -1, 1, 1, -1,
                1, 1, 1, -1, 1, 1,
                -1, -1, -1, 1, -1, -1,
                1, -1, 1, -1, -1, 1 //
            ];
            this.subGeometry.updateVertexPositionData(vertexData);
            //6个面，12个三角形，36个顶点索引
            var indexData = new  < number > [
                0, 1, 2, 2, 3, 0,
                6, 5, 4, 4, 7, 6,
                2, 6, 7, 7, 3, 2,
                4, 5, 1, 1, 0, 4,
                4, 0, 3, 3, 7, 4,
                2, 1, 5, 5, 6, 2 //
            ];
            this.subGeometry.updateIndexData(indexData);
        };
        /**
         * @inheritDoc
         */
        SkyBox.prototype.createEntityPartitionNode = function () {
            return new feng3d.SkyBoxNode(this);
        };
        /**
         * @inheritDoc
         */
        SkyBox.prototype.updateBounds = function () {
            _boundsInvalid = false;
        };
        Object.defineProperty(SkyBox.prototype, "castsShadows", {
            /**
             * 天空盒不会投射阴影，始终为false
             */
            get: function () {
                return false;
            },
            enumerable: true,
            configurable: true
        });
        return SkyBox;
    }(feng3d.Mesh));
    feng3d.SkyBox = SkyBox;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * Sprite3D is a 3D billboard, a renderable rectangular area that is always aligned with the projection plane.
     * As a result, no perspective transformation occurs on a Sprite3D object.
     *
     * todo: mvp generation or vertex shader code can be optimized
     */
    var Sprite3D = (function (_super) {
        __extends(Sprite3D, _super);
        function Sprite3D(material, width, height) {
            _super.call(this);
            this._shadowCaster = false;
            this.transform3D.addEventListener(feng3d.Transform3DEvent.TRANSFORM_UPDATED, this.onTransformUpdated);
            this.material = material;
            this._width = width;
            this._height = height;
            this._spriteMatrix = new Matrix3D();
            if (!_sprite3DGeometry) {
                _sprite3DGeometry = new feng3d.SubGeometry();
                _sprite3DGeometry.numVertices = 4;
                _sprite3DGeometry.updateVertexPositionData(number[]([-.5, .5, .0, .5, .5, .0, .5, -.5, .0, -.5, -.5, .0]));
                _sprite3DGeometry.updateUVData(number[]([.0, .0, 1.0, .0, 1.0, 1.0, .0, 1.0]));
                _sprite3DGeometry.updateIndexData(number[]([0, 1, 2, 0, 2, 3]));
                _sprite3DGeometry.updateVertexTangentData(number[]([1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0]));
                _sprite3DGeometry.updateVertexNormalData(number[]([.0, .0, -1.0, .0, .0, -1.0, .0, .0, -1.0, .0, .0, -1.0]));
            }
            this.geometry.addSubGeometry(_sprite3DGeometry);
        }
        Object.defineProperty(Sprite3D.prototype, "pickingCollider", {
            set: function (value) {
                _super.prototype.pickingCollider = value;
                if (value) {
                    _pickingSubMesh = new feng3d.SubMesh(_sprite3DGeometry, null);
                    _pickingTransform = new Matrix3D();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Sprite3D.prototype, "width", {
            get: function () {
                return _width;
            },
            set: function (value) {
                if (_width == value)
                    return;
                _width = value;
                transform3D.invalidateTransform();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Sprite3D.prototype, "height", {
            get: function () {
                return _height;
            },
            set: function (value) {
                if (_height == value)
                    return;
                _height = value;
                transform3D.invalidateTransform();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Sprite3D.prototype, "castsShadows", {
            get: function () {
                return _shadowCaster;
            },
            enumerable: true,
            configurable: true
        });
        Sprite3D.prototype.updateBounds = function () {
            _bounds.fromExtremes(-.5 * this.transform3D.scaleX, -.5 * this.transform3D.scaleY, -.5 * this.transform3D.scaleZ, .5 * this.transform3D.scaleX, .5 * this.transform3D.scaleY, .5 * this.transform3D.scaleZ);
            _boundsInvalid = false;
        };
        Sprite3D.prototype.onTransformUpdated = function (event) {
            this.transform3D.transform.prependScale(this._width, this._height, Math.max(this._width, this._height));
        };
        Sprite3D.prototype.collidesBefore = function (shortestCollisionDistance, findClosest) {
            findClosest = findClosest;
            var viewTransform = this._camera.inverseSceneTransform.clone();
            viewTransform.transpose();
            var rawViewTransform = feng3d.Matrix3DUtils.RAW_DATA_CONTAINER;
            viewTransform.copyRawDataTo(rawViewTransform);
            rawViewTransform[3] = 0;
            rawViewTransform[7] = 0;
            rawViewTransform[11] = 0;
            rawViewTransform[12] = 0;
            rawViewTransform[13] = 0;
            rawViewTransform[14] = 0;
            this._pickingTransform.copyRawDataFrom(rawViewTransform);
            this._pickingTransform.prependScale(this._width, this._height, Math.max(this._width, this._height));
            this._pickingTransform.appendTranslation(this.scenePosition.x, this.scenePosition.y, this.scenePosition.z);
            this._pickingTransform.invert();
            var localRayPosition = this._pickingTransform.transformVector(this._pickingCollisionVO.ray3D.position);
            var localRayDirection = this._pickingTransform.deltaTransformVector(this._pickingCollisionVO.ray3D.direction);
            var ray3D = new feng3d.Ray3D(localRayPosition, localRayDirection);
            this._pickingCollider.setLocalRay(ray3D);
            this._pickingCollisionVO.renderable = null;
            if (this._pickingCollider.testSubMeshCollision(this._pickingSubMesh, this._pickingCollisionVO, shortestCollisionDistance))
                this._pickingCollisionVO.renderable = this._pickingSubMesh.renderableBase;
            return this._pickingCollisionVO.renderable != null;
        };
        Sprite3D.prototype.getRenderSceneTransform = function (camera) {
            var comps = feng3d.Matrix3DUtils.decompose(camera.sceneTransform);
            var scale = comps[2];
            comps[0].x = this.scenePosition.x;
            comps[0].y = this.scenePosition.y;
            comps[0].z = this.scenePosition.z;
            scale.x = this._width * this.transform3D.scaleX;
            scale.y = this._height * this.transform3D.scaleY;
            this._spriteMatrix.recompose(comps);
            return this._spriteMatrix;
        };
        return Sprite3D;
    }(feng3d.Mesh));
    feng3d.Sprite3D = Sprite3D;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 灯光基类
     * @author feng 2014-9-11
     */
    var LightBase = (function (_super) {
        __extends(LightBase, _super);
        /**
         * 创建一个灯光
         */
        function LightBase() {
            _super.call(this);
            this._color = 0xffffff;
            this._colorR = 1;
            this._colorG = 1;
            this._colorB = 1;
            this._ambientColor = 0xffffff;
            this._ambient = 0;
            this._ambientR = 0;
            this._ambientG = 0;
            this._ambientB = 0;
            this._specular = 1;
            this._specularR = 1;
            this._specularG = 1;
            this._specularB = 1;
            this._diffuse = 1;
            this._diffuseR = 1;
            this._diffuseG = 1;
            this._diffuseB = 1;
            _namedAsset._assetType = feng3d.AssetType.LIGHT;
        }
        Object.defineProperty(LightBase.prototype, "castsShadows", {
            get: function () {
                return _castsShadows;
            },
            set: function (value) {
                if (_castsShadows == value)
                    return;
                _castsShadows = value;
                if (value) {
                    _shadowMapper || ;
                    createShadowMapper();
                    _shadowMapper.light = this;
                }
                else {
                    _shadowMapper.dispose();
                    _shadowMapper = null;
                }
                dispatchEvent(new feng3d.LightEvent(feng3d.LightEvent.CASTS_SHADOW_CHANGE));
            },
            enumerable: true,
            configurable: true
        });
        LightBase.prototype.createShadowMapper = function () {
            throw new feng3d.AbstractMethodError();
        };
        Object.defineProperty(LightBase.prototype, "color", {
            /**
             * 灯光颜色。默认为<code>0xffffff</code>。
             */
            get: function () {
                return _color;
            },
            set: function (value) {
                _color = value;
                _colorR = ((_color >> 16) & 0xff) / 0xff;
                _colorG = ((_color >> 8) & 0xff) / 0xff;
                _colorB = (_color & 0xff) / 0xff;
                updateDiffuse();
                updateSpecular();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LightBase.prototype, "ambient", {
            /**
             * 环境光强。默认为<code>0</code>。
             */
            get: function () {
                return _ambient;
            },
            set: function (value) {
                if (value < 0)
                    value = 0;
                else if (value > 1)
                    value = 1;
                _ambient = value;
                updateAmbient();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LightBase.prototype, "ambientColor", {
            /**
             * 环境光颜色。默认为<code>0xffffff</code>。
             */
            get: function () {
                return _ambientColor;
            },
            set: function (value) {
                _ambientColor = value;
                updateAmbient();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LightBase.prototype, "diffuse", {
            /**
             * 漫反射光强。默认为<code>1</code>。
             */
            get: function () {
                return _diffuse;
            },
            set: function (value) {
                if (value < 0)
                    value = 0;
                _diffuse = value;
                updateDiffuse();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LightBase.prototype, "specular", {
            /**
             * 镜面反射光强。默认为<code>1</code>。
             */
            get: function () {
                return _specular;
            },
            set: function (value) {
                if (value < 0)
                    value = 0;
                _specular = value;
                updateSpecular();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 更新镜面反射光成分
         */
        LightBase.prototype.updateSpecular = function () {
            this._specularR = this._colorR * this._specular;
            this._specularG = this._colorG * this._specular;
            this._specularB = this._colorB * this._specular;
        };
        /**
         * 更新漫反射光成分
         */
        LightBase.prototype.updateDiffuse = function () {
            this._diffuseR = this._colorR * this._diffuse;
            this._diffuseG = this._colorG * this._diffuse;
            this._diffuseB = this._colorB * this._diffuse;
        };
        /**
         * 更新环境光成分
         */
        LightBase.prototype.updateAmbient = function () {
            this._ambientR = ((this._ambientColor >> 16) & 0xff) / 0xff * this._ambient;
            this._ambientG = ((this._ambientColor >> 8) & 0xff) / 0xff * this._ambient;
            this._ambientB = (this._ambientColor & 0xff) / 0xff * this._ambient;
        };
        Object.defineProperty(LightBase.prototype, "shadowMapper", {
            get: function () {
                return _shadowMapper;
            },
            set: function (value) {
                _shadowMapper = value;
                _shadowMapper.light = this;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Gets the optimal projection matrix to render a light-based depth map for a single object.
         *
         * @param renderable The IRenderable object to render to a depth map.
         * @param target An optional target Matrix3D object. If not provided, an instance will be created.
         * @return A Matrix3D object containing the projection transformation.
         */
        LightBase.prototype.getObjectProjectionMatrix = function (renderable, target) {
            if (target === void 0) { target = null; }
            throw new feng3d.AbstractMethodError();
        };
        return LightBase;
    }(feng3d.Entity));
    feng3d.LightBase = LightBase;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 方向灯光
     * @author feng 2014-9-11
     */
    var DirectionalLight = (function (_super) {
        __extends(DirectionalLight, _super);
        /**
         * 创建一个方向灯光
         * @param xDir		方向X值
         * @param yDir		方向Y值
         * @param zDir		方向Z值
         */
        function DirectionalLight(xDir, yDir, zDir) {
            if (xDir === void 0) { xDir = 0; }
            if (yDir === void 0) { yDir = -1; }
            if (zDir === void 0) { zDir = 1; }
            _super.call(this);
            direction = new Vector3D(xDir, yDir, zDir);
            _sceneDirection = new Vector3D();
        }
        Object.defineProperty(DirectionalLight.prototype, "direction", {
            /**
             * 灯光方向
             */
            get: function () {
                return _direction;
            },
            set: function (value) {
                _direction = value;
                //lookAt(new Vector3D(x + _direction.x, y + _direction.y, z + _direction.z));
                if (!_tmpLookAt)
                    _tmpLookAt = new Vector3D();
                _tmpLookAt.x = transform3D.x + _direction.x;
                _tmpLookAt.y = transform3D.y + _direction.y;
                _tmpLookAt.z = transform3D.z + _direction.z;
                transform3D.lookAt(_tmpLookAt);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DirectionalLight.prototype, "sceneDirection", {
            /**
             * 灯光场景方向
             */
            get: function () {
                if (_sceneTransformDirty)
                    updateSceneTransform();
                return _sceneDirection;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        DirectionalLight.prototype.updateSceneTransform = function () {
            _super.prototype.updateSceneTransform.call(this);
            this.sceneTransform.copyColumnTo(2, this._sceneDirection);
            this._sceneDirection.normalize();
        };
        /**
         * @inheritDoc
         */
        DirectionalLight.prototype.createEntityPartitionNode = function () {
            return new feng3d.DirectionalLightNode(this);
        };
        /**
         * @inheritDoc
         */
        DirectionalLight.prototype.getDefaultBoundingVolume = function () {
            // 方向光源并没有坐标，因此永远在3D场景中
            return new feng3d.NullBounds();
        };
        /**
         * @inheritDoc
         */
        DirectionalLight.prototype.updateBounds = function () {
        };
        DirectionalLight.prototype.createShadowMapper = function () {
            return new feng3d.DirectionalShadowMapper();
        };
        return DirectionalLight;
    }(feng3d.LightBase));
    feng3d.DirectionalLight = DirectionalLight;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 点灯光
     * @author feng 2014-10-9
     */
    var PointLight = (function (_super) {
        __extends(PointLight, _super);
        function PointLight() {
            _super.call(this);
            this._radius = 90000;
            this._fallOff = 100000;
            this._fallOffFactor = 1 / (this._fallOff * this._fallOff - this._radius * this._radius);
        }
        Object.defineProperty(PointLight.prototype, "radius", {
            /**
             * 灯光可照射的最小距离
             */
            get: function () {
                return _radius;
            },
            set: function (value) {
                _radius = value;
                if (_radius < 0)
                    _radius = 0;
                else if (_radius > _fallOff) {
                    _fallOff = _radius;
                    invalidateBounds();
                }
                _fallOffFactor = 1 / (_fallOff * _fallOff - _radius * _radius);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PointLight.prototype, "fallOff", {
            /**
             * 灯光可照射的最大距离
             */
            get: function () {
                return _fallOff;
            },
            set: function (value) {
                _fallOff = value;
                if (_fallOff < 0)
                    _fallOff = 0;
                if (_fallOff < _radius)
                    _radius = _fallOff;
                _fallOffFactor = 1 / (_fallOff * _fallOff - _radius * _radius);
                invalidateBounds();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        PointLight.prototype.createEntityPartitionNode = function () {
            return new feng3d.PointLightNode(this);
        };
        /**
         * @inheritDoc
         */
        PointLight.prototype.updateBounds = function () {
            //			super.updateBounds();
            //			_bounds.fromExtremes(-this._fallOff, -this._fallOff, -this._fallOff, this._fallOff, this._fallOff, this._fallOff);
            _bounds.fromSphere(new Vector3D(), this._fallOff);
            _boundsInvalid = false;
        };
        return PointLight;
    }(feng3d.LightBase));
    feng3d.PointLight = PointLight;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 顶点数据拥有者
     * @author feng 2015-1-14
     */
    var VertexBufferOwner = (function (_super) {
        __extends(VertexBufferOwner, _super);
        /**
         * 创建顶点数据拥有者
         */
        function VertexBufferOwner() {
            _super.call(this);
            this._vaIdList = new string[]();
            /** 顶点属性数据缓存字典 */
            this.vaBufferDic = {};
            /** 顶点数据长度字典 */
            this.data32PerVertexDic = {};
            /** 顶点数据字典 */
            this.vertexDataDic = {};
            /** 数据有效(与脏相反)标记字典 */
            this.dataValidDic = {};
            this.context3DBufferOwner = new feng3d.Context3DBufferOwner();
        }
        Object.defineProperty(VertexBufferOwner.prototype, "numVertices", {
            /**
             * 顶点个数
             */
            get: function () {
                return _numVertices;
            },
            set: function (value) {
                if (_numVertices != value) {
                    for (each(); ; )
                        var vaBuffer;
                     in vaBufferDic;
                    {
                        vaBuffer.invalid();
                    }
                }
                _numVertices = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 注册顶点数据
         * @param dataTypeId
         * @param data32PerVertex
         */
        VertexBufferOwner.prototype.mapVABuffer = function (dataTypeId, data32PerVertex) {
            this.data32PerVertexDic[dataTypeId] = data32PerVertex;
            this.vertexDataDic[dataTypeId] = new number[]();
            this._vaIdList.push(dataTypeId);
            this.vaBufferDic[dataTypeId] = this.context3DBufferOwner.mapContext3DBuffer(dataTypeId, this.updateVABuffer);
        };
        /**
         * 更新顶点数据缓冲
         * @param vaBuffer
         */
        VertexBufferOwner.prototype.updateVABuffer = function (vaBuffer) {
            var data32PerVertex = this.getVALen(vaBuffer.dataTypeId);
            var data = this.getVAData(vaBuffer.dataTypeId);
            vaBuffer.update(data, this.numVertices, data32PerVertex);
        };
        /**
         * 使顶点数据失效
         * @param dataTypeId
         */
        VertexBufferOwner.prototype.invalidVAData = function (dataTypeId) {
            this.dataValidDic[dataTypeId] = false;
            this.context3DBufferOwner.markBufferDirty(dataTypeId);
        };
        /**
         * 获取顶点属性长度(1-4)
         * @param dataTypeId 数据类型编号
         * @return 顶点属性长度
         */
        VertexBufferOwner.prototype.getVALen = function (dataTypeId) {
            return this.data32PerVertexDic[dataTypeId];
        };
        /**
         * 设置顶点属性数据
         * @param dataTypeId 数据类型编号
         * @param data 顶点属性数据
         */
        VertexBufferOwner.prototype.setVAData = function (dataTypeId, data) {
            var vaLen = this.getVALen(dataTypeId);
            feng3d.assert(data.length == this.numVertices * vaLen, "数据长度不对，更新数据之前需要给SubGeometry.numVertices赋值");
            this.vertexDataDic[dataTypeId] = data;
            this.context3DBufferOwner.markBufferDirty(dataTypeId);
            this.dataValidDic[dataTypeId] = true;
            this.notifyVADataChanged(dataTypeId);
        };
        /**
         * 获取顶点属性数据
         * @param dataTypeId 数据类型编号
         * @param needUpdate 是否需要更新数据
         * @return 顶点属性数据
         */
        VertexBufferOwner.prototype.getVAData = function (dataTypeId) {
            if (!this.dataValidDic[dataTypeId])
                this.updateVAdata(dataTypeId);
            this.dataValidDic[dataTypeId] = true;
            return this.vertexDataDic[dataTypeId];
        };
        /**
         * 通知数据发生变化<br/>
         * 通常会在setVAData后被调用<br/>
         * 处理某数据改变后对其他数据造成的影响<br/>
         * 比如顶点数据发生变化后法线、切线等数据就变得无效了
         * @param dataTypeId 数据类型编号
         */
        VertexBufferOwner.prototype.notifyVADataChanged = function (dataTypeId) {
        };
        /**
         * 更新顶点数据
         * @param dataTypeId 数据类型编号
         */
        VertexBufferOwner.prototype.updateVAdata = function (dataTypeId) {
        };
        Object.defineProperty(VertexBufferOwner.prototype, "vaIdList", {
            /** 顶点属性编号列表 */
            get: function () {
                return _vaIdList;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(VertexBufferOwner.prototype, "_", {
            /**
             * Fagal编号中心
             */
            get: function () {
                return FagalIdCenter.instance;
            },
            enumerable: true,
            configurable: true
        });
        return VertexBufferOwner;
    }(feng3d.Component));
    feng3d.VertexBufferOwner = VertexBufferOwner;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 动画数据
     * @author feng 2015-1-14
     */
    var AnimationSubGeometry = (function (_super) {
        __extends(AnimationSubGeometry, _super);
        /**
         * 创建一个动画数据
         */
        function AnimationSubGeometry() {
        }
        return AnimationSubGeometry;
    }(feng3d.VertexBufferOwner));
    feng3d.AnimationSubGeometry = AnimationSubGeometry;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 获取几何体顶点数据时触发
     */
    [feng3d.Event(name = "getVAData", type = "me.feng3d.events.GeometryComponentEvent")][feng3d.Event(name = "changedVAData", type = "me.feng3d.events.GeometryComponentEvent")][feng3d.Event(name = "changedIndexData", type = "me.feng3d.events.GeometryComponentEvent")];
    /**
     * 子几何体
     */
    var SubGeometry = (function (_super) {
        __extends(SubGeometry, _super);
        /**
         * 创建一个新几何体
         */
        function SubGeometry() {
            _super.call(this);
            this.initBuffers();
        }
        SubGeometry.prototype.initBuffers = function () {
            this.context3DBufferOwner.mapContext3DBuffer(this._.index, this.updateIndexBuffer);
            this.mapVABuffer(this._.position_va_3, 3);
            this.mapVABuffer(this._.uv_va_2, 2);
            this.mapVABuffer(this._.normal_va_3, 3);
            this.mapVABuffer(this._.tangent_va_3, 3);
        };
        /**
         * 更新索引数据
         * @param indexBuffer 索引缓存
         */
        SubGeometry.prototype.updateIndexBuffer = function (indexBuffer) {
            indexBuffer.update(this.indices, this.numIndices, this.numIndices);
        };
        Object.defineProperty(SubGeometry.prototype, "numTriangles", {
            /**
             * 可绘制三角形的个数
             */
            get: function () {
                return _numTriangles;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 销毁
         */
        SubGeometry.prototype.dispose = function () {
            this._indices = null;
        };
        Object.defineProperty(SubGeometry.prototype, "indexData", {
            /**
             * 顶点索引数据
             */
            get: function () {
                if (_indices == null)
                    _indices = new number[]();
                return _indices;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SubGeometry.prototype, "numIndices", {
            /**
             * 索引数量
             */
            get: function () {
                return _numIndices;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SubGeometry.prototype, "indices", {
            /**
             * 索引数据
             */
            get: function () {
                return _indices;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 更新顶点索引数据
         */
        SubGeometry.prototype.updateIndexData = function (indices) {
            this._indices = indices;
            this._numIndices = indices.length;
            var numTriangles = this._numIndices / 3;
            this._numTriangles = numTriangles;
            this.context3DBufferOwner.markBufferDirty(this._.index);
            this.dispatchEvent(new feng3d.GeometryComponentEvent(feng3d.GeometryComponentEvent.CHANGED_INDEX_DATA));
        };
        SubGeometry.prototype.fromVectors = function (vertices, uvs) {
            this.updateVertexPositionData(vertices);
            this.updateUVData(uvs);
        };
        /**
         * 应用变换矩阵
         * @param transform 变换矩阵
         */
        SubGeometry.prototype.applyTransformation = function (transform) {
            var vertices = this.vertexPositionData;
            var normals = this.vertexNormalData;
            var tangents = this.vertexTangentData;
            var posStride = this.vertexPositionStride;
            var normalStride = this.vertexNormalStride;
            var tangentStride = this.vertexTangentStride;
            var len = vertices.length / posStride;
            var i, i1, i2;
            var vector = new Vector3D();
            var bakeNormals = normals != null;
            var bakeTangents = tangents != null;
            var invTranspose;
            if (bakeNormals || bakeTangents) {
                invTranspose = transform.clone();
                invTranspose.invert();
                invTranspose.transpose();
            }
            var vi0 = 0;
            var ni0 = 0;
            var ti0 = 0;
            for (i = 0; i < len; ++i) {
                i1 = vi0 + 1;
                i2 = vi0 + 2;
                // bake position
                vector.x = vertices[vi0];
                vector.y = vertices[i1];
                vector.z = vertices[i2];
                vector = transform.transformVector(vector);
                vertices[vi0] = vector.x;
                vertices[i1] = vector.y;
                vertices[i2] = vector.z;
                vi0 += posStride;
                // bake normal
                if (bakeNormals) {
                    i1 = ni0 + 1;
                    i2 = ni0 + 2;
                    vector.x = normals[ni0];
                    vector.y = normals[i1];
                    vector.z = normals[i2];
                    vector = invTranspose.deltaTransformVector(vector);
                    vector.normalize();
                    normals[ni0] = vector.x;
                    normals[i1] = vector.y;
                    normals[i2] = vector.z;
                    ni0 += normalStride;
                }
                // bake tangent
                if (bakeTangents) {
                    i1 = ti0 + 1;
                    i2 = ti0 + 2;
                    vector.x = tangents[ti0];
                    vector.y = tangents[i1];
                    vector.z = tangents[i2];
                    vector = invTranspose.deltaTransformVector(vector);
                    vector.normalize();
                    tangents[ti0] = vector.x;
                    tangents[i1] = vector.y;
                    tangents[i2] = vector.z;
                    ti0 += tangentStride;
                }
            }
            this.context3DBufferOwner.markBufferDirty(this._.position_va_3);
            this.context3DBufferOwner.markBufferDirty(this._.normal_va_3);
            this.context3DBufferOwner.markBufferDirty(this._.tangent_va_3);
        };
        /**
         * 更新uv数据
         * @param data	uv数据
         */
        SubGeometry.prototype.updateUVData = function (data) {
            this.setVAData(this._.uv_va_2, data);
        };
        /**
         * 更新顶点数据
         */
        SubGeometry.prototype.updateVertexPositionData = function (data) {
            this.setVAData(this._.position_va_3, data);
            this.dispatchEvent(new feng3d.GeometryEvent(feng3d.GeometryEvent.SHAPE_CHANGE, this, true));
        };
        /**
         * 更新顶点法线数据
         * @param vertexNormals 顶点法线数据
         */
        SubGeometry.prototype.updateVertexNormalData = function (vertexNormals) {
            this.setVAData(this._.normal_va_3, vertexNormals);
        };
        /**
         * 更新顶点切线数据
         * @param vertexTangents 顶点切线数据
         */
        SubGeometry.prototype.updateVertexTangentData = function (vertexTangents) {
            this.setVAData(this._.tangent_va_3, vertexTangents);
        };
        Object.defineProperty(SubGeometry.prototype, "vertexPositionData", {
            /**
             * 顶点数据
             */
            get: function () {
                return getVAData(_.position_va_3);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SubGeometry.prototype, "vertexNormalData", {
            /**
             * 顶点法线数据
             */
            get: function () {
                return getVAData(_.normal_va_3);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SubGeometry.prototype, "vertexTangentData", {
            /**
             * 顶点切线数据
             */
            get: function () {
                return getVAData(_.tangent_va_3);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SubGeometry.prototype, "UVData", {
            /**
             * uv数据
             */
            get: function () {
                return getVAData(_.uv_va_2);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SubGeometry.prototype, "vertexPositionStride", {
            /**
             * 顶点坐标数据步长
             */
            get: function () {
                return getVALen(_.position_va_3);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SubGeometry.prototype, "vertexTangentStride", {
            /**
             * 顶点切线步长
             */
            get: function () {
                return getVALen(_.tangent_va_3);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SubGeometry.prototype, "vertexNormalStride", {
            /**
             * 顶点法线步长
             */
            get: function () {
                return getVALen(_.normal_va_3);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SubGeometry.prototype, "UVStride", {
            /**
             * UV步长
             */
            get: function () {
                return getVALen(_.uv_va_2);
            },
            enumerable: true,
            configurable: true
        });
        SubGeometry.prototype.notifyVADataChanged = function (dataTypeId) {
            _super.prototype.notifyVADataChanged.call(this, dataTypeId);
            this.dispatchEvent(new feng3d.GeometryComponentEvent(feng3d.GeometryComponentEvent.CHANGED_VA_DATA, dataTypeId));
        };
        SubGeometry.prototype.getVAData = function (dataTypeId) {
            this.dispatchEvent(new feng3d.GeometryComponentEvent(feng3d.GeometryComponentEvent.GET_VA_DATA, dataTypeId));
            return _super.prototype.getVAData.call(this, dataTypeId);
        };
        SubGeometry.prototype.clone = function () {
            var cls = getDefinitionByName(getQualifiedClassName(this));
            var _clone = new cls();
            //顶点属性编号列表
            var vaId;
            /** 顶点数据字典 */
            var sourceVertexDataDic = {};
            for (each(vaId in this.vaIdList); {
                sourceVertexDataDic: (_a = this.getVAData(vaId), vaId = _a[0], _a),
                assert: function (sourceVertexDataDic) { }
            }; 
            //添加索引数据
            _clone.updateIndexData(this.indices.concat()))
                ;
            //更改顶点数量
            _clone.numVertices = this.numVertices;
            //添加顶点数据
            for (each(vaId in this.vaIdList); {
                _clone: .setVAData(vaId, sourceVertexDataDic[vaId].concat())
            }; )
                return _clone;
            var _a;
        };
        Object.defineProperty(SubGeometry.prototype, "parent", {
            /**
             * 父网格
             */
            get: function () {
                return _parent;
            },
            set: function (value) {
                _parent = value;
            },
            enumerable: true,
            configurable: true
        });
        return SubGeometry;
    }(feng3d.VertexBufferOwner));
    feng3d.SubGeometry = SubGeometry;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 线段渲染数据缓存
     * @author feng 2014-5-9
     */
    var SegmentSubGeometry = (function (_super) {
        __extends(SegmentSubGeometry, _super);
        function SegmentSubGeometry() {
            _super.call(this);
        }
        SegmentSubGeometry.prototype.initBuffers = function () {
            _super.prototype.initBuffers.call(this);
            this.mapVABuffer(this._.segmentStart_va_3, 3);
            this.mapVABuffer(this._.segmentEnd_va_3, 3);
            this.mapVABuffer(this._.segmentThickness_va_1, 1);
            this.mapVABuffer(this._.segmentColor_va_4, 4);
        };
        Object.defineProperty(SegmentSubGeometry.prototype, "vertexPositionData", {
            get: function () {
                return pointData0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SegmentSubGeometry.prototype, "pointData0", {
            get: function () {
                var data = getVAData(_.segmentStart_va_3);
                return data;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SegmentSubGeometry.prototype, "pointData1", {
            get: function () {
                var data = getVAData(_.segmentEnd_va_3);
                return data;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SegmentSubGeometry.prototype, "thicknessData", {
            get: function () {
                var data = getVAData(_.segmentThickness_va_1);
                return data;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SegmentSubGeometry.prototype, "colorData", {
            get: function () {
                var data = getVAData(_.segmentColor_va_4);
                return data;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SegmentSubGeometry.prototype, "pointData0Stride", {
            get: function () {
                return 3;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SegmentSubGeometry.prototype, "pointData1Stride", {
            get: function () {
                return 3;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SegmentSubGeometry.prototype, "thicknessDataStride", {
            get: function () {
                return 1;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SegmentSubGeometry.prototype, "colorDataStride", {
            get: function () {
                return 4;
            },
            enumerable: true,
            configurable: true
        });
        SegmentSubGeometry.prototype.updatePointData0 = function (value) {
            this.setVAData(this._.segmentStart_va_3, value);
        };
        SegmentSubGeometry.prototype.updatePointData1 = function (value) {
            this.setVAData(this._.segmentEnd_va_3, value);
        };
        SegmentSubGeometry.prototype.updateThicknessData = function (value) {
            this.setVAData(this._.segmentThickness_va_1, value);
        };
        SegmentSubGeometry.prototype.updateColorData = function (value) {
            this.setVAData(this._.segmentColor_va_4, value);
        };
        return SegmentSubGeometry;
    }(feng3d.SubGeometry));
    feng3d.SegmentSubGeometry = SegmentSubGeometry;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 动画渲染参数
     * @author feng 2015-12-1
     */
    var AnimationShaderParams = (function (_super) {
        __extends(AnimationShaderParams, _super);
        /**
         * 动画渲染参数
         */
        function AnimationShaderParams() {
            _super.call(this);
        }
        AnimationShaderParams.prototype.init = function () {
            //
            this.numJoints = 0;
            this.animationType = feng3d.AnimationType.NONE;
            this.useUVAnimation = 0;
        };
        return AnimationShaderParams;
    }(feng3d.Component));
    feng3d.AnimationShaderParams = AnimationShaderParams;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 通用渲染参数
     * @author feng 2015-12-1
     */
    var CommonShaderParams = (function (_super) {
        __extends(CommonShaderParams, _super);
        /**
         * 通用渲染参数
         */
        function CommonShaderParams() {
            _super.call(this);
            this.alphaThreshold = 0;
        }
        /**
         * 初始化
         */
        CommonShaderParams.prototype.init = function () {
            this.hasDiffuseTexture = 0;
            this.needsUV = 0;
        };
        return CommonShaderParams;
    }(feng3d.Component));
    feng3d.CommonShaderParams = CommonShaderParams;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 环境渲染参数
     * @author feng 2015-12-1
     */
    var EnvShaderParams = (function (_super) {
        __extends(EnvShaderParams, _super);
        function EnvShaderParams() {
            _super.call(this);
        }
        return EnvShaderParams;
    }(feng3d.Component));
    feng3d.EnvShaderParams = EnvShaderParams;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 雾渲染参数
     * @author feng 2015-12-1
     */
    var FogShaderParams = (function (_super) {
        __extends(FogShaderParams, _super);
        /**
         * 雾渲染参数
         */
        function FogShaderParams() {
            _super.call(this);
        }
        /**
         * 初始化
         */
        FogShaderParams.prototype.init = function () {
            this.useFog = 0;
        };
        return FogShaderParams;
    }(feng3d.Component));
    feng3d.FogShaderParams = FogShaderParams;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 灯光渲染参数
     * @author feng 2015-12-1
     */
    var LightShaderParams = (function (_super) {
        __extends(LightShaderParams, _super);
        /**
         * 灯光渲染参数
         */
        function LightShaderParams() {
            _super.call(this);
            /** 是否使用灯光衰减 */
            this.useLightFallOff = true;
        }
        Object.defineProperty(LightShaderParams.prototype, "numDirectionalLights", {
            /** 方向光源数量 */
            get: function () {
                return _numDirectionalLights;
            },
            /**
             * @private
             */
            set: function (value) {
                _numDirectionalLights = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 初始化
         */
        LightShaderParams.prototype.init = function () {
            //
            this.numPointLights = 0;
            this.numDirectionalLights = 0;
            this.needsNormals = 0;
            this.needsViewDir = 0;
        };
        /**
         * 运行渲染程序前
         */
        LightShaderParams.prototype.preRun = function () {
            this.isFirstSpecLight = true;
            this.isFirstDiffLight = true;
        };
        Object.defineProperty(LightShaderParams.prototype, "numLights", {
            /** 灯光数量 */
            get: function () {
                return numPointLights + numDirectionalLights;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LightShaderParams.prototype, "needWorldPosition", {
            /** 是否需要世界坐标 */
            get: function () {
                return needsViewDir || numPointLights > 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LightShaderParams.prototype, "usesGlobalPosFragment", {
            /** 片段程序是否需要世界坐标 */
            get: function () {
                return numPointLights > 0;
            },
            enumerable: true,
            configurable: true
        });
        return LightShaderParams;
    }(feng3d.Component));
    feng3d.LightShaderParams = LightShaderParams;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 粒子渲染参数
     * @author feng 2015-12-1
     */
    var ParticleShaderParams = (function (_super) {
        __extends(ParticleShaderParams, _super);
        /**
         * 粒子渲染参数
         */
        function ParticleShaderParams() {
            _super.call(this);
        }
        /**
         * 初始化
         */
        ParticleShaderParams.prototype.init = function () {
            //
            this.changePosition = 0;
            this.changeColor = 0;
        };
        return ParticleShaderParams;
    }(feng3d.Component));
    feng3d.ParticleShaderParams = ParticleShaderParams;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 渲染参数
     * <p>? 是否需要限定组件为ShaderParamsComponent</p>
     * @author feng 2014-11-4
     */
    var ShaderParams = (function (_super) {
        __extends(ShaderParams, _super);
        /**
         * 创建一个渲染参数
         */
        function ShaderParams() {
            _super.call(this);
            this.addEventListener(feng3d.ComponentEvent.ADDED_COMPONET, this.onAddedComponet);
        }
        ShaderParams.prototype.onAddedComponet = function (event) {
            var shaderParam = event.data.child;
            if (shaderParam.hasOwnProperty("this.init")) {
                shaderParam["this.init"]();
            }
            if (shaderParam.hasOwnProperty("this.preRun")) {
                shaderParam["this.preRun"]();
            }
        };
        /**
         * 初始化渲染参数
         */
        ShaderParams.prototype.initParams = function () {
            this.init();
            for (each(); ; )
                var shaderParam;
             in components;
            {
                if (shaderParam.hasOwnProperty("this.init")) {
                    shaderParam["this.init"]();
                }
            }
        };
        /**
         * 渲染前初始化
         */
        ShaderParams.prototype.preRunParams = function () {
            this.preRun();
            for (each(); ; )
                var shaderParam;
             in components;
            {
                if (shaderParam.hasOwnProperty("this.preRun")) {
                    shaderParam["this.preRun"]();
                }
            }
        };
        /**
         * 初始化
         */
        ShaderParams.prototype.init = function () {
            this.sampleFlagsDic = {};
        };
        /**
         * 运行渲染程序前
         */
        ShaderParams.prototype.preRun = function () {
        };
        /**
         * 添加纹理取样参数
         * @param dataTypeId		纹理数据缓冲类型编号
         * @param texture			纹理代理
         * @param forceWrap			强制重复纹理参数
         */
        ShaderParams.prototype.addSampleFlags = function (dataTypeId, texture, forceWrap) {
            if (forceWrap === void 0) { forceWrap = null; }
            this.sampleFlagsDic[dataTypeId] = null;
            if (texture) {
                var flags = feng3d.TextureUtils.getFlags(this.useMipmapping, this.useSmoothTextures, this.repeatTextures, texture, forceWrap);
                this.sampleFlagsDic[dataTypeId] = flags;
            }
        };
        /**
         * 设置取样标记
         * @param dataTypeId		纹理数据缓冲类型编号
         * @param flags				纹理取样标记
         */
        ShaderParams.prototype.setSampleFlags = function (dataTypeId, flags) {
            this.sampleFlagsDic[dataTypeId] = flags;
        };
        /**
         * 获取取样标记
         * @param dataTypeId		纹理数据缓冲类型编号
         * @return					纹理取样标记
         */
        ShaderParams.prototype.getFlags = function (dataTypeId) {
            return this.sampleFlagsDic[dataTypeId];
        };
        return ShaderParams;
    }(feng3d.Component));
    feng3d.ShaderParams = ShaderParams;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 阴影渲染参数
     * @author feng 2015-12-1
     */
    var ShadowShaderParams = (function (_super) {
        __extends(ShadowShaderParams, _super);
        /**
         * 阴影渲染参数
         */
        function ShadowShaderParams() {
            _super.call(this);
        }
        /**
         * 初始化
         */
        ShadowShaderParams.prototype.init = function () {
            this.usingShadowMapMethod = 0;
            this.usePoint = 0;
            this.needsProjection = 0;
            this.useNearShadowMap = 0;
            this.needsShadowRegister = 0;
        };
        return ShadowShaderParams;
    }(feng3d.Component));
    feng3d.ShadowShaderParams = ShadowShaderParams;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 地形渲染参数
     * @author feng 2015-12-1
     */
    var TerrainShaderParams = (function (_super) {
        __extends(TerrainShaderParams, _super);
        /**
         * 地形渲染参数
         */
        function TerrainShaderParams() {
            _super.call(this);
        }
        /**
         * 初始化
         */
        TerrainShaderParams.prototype.init = function () {
            //
            this.splatNum = 0;
        };
        return TerrainShaderParams;
    }(feng3d.Component));
    feng3d.TerrainShaderParams = TerrainShaderParams;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 灯光采集器
     * @author feng 2014-9-11
     */
    var LightPickerBase = (function (_super) {
        __extends(LightPickerBase, _super);
        function LightPickerBase() {
            _super.call(this);
            this._namedAsset = new feng3d.NamedAsset(this, feng3d.AssetType.CONTAINER);
        }
        Object.defineProperty(LightPickerBase.prototype, "assetType", {
            get: function () {
                return feng3d.AssetType.LIGHT_PICKER;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LightPickerBase.prototype, "numDirectionalLights", {
            /**
             * 方向光数量
             */
            get: function () {
                return _numDirectionalLights;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LightPickerBase.prototype, "numPointLights", {
            /**
             * 点光源数量
             */
            get: function () {
                return _numPointLights;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LightPickerBase.prototype, "pointLights", {
            /**
             * 点光源列表
             */
            get: function () {
                return _pointLights;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LightPickerBase.prototype, "directionalLights", {
            /**
             * 方向光列表
             */
            get: function () {
                return _directionalLights;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LightPickerBase.prototype, "allPickedLights", {
            /**
             * A collection of all the collected lights.
             */
            get: function () {
                return _allPickedLights;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LightPickerBase.prototype, "namedAsset", {
            get: function () {
                return _namedAsset;
            },
            enumerable: true,
            configurable: true
        });
        return LightPickerBase;
    }(feng3d.Component));
    feng3d.LightPickerBase = LightPickerBase;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 灯光采集器
     * @author feng 2014-9-11
     */
    var StaticLightPicker = (function (_super) {
        __extends(StaticLightPicker, _super);
        function StaticLightPicker(lights) {
            this.lights = lights;
        }
        Object.defineProperty(StaticLightPicker.prototype, "lights", {
            /**
             * 需要渲染的灯光
             */
            get: function () {
                return _lights;
            },
            set: function (value) {
                var numPointLights = 0;
                var numDirectionalLights = 0;
                var light;
                _lights = value;
                _directionalLights = new feng3d.DirectionalLight[]();
                _pointLights = new feng3d.PointLight[]();
                //灯光分类
                var len = value.length;
                for (var i = 0; i < len; ++i) {
                    light = value[i];
                    if (light)
                        is;
                    feng3d.PointLight;
                    {
                        _pointLights[numPointLights++] = feng3d.PointLight(light);
                    }
                    if (light)
                        is;
                    feng3d.DirectionalLight;
                    {
                        _directionalLights[numDirectionalLights++] = feng3d.DirectionalLight(light);
                    }
                }
                _numDirectionalLights = numDirectionalLights;
                _numPointLights = numPointLights;
                dispatchEvent(new feng3d.Event(feng3d.Event.CHANGE));
            },
            enumerable: true,
            configurable: true
        });
        return StaticLightPicker;
    }(feng3d.LightPickerBase));
    feng3d.StaticLightPicker = StaticLightPicker;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 渲染函数设置
     * @author feng 2014-7-1
     */
    var ShaderMethodSetup = (function (_super) {
        __extends(ShaderMethodSetup, _super);
        /**
         * 创建一个渲染函数设置
         */
        function ShaderMethodSetup() {
            this.context3DBufferOwner = new feng3d.Context3DBufferOwner();
            this.initBuffers();
            this.uniqueMethodDic = {};
            this.methods = new feng3d.ShadingMethodBase[]();
            this.addMethod(new feng3d.BasicNormalMethod());
            this.addMethod(new feng3d.BasicAmbientMethod());
            this.addMethod(new feng3d.BasicDiffuseMethod());
            this.addMethod(new feng3d.BasicSpecularMethod());
        }
        /**
         * 初始化Context3d缓存
         */
        ShaderMethodSetup.prototype.initBuffers = function () {
        };
        Object.defineProperty(ShaderMethodSetup.prototype, "_", {
            /**
             * Fagal编号中心
             */
            get: function () {
                return FagalIdCenter.instance;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ShaderMethodSetup.prototype, "numMethods", {
            /**
             * The number of "effect" methods added to the material.
             */
            get: function () {
                return methods.length;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ShaderMethodSetup.prototype, "diffuseMethod", {
            /**
             * 漫反射函数
             */
            get: function () {
                return uniqueMethodDic[feng3d.BasicDiffuseMethod.METHOD_TYPE];
            },
            set: function (value) {
                addUniqueMethod(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ShaderMethodSetup.prototype, "specularMethod", {
            /**
             * 镜面反射函数
             */
            get: function () {
                return uniqueMethodDic[feng3d.BasicSpecularMethod.METHOD_TYPE];
            },
            set: function (value) {
                addUniqueMethod(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ShaderMethodSetup.prototype, "normalMethod", {
            /**
             * 法线函数
             */
            get: function () {
                return uniqueMethodDic[feng3d.BasicNormalMethod.METHOD_TYPE];
            },
            set: function (value) {
                addUniqueMethod(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ShaderMethodSetup.prototype, "ambientMethod", {
            /**
             * 漫反射函数
             */
            get: function () {
                return uniqueMethodDic[feng3d.BasicAmbientMethod.METHOD_TYPE];
            },
            set: function (value) {
                addUniqueMethod(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ShaderMethodSetup.prototype, "shadowMethod", {
            /**
             * 阴影映射函数
             */
            get: function () {
                return uniqueMethodDic[feng3d.ShadowMapMethodBase.METHOD_TYPE];
            },
            set: function (value) {
                addUniqueMethod(value);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 通知渲染程序失效
         */
        ShaderMethodSetup.prototype.invalidateShaderProgram = function () {
            this.dispatchEvent(new feng3d.ShadingMethodEvent(feng3d.ShadingMethodEvent.SHADER_INVALIDATED));
        };
        /**
         * 渲染程序失效事件处理函数
         */
        ShaderMethodSetup.prototype.onShaderInvalidated = function (event) {
            this.invalidateShaderProgram();
        };
        /**
         * 添加渲染函数
         * @param method			渲染函数
         */
        ShaderMethodSetup.prototype.addMethod = function (method) {
            if (method.typeUnique) {
                this.addUniqueMethod(method);
            }
            else {
                this.$addMethod(method);
            }
        };
        /**
         * 移除渲染函数
         * @param method			渲染函数
         */
        ShaderMethodSetup.prototype.removeMethod = function (method) {
            if (method.typeUnique) {
                this.removeUniqueMethod(method);
            }
            else {
                this.$removeMethod(method);
            }
        };
        /**
         * 添加唯一渲染函数
         * @param method			渲染函数
         */
        ShaderMethodSetup.prototype.addUniqueMethod = function (method) {
            var oldMethod = this.uniqueMethodDic[method.methodType];
            if (oldMethod != null) {
                method.copyFrom(oldMethod);
                this.$removeMethod(oldMethod);
            }
            this.$addMethod(method);
            this.uniqueMethodDic[method.methodType] = method;
            this.invalidateShaderProgram();
        };
        /**
         * 移除唯一渲染函数
         * @param method			渲染函数
         */
        ShaderMethodSetup.prototype.removeUniqueMethod = function (method) {
            this.$removeMethod(method);
            this.uniqueMethodDic[method.methodType] = null;
        };
        /**
         * 添加函数
         * @param method			渲染函数
         */
        ShaderMethodSetup.prototype.$addMethod = function (method) {
            method.addEventListener(feng3d.ShadingMethodEvent.SHADER_INVALIDATED, this.onShaderInvalidated);
            this.context3DBufferOwner.addChildBufferOwner(method.context3DBufferOwner);
            this.methods.push(method);
            this.invalidateShaderProgram();
        };
        /**
         * 删除函数
         * @param method			渲染函数
         */
        ShaderMethodSetup.prototype.$removeMethod = function (method) {
            method.removeEventListener(feng3d.ShadingMethodEvent.SHADER_INVALIDATED, this.onShaderInvalidated);
            this.context3DBufferOwner.removeChildBufferOwner(method.context3DBufferOwner);
            var index = this.methods.indexOf(method);
            this.methods.splice(index, 1);
            this.invalidateShaderProgram();
        };
        /**
         * 设置渲染状态
         * @param renderable		可渲染对象
         * @param stage3DProxy		3D舞台代理
         * @param camera			摄像机
         */
        ShaderMethodSetup.prototype.setRenderState = function (renderable, camera) {
            for (var i = 0; i < this.methods.length; i++) {
                this.methods[i].setRenderState(renderable, camera);
            }
        };
        /**
         * 激活
         * @param shaderParams		渲染参数
         * @param stage3DProxy		3D舞台代理
         */
        ShaderMethodSetup.prototype.activate = function (shaderParams) {
            for (var i = 0; i < this.methods.length; i++) {
                this.methods[i].activate(shaderParams);
            }
        };
        /**
         * 初始化常量数据
         */
        ShaderMethodSetup.prototype.initConstants = function () {
            for (var i = 0; i < this.methods.length; i++) {
                this.methods[i].initConstants();
            }
        };
        return ShaderMethodSetup;
    }(feng3d.Component));
    feng3d.ShaderMethodSetup = ShaderMethodSetup;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 渲染函数基类
     * @author feng 2014-7-1
     */
    var ShadingMethodBase = (function (_super) {
        __extends(ShadingMethodBase, _super);
        /**
         * 创建渲染寄函数基类
         */
        function ShadingMethodBase() {
            _super.call(this);
            /**
             * 是否唯一
             * <p>值为true时一个pass只能包含一个该类型函数，否则允许多个</p>
             * @see #methodType
             */
            this.typeUnique = false;
            this.context3DBufferOwner = new feng3d.Context3DBufferOwner();
            this.initBuffers();
        }
        /**
         * 初始化Context3d缓存
         */
        ShadingMethodBase.prototype.initBuffers = function () {
        };
        Object.defineProperty(ShadingMethodBase.prototype, "_", {
            /**
             * Fagal编号中心
             */
            get: function () {
                return FagalIdCenter.instance;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 激活渲染函数
         * @param shaderParams 		渲染参数
         */
        ShadingMethodBase.prototype.activate = function (shaderParams) {
        };
        /**
         * 设置渲染状态
         * @param renderable 		渲染对象
         * @param camera 			摄像机
         */
        ShadingMethodBase.prototype.setRenderState = function (renderable, camera) {
        };
        /**
         * 初始化常量数据
         */
        ShadingMethodBase.prototype.initConstants = function () {
        };
        /**
         * 清除编译数据
         */
        ShadingMethodBase.prototype.cleanCompilationData = function () {
        };
        /**
         * 使渲染程序失效
         */
        ShadingMethodBase.prototype.invalidateShaderProgram = function () {
            this.dispatchEvent(new feng3d.ShadingMethodEvent(feng3d.ShadingMethodEvent.SHADER_INVALIDATED));
        };
        /**
         * 拷贝渲染方法
         * @param method		被拷贝的方法
         */
        ShadingMethodBase.prototype.copyFrom = function (method) {
        };
        Object.defineProperty(ShadingMethodBase.prototype, "passes", {
            /**
             * Any passes required that render to a texture used by this method.
             */
            get: function () {
                return _passes;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Cleans up any resources used by the current object.
         */
        ShadingMethodBase.prototype.dispose = function () {
        };
        return ShadingMethodBase;
    }(feng3d.Component));
    feng3d.ShadingMethodBase = ShadingMethodBase;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 环境光函数
     *
     * 参考《3d数学基础：图形与游戏开发》337页，15.4.6 环境光分量
     * Camb = Gamb X Mamb
     * Camb：环境光分量。
     * Gamb：整个场景的环境光值。
     * Mamb：材质的环境光分量。它总是等于漫反射分量——由纹理图定义。
     *
     * @author feng 2014-7-1
     */
    var BasicAmbientMethod = (function (_super) {
        __extends(BasicAmbientMethod, _super);
        /**
         * 创建一个基础环境光函数
         */
        function BasicAmbientMethod() {
            this._ambientColor = 0xffffff;
            this._ambient = 1;
            this._lightAmbientR = 0;
            this._lightAmbientG = 0;
            this._lightAmbientB = 0;
            /** 环境光分量数据 */
            this.ambientColorData = new number[](4);
            this.methodType = METHOD_TYPE;
            this.typeUnique = true;
        }
        /**
         * @inheritDoc
         */
        BasicAmbientMethod.prototype.initBuffers = function () {
            _super.prototype.initBuffers.call(this);
            this.context3DBufferOwner.mapContext3DBuffer(this._.ambientColor_fc_vector, this.updateAmbientInputBuffer);
            this.context3DBufferOwner.mapContext3DBuffer(this._.ambientTexture_fs, this.updateSpecularTextureBuffer);
        };
        BasicAmbientMethod.prototype.updateAmbientInputBuffer = function (ambientInputBuffer) {
            ambientInputBuffer.update(this.ambientColorData);
        };
        BasicAmbientMethod.prototype.updateSpecularTextureBuffer = function (fsBuffer) {
            fsBuffer.update(this.texture);
        };
        /**
         * 更新环境光数据
         */
        BasicAmbientMethod.prototype.updateAmbient = function () {
            this.ambientColorData[0] = ((this._ambientColor >> 16) & 0xff) / 0xff * this._ambient * this._lightAmbientR;
            this.ambientColorData[1] = ((this._ambientColor >> 8) & 0xff) / 0xff * this._ambient * this._lightAmbientG;
            this.ambientColorData[2] = (this._ambientColor & 0xff) / 0xff * this._ambient * this._lightAmbientB;
            this.ambientColorData[3] = 1;
        };
        /**
         * @inheritDoc
         */
        BasicAmbientMethod.prototype.setRenderState = function (renderable, camera) {
            this.updateAmbient();
        };
        Object.defineProperty(BasicAmbientMethod.prototype, "ambient", {
            /**
             * 环境光强
             */
            get: function () {
                return _ambient;
            },
            set: function (value) {
                _ambient = value;
                updateAmbient();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BasicAmbientMethod.prototype, "ambientColor", {
            /**
             * 环境光颜色
             */
            get: function () {
                return _ambientColor;
            },
            set: function (value) {
                _ambientColor = value;
                updateAmbient();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BasicAmbientMethod.prototype, "texture", {
            /**
             * The bitmapData to use to define the diffuse reflection color per texel.
             */
            get: function () {
                return _texture;
            },
            set: function (value) {
                if (boolean(value) != _useTexture || (value && _texture && (value.hasMipMaps != _texture.hasMipMaps || value.format != _texture.format))) {
                    invalidateShaderProgram();
                }
                _useTexture = boolean(value);
                _texture = value;
                context3DBufferOwner.markBufferDirty(_.ambientTexture_fs);
            },
            enumerable: true,
            configurable: true
        });
        BasicAmbientMethod.prototype.activate = function (shaderParams) {
            if (this.texture != null) {
                var commonShaderParams = shaderParams.getOrCreateComponentByClass(feng3d.CommonShaderParams);
                commonShaderParams.needsUV++;
                commonShaderParams.useAmbientTexture++;
                shaderParams.addSampleFlags(this._.ambientTexture_fs, this.texture);
            }
        };
        BasicAmbientMethod.prototype.copyFrom = function (method) {
            var diff = BasicAmbientMethod(method);
            this.ambient = diff.ambient;
            this.ambientColor = diff.ambientColor;
        };
        BasicAmbientMethod.METHOD_TYPE = "AmbientMethod";
        return BasicAmbientMethod;
    }(feng3d.ShadingMethodBase));
    feng3d.BasicAmbientMethod = BasicAmbientMethod;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 基础法线函数
     * @author feng 2014-7-16
     */
    var BasicNormalMethod = (function (_super) {
        __extends(BasicNormalMethod, _super);
        /**
         * 创建一个基础法线函数
         */
        function BasicNormalMethod() {
            this.methodType = METHOD_TYPE;
            this.typeUnique = true;
        }
        /**
         * @inheritDoc
         */
        BasicNormalMethod.prototype.initBuffers = function () {
            _super.prototype.initBuffers.call(this);
            this.context3DBufferOwner.mapContext3DBuffer(this._.normalTexture_fs, this.updateNormalTextureBuffer);
        };
        BasicNormalMethod.prototype.updateNormalTextureBuffer = function (normalTextureBuffer) {
            normalTextureBuffer.update(this._texture);
        };
        Object.defineProperty(BasicNormalMethod.prototype, "normalMap", {
            /**
             * The texture containing the normals per pixel.
             */
            get: function () {
                return _texture;
            },
            set: function (value) {
                if (boolean(value) != boolean(_texture) ||
                    (value && _texture && (value.hasMipMaps != _texture.hasMipMaps || value.format != _texture.format))) {
                    invalidateShaderProgram();
                }
                _texture = value;
                context3DBufferOwner.markBufferDirty(_.normalTexture_fs);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BasicNormalMethod.prototype, "hasOutput", {
            /**
             * Indicates if the normal method output is not based on a texture (if not, it will usually always return true)
             * Override if subclasses are different.
             */
            get: function () {
                return boolean(_texture);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        BasicNormalMethod.prototype.copyFrom = function (method) {
            this.normalMap = BasicNormalMethod(method).normalMap;
        };
        BasicNormalMethod.prototype.activate = function (shaderParams) {
            var lightShaderParams = shaderParams.getOrCreateComponentByClass(feng3d.LightShaderParams);
            lightShaderParams.hasNormalTexture = this._texture != null;
            shaderParams.addSampleFlags(this._.normalTexture_fs, this._texture);
        };
        BasicNormalMethod.METHOD_TYPE = "NormalMethod";
        return BasicNormalMethod;
    }(feng3d.ShadingMethodBase));
    feng3d.BasicNormalMethod = BasicNormalMethod;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 特效函数基类
     * @author feng 2015-8-27
     */
    var EffectMethodBase = (function (_super) {
        __extends(EffectMethodBase, _super);
        /**
         * 创建特效函数基类实例
         */
        function EffectMethodBase() {
            _super.call(this);
            this._namedAsset = new feng3d.NamedAsset(this, feng3d.AssetType.EFFECTS_METHOD);
        }
        Object.defineProperty(EffectMethodBase.prototype, "namedAsset", {
            get: function () {
                return _namedAsset;
            },
            enumerable: true,
            configurable: true
        });
        return EffectMethodBase;
    }(feng3d.ShadingMethodBase));
    feng3d.EffectMethodBase = EffectMethodBase;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 环境映射函数
     * @author feng 2015-8-27
     */
    var EnvMapMethod = (function (_super) {
        __extends(EnvMapMethod, _super);
        /**
         * 创建EnvMapMethod实例
         * @param envMap		环境映射贴图
         * @param alpha			反射率
         */
        function EnvMapMethod(envMap, alpha) {
            if (alpha === void 0) { alpha = 1; }
            _super.call(this);
            this._envMapData = number[]([1, 0, 0, 0]);
            /**
             * @inheritDoc
             */
            this.override = function activate(shaderParams) {
                var commonShaderParams = shaderParams.getOrCreateComponentByClass(feng3d.CommonShaderParams);
                commonShaderParams.needsUV += this._mask != null;
                var lightShaderParams = shaderParams.getOrCreateComponentByClass(feng3d.LightShaderParams);
                lightShaderParams.needsNormals++;
                lightShaderParams.needsViewDir++;
                //			shaderParams.needsView = true;
                var envShaderParams = shaderParams.getOrCreateComponentByClass(feng3d.EnvShaderParams);
                envShaderParams.useEnvMapMethod++;
                envShaderParams.useEnvMapMask += this._mask != null;
                shaderParams.addSampleFlags(this._.envMapcubeTexture_fs, this._cubeTexture);
                shaderParams.addSampleFlags(this._.envMapMaskTexture_fs, this._mask);
                //			var context:Context3D = stage3DProxy._context3D;
                //			vo.fragmentData[vo.fragmentConstantsIndex] = this._alpha;
                //			context.setTextureAt(vo.texturesIndex, this._cubeTexture.getTextureForStage3D(stage3DProxy));
                //			if (this._mask)
                //				context.setTextureAt(vo.texturesIndex + 1, this._mask.getTextureForStage3D(stage3DProxy));
            };
            this._cubeTexture = envMap;
            this.alpha = alpha;
        }
        Object.defineProperty(EnvMapMethod.prototype, "mask", {
            /**
             * 用来调节反射率的纹理
             */
            get: function () {
                return _mask;
            },
            set: function (value) {
                if (boolean(value) != boolean(_mask) || (value && _mask && (value.hasMipMaps != _mask.hasMipMaps || value.format != _mask.format))) {
                    invalidateShaderProgram();
                }
                _mask = value;
                context3DBufferOwner.markBufferDirty(_.envMapMaskTexture_fs);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EnvMapMethod.prototype, "envMap", {
            /**
             * 环境映射贴图
             */
            get: function () {
                return _cubeTexture;
            },
            set: function (value) {
                _cubeTexture = value;
                context3DBufferOwner.markBufferDirty(_.envMapcubeTexture_fs);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EnvMapMethod.prototype, "alpha", {
            /**
             * 反射率
             */
            get: function () {
                return _alpha;
            },
            set: function (value) {
                _alpha = value;
                _envMapData[0] = _alpha;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        EnvMapMethod.prototype.initBuffers = function () {
            _super.prototype.initBuffers.call(this);
            this.context3DBufferOwner.mapContext3DBuffer(this._.envMapcubeTexture_fs, this.updateCubeTextureBuffer);
            this.context3DBufferOwner.mapContext3DBuffer(this._.envMapMaskTexture_fs, this.updateMaskTextureBuffer);
            this.context3DBufferOwner.mapContext3DBuffer(this._.envMapData_fc_vector, this.updateDataBuffer);
        };
        EnvMapMethod.prototype.updateCubeTextureBuffer = function (fsBuffer) {
            fsBuffer.update(this._cubeTexture);
        };
        EnvMapMethod.prototype.updateMaskTextureBuffer = function (fsBuffer) {
            fsBuffer.update(this._mask);
        };
        EnvMapMethod.prototype.updateDataBuffer = function (fcVectorBuffer) {
            fcVectorBuffer.update(this._envMapData);
        };
        return EnvMapMethod;
    }(feng3d.EffectMethodBase));
    feng3d.EnvMapMethod = EnvMapMethod;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 雾函数
     * @author feng 2015-8-27
     */
    var FogMethod = (function (_super) {
        __extends(FogMethod, _super);
        /**
         * 创建FogMethod实例
         * @param minDistance			出现雾效果的最近距离
         * @param maxDistance			最远距离
         * @param fogColor				雾的颜色
         */
        function FogMethod(minDistance, maxDistance, fogColor) {
            if (fogColor === void 0) { fogColor = 0x808080; }
            _super.call(this);
            this._minDistance = 0;
            this._maxDistance = 1000;
            /**
             * 雾颜色常量数据
             */
            this.fogColorData = number[]([0, 0, 0, 1]);
            /**
             * 雾通用常量数据
             */
            this.fogCommonData = number[]([0, 0, 0, 0]);
            /**
             * @inheritDoc
             */
            this.override = function activate(shaderParams) {
                this.fogCommonData[0] = this._minDistance;
                this.fogCommonData[1] = 1 / (this._maxDistance - this._minDistance);
                var fogShaderParams = shaderParams.getOrCreateComponentByClass(feng3d.FogShaderParams);
                fogShaderParams.useFog++;
                var shadowShaderParams = shaderParams.getOrCreateComponentByClass(feng3d.ShadowShaderParams);
                shadowShaderParams.needsProjection++;
            };
            this.minDistance = minDistance;
            this.maxDistance = maxDistance;
            this.fogColor = fogColor;
        }
        Object.defineProperty(FogMethod.prototype, "minDistance", {
            /**
             * 出现雾效果的最近距离
             */
            get: function () {
                return _minDistance;
            },
            set: function (value) {
                _minDistance = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FogMethod.prototype, "maxDistance", {
            /**
             * 最远距离
             */
            get: function () {
                return _maxDistance;
            },
            set: function (value) {
                _maxDistance = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FogMethod.prototype, "fogColor", {
            /**
             * 雾的颜色
             */
            get: function () {
                return _fogColor;
            },
            set: function (value) {
                _fogColor = value;
                fogColorData[0] = ((value >> 16) & 0xff) / 0xff;
                fogColorData[1] = ((value >> 8) & 0xff) / 0xff;
                fogColorData[2] = (value & 0xff) / 0xff;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        FogMethod.prototype.initBuffers = function () {
            _super.prototype.initBuffers.call(this);
            this.context3DBufferOwner.mapContext3DBuffer(this._.fogColor_fc_vector, this.updateFogColorBuffer);
            this.context3DBufferOwner.mapContext3DBuffer(this._.fogCommonData_fc_vector, this.updateFogCommonDataBuffer);
        };
        /**
         * 更新雾颜色常量数据
         */
        FogMethod.prototype.updateFogColorBuffer = function (fcVectorBuffer) {
            fcVectorBuffer.update(this.fogColorData);
        };
        /**
         * 更新雾通用常量数据
         */
        FogMethod.prototype.updateFogCommonDataBuffer = function (fcVectorBuffer) {
            fcVectorBuffer.update(this.fogCommonData);
        };
        return FogMethod;
    }(feng3d.EffectMethodBase));
    feng3d.FogMethod = FogMethod;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 灯光函数
     * @author feng 2014-7-1
     */
    var LightingMethodBase = (function (_super) {
        __extends(LightingMethodBase, _super);
        function LightingMethodBase() {
            _super.apply(this, arguments);
        }
        return LightingMethodBase;
    }(feng3d.ShadingMethodBase));
    feng3d.LightingMethodBase = LightingMethodBase;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    _DiffusePostLighting;
    /**
     * 基础漫反射函数
     * @author feng 2014-7-1
     */
    var BasicDiffuseMethod = (function (_super) {
        __extends(BasicDiffuseMethod, _super);
        /**
         * 创建一个基础漫反射函数
         */
        function BasicDiffuseMethod() {
            this._diffuseColor = 0xffffff;
            /** 漫反射颜色数据RGBA */
            this.diffuseInputData = new number[](4);
            this.alphaThresholdData = number[]([0, 0, 0, 0]);
            this._alphaThreshold = 0;
            this.methodType = METHOD_TYPE;
            this.typeUnique = true;
        }
        /**
         * @inheritDoc
         */
        BasicDiffuseMethod.prototype.initBuffers = function () {
            _super.prototype.initBuffers.call(this);
            this.context3DBufferOwner.mapContext3DBuffer(this._.texture_fs, this.updateTextureBuffer);
            this.context3DBufferOwner.mapContext3DBuffer(this._.diffuseInput_fc_vector, this.updateDiffuseInputBuffer);
            this.context3DBufferOwner.mapContext3DBuffer(this._.alphaThreshold_fc_vector, this.updateAlphaThresholdBuffer);
        };
        Object.defineProperty(BasicDiffuseMethod.prototype, "diffuseColor", {
            /** 漫反射颜色 */
            get: function () {
                return _diffuseColor;
            },
            set: function (diffuseColor) {
                _diffuseColor = diffuseColor;
                updateDiffuse();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 更新漫反射值
         */
        BasicDiffuseMethod.prototype.updateDiffuse = function () {
            this.diffuseInputData[0] = ((this._diffuseColor >> 16) & 0xff) / 0xff;
            this.diffuseInputData[1] = ((this._diffuseColor >> 8) & 0xff) / 0xff;
            this.diffuseInputData[2] = (this._diffuseColor & 0xff) / 0xff;
        };
        Object.defineProperty(BasicDiffuseMethod.prototype, "diffuseAlpha", {
            /** 漫反射alpha */
            get: function () {
                return diffuseInputData[3];
            },
            set: function (value) {
                diffuseInputData[3] = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 更新纹理缓冲
         */
        BasicDiffuseMethod.prototype.updateTextureBuffer = function (textureBuffer) {
            textureBuffer.update(this.texture);
        };
        /**
         * 更新漫反射输入片段常量缓冲
         */
        BasicDiffuseMethod.prototype.updateDiffuseInputBuffer = function (diffuseInputBuffer) {
            diffuseInputBuffer.update(this.diffuseInputData);
        };
        BasicDiffuseMethod.prototype.updateAlphaThresholdBuffer = function (fcVectorBuffer) {
            fcVectorBuffer.update(this.alphaThresholdData);
        };
        Object.defineProperty(BasicDiffuseMethod.prototype, "texture", {
            /**
             * 漫反射纹理
             */
            get: function () {
                return _texture;
            },
            set: function (value) {
                if (boolean(value) != boolean(_texture) || (value && _texture && (value.hasMipMaps != _texture.hasMipMaps || value.format != _texture.format))) {
                    invalidateShaderProgram();
                }
                _texture = value;
                context3DBufferOwner.markBufferDirty(_.texture_fs);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BasicDiffuseMethod.prototype, "alphaThreshold", {
            /**
             * The minimum alpha value for which pixels should be drawn. This is used for transparency that is either
             * invisible or entirely opaque, often used with textures for foliage, etc.
             * Recommended values are 0 to disable alpha, or 0.5 to create smooth edges. Default value is 0 (disabled).
             */
            get: function () {
                return _alphaThreshold;
            },
            set: function (value) {
                if (value < 0)
                    value = 0;
                else if (value > 1)
                    value = 1;
                if (value == _alphaThreshold)
                    return;
                if (value == 0 || _alphaThreshold == 0)
                    invalidateShaderProgram();
                _alphaThreshold = value;
                alphaThresholdData[0] = _alphaThreshold;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        BasicDiffuseMethod.prototype.activate = function (shaderParams) {
            var commonShaderParams = shaderParams.getOrCreateComponentByClass(feng3d.CommonShaderParams);
            if (this.texture != null) {
                commonShaderParams.needsUV++;
                commonShaderParams.hasDiffuseTexture++;
                shaderParams.addSampleFlags(this._.texture_fs, this.texture);
            }
            commonShaderParams.usingDiffuseMethod += 1;
            commonShaderParams.alphaThreshold = this._alphaThreshold;
            shaderParams.diffuseModulateMethod = this._modulateMethod;
            var lightShaderParams = shaderParams.getOrCreateComponentByClass(feng3d.LightShaderParams);
            lightShaderParams.needsNormals += lightShaderParams.numLights > 0 ? 1 : 0;
            lightShaderParams.diffuseMethod = F_DiffusePostLighting;
        };
        /**
         * @inheritDoc
         */
        BasicDiffuseMethod.prototype.copyFrom = function (method) {
            var diff = BasicDiffuseMethod(method);
            this.texture = diff.texture;
            this.diffuseAlpha = diff.diffuseAlpha;
            this.diffuseColor = diff.diffuseColor;
        };
        BasicDiffuseMethod.METHOD_TYPE = "DiffuseMethod";
        return BasicDiffuseMethod;
    }(feng3d.LightingMethodBase));
    feng3d.BasicDiffuseMethod = BasicDiffuseMethod;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * CompositeDiffuseMethod provides a base class for diffuse methods that wrap a diffuse method to alter the
     * calculated diffuse reflection strength.
     */
    var CompositeDiffuseMethod = (function (_super) {
        __extends(CompositeDiffuseMethod, _super);
        /**
         * Creates a new WrapDiffuseMethod object.
         * @param modulateMethod The method which will add the code to alter the base method's strength. It needs to have the signature clampDiffuse(t : ShaderRegisterElement, regCache : ShaderRegisterCache) :string, in which t.w will contain the diffuse strength.
         * @param baseDiffuseMethod The base diffuse method on which this method's shading is based.
         */
        function CompositeDiffuseMethod(modulateMethod, baseDiffuseMethod) {
            if (modulateMethod === void 0) { modulateMethod = null; }
            if (baseDiffuseMethod === void 0) { baseDiffuseMethod = null; }
            /**
             * @inheritDoc
             */
            this.override = function cleanCompilationData() {
                _super.cleanCompilationData.call(this);
                this._baseMethod.cleanCompilationData();
            };
            this._baseMethod = baseDiffuseMethod || new feng3d.BasicDiffuseMethod();
            this._baseMethod._modulateMethod = modulateMethod;
            this._baseMethod.addEventListener(feng3d.ShadingMethodEvent.SHADER_INVALIDATED, this.onShaderInvalidated);
        }
        Object.defineProperty(CompositeDiffuseMethod.prototype, "baseMethod", {
            /**
             * The base diffuse method on which this method's shading is based.
             */
            get: function () {
                return _baseMethod;
            },
            set: function (value) {
                if (_baseMethod == value)
                    return;
                _baseMethod.removeEventListener(feng3d.ShadingMethodEvent.SHADER_INVALIDATED, onShaderInvalidated);
                _baseMethod = value;
                _baseMethod.addEventListener(feng3d.ShadingMethodEvent.SHADER_INVALIDATED, onShaderInvalidated, false, 0, true);
                invalidateShaderProgram();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        CompositeDiffuseMethod.prototype.dispose = function () {
            this._baseMethod.removeEventListener(feng3d.ShadingMethodEvent.SHADER_INVALIDATED, this.onShaderInvalidated);
            this._baseMethod.dispose();
        };
        Object.defineProperty(CompositeDiffuseMethod.prototype, "alphaThreshold", {
            /**
             * @inheritDoc
             */
            get: function () {
                return _baseMethod.alphaThreshold;
            },
            set: function (value) {
                _baseMethod.alphaThreshold = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CompositeDiffuseMethod.prototype, "texture", {
            /**
             * @inheritDoc
             */
            get: function () {
                return _baseMethod.texture;
            },
            /**
             * @inheritDoc
             */
            set: function (value) {
                _baseMethod.texture = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CompositeDiffuseMethod.prototype, "diffuseAlpha", {
            /**
             * @inheritDoc
             */
            get: function () {
                return _baseMethod.diffuseAlpha;
            },
            /**
             * @inheritDoc
             */
            set: function (value) {
                _baseMethod.diffuseAlpha = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CompositeDiffuseMethod.prototype, "diffuseColor", {
            /**
             * @inheritDoc
             */
            get: function () {
                return _baseMethod.diffuseColor;
            },
            /**
             * @inheritDoc
             */
            set: function (diffuseColor) {
                _baseMethod.diffuseColor = diffuseColor;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        CompositeDiffuseMethod.prototype.activate = function (shaderParams) {
            this._baseMethod.activate(shaderParams);
        };
        /**
         * Called when the base method's shader code is invalidated.
         */
        CompositeDiffuseMethod.prototype.onShaderInvalidated = function (event) {
            invalidateShaderProgram();
        };
        return CompositeDiffuseMethod;
    }(feng3d.BasicDiffuseMethod));
    feng3d.CompositeDiffuseMethod = CompositeDiffuseMethod;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * SubsurfaceScatteringDiffuseMethod provides a depth map-based diffuse shading method that mimics the scattering of
     * light inside translucent surfaces. It allows light to shine through an object and to soften the diffuse shading.
     * It can be used for candle wax, ice, skin, ...
     */
    var SubsurfaceScatteringDiffuseMethod = (function (_super) {
        __extends(SubsurfaceScatteringDiffuseMethod, _super);
        /**
         * Creates a new SubsurfaceScatteringDiffuseMethod object.
         * @param depthMapSize The size of the depth map used.
         * @param depthMapOffset The amount by which the rendered object will be inflated, to prevent depth map rounding errors.
         */
        function SubsurfaceScatteringDiffuseMethod(depthMapSize, depthMapOffset) {
            if (depthMapSize === void 0) { depthMapSize = 512; }
            if (depthMapOffset === void 0) { depthMapOffset = 15; }
            _super.call(this, this.scatterLight);
            this._translucency = 1;
            this._scatterColor = 0xffffff;
            this._scatterR = 1.0;
            this._scatterG = 1.0;
            this._scatterB = 1.0;
            this.vertexToTexData = number[]([0.5, -0.5, 0, 1]);
            this.f$ColorData = number[]([1.0, 1.0, 1.0, 1.0]);
            this.fragmentData0 = number[]([1.0, 1.0 / 255, 1.0 / 65025, 1.0 / 16581375]);
            this.fragmentData1 = number[]([0.2, 1, 0.5, -0.1]);
            this.lightProjection = new Matrix3D();
            this.override = function cleanCompilationData() {
                _super.cleanCompilationData.call(this);
                this._propReg = null;
                this._lightColorReg = null;
                this._decReg = null;
                this._targetReg = null;
            };
            /**
             * @inheritDoc
             */
            this.override = function activate(shaderParams) {
                _super.activate.call(this, shaderParams);
                this.f$ColorData[0] = this._scatterR;
                this.f$ColorData[1] = this._scatterG;
                this.f$ColorData[2] = this._scatterB;
                this.fragmentData1[0] = this._scattering;
                this.fragmentData1[1] = this._translucency;
            };
            /**
             * @inheritDoc
             */
            this.override = function setRenderState(renderable, camera) {
                this.depthMap = this._depthPass.getDepthMap(renderable);
                var projection = this._depthPass.getProjection(renderable);
                this.lightProjection.copyFrom(projection);
            };
            _passes = new feng3d.MaterialPassBase[]();
            this._depthPass = new feng3d.SingleObjectDepthPass(depthMapSize, depthMapOffset);
            _passes.push(this._depthPass);
            this._scattering = 0.2;
            this._translucency = 1;
        }
        Object.defineProperty(SubsurfaceScatteringDiffuseMethod.prototype, "depthMap", {
            get: function () {
                return _depthMap;
            },
            set: function (value) {
                if (_depthMap != value) {
                    _depthMap = value;
                    context3DBufferOwner.markBufferDirty(_.SSD$depthMap_fs);
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        SubsurfaceScatteringDiffuseMethod.prototype.initBuffers = function () {
            _super.prototype.initBuffers.call(this);
            this.context3DBufferOwner.mapContext3DBuffer(this._.SSD$ToTex_vc_vector, this.SSD$ToTexBuffer);
            this.context3DBufferOwner.mapContext3DBuffer(this._.SSD$f$ColorData_vc_vector, this.f$ColorDataBuffer);
            this.context3DBufferOwner.mapContext3DBuffer(this._.SSD$fragmentData0_vc_vector, this.fragmentData0Buffer);
            this.context3DBufferOwner.mapContext3DBuffer(this._.SSD$fragmentData1_vc_vector, this.fragmentData1Buffer);
            this.context3DBufferOwner.mapContext3DBuffer(this._.SSD$depthMap_fs, this.updateDepthMapBuffer);
            this.context3DBufferOwner.mapContext3DBuffer(this._.SSD$LightProjection_vc_matrix, this.updateLightProjectionBuffer);
        };
        SubsurfaceScatteringDiffuseMethod.prototype.SSD$ToTexBuffer = function (vcVectorBuffer) {
            vcVectorBuffer.update(this.vertexToTexData);
        };
        SubsurfaceScatteringDiffuseMethod.prototype.f$ColorDataBuffer = function (fcVectorBuffer) {
            fcVectorBuffer.update(this.f$ColorData);
        };
        SubsurfaceScatteringDiffuseMethod.prototype.fragmentData0Buffer = function (fcVectorBuffer) {
            fcVectorBuffer.update(this.fragmentData0);
        };
        SubsurfaceScatteringDiffuseMethod.prototype.fragmentData1Buffer = function (fcVectorBuffer) {
            fcVectorBuffer.update(this.fragmentData1);
        };
        SubsurfaceScatteringDiffuseMethod.prototype.updateDepthMapBuffer = function (textureBuffer) {
            textureBuffer.update(this.depthMap);
        };
        SubsurfaceScatteringDiffuseMethod.prototype.updateLightProjectionBuffer = function (vcMatrixBuffer) {
            vcMatrixBuffer.update(this.lightProjection, true);
        };
        Object.defineProperty(SubsurfaceScatteringDiffuseMethod.prototype, "scattering", {
            /**
             * The amount by which the light scatters. It can be used to set the translucent surface's thickness. Use low
             * values for skin.
             */
            get: function () {
                return _scattering;
            },
            set: function (value) {
                _scattering = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SubsurfaceScatteringDiffuseMethod.prototype, "translucency", {
            /**
             * The translucency of the object.
             */
            get: function () {
                return _translucency;
            },
            set: function (value) {
                _translucency = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SubsurfaceScatteringDiffuseMethod.prototype, "scatterColor", {
            /**
             * The colour of the "insides" of the object, ie: the colour the light becomes after leaving the object.
             */
            get: function () {
                return _scatterColor;
            },
            set: function (scatterColor) {
                _scatterColor = scatterColor;
                _scatterR = ((scatterColor >> 16) & 0xff) / 0xff;
                _scatterG = ((scatterColor >> 8) & 0xff) / 0xff;
                _scatterB = (scatterColor & 0xff) / 0xff;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        SubsurfaceScatteringDiffuseMethod.prototype.getVertexCode = function () {
            var vt0;
            var _ =  * , FagalRE, instance, space;
            var lightProjection;
            var toTexRegister = _.SSD$ToTex_vc_vector;
            var temp = _.getFreeTemp();
            var _lightProjVarying = _.SSD$LightProj_v;
            lightProjection = _.SSD$LightProjection_vc_matrix;
            _.m44(temp, vt0, lightProjection); //
            _.div(temp.xyz, temp.xyz, temp.w); //
            _.mul(temp.xy, temp.xy, toTexRegister.xy); //
            _.add(temp.xy, temp.xy, toTexRegister.xx); //
            _.mov(_lightProjVarying.xyz, temp.xyz); //
            _.mov(_lightProjVarying.w, _.position_va_3.w);
        };
        /**
         * @inheritDoc
         */
        SubsurfaceScatteringDiffuseMethod.prototype.getFragmentPreLightingCode = function () {
            var _ =  * , FagalRE, instance, space;
            this._decReg = _.SSD$dec_fc_vector;
            this._propReg = _.SSD$prop_fc_vector;
        };
        /**
         * @inheritDoc
         */
        SubsurfaceScatteringDiffuseMethod.prototype.getFragmentCodePerLight = function () {
            var lightColReg;
            this._isFirstLight = true;
            this._lightColorReg = lightColReg;
        };
        /**
         * @inheritDoc
         */
        SubsurfaceScatteringDiffuseMethod.prototype.getFragmentPostLightingCode = function () {
            var targetReg;
            var _ =  * , FagalRE, instance, space;
            var temp = _.getFreeTemp();
            var _colorReg = _.SSD$Color_fc_vector;
            _.mul(temp.xyz, this._lightColorReg.xyz, this._targetReg.w); //
            _.mul(temp.xyz, temp.xyz, _colorReg.xyz); //
            _.add(targetReg.xyz, targetReg.xyz, temp.xyz);
        };
        /**
         * Generates the code for this method
         */
        SubsurfaceScatteringDiffuseMethod.prototype.scatterLight = function () {
            var _ =  * , FagalRE, instance, space;
            var shaderParams = FagalRE.instance.context3DCache.shaderParams;
            var lightShaderParams = shaderParams.getOrCreateComponentByClass(feng3d.LightShaderParams);
            // only scatter first light
            if (!this._isFirstLight)
                return;
            this._isFirstLight = false;
            var targetReg;
            var depthReg = _.SSD$depthMap_fs;
            if (lightShaderParams.needsViewDir > 0)
                this._targetReg = _.viewDir_ft_4;
            else {
                this._targetReg = _.getFreeTemp();
            }
            var _lightProjVarying = _.SSD$LightProj_v;
            var _colorReg = _.SSD$Color_fc_vector;
            var temp = _.getFreeTemp();
            "tex " + temp + ", " + _lightProjVarying + ", " + depthReg + " <2d,nearest,clamp>\n";
            // reencode RGBA
            _.dp4(targetReg.z, temp, this._decReg);
            // currentDistanceToLight - closestDistanceToLight
            _.sub(targetReg.z, _lightProjVarying.z, targetReg.z);
            _.sub(targetReg.z, this._propReg.x, targetReg.z);
            _.mul(targetReg.z, this._propReg.y, targetReg.z);
            _.sat(targetReg.z, targetReg.z);
            // targetReg.x contains dot(lightDir, normal)
            // modulate according to incident light angle (scatter = scatter*(-.5*dot(light, normal) + .5)
            _.neg(targetReg.y, targetReg.x);
            _.mul(targetReg.y, targetReg.y, this._propReg.z);
            _.add(targetReg.y, targetReg.y, this._propReg.z);
            _.mul(this._targetReg.w, targetReg.z, targetReg.y);
            // blend diffuse: d' = (1-s)*d + s*1
            _.sub(targetReg.y, _colorReg.w, this._targetReg.w);
            _.mul(targetReg.w, targetReg.w, targetReg.y);
        };
        return SubsurfaceScatteringDiffuseMethod;
    }(feng3d.CompositeDiffuseMethod));
    feng3d.SubsurfaceScatteringDiffuseMethod = SubsurfaceScatteringDiffuseMethod;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    _TerrainDiffusePostLighting;
    /**
     * 地形渲染函数
     * @author feng 2014-7-16
     */
    var TerrainDiffuseMethod = (function (_super) {
        __extends(TerrainDiffuseMethod, _super);
        function TerrainDiffuseMethod(splatTextures, blendingTexture, tileData) {
            _super.call(this);
            this.tileData = new number[](4);
            this.splats = splatTextures;
            for (var i = 0; i < this.tileData.length && i < tileData.length; i++) {
                this.tileData[i] = tileData[i];
            }
            this.blendingTexture = blendingTexture;
            this._numSplattingLayers = this.splats.length;
            if (this._numSplattingLayers > 4)
                throw new Error("More than 4 splatting layers is not supported!");
        }
        Object.defineProperty(TerrainDiffuseMethod.prototype, "splats", {
            get: function () {
                return _splats;
            },
            set: function (value) {
                _splats = value;
                context3DBufferOwner.markBufferDirty(_.terrainTextures_fs_array);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TerrainDiffuseMethod.prototype, "blendingTexture", {
            get: function () {
                return _blendingTexture;
            },
            set: function (value) {
                _blendingTexture = value;
                context3DBufferOwner.markBufferDirty(_.blendingtexture_fs);
            },
            enumerable: true,
            configurable: true
        });
        TerrainDiffuseMethod.prototype.initBuffers = function () {
            _super.prototype.initBuffers.call(this);
            this.context3DBufferOwner.mapContext3DBuffer(this._.blendingtexture_fs, this.updateBlendingTextureBuffer);
            this.context3DBufferOwner.mapContext3DBuffer(this._.terrainTextures_fs_array, this.updateTerrainTextureBuffer);
            this.context3DBufferOwner.mapContext3DBuffer(this._.tile_fc_vector, this.updateTileDataBuffer);
        };
        TerrainDiffuseMethod.prototype.updateTerrainTextureBuffer = function (terrainTextureBufferArr) {
            terrainTextureBufferArr.update(this.splats);
        };
        TerrainDiffuseMethod.prototype.updateTileDataBuffer = function (tileDataBuffer) {
            tileDataBuffer.update(this.tileData);
        };
        TerrainDiffuseMethod.prototype.updateBlendingTextureBuffer = function (nBlendingTextureBuffer) {
            nBlendingTextureBuffer.update(this.blendingTexture);
        };
        TerrainDiffuseMethod.prototype.activate = function (shaderParams) {
            _super.prototype.activate.call(this, shaderParams);
            //通用渲染参数
            var terrainShaderParams = shaderParams.getOrCreateComponentByClass(feng3d.TerrainShaderParams);
            terrainShaderParams.splatNum = this._numSplattingLayers;
            shaderParams.addSampleFlags(this._.texture_fs, this.texture, Context3DWrapMode.REPEAT);
            shaderParams.addSampleFlags(this._.terrainTextures_fs_array, this.splats[0], Context3DWrapMode.REPEAT);
            shaderParams.addSampleFlags(this._.blendingtexture_fs, this.blendingTexture);
            var lightShaderParams = shaderParams.getOrCreateComponentByClass(feng3d.LightShaderParams);
            lightShaderParams.diffuseMethod = F_TerrainDiffusePostLighting;
        };
        return TerrainDiffuseMethod;
    }(feng3d.BasicDiffuseMethod));
    feng3d.TerrainDiffuseMethod = TerrainDiffuseMethod;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 镜面反射函数
     * @author feng 2014-5-19
     */
    var BasicSpecularMethod = (function (_super) {
        __extends(BasicSpecularMethod, _super);
        /**
         * 创建镜面反射函数
         */
        function BasicSpecularMethod() {
            this._gloss = 50;
            this._specular = 1;
            this._specularColor = 0xffffff;
            /** 镜面反射数据 */
            this._specularData = number[]([1, 1, 1, 50]);
            this.methodType = METHOD_TYPE;
            this.typeUnique = true;
            _super.call(this);
        }
        Object.defineProperty(BasicSpecularMethod.prototype, "specularColor", {
            /**
             * 镜面反射颜色
             */
            get: function () {
                return _specularColor;
            },
            set: function (value) {
                if (_specularColor == value)
                    return;
                if (_specularColor == 0 || value == 0)
                    invalidateShaderProgram();
                _specularColor = value;
                updateSpecular();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BasicSpecularMethod.prototype, "texture", {
            /**
             * 镜面反射光泽图
             */
            get: function () {
                return _texture;
            },
            set: function (value) {
                if (boolean(value) != boolean(_texture) || (value && _texture && (value.hasMipMaps != _texture.hasMipMaps || value.format != _texture.format))) {
                    invalidateShaderProgram();
                }
                _texture = value;
                context3DBufferOwner.markBufferDirty(_.specularTexture_fs);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BasicSpecularMethod.prototype, "gloss", {
            /**
             * The sharpness of the specular highlight.
             */
            get: function () {
                return _gloss;
            },
            set: function (value) {
                _gloss = value;
                updateSpecular();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BasicSpecularMethod.prototype, "specular", {
            /**
             * 镜面反射光反射强度
             */
            get: function () {
                return _specular;
            },
            set: function (value) {
                if (value == _specular)
                    return;
                _specular = value;
                updateSpecular();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        BasicSpecularMethod.prototype.initBuffers = function () {
            _super.prototype.initBuffers.call(this);
            this.context3DBufferOwner.mapContext3DBuffer(this._.specularData_fc_vector, this.updateSpecularDataBuffer);
            this.context3DBufferOwner.mapContext3DBuffer(this._.specularTexture_fs, this.updateSpecularTextureBuffer);
        };
        BasicSpecularMethod.prototype.updateSpecularDataBuffer = function (_specularDataBuffer) {
            _specularDataBuffer.update(this._specularData);
        };
        BasicSpecularMethod.prototype.updateSpecularTextureBuffer = function (_specularTextureBuffer) {
            _specularTextureBuffer.update(this.texture);
        };
        /**
         * @inheritDoc
         */
        BasicSpecularMethod.prototype.activate = function (shaderParams) {
            var lightShaderParams = shaderParams.getOrCreateComponentByClass(feng3d.LightShaderParams);
            lightShaderParams.needsNormals += lightShaderParams.numLights > 0 ? 1 : 0;
            lightShaderParams.needsViewDir += lightShaderParams.numLights > 0 ? 1 : 0;
            lightShaderParams.usingSpecularMethod += 1;
            if (this.texture != null) {
                lightShaderParams.hasSpecularTexture++;
                var commonShaderParams = shaderParams.getOrCreateComponentByClass(feng3d.CommonShaderParams);
                commonShaderParams.needsUV++;
                shaderParams.addSampleFlags(this._.specularTexture_fs, this.texture);
            }
            shaderParams.modulateMethod = this._modulateMethod;
            shaderParams.specularModelType = feng3d.SpecularModelType.BLINN_PHONG;
        };
        BasicSpecularMethod.prototype.updateSpecular = function () {
            this._specularData[0] = ((this._specularColor >> 16) & 0xff) / 0xff * this._specular;
            this._specularData[1] = ((this._specularColor >> 8) & 0xff) / 0xff * this._specular;
            this._specularData[2] = (this._specularColor & 0xff) / 0xff * this._specular;
            this._specularData[3] = this._gloss;
        };
        BasicSpecularMethod.METHOD_TYPE = "SpecularMethod";
        return BasicSpecularMethod;
    }(feng3d.LightingMethodBase));
    feng3d.BasicSpecularMethod = BasicSpecularMethod;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * CompositeSpecularMethod provides a base class for specular methods that wrap a specular method to alter the
     * calculated specular reflection strength.
     */
    var CompositeSpecularMethod = (function (_super) {
        __extends(CompositeSpecularMethod, _super);
        /**
         * Creates a new WrapSpecularMethod object.
         * @param modulateMethod The method which will add the code to alter the base method's strength. It needs to have the signature modSpecular(t : ShaderRegisterElement, regCache : ShaderRegisterCache) :string, in which t.w will contain the specular strength and t.xyz will contain the half-vector or the reflection vector.
         * @param baseSpecularMethod The base specular method on which this method's shading is based.
         */
        function CompositeSpecularMethod(modulateMethod, baseSpecularMethod) {
            if (baseSpecularMethod === void 0) { baseSpecularMethod = null; }
            _super.call(this);
            /**
             * @inheritDoc
             */
            this.override = function cleanCompilationData() {
                _super.cleanCompilationData.call(this);
                this._baseMethod.cleanCompilationData();
            };
            this._baseMethod = baseSpecularMethod || new feng3d.BasicSpecularMethod();
            this._baseMethod._modulateMethod = modulateMethod;
            this._baseMethod.addEventListener(feng3d.ShadingMethodEvent.SHADER_INVALIDATED, this.onShaderInvalidated);
        }
        Object.defineProperty(CompositeSpecularMethod.prototype, "baseMethod", {
            /**
             * The base specular method on which this method's shading is based.
             */
            get: function () {
                return _baseMethod;
            },
            set: function (value) {
                if (_baseMethod == value)
                    return;
                _baseMethod.removeEventListener(feng3d.ShadingMethodEvent.SHADER_INVALIDATED, onShaderInvalidated);
                _baseMethod = value;
                _baseMethod.addEventListener(feng3d.ShadingMethodEvent.SHADER_INVALIDATED, onShaderInvalidated, false, 0, true);
                invalidateShaderProgram();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CompositeSpecularMethod.prototype, "gloss", {
            /**
             * @inheritDoc
             */
            get: function () {
                return _baseMethod.gloss;
            },
            set: function (value) {
                _baseMethod.gloss = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CompositeSpecularMethod.prototype, "specular", {
            /**
             * @inheritDoc
             */
            get: function () {
                return _baseMethod.specular;
            },
            set: function (value) {
                _baseMethod.specular = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        CompositeSpecularMethod.prototype.dispose = function () {
            this._baseMethod.removeEventListener(feng3d.ShadingMethodEvent.SHADER_INVALIDATED, this.onShaderInvalidated);
            this._baseMethod.dispose();
        };
        Object.defineProperty(CompositeSpecularMethod.prototype, "texture", {
            /**
             * @inheritDoc
             */
            get: function () {
                return _baseMethod.texture;
            },
            set: function (value) {
                _baseMethod.texture = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        CompositeSpecularMethod.prototype.activate = function (shaderParams) {
            this._baseMethod.activate(shaderParams);
        };
        /**
         * Called when the base method's shader code is invalidated.
         */
        CompositeSpecularMethod.prototype.onShaderInvalidated = function (event) {
            invalidateShaderProgram();
        };
        return CompositeSpecularMethod;
    }(feng3d.BasicSpecularMethod));
    feng3d.CompositeSpecularMethod = CompositeSpecularMethod;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * PhongSpecularMethod provides a specular method that provides Phong highlights.
     */
    var PhongSpecularMethod = (function (_super) {
        __extends(PhongSpecularMethod, _super);
        /**
         * Creates a new PhongSpecularMethod object.
         */
        function PhongSpecularMethod() {
            _super.call(this);
        }
        PhongSpecularMethod.prototype.activate = function (shaderParams) {
            _super.prototype.activate.call(this, shaderParams);
            shaderParams.specularModelType = feng3d.SpecularModelType.PHONG;
        };
        return PhongSpecularMethod;
    }(feng3d.BasicSpecularMethod));
    feng3d.PhongSpecularMethod = PhongSpecularMethod;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    _FresnelSpecular;
    /**
     * FresnelSpecularMethod provides a specular shading method that causes stronger highlights on grazing view angles.
     */
    var FresnelSpecularMethod = (function (_super) {
        __extends(FresnelSpecularMethod, _super);
        /**
         * Creates a new FresnelSpecularMethod object.
         * @param basedOnSurface Defines whether the fresnel effect should be based on the view angle on the surface (if true), or on the angle between the light and the view.
         * @param baseSpecularMethod The specular method to which the fresnel equation. Defaults to BasicSpecularMethod.
         */
        function FresnelSpecularMethod(basedOnSurface) {
            if (basedOnSurface === void 0) { basedOnSurface = true; }
            // may want to offer diff speculars
            _super.call(this);
            this._fresnelPower = 5;
            this._normalReflectance = .028; // default value for skin
            this.data = number[]([0, 0, 1, 0]);
            this._incidentLight = !basedOnSurface;
        }
        Object.defineProperty(FresnelSpecularMethod.prototype, "basedOnSurface", {
            /**
             * Defines whether the fresnel effect should be based on the view angle on the surface (if true), or on the angle between the light and the view.
             */
            get: function () {
                return !_incidentLight;
            },
            set: function (value) {
                if (_incidentLight != value)
                    return;
                _incidentLight = !value;
                invalidateShaderProgram();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FresnelSpecularMethod.prototype, "fresnelPower", {
            /**
             * The power used in the Fresnel equation. Higher values make the fresnel effect more pronounced. Defaults to 5.
             */
            get: function () {
                return _fresnelPower;
            },
            set: function (value) {
                _fresnelPower = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FresnelSpecularMethod.prototype, "normalReflectance", {
            /**
             * The minimum amount of reflectance, ie the reflectance when the view direction is normal to the surface or light direction.
             */
            get: function () {
                return _normalReflectance;
            },
            set: function (value) {
                _normalReflectance = value;
            },
            enumerable: true,
            configurable: true
        });
        FresnelSpecularMethod.prototype.initBuffers = function () {
            _super.prototype.initBuffers.call(this);
            this.context3DBufferOwner.mapContext3DBuffer(this._.fresnelSpecularData_fc_vector, this.updateSpecularDataBuffer);
        };
        FresnelSpecularMethod.prototype.updateSpecularDataBuffer = function (fcVectorBuffer) {
            fcVectorBuffer.update(this.data);
        };
        /**
         * @inheritDoc
         */
        FresnelSpecularMethod.prototype.activate = function (shaderParams) {
            _super.prototype.activate.call(this, shaderParams);
            this.data[0] = this._normalReflectance;
            this.data[1] = this._fresnelPower;
            shaderParams.incidentLight = this._incidentLight;
            shaderParams.modulateMethod = F_FresnelSpecular;
        };
        return FresnelSpecularMethod;
    }(feng3d.PhongSpecularMethod));
    feng3d.FresnelSpecularMethod = FresnelSpecularMethod;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 阴影映射函数基类
     * @author feng 2015-5-28
     */
    var ShadowMapMethodBase = (function (_super) {
        __extends(ShadowMapMethodBase, _super);
        /**
         * 创建阴影映射函数基类
         * @param castingLight		投射灯光
         */
        function ShadowMapMethodBase(castingLight) {
            this._epsilon = .02;
            this._alpha = 1;
            this.methodType = METHOD_TYPE;
            this.typeUnique = true;
            _super.call(this);
            this._namedAsset = new feng3d.NamedAsset(this, feng3d.AssetType.SHADOW_MAP_METHOD);
            this._castingLight = castingLight;
            castingLight.castsShadows = true;
            this._shadowMapper = castingLight.shadowMapper;
        }
        Object.defineProperty(ShadowMapMethodBase.prototype, "castingLight", {
            /**
             * 投射灯光
             */
            get: function () {
                return _castingLight;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ShadowMapMethodBase.prototype, "alpha", {
            /**
             * The "transparency" of the shadows. This allows making shadows less strong.
             */
            get: function () {
                return _alpha;
            },
            set: function (value) {
                _alpha = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ShadowMapMethodBase.prototype, "epsilon", {
            /**
             * A small value to counter floating point precision errors when comparing values in the shadow map with the
             * calculated depth value. Increase this if shadow banding occurs, decrease it if the shadow seems to be too detached.
             */
            get: function () {
                return _epsilon;
            },
            set: function (value) {
                _epsilon = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        ShadowMapMethodBase.prototype.activate = function (shaderParams) {
            var shadowShaderParams = shaderParams.getOrCreateComponentByClass(feng3d.ShadowShaderParams);
            shadowShaderParams.usingShadowMapMethod += 1;
            shadowShaderParams.needsShadowRegister++;
        };
        Object.defineProperty(ShadowMapMethodBase.prototype, "namedAsset", {
            get: function () {
                return _namedAsset;
            },
            enumerable: true,
            configurable: true
        });
        ShadowMapMethodBase.METHOD_TYPE = "ShadowMapMethod";
        return ShadowMapMethodBase;
    }(feng3d.ShadingMethodBase));
    feng3d.ShadowMapMethodBase = ShadowMapMethodBase;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 简单阴影映射函数基类
     * @author feng 2015-5-28
     */
    var SimpleShadowMapMethodBase = (function (_super) {
        __extends(SimpleShadowMapMethodBase, _super);
        /**
         * 创建简单阴影映射方法基类
         * @param castingLight			投射阴影的灯光
         */
        function SimpleShadowMapMethodBase(castingLight) {
            /**
             * 顶点常量数据0
             */
            this.shadowCommonsVCData0 = number[]([0.5, -0.5, 0.0, 1.0]);
            /**
             * 通用数据0
             */
            this.shadowCommonsData0 = number[]([1.0, 1 / 255.0, 1 / 65025.0, 1 / 16581375.0]);
            /**
             * 通用数据1
             */
            this.shadowCommonsData1 = number[]([0, 0, 0, 1]);
            /**
             * 通用数据2
             */
            this.shadowCommonsData2 = number[]([0.5, 2048, 1.0 / 2048, 0]);
            /**
             * 深度投影矩阵
             */
            this.depthProjection = new Matrix3D();
            this._usePoint = castingLight;
            is;
            feng3d.PointLight;
            _super.call(this, castingLight);
        }
        /**
         * @inheritDoc
         */
        SimpleShadowMapMethodBase.prototype.initBuffers = function () {
            _super.prototype.initBuffers.call(this);
            this.context3DBufferOwner.mapContext3DBuffer(this._.shadowCommondata0_vc_vector, this.updateShadowCommonVCData0Buffer);
            this.context3DBufferOwner.mapContext3DBuffer(this._.shadowCommondata0_fc_vector, this.updateShadowCommonData0Buffer);
            this.context3DBufferOwner.mapContext3DBuffer(this._.shadowCommondata1_fc_vector, this.updateShadowCommonData1Buffer);
            this.context3DBufferOwner.mapContext3DBuffer(this._.shadowCommondata2_fc_vector, this.updateShadowCommonData2Buffer);
            this.context3DBufferOwner.mapContext3DBuffer(this._.depthMap_vc_matrix, this.updateDepthProjectionMatrixBuffer);
            this.context3DBufferOwner.mapContext3DBuffer(this._.depthMap_fs, this.updateTextureBuffer);
        };
        SimpleShadowMapMethodBase.prototype.updateShadowCommonVCData0Buffer = function (vcVectorBuffer) {
            vcVectorBuffer.update(this.shadowCommonsVCData0);
        };
        SimpleShadowMapMethodBase.prototype.updateShadowCommonData0Buffer = function (fcVectorBuffer) {
            fcVectorBuffer.update(this.shadowCommonsData0);
        };
        SimpleShadowMapMethodBase.prototype.updateShadowCommonData1Buffer = function (fcVectorBuffer) {
            fcVectorBuffer.update(this.shadowCommonsData1);
        };
        SimpleShadowMapMethodBase.prototype.updateShadowCommonData2Buffer = function (fcVectorBuffer) {
            fcVectorBuffer.update(this.shadowCommonsData2);
        };
        /**
         * 更新深度投影矩阵缓冲
         * @param sceneTransformMatrixBuffer		场景变换矩阵缓冲
         */
        SimpleShadowMapMethodBase.prototype.updateDepthProjectionMatrixBuffer = function (sceneTransformMatrixBuffer) {
            sceneTransformMatrixBuffer.update(this.depthProjection, true);
        };
        /**
         * 更新深度图纹理缓冲
         */
        SimpleShadowMapMethodBase.prototype.updateTextureBuffer = function (textureBuffer) {
            textureBuffer.update(_castingLight.shadowMapper.depthMap);
        };
        /**
         * @inheritDoc
         */
        SimpleShadowMapMethodBase.prototype.activate = function (shaderParams) {
            _super.prototype.activate.call(this, shaderParams);
            var shadowShaderParams = shaderParams.getOrCreateComponentByClass(feng3d.ShadowShaderParams);
            shadowShaderParams.usePoint += this._usePoint;
            if (this._usePoint)
                this.shadowCommonsData1[0] = -Math.pow(1 / (_castingLight.fallOff * _epsilon), 2);
            else
                this.shadowCommonsVCData0[3] = -1 / (feng3d.DirectionalShadowMapper(_shadowMapper).depth * _epsilon);
            this.shadowCommonsData1[1] = 1 - _alpha;
            var size = this.castingLight.shadowMapper.depthMapSize;
            this.shadowCommonsData2[1] = size;
            this.shadowCommonsData2[2] = 1 / size;
            //通用渲染参数
            var flags = [this.castingLight.shadowMapper.depthMap.type, Context3DTextureFilter.NEAREST, Context3DWrapMode.CLAMP];
            shaderParams.setSampleFlags(this._.depthMap_fs, flags);
        };
        /**
         * @inheritDoc
         */
        SimpleShadowMapMethodBase.prototype.setRenderState = function (renderable, camera) {
            if (!this._usePoint) {
                this.depthProjection.copyFrom(feng3d.DirectionalShadowMapper(_shadowMapper).depthProjection);
            }
        };
        return SimpleShadowMapMethodBase;
    }(feng3d.ShadowMapMethodBase));
    feng3d.SimpleShadowMapMethodBase = SimpleShadowMapMethodBase;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 过滤的阴影映射函数
     * @author feng 2015-5-28
     */
    var FilteredShadowMapMethod = (function (_super) {
        __extends(FilteredShadowMapMethod, _super);
        /**
         * 过滤的阴影映射函数
         * @param castingLight		投射灯光
         */
        function FilteredShadowMapMethod(castingLight) {
            _super.call(this, castingLight);
        }
        return FilteredShadowMapMethod;
    }(feng3d.SimpleShadowMapMethodBase));
    feng3d.FilteredShadowMapMethod = FilteredShadowMapMethod;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 近阴影映射函数
     * @author feng 2015-5-28
     */
    var NearShadowMapMethod = (function (_super) {
        __extends(NearShadowMapMethod, _super);
        /**
         * 创建近阴影映射函数
         * @param baseMethod		基础映射函数
         * @param fadeRatio			消退比率
         */
        function NearShadowMapMethod(baseMethod, fadeRatio) {
            if (fadeRatio === void 0) { fadeRatio = .1; }
            _super.call(this, baseMethod.castingLight);
            this.secondaryFragmentConstants = new number[](4);
            this._baseMethod = baseMethod;
            this._fadeRatio = fadeRatio;
            this._nearShadowMapper = _castingLight.shadowMapper;
            if (!this._nearShadowMapper)
                throw new Error("NearShadowMapMethod requires a light that has a NearDirectionalShadowMapper instance assigned to shadowMapper.");
            this._baseMethod.addEventListener(feng3d.ShadingMethodEvent.SHADER_INVALIDATED, this.onShaderInvalidated);
        }
        Object.defineProperty(NearShadowMapMethod.prototype, "baseMethod", {
            /**
             * The base shadow map method on which this method's shading is based.
             */
            get: function () {
                return _baseMethod;
            },
            set: function (value) {
                if (_baseMethod == value)
                    return;
                _baseMethod.removeEventListener(feng3d.ShadingMethodEvent.SHADER_INVALIDATED, onShaderInvalidated);
                _baseMethod = value;
                _baseMethod.addEventListener(feng3d.ShadingMethodEvent.SHADER_INVALIDATED, onShaderInvalidated, false, 0, true);
                invalidateShaderProgram();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        NearShadowMapMethod.prototype.initBuffers = function () {
            _super.prototype.initBuffers.call(this);
            this.context3DBufferOwner.mapContext3DBuffer(this._.secondary_fc_vector, this.updateSecondaryCommonData0Buffer);
        };
        /**
         * @inheritDoc
         */
        NearShadowMapMethod.prototype.initConstants = function () {
            _super.prototype.initConstants.call(this);
            this._baseMethod.initConstants();
            this.secondaryFragmentConstants[0] = 0;
            this.secondaryFragmentConstants[1] = 0;
            this.secondaryFragmentConstants[2] = 0;
            this.secondaryFragmentConstants[3] = 1;
        };
        NearShadowMapMethod.prototype.updateSecondaryCommonData0Buffer = function (fcVectorBuffer) {
            fcVectorBuffer.update(this.secondaryFragmentConstants);
        };
        /**
         * @inheritDoc
         */
        NearShadowMapMethod.prototype.setRenderState = function (renderable, camera) {
            var near = camera.lens.near;
            var d = camera.lens.far - near;
            var maxDistance = this._nearShadowMapper.coverageRatio;
            var minDistance = maxDistance * (1 - this._fadeRatio);
            maxDistance = near + maxDistance * d;
            minDistance = near + minDistance * d;
            this.secondaryFragmentConstants[0] = minDistance;
            this.secondaryFragmentConstants[1] = 1 / (maxDistance - minDistance);
            _super.prototype.setRenderState.call(this, renderable, camera);
            this._baseMethod.setRenderState(renderable, camera);
        };
        /**
         * @inheritDoc
         */
        NearShadowMapMethod.prototype.activate = function (shaderParams) {
            _super.prototype.activate.call(this, shaderParams);
            var shadowShaderParams = shaderParams.getOrCreateComponentByClass(feng3d.ShadowShaderParams);
            shadowShaderParams.needsProjection++;
            shadowShaderParams.useNearShadowMap++;
        };
        /**
         * 处理渲染程序失效事件
         */
        NearShadowMapMethod.prototype.onShaderInvalidated = function (event) {
            invalidateShaderProgram();
        };
        return NearShadowMapMethod;
    }(feng3d.SimpleShadowMapMethodBase));
    feng3d.NearShadowMapMethod = NearShadowMapMethod;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 材质基类
     * @author feng 2014-4-15
     */
    var MaterialBase = (function (_super) {
        __extends(MaterialBase, _super);
        /**
         * 创建一个材质基类
         */
        function MaterialBase() {
            this._blendMode = BlendMode.NORMAL;
            this._mipmap = true;
            this._smooth = true;
            this._namedAsset = new feng3d.NamedAsset(this, feng3d.AssetType.MATERIAL);
            this._owners = new IMaterialOwner[]();
            this._passes = new feng3d.MaterialPassBase[]();
            this._depthPass = new feng3d.DepthMapPass();
            this._planarShadowPass = new feng3d.PlanarShadowPass();
            // Default to considering pre-multiplied textures while blending
            this.alphaPremultiplied = true;
        }
        Object.defineProperty(MaterialBase.prototype, "depthPass", {
            /**
             * 深度渲染通道
             */
            get: function () {
                return _depthPass;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialBase.prototype, "planarShadowPass", {
            /**
             * 平面阴影映射通道
             */
            get: function () {
                return _planarShadowPass;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialBase.prototype, "bothSides", {
            /**
             * 是否双面渲染
             */
            get: function () {
                return _bothSides;
            },
            set: function (value) {
                _bothSides = value;
                for (var i = 0; i < _numPasses; ++i)
                    _passes[i].bothSides = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialBase.prototype, "requiresBlending", {
            /**
             * 是否需要混合
             */
            get: function () {
                return _blendMode != BlendMode.NORMAL;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialBase.prototype, "blendMode", {
            /**
             * 混合模式
             */
            get: function () {
                return _blendMode;
            },
            set: function (value) {
                _blendMode = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialBase.prototype, "alphaPremultiplied", {
            /**
             * Indicates whether visible textures (or other pixels) used by this material have
             * already been premultiplied. Toggle this if you are seeing black halos around your
             * blended alpha edges.
             */
            get: function () {
                return _alphaPremultiplied;
            },
            set: function (value) {
                _alphaPremultiplied = value;
                for (var i = 0; i < _numPasses; ++i)
                    _passes[i].alphaPremultiplied = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialBase.prototype, "mipmap", {
            /**
             * 是否使用纹理分级细化
             */
            get: function () {
                return _mipmap;
            },
            set: function (value) {
                _mipmap = value;
                for (each(); ; )
                    var pass;
                 in _passes;
                {
                    pass.mipmap = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialBase.prototype, "repeat", {
            /**
             * 是否重复
             */
            get: function () {
                return _repeat;
            },
            set: function (value) {
                _repeat = value;
                for (each(); ; )
                    var pass;
                 in _passes;
                {
                    pass.repeat = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialBase.prototype, "smooth", {
            /**
             * 是否平滑
             */
            get: function () {
                return _smooth;
            },
            set: function (value) {
                _smooth = value;
                for (each(); ; )
                    var pass;
                 in _passes;
                {
                    pass.smooth = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 添加通道
         * @param pass 通道
         */
        MaterialBase.prototype.addPass = function (pass) {
            this._passes.push(pass);
            this._numPasses = this._passes.length;
            pass.alphaPremultiplied = this._alphaPremultiplied;
            pass.mipmap = this._mipmap;
            pass.smooth = this._smooth;
            pass.repeat = this._repeat;
            pass.bothSides = this._bothSides;
            pass.addEventListener(feng3d.Event.CHANGE, this.onPassChange);
            this.invalidatePasses(null);
        };
        /**
         * 获取渲染通道
         * @param index		渲染通道索引
         * @return			返回指定索引处渲染通道
         */
        MaterialBase.prototype.getPass = function (index) {
            return this._passes[index];
        };
        /**
         * 处理通道变化事件
         */
        MaterialBase.prototype.onPassChange = function (event) {
        };
        /**
         * 移除通道
         * @param pass 通道
         */
        MaterialBase.prototype.removePass = function (pass) {
            this._passes.splice(this._passes.indexOf(pass), 1);
        };
        Object.defineProperty(MaterialBase.prototype, "animationSet", {
            /**
             * 动画集合
             */
            set: function (value) {
                for (each(); ; )
                    var pass;
                 in _passes;
                {
                    pass.animationSet = value;
                }
                depthPass.animationSet = value;
                planarShadowPass.animationSet = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialBase.prototype, "lightPicker", {
            /**
             * 灯光采集器
             */
            get: function () {
                return _lightPicker;
            },
            set: function (value) {
                if (value != _lightPicker) {
                    _lightPicker = value;
                    var len = _passes.length;
                    for (var i = 0; i < len; ++i)
                        _passes[i].lightPicker = _lightPicker;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 通道失效
         */
        MaterialBase.prototype.invalidatePasses = function (triggerPass) {
            for (each(); ; )
                var pass;
             in this._passes;
            {
                if (pass != triggerPass)
                    pass.invalidateShaderProgram();
            }
        };
        Object.defineProperty(MaterialBase.prototype, "numPasses", {
            /**
             * 渲染通道数量
             */
            get: function () {
                return _numPasses;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 更新材质
         */
        MaterialBase.prototype.updateMaterial = function () {
        };
        /**
         * 清除通道渲染状态
         * @param index				通道索引
         * @param stage3DProxy		3D舞台代理
         */
        MaterialBase.prototype.deactivatePass = function (index) {
            this._passes[index].deactivate();
        };
        /**
         * 停用材质的最后一个通道
         */
        MaterialBase.prototype.deactivate = function () {
            this._passes[this._numPasses - 1].deactivate();
        };
        /**
         * 添加材质拥有者
         * @param owner		材质拥有者
         */
        MaterialBase.prototype.addOwner = function (owner) {
            this._owners.push(owner);
        };
        /**
         * 移除材质拥有者
         * @param owner		材质拥有者
         */
        MaterialBase.prototype.removeOwner = function (owner) {
            this._owners.splice(this._owners.indexOf(owner), 1);
            if (this._owners.length == 0) {
                this.invalidatePasses(null);
            }
        };
        /**
         * Cleans up resources owned by the material, including passes. Textures are not owned by the material since they
         * could be used by other materials and will not be disposed.
         */
        MaterialBase.prototype.dispose = function () {
            var i;
            for (i = 0; i < this._numPasses; ++i)
                this._passes[i].dispose();
            this._depthPass.dispose();
            this._depthPass.removeEventListener(feng3d.Event.CHANGE, this.onPassChange);
        };
        Object.defineProperty(MaterialBase.prototype, "namedAsset", {
            get: function () {
                return _namedAsset;
            },
            enumerable: true,
            configurable: true
        });
        return MaterialBase;
    }(feng3d.Component));
    feng3d.MaterialBase = MaterialBase;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     *
     * @author feng 2014-5-19
     */
    var MultiPassMaterialBase = (function (_super) {
        __extends(MultiPassMaterialBase, _super);
        function MultiPassMaterialBase() {
            _super.call(this);
        }
        Object.defineProperty(MultiPassMaterialBase.prototype, "texture", {
            get: function () {
                return null;
            },
            set: function (value) {
            },
            enumerable: true,
            configurable: true
        });
        return MultiPassMaterialBase;
    }(feng3d.MaterialBase));
    feng3d.MultiPassMaterialBase = MultiPassMaterialBase;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     *
     * @author feng 2014-5-19
     */
    var ColorMultiPassMaterial = (function (_super) {
        __extends(ColorMultiPassMaterial, _super);
        function ColorMultiPassMaterial(color) {
            if (color === void 0) { color = 0xcccccc; }
            _super.call(this);
            this._ambientColor = 0xffffff;
            this._specularColor = 0xffffff;
            this._specular = 1;
        }
        Object.defineProperty(ColorMultiPassMaterial.prototype, "ambientColor", {
            get: function () {
                return _ambientColor;
            },
            set: function (value) {
                _ambientColor = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ColorMultiPassMaterial.prototype, "specularColor", {
            get: function () {
                return _specularColor;
            },
            set: function (value) {
                _specularColor = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ColorMultiPassMaterial.prototype, "specular", {
            get: function () {
                return _specular;
            },
            set: function (value) {
                _specular = value;
            },
            enumerable: true,
            configurable: true
        });
        return ColorMultiPassMaterial;
    }(feng3d.MultiPassMaterialBase));
    feng3d.ColorMultiPassMaterial = ColorMultiPassMaterial;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     *
     * @author feng 2014-5-19
     */
    var TextureMultiPassMaterial = (function (_super) {
        __extends(TextureMultiPassMaterial, _super);
        function TextureMultiPassMaterial(texture, smooth, repeat, mipmap) {
            if (texture === void 0) { texture = null; }
            if (smooth === void 0) { smooth = true; }
            if (repeat === void 0) { repeat = false; }
            if (mipmap === void 0) { mipmap = true; }
            _super.call(this);
            this._ambientColor = 0xffffff;
            this._specularMethod = new feng3d.BasicSpecularMethod();
            this._normalMethod = new feng3d.BasicNormalMethod();
            this.texture = texture;
        }
        Object.defineProperty(TextureMultiPassMaterial.prototype, "ambientColor", {
            get: function () {
                return _ambientColor;
            },
            set: function (value) {
                _ambientColor = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TextureMultiPassMaterial.prototype, "specularMethod", {
            get: function () {
                return _specularMethod;
            },
            set: function (value) {
                _specularMethod = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TextureMultiPassMaterial.prototype, "normalMap", {
            /**
             * The normal map to modulate the direction of the surface for each texel. The default normal method expects
             * tangent-space normal maps, but others could expect object-space maps.
             */
            get: function () {
                return _normalMethod.normalMap;
            },
            set: function (value) {
                _normalMethod.normalMap = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TextureMultiPassMaterial.prototype, "specularMap", {
            /**
             * 高光贴图
             *
             * A specular map that defines the strength of specular reflections for each texel in the red channel,
             * and the gloss factor in the green channel. You can use SpecularBitmapTexture if you want to easily set
             * specular and gloss maps from grayscale images, but correctly authored images are preferred.
             */
            get: function () {
                return _specularMethod.texture;
            },
            set: function (value) {
                _specularMethod.texture = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TextureMultiPassMaterial.prototype, "specular", {
            /**
             * The overall strength of the specular reflection.
             */
            get: function () {
                return _specularMethod ? _specularMethod.specular : 0;
            },
            set: function (value) {
                if (_specularMethod)
                    _specularMethod.specular = value;
            },
            enumerable: true,
            configurable: true
        });
        return TextureMultiPassMaterial;
    }(feng3d.MultiPassMaterialBase));
    feng3d.TextureMultiPassMaterial = TextureMultiPassMaterial;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 线段材质
     * @author feng 2014-4-16
     */
    var SegmentMaterial = (function (_super) {
        __extends(SegmentMaterial, _super);
        function SegmentMaterial(thickness) {
            if (thickness === void 0) { thickness = 1.25; }
            _super.call(this);
            this.bothSides = true;
            addPass(this._screenPass = new feng3d.SegmentPass(thickness));
        }
        return SegmentMaterial;
    }(feng3d.MaterialBase));
    feng3d.SegmentMaterial = SegmentMaterial;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 单通道纹理
     * @author feng 2014-6-5
     */
    var SinglePassMaterialBase = (function (_super) {
        __extends(SinglePassMaterialBase, _super);
        /**
         * 创建一个单通道纹理
         */
        function SinglePassMaterialBase() {
            _super.call(this);
            addPass(this._screenPass = new feng3d.SuperShaderPass());
        }
        Object.defineProperty(SinglePassMaterialBase.prototype, "numMethods", {
            /**
             * The number of "effect" methods added to the material.
             */
            get: function () {
                return _screenPass.numMethods;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SinglePassMaterialBase.prototype, "blendMode", {
            /**
             * @inheritDoc
             */
            set: function (value) {
                _super.prototype.blendMode = value;
                _screenPass.setBlendMode(blendMode == BlendMode.NORMAL && requiresBlending ? BlendMode.LAYER : blendMode);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SinglePassMaterialBase.prototype, "requiresBlending", {
            /**
             * @inheritDoc
             */
            get: function () {
                return _super.prototype.requiresBlending || _alphaBlending;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SinglePassMaterialBase.prototype, "alphaThreshold", {
            /**
             * The minimum alpha value for which pixels should be drawn. This is used for transparency that is either
             * invisible or entirely opaque, often used with textures for foliage, etc.
             * Recommended values are 0 to disable alpha, or 0.5 to create smooth edges. Default value is 0 (disabled).
             */
            get: function () {
                return _screenPass.diffuseMethod.alphaThreshold;
            },
            set: function (value) {
                _screenPass.diffuseMethod.alphaThreshold = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SinglePassMaterialBase.prototype, "ambientColor", {
            /**
             * 环境光反射颜色
             */
            get: function () {
                return _screenPass.ambientMethod.ambientColor;
            },
            set: function (value) {
                _screenPass.ambientMethod.ambientColor = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SinglePassMaterialBase.prototype, "specularColor", {
            /**
             * 镜面反射光反射颜色
             */
            get: function () {
                return _screenPass.specularMethod.specularColor;
            },
            set: function (value) {
                _screenPass.specularMethod.specularColor = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SinglePassMaterialBase.prototype, "specular", {
            /**
             * 镜面反射光反射强度
             */
            get: function () {
                return _screenPass.specularMethod ? _screenPass.specularMethod.specular : 0;
            },
            set: function (value) {
                if (_screenPass.specularMethod)
                    _screenPass.specularMethod.specular = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SinglePassMaterialBase.prototype, "ambient", {
            /**
             * 环境光反射强度
             */
            get: function () {
                return _screenPass.ambientMethod.ambient;
            },
            set: function (value) {
                _screenPass.ambientMethod.ambient = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SinglePassMaterialBase.prototype, "alphaBlending", {
            /**
             * 是否透明度混合
             */
            get: function () {
                return _alphaBlending;
            },
            set: function (value) {
                _alphaBlending = value;
                _screenPass.setBlendMode(blendMode == BlendMode.NORMAL && requiresBlending ? BlendMode.LAYER : blendMode);
                //			_screenPass.preserveAlpha = requiresBlending;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SinglePassMaterialBase.prototype, "diffuseMethod", {
            /**
             * 漫反射函数
             */
            get: function () {
                return _screenPass.diffuseMethod;
            },
            set: function (value) {
                _screenPass.diffuseMethod = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SinglePassMaterialBase.prototype, "normalMethod", {
            /**
             * The method used to generate the per-pixel normals. Defaults to BasicNormalMethod.
             */
            get: function () {
                return _screenPass.normalMethod;
            },
            set: function (value) {
                _screenPass.normalMethod = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SinglePassMaterialBase.prototype, "ambientMethod", {
            /**
             * 环境光函数
             */
            get: function () {
                return _screenPass.ambientMethod;
            },
            set: function (value) {
                _screenPass.ambientMethod = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SinglePassMaterialBase.prototype, "specularMethod", {
            /**
             * 镜面反射函数
             */
            get: function () {
                return _screenPass.specularMethod;
            },
            set: function (value) {
                _screenPass.specularMethod = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SinglePassMaterialBase.prototype, "normalMap", {
            /**
             * 法线贴图
             */
            get: function () {
                return _screenPass.normalMethod.normalMap;
            },
            set: function (value) {
                _screenPass.normalMethod.normalMap = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SinglePassMaterialBase.prototype, "specularMap", {
            /**
             * 镜面反射光泽图
             */
            get: function () {
                return _screenPass.specularMethod.texture;
            },
            set: function (value) {
                if (_screenPass.specularMethod)
                    _screenPass.specularMethod.texture = value;
                else
                    throw new Error("No specular method was set to assign the specularGlossMap to");
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SinglePassMaterialBase.prototype, "gloss", {
            /**
             * 高光值
             */
            get: function () {
                return _screenPass.specularMethod ? _screenPass.specularMethod.gloss : 0;
            },
            set: function (value) {
                if (_screenPass.specularMethod)
                    _screenPass.specularMethod.gloss = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SinglePassMaterialBase.prototype, "shadowMethod", {
            /**
             * 阴影映射函数
             */
            get: function () {
                return _screenPass.shadowMethod;
            },
            set: function (value) {
                _screenPass.shadowMethod = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SinglePassMaterialBase.prototype, "lightPicker", {
            /**
             * @inheritDoc
             */
            set: function (value) {
                _super.prototype.lightPicker = value;
                _screenPass.lightPicker = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 添加特效函数
         * @param method		特效函数
         */
        SinglePassMaterialBase.prototype.addMethod = function (method) {
            this._screenPass.addMethod(method);
        };
        return SinglePassMaterialBase;
    }(feng3d.MaterialBase));
    feng3d.SinglePassMaterialBase = SinglePassMaterialBase;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 颜色材质
     * @author feng 2014-4-15
     */
    var ColorMaterial = (function (_super) {
        __extends(ColorMaterial, _super);
        function ColorMaterial(color, alpha) {
            if (color === void 0) { color = 0xcccccc; }
            if (alpha === void 0) { alpha = 1; }
            _super.call(this);
            this._diffuseAlpha = 1;
            this.color = color;
            this.alpha = alpha;
        }
        Object.defineProperty(ColorMaterial.prototype, "alpha", {
            /**
             * 透明度
             */
            get: function () {
                return _screenPass.diffuseMethod.diffuseAlpha;
            },
            set: function (value) {
                if (value > 1)
                    value = 1;
                else if (value < 0)
                    value = 0;
                _screenPass.diffuseMethod.diffuseAlpha = _diffuseAlpha = value;
                _screenPass.setBlendMode(blendMode == BlendMode.NORMAL && requiresBlending ? BlendMode.LAYER : blendMode);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ColorMaterial.prototype, "color", {
            /**
             * 颜色
             */
            get: function () {
                return _screenPass.diffuseMethod.diffuseColor;
            },
            set: function (value) {
                _screenPass.diffuseMethod.diffuseColor = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ColorMaterial.prototype, "requiresBlending", {
            get: function () {
                return _super.prototype.requiresBlending || _diffuseAlpha < 1;
            },
            enumerable: true,
            configurable: true
        });
        return ColorMaterial;
    }(feng3d.SinglePassMaterialBase));
    feng3d.ColorMaterial = ColorMaterial;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 纹理材质
     * @author feng 2014-4-15
     */
    var TextureMaterial = (function (_super) {
        __extends(TextureMaterial, _super);
        /**
         * 创建纹理材质
         * @param texture		纹理
         * @param smooth		是否平滑
         * @param repeat		是否重复
         * @param mipmap		是否使用mipmap
         */
        function TextureMaterial(texture, smooth, repeat, mipmap) {
            if (texture === void 0) { texture = null; }
            if (smooth === void 0) { smooth = true; }
            if (repeat === void 0) { repeat = false; }
            if (mipmap === void 0) { mipmap = true; }
            _super.call(this);
            this.texture = texture;
            this.smooth = smooth;
            this.repeat = repeat;
            this.mipmap = mipmap;
        }
        Object.defineProperty(TextureMaterial.prototype, "texture", {
            /**
             * 纹理
             */
            get: function () {
                return _screenPass.diffuseMethod.texture;
            },
            set: function (value) {
                _screenPass.diffuseMethod.texture = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TextureMaterial.prototype, "alpha", {
            /**
             * 透明度
             */
            get: function () {
                return _alpha;
            },
            set: function (value) {
                _alpha = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TextureMaterial.prototype, "ambientTexture", {
            /**
             * The texture object to use for the ambient colour.
             */
            get: function () {
                return _screenPass.ambientMethod.texture;
            },
            set: function (value) {
                _screenPass.ambientMethod.texture = value;
            },
            enumerable: true,
            configurable: true
        });
        return TextureMaterial;
    }(feng3d.SinglePassMaterialBase));
    feng3d.TextureMaterial = TextureMaterial;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * SpriteSheet材质
     * @author feng 2014-4-15
     */
    var SpriteSheetMaterial = (function (_super) {
        __extends(SpriteSheetMaterial, _super);
        /**
         * 创建SpriteSheetMaterial实例
         *
         * @param diffuses			漫反射纹理列表
         * @param normals			法线纹理列表
         * @param speculars			高光纹理列表
         * @param smooth			是否平滑
         * @param repeat			是否重复
         * @param mipmap			是否使用mipmap
         */
        function SpriteSheetMaterial(diffuses, normals, speculars, smooth, repeat, mipmap) {
            if (normals === void 0) { normals = null; }
            if (speculars === void 0) { speculars = null; }
            if (smooth === void 0) { smooth = true; }
            if (repeat === void 0) { repeat = false; }
            if (mipmap === void 0) { mipmap = true; }
            this._diffuses = diffuses;
            this._normals = normals;
            this._speculars = speculars;
            this.initTextures();
            _super.call(this, this._TBDiffuse, smooth, repeat, mipmap);
            if (this._TBNormal)
                this.normalMap = this._TBNormal;
            if (this._TBSpecular)
                this.specularMap = this._TBSpecular;
        }
        SpriteSheetMaterial.prototype.initTextures = function () {
            if (!this._diffuses || this._diffuses.length == 0)
                throw new Error("you must pass at least one bitmapdata into diffuses param!");
            this._TBDiffuse = this._diffuses[0];
            if (this._normals && this._normals.length > 0) {
                if (this._normals.length != this._diffuses.length)
                    throw new Error("The amount of normals bitmapDatas must be same as the amount of diffuses param!");
                this._TBNormal = this._normals[0];
            }
            if (this._speculars && this._speculars.length > 0) {
                if (this._speculars.length != this._diffuses.length)
                    throw new Error("The amount of normals bitmapDatas must be same as the amount of diffuses param!");
                this._TBSpecular = this._speculars[0];
            }
            this._currentMapID = 0;
        };
        /**
         * 切换
         * @param mapID			映射编号
         * @return				是否切换成功
         */
        SpriteSheetMaterial.prototype.swap = function (mapID) {
            if (mapID === void 0) { mapID = 0; }
            if (this._currentMapID != mapID) {
                this._currentMapID = mapID;
                this._TBDiffuse = this._diffuses[mapID];
                this.texture = this._TBDiffuse;
                if (this._TBNormal)
                    this.normalMap = this._TBNormal = this._normals[mapID];
                if (this._TBSpecular)
                    this.specularMap = this._TBSpecular = this._speculars[mapID];
                return true;
            }
            return false;
        };
        return SpriteSheetMaterial;
    }(feng3d.TextureMaterial));
    feng3d.SpriteSheetMaterial = SpriteSheetMaterial;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 天空盒材质
     * @author feng 2014-7-11
     */
    var SkyBoxMaterial = (function (_super) {
        __extends(SkyBoxMaterial, _super);
        /**
         * 创建天空盒材质实例
         * @param cubeMap			立方体映射纹理
         */
        function SkyBoxMaterial(cubeMap) {
            this._cubeMap = cubeMap;
            addPass(this._skyboxPass = new feng3d.SkyBoxPass());
            this._skyboxPass.cubeTexture = this._cubeMap;
        }
        Object.defineProperty(SkyBoxMaterial.prototype, "cubeMap", {
            /**
             * 立方体映射纹理
             */
            get: function () {
                return _cubeMap;
            },
            set: function (value) {
                if (value && _cubeMap && (value.hasMipMaps != _cubeMap.hasMipMaps || value.format != _cubeMap.format))
                    invalidatePasses(null);
                _cubeMap = value;
                _skyboxPass.cubeTexture = _cubeMap;
            },
            enumerable: true,
            configurable: true
        });
        return SkyBoxMaterial;
    }(feng3d.MaterialBase));
    feng3d.SkyBoxMaterial = SkyBoxMaterial;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    _Main;
    _Main;
    /**
     * 纹理通道基类
     * <p>该类实现了生成与管理渲染程序功能</p>
     * @author feng 2014-4-15
     */
    var MaterialPassBase = (function (_super) {
        __extends(MaterialPassBase, _super);
        /**
         * 创建一个纹理通道基类
         */
        function MaterialPassBase() {
            this._blendFactorSource = Context3DBlendFactor.ONE;
            this._blendFactorDest = Context3DBlendFactor.ZERO;
            this._depthCompareMode = Context3DCompareMode.LESS_EQUAL;
            this._defaultCulling = Context3DTriangleFace.BACK;
            this._writeDepth = true;
            this._smooth = true;
            this._repeat = false;
            this._mipmap = true;
            feng3d.AbstractClassError.check(this);
            this.context3DBufferOwner = new feng3d.Context3DBufferOwner();
            this.initBuffers();
        }
        Object.defineProperty(MaterialPassBase.prototype, "_", {
            /**
             * Fagal编号中心
             */
            get: function () {
                return FagalIdCenter.instance;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialPassBase.prototype, "material", {
            /**
             * The material to which this pass belongs.
             */
            get: function () {
                return _material;
            },
            set: function (value) {
                _material = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialPassBase.prototype, "shaderParams", {
            /**
             * 渲染参数
             */
            get: function () {
                return _shaderParams || ;
                new feng3d.ShaderParams();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialPassBase.prototype, "smooth", {
            /**
             * 是否平滑
             */
            get: function () {
                return _smooth;
            },
            set: function (value) {
                if (_smooth == value)
                    return;
                _smooth = value;
                invalidateShaderProgram();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialPassBase.prototype, "repeat", {
            /**
             * 是否重复平铺
             */
            get: function () {
                return _repeat;
            },
            set: function (value) {
                if (_repeat == value)
                    return;
                _repeat = value;
                invalidateShaderProgram();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialPassBase.prototype, "mipmap", {
            /**
             * 贴图是否使用分级细化
             */
            get: function () {
                return _mipmap;
            },
            set: function (value) {
                if (_mipmap == value)
                    return;
                _mipmap = value;
                invalidateShaderProgram();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialPassBase.prototype, "enableBlending", {
            /**
             * 是否开启混合模式
             */
            get: function () {
                return _enableBlending;
            },
            set: function (value) {
                _enableBlending = value;
                context3DBufferOwner.markBufferDirty(_.blendFactors);
                context3DBufferOwner.markBufferDirty(_.depthTest);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 初始化Context3d缓存
         */
        MaterialPassBase.prototype.initBuffers = function () {
            this.context3DBufferOwner.mapContext3DBuffer(this._.culling, this.updateCullingBuffer);
            this.context3DBufferOwner.mapContext3DBuffer(this._.blendFactors, this.updateBlendFactorsBuffer);
            this.context3DBufferOwner.mapContext3DBuffer(this._.depthTest, this.updateDepthTestBuffer);
            this.context3DBufferOwner.mapContext3DBuffer(this._.program, this.updateProgramBuffer);
        };
        Object.defineProperty(MaterialPassBase.prototype, "animationSet", {
            /**
             * 动画数据集合
             */
            get: function () {
                return _animationSet;
            },
            set: function (value) {
                if (_animationSet == value)
                    return;
                _animationSet = value;
                invalidateShaderProgram();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 激活渲染通道
         * @param shaderParams		渲染参数
         * @param stage3DProxy		3D舞台代理
         * @param camera			摄像机
         */
        MaterialPassBase.prototype.activate = function (camera, target) {
            if (target === void 0) { target = null; }
            this.shaderParams.useMipmapping = this._mipmap;
            this.shaderParams.useSmoothTextures = this._smooth;
            this.shaderParams.repeatTextures = this._repeat;
            this.shaderParams.alphaPremultiplied = this._alphaPremultiplied && this._enableBlending;
            if (this._animationSet)
                this._animationSet.activate(this.shaderParams, this);
        };
        /**
         * 清除通道渲染数据
         * @param stage3DProxy		3D舞台代理
         */
        MaterialPassBase.prototype.deactivate = function () {
        };
        /**
         * 更新动画状态
         * @param renderable			渲染对象
         * @param stage3DProxy			3D舞台代理
         * @param camera				摄像机
         */
        MaterialPassBase.prototype.updateAnimationState = function (renderable, camera) {
            renderable.animator.setRenderState(renderable, camera);
        };
        /**
         * 渲染
         * @param renderable			渲染对象
         * @param stage3DProxy			3D舞台代理
         * @param camera				摄像机
         * @param renderIndex			渲染编号
         */
        MaterialPassBase.prototype.render = function (renderable, stage3DProxy, camera, renderIndex) {
            this.updateConstantData(renderable, camera);
            var context3dCache = renderable.context3dCache;
            context3dCache.addChildBufferOwner(this.context3DBufferOwner);
            //设置渲染参数
            context3dCache.shaderParams = this.shaderParams;
            if (renderable.animator)
                this.updateAnimationState(renderable, camera);
            //绘制图形
            context3dCache.render(stage3DProxy.context3D, renderIndex);
            context3dCache.removeChildBufferOwner(this.context3DBufferOwner);
        };
        /**
         * 更新常量数据
         * @param renderable			渲染对象
         * @param camera				摄像机
         */
        MaterialPassBase.prototype.updateConstantData = function (renderable, camera) {
        };
        /**
         * 标记渲染程序失效
         */
        MaterialPassBase.prototype.invalidateShaderProgram = function () {
            this.context3DBufferOwner.markBufferDirty(this._.program);
        };
        /**
         * 更新深度测试缓冲
         * @param depthTestBuffer			深度测试缓冲
         */
        MaterialPassBase.prototype.updateDepthTestBuffer = function (depthTestBuffer) {
            depthTestBuffer.update(this._writeDepth && !this.enableBlending, this._depthCompareMode);
        };
        /**
         * 更新混合因子缓冲
         * @param blendFactorsBuffer		混合因子缓冲
         */
        MaterialPassBase.prototype.updateBlendFactorsBuffer = function (blendFactorsBuffer) {
            blendFactorsBuffer.update(this._blendFactorSource, this._blendFactorDest);
        };
        /**
         * 更新剔除模式缓冲
         * @param cullingBuffer		剔除模式缓冲
         */
        MaterialPassBase.prototype.updateCullingBuffer = function (cullingBuffer) {
            cullingBuffer.update(this._bothSides ? Context3DTriangleFace.NONE : this._defaultCulling);
        };
        /**
         * 更新（编译）渲染程序
         */
        MaterialPassBase.prototype.updateProgramBuffer = function (programBuffer) {
            var result = FagalRE.runShader(feng3d.V_Main, feng3d.F_Main);
            //上传程序
            programBuffer.update(result.vertexCode, result.fragmentCode);
        };
        Object.defineProperty(MaterialPassBase.prototype, "lightPicker", {
            /**
             * 灯光采集器
             */
            get: function () {
                return _lightPicker;
            },
            set: function (value) {
                if (_lightPicker)
                    _lightPicker.removeEventListener(feng3d.Event.CHANGE, onLightsChange);
                _lightPicker = value;
                if (_lightPicker)
                    _lightPicker.addEventListener(feng3d.Event.CHANGE, onLightsChange);
                updateLights();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 灯光发生变化
         */
        MaterialPassBase.prototype.onLightsChange = function (event) {
            this.updateLights();
        };
        /**
         * 更新灯光渲染
         */
        MaterialPassBase.prototype.updateLights = function () {
            if (this._lightPicker) {
                this._numPointLights = this._lightPicker.numPointLights;
                this._numDirectionalLights = this._lightPicker.numDirectionalLights;
            }
            this.invalidateShaderProgram();
        };
        /**
         * 设置混合模式
         * @param value		混合模式
         */
        MaterialPassBase.prototype.setBlendMode = function (value) {
            switch (value) {
                case BlendMode.NORMAL:
                    this._blendFactorSource = Context3DBlendFactor.ONE;
                    this._blendFactorDest = Context3DBlendFactor.ZERO;
                    this.enableBlending = false;
                    break;
                case BlendMode.LAYER:
                    this._blendFactorSource = Context3DBlendFactor.SOURCE_ALPHA;
                    this._blendFactorDest = Context3DBlendFactor.ONE_MINUS_SOURCE_ALPHA;
                    this.enableBlending = true;
                    break;
                case BlendMode.MULTIPLY:
                    this._blendFactorSource = Context3DBlendFactor.ZERO;
                    this._blendFactorDest = Context3DBlendFactor.SOURCE_COLOR;
                    this.enableBlending = true;
                    break;
                case BlendMode.ADD:
                    this._blendFactorSource = Context3DBlendFactor.SOURCE_ALPHA;
                    this._blendFactorDest = Context3DBlendFactor.ONE;
                    this.enableBlending = true;
                    break;
                case BlendMode.ALPHA:
                    this._blendFactorSource = Context3DBlendFactor.ZERO;
                    this._blendFactorDest = Context3DBlendFactor.SOURCE_ALPHA;
                    this.enableBlending = true;
                    break;
                case BlendMode.SCREEN:
                    this._blendFactorSource = Context3DBlendFactor.ONE;
                    this._blendFactorDest = Context3DBlendFactor.ONE_MINUS_SOURCE_COLOR;
                    this.enableBlending = true;
                    break;
                default:
                    throw new ArgumentError("Unsupported blend mode!");
            }
        };
        Object.defineProperty(MaterialPassBase.prototype, "writeDepth", {
            /**
             * 是否写入到深度缓存
             */
            get: function () {
                return _writeDepth;
            },
            set: function (value) {
                _writeDepth = value;
                context3DBufferOwner.markBufferDirty(_.depthTest);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialPassBase.prototype, "depthCompareMode", {
            /**
             * 深度比较模式
             */
            get: function () {
                return _depthCompareMode;
            },
            set: function (value) {
                _depthCompareMode = value;
                context3DBufferOwner.markBufferDirty(_.depthTest);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialPassBase.prototype, "bothSides", {
            /**
             * 是否双面渲染
             */
            get: function () {
                return _bothSides;
            },
            set: function (value) {
                _bothSides = value;
                context3DBufferOwner.markBufferDirty(_.culling);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 渲染中是否使用了灯光
         */
        MaterialPassBase.prototype.usesLights = function () {
            return (this._numPointLights > 0 || this._numDirectionalLights > 0);
        };
        Object.defineProperty(MaterialPassBase.prototype, "alphaPremultiplied", {
            /**
             * Indicates whether visible textures (or other pixels) used by this material have
             * already been premultiplied. Toggle this if you are seeing black halos around your
             * blended alpha edges.
             */
            get: function () {
                return _alphaPremultiplied;
            },
            set: function (value) {
                _alphaPremultiplied = value;
                invalidateShaderProgram();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Cleans up any resources used by the current object.
         * @param deep Indicates whether other resources should be cleaned up, that could potentially be shared across different instances.
         */
        MaterialPassBase.prototype.dispose = function () {
            if (this._lightPicker)
                this._lightPicker.removeEventListener(feng3d.Event.CHANGE, this.onLightsChange);
        };
        return MaterialPassBase;
    }(feng3d.Component));
    feng3d.MaterialPassBase = MaterialPassBase;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 编译通道
     * <p>用于处理复杂的渲染通道</p>
     * @author feng 2014-6-5
     */
    var CompiledPass = (function (_super) {
        __extends(CompiledPass, _super);
        /**
         * 创建一个编译通道类
         */
        function CompiledPass() {
            /**
             * 物体投影变换矩阵（模型空间坐标-->GPU空间坐标）
             */
            this.modelViewProjection = new Matrix3D();
            /**
             * 法线场景变换矩阵（模型空间坐标-->世界空间坐标）
             */
            this.normalSceneMatrix = new Matrix3D();
            /**
             * 场景变换矩阵（模型空间坐标-->世界空间坐标）
             */
            this.sceneTransformMatrix = new Matrix3D();
            /**
             * 世界投影矩阵（世界空间坐标-->投影空间坐标）
             */
            this.worldProjectionMatrix = new Matrix3D();
            /**
             * 通用数据
             */
            this.commonsData = number[]([0.5, 0, 1 / 255, 1]);
            /**
             * 摄像机世界坐标
             */
            this.cameraPosition = new number[](4);
            /**
             * 是否开启灯光衰减
             */
            this._enableLightFallOff = true;
            this.init();
        }
        /**
         * 初始化
         */
        CompiledPass.prototype.init = function () {
            _methodSetup = new feng3d.ShaderMethodSetup();
            _methodSetup.addEventListener(feng3d.ShadingMethodEvent.SHADER_INVALIDATED, this.onShaderInvalidated);
            this.context3DBufferOwner.addChildBufferOwner(_methodSetup.context3DBufferOwner);
        };
        /**
         * @inheritDoc
         */
        CompiledPass.prototype.initBuffers = function () {
            _super.prototype.initBuffers.call(this);
            this.context3DBufferOwner.mapContext3DBuffer(this._.commonsData_fc_vector, this.updateCommonsDataBuffer);
            this.context3DBufferOwner.mapContext3DBuffer(this._.cameraPosition_vc_vector, this.updateCameraPositionBuffer);
            this.context3DBufferOwner.mapContext3DBuffer(this._.projection_vc_matrix, this.updateProjectionBuffer);
            this.context3DBufferOwner.mapContext3DBuffer(this._.normalSceneTransform_vc_matrix, this.updateSceneNormalMatrixBuffer);
            this.context3DBufferOwner.mapContext3DBuffer(this._.sceneTransform_vc_matrix, this.updateSceneTransformMatrixBuffer);
            this.context3DBufferOwner.mapContext3DBuffer(this._.wordProjection_vc_matrix, this.updateWordProjectionMatrixBuffer);
        };
        /**
         * @inheritDoc
         */
        CompiledPass.prototype.activate = function (camera, target) {
            if (target === void 0) { target = null; }
            _super.prototype.activate.call(this, camera, target);
            var lightShaderParams = this.shaderParams.getOrCreateComponentByClass(feng3d.LightShaderParams);
            lightShaderParams.useLightFallOff = this._enableLightFallOff;
            _methodSetup.activate(this.shaderParams);
            this._ambientLightR = this._ambientLightG = this._ambientLightB = 0;
            if (usesLights())
                this.updateLightConstants();
            var ambientMethod = _methodSetup.ambientMethod;
            ambientMethod._lightAmbientR = this._ambientLightR;
            ambientMethod._lightAmbientG = this._ambientLightG;
            ambientMethod._lightAmbientB = this._ambientLightB;
        };
        /**
         * @inheritDoc
         */
        CompiledPass.prototype.updateConstantData = function (renderable, camera) {
            _super.prototype.updateConstantData.call(this, renderable, camera);
            //场景变换矩阵（物体坐标-->世界坐标）
            var sceneTransform = renderable.sourceEntity.getRenderSceneTransform(camera);
            //投影矩阵（世界坐标-->投影坐标）
            var projectionmatrix = camera.viewProjection;
            //全局变换矩阵
            this.sceneTransformMatrix.copyFrom(sceneTransform);
            //投影矩阵
            this.worldProjectionMatrix.copyFrom(projectionmatrix);
            //法线全局变换矩阵
            this.normalSceneMatrix.copyFrom(sceneTransform);
            //物体投影变换矩阵
            this.modelViewProjection.identity();
            this.modelViewProjection.append(sceneTransform);
            this.modelViewProjection.append(projectionmatrix);
            //摄像机世界坐标
            this.cameraPosition[0] = camera.scenePosition.x;
            this.cameraPosition[1] = camera.scenePosition.y;
            this.cameraPosition[2] = camera.scenePosition.z;
            this.cameraPosition[3] = 1;
            _methodSetup.setRenderState(renderable, camera);
        };
        /**
         * 更新摄像机坐标缓冲
         * @param cameraPositionBuffer		摄像机坐标缓冲
         */
        CompiledPass.prototype.updateCameraPositionBuffer = function (cameraPositionBuffer) {
            cameraPositionBuffer.update(this.cameraPosition);
        };
        /**
         * 更新通用缓冲
         * @param commonsDataBuffer		通用缓冲
         */
        CompiledPass.prototype.updateCommonsDataBuffer = function (commonsDataBuffer) {
            commonsDataBuffer.update(this.commonsData);
        };
        /**
         * 更新投影矩阵缓冲
         * @param projectionBuffer		投影矩阵缓冲
         */
        CompiledPass.prototype.updateProjectionBuffer = function (projectionBuffer) {
            projectionBuffer.update(this.modelViewProjection, true);
        };
        /**
         * 更新摄像机投影矩阵缓冲
         * @param cameraProjectionMatrixBuffer		摄像机投影矩阵缓冲
         */
        CompiledPass.prototype.updateWordProjectionMatrixBuffer = function (worldProjectionMatrixBuffer) {
            worldProjectionMatrixBuffer.update(this.worldProjectionMatrix, true);
        };
        /**
         * 更新场景变换矩阵缓冲
         * @param sceneTransformMatrixBuffer		场景变换矩阵缓冲
         */
        CompiledPass.prototype.updateSceneTransformMatrixBuffer = function (sceneTransformMatrixBuffer) {
            sceneTransformMatrixBuffer.update(this.sceneTransformMatrix, true);
        };
        /**
         * 更新法线场景变换矩阵缓冲
         * @param normalSceneMatrixBuffer			法线场景变换矩阵缓冲
         */
        CompiledPass.prototype.updateSceneNormalMatrixBuffer = function (normalSceneMatrixBuffer) {
            normalSceneMatrixBuffer.update(this.normalSceneMatrix, true);
        };
        /**
         * @inheritDoc
         */
        CompiledPass.prototype.updateProgramBuffer = function (programBuffer) {
            this.reset();
            _super.prototype.updateProgramBuffer.call(this, programBuffer);
        };
        /**
         * 重置编译通道
         */
        CompiledPass.prototype.reset = function () {
            this.initConstantData();
        };
        /**
         * 初始化常量数据
         */
        CompiledPass.prototype.initConstantData = function () {
            this.updateMethodConstants();
        };
        /**
         * 更新函数常量数据
         */
        CompiledPass.prototype.updateMethodConstants = function () {
            _methodSetup.initConstants();
        };
        Object.defineProperty(CompiledPass.prototype, "diffuseMethod", {
            /**
             * 漫反射方法，默认为BasicDiffuseMethod
             */
            get: function () {
                return _methodSetup.diffuseMethod;
            },
            set: function (value) {
                _methodSetup.diffuseMethod = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CompiledPass.prototype, "specularMethod", {
            /**
             * 镜面反射方法，默认为BasicSpecularMethod
             */
            get: function () {
                return _methodSetup.specularMethod;
            },
            set: function (value) {
                _methodSetup.specularMethod = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CompiledPass.prototype, "ambientMethod", {
            /**
             * 环境光方法，默认为BasicAmbientMethod
             */
            get: function () {
                return _methodSetup.ambientMethod;
            },
            set: function (value) {
                _methodSetup.ambientMethod = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CompiledPass.prototype, "normalMethod", {
            /**
             * 法线函数，默认为BasicNormalMethod
             */
            get: function () {
                return _methodSetup.normalMethod;
            },
            set: function (value) {
                _methodSetup.normalMethod = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CompiledPass.prototype, "enableLightFallOff", {
            /**
             * 是否开启灯光衰减，可以提高灯光渲染性能与真实性
             */
            get: function () {
                return _enableLightFallOff;
            },
            set: function (value) {
                if (value != _enableLightFallOff)
                    invalidateShaderProgram();
                _enableLightFallOff = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 处理渲染失效事件
         */
        CompiledPass.prototype.onShaderInvalidated = function (event) {
            var oldPasses = this._passes;
            this._passes = new feng3d.MaterialPassBase[]();
            if (_methodSetup)
                this.addPassesFromMethods();
            this.invalidateShaderProgram();
        };
        /**
         * Adds any possible passes needed by the used methods.
         */
        CompiledPass.prototype.addPassesFromMethods = function () {
            if (_methodSetup.normalMethod && _methodSetup.normalMethod.hasOutput)
                this.addPasses(_methodSetup.normalMethod.passes);
            if (_methodSetup.ambientMethod)
                this.addPasses(_methodSetup.ambientMethod.passes);
            if (_methodSetup.shadowMethod)
                this.addPasses(_methodSetup.shadowMethod.passes);
            if (_methodSetup.diffuseMethod)
                this.addPasses(_methodSetup.diffuseMethod.passes);
            if (_methodSetup.specularMethod)
                this.addPasses(_methodSetup.specularMethod.passes);
        };
        /**
         * Adds internal passes to the material.
         *
         * @param passes The passes to add.
         */
        CompiledPass.prototype.addPasses = function (passes) {
            if (!passes)
                return;
            var len = passes.length;
            for (var i = 0; i < len; ++i) {
                passes[i].material = this.material;
                passes[i].lightPicker = _lightPicker;
                this._passes.push(passes[i]);
            }
        };
        /**
         * 更新灯光常数数据
         */
        CompiledPass.prototype.updateLightConstants = function () {
        };
        Object.defineProperty(CompiledPass.prototype, "shadowMethod", {
            /**
             * 阴影映射函数
             */
            get: function () {
                return _methodSetup.shadowMethod;
            },
            set: function (value) {
                _methodSetup.shadowMethod = value;
            },
            enumerable: true,
            configurable: true
        });
        return CompiledPass;
    }(feng3d.MaterialPassBase));
    feng3d.CompiledPass = CompiledPass;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 超级渲染通道
     * <p>提供灯光渲染相关信息</p>
     * @author feng 2014-7-1
     */
    var SuperShaderPass = (function (_super) {
        __extends(SuperShaderPass, _super);
        /**
         * 创建超级渲染通道
         */
        function SuperShaderPass() {
            _super.call(this);
            /** 方向光源场景方向数据 */
            this.dirLightSceneDirData = new number[]();
            /** 方向光源漫反射光颜色数据 */
            this.dirLightDiffuseData = new number[]();
            /** 方向光源镜面反射颜色数据 */
            this.dirLightSpecularData = new number[]();
            /** 点光源场景位置数据 */
            this.pointLightScenePositionData = new number[]();
            /** 点光源漫反射光颜色数据 */
            this.pointLightDiffuseData = new number[]();
            /** 点光源镜面反射颜色数据 */
            this.pointLightSpecularData = new number[]();
        }
        Object.defineProperty(SuperShaderPass.prototype, "numMethods", {
            /**
             * The number of "effect" methods added to the material.
             */
            get: function () {
                return _methodSetup.numMethods;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        SuperShaderPass.prototype.initBuffers = function () {
            _super.prototype.initBuffers.call(this);
            this.context3DBufferOwner.mapContext3DBuffer(this._.dirLightSceneDir_fc_vector, this.updateDirLightSceneDirBuffer);
            this.context3DBufferOwner.mapContext3DBuffer(this._.dirLightDiffuse_fc_vector, this.updateDirLightDiffuseReg);
            this.context3DBufferOwner.mapContext3DBuffer(this._.dirLightSpecular_fc_vector, this.updateDirLightSpecularBuffer);
            this.context3DBufferOwner.mapContext3DBuffer(this._.pointLightScenePos_fc_vector, this.updatePointLightScenePositionBuffer);
            this.context3DBufferOwner.mapContext3DBuffer(this._.pointLightDiffuse_fc_vector, this.updatePointLightDiffuseReg);
            this.context3DBufferOwner.mapContext3DBuffer(this._.pointLightSpecular_fc_vector, this.updatePointLightSpecularBuffer);
        };
        SuperShaderPass.prototype.updateDirLightSpecularBuffer = function (dirLightSpecularBuffer) {
            dirLightSpecularBuffer.update(this.dirLightSpecularData);
        };
        SuperShaderPass.prototype.updateDirLightDiffuseReg = function (dirLightDiffuseBuffer) {
            dirLightDiffuseBuffer.update(this.dirLightDiffuseData);
        };
        SuperShaderPass.prototype.updateDirLightSceneDirBuffer = function (dirLightSceneDirBuffer) {
            dirLightSceneDirBuffer.update(this.dirLightSceneDirData);
        };
        SuperShaderPass.prototype.updatePointLightSpecularBuffer = function (pointLightSpecularBuffer) {
            pointLightSpecularBuffer.update(this.pointLightSpecularData);
        };
        SuperShaderPass.prototype.updatePointLightDiffuseReg = function (pointLightDiffuseBuffer) {
            pointLightDiffuseBuffer.update(this.pointLightDiffuseData);
        };
        SuperShaderPass.prototype.updatePointLightScenePositionBuffer = function (pointLightScenePositionBuffer) {
            pointLightScenePositionBuffer.update(this.pointLightScenePositionData);
        };
        /**
         * 添加特效函数
         * @param method		特效函数
         */
        SuperShaderPass.prototype.addMethod = function (method) {
            _methodSetup.addMethod(method);
        };
        /**
         * @inheritDoc
         */
        SuperShaderPass.prototype.activate = function (camera, target) {
            if (target === void 0) { target = null; }
            if (_lightPicker) {
                var lightShaderParams = this.shaderParams.getOrCreateComponentByClass(feng3d.LightShaderParams);
                lightShaderParams.numPointLights = _lightPicker.numPointLights;
                lightShaderParams.numDirectionalLights = _lightPicker.numDirectionalLights;
            }
            var methods = _methodSetup.methods;
            var len = methods.length;
            for (var i = 0; i < len; ++i) {
                methods[i].activate(this.shaderParams);
            }
            _super.prototype.activate.call(this, camera);
        };
        /**
         * @inheritDoc
         */
        SuperShaderPass.prototype.updateLightConstants = function () {
            var dirLight;
            var pointLight;
            var sceneDirection;
            var scenePosition;
            var len;
            var i, k;
            var dirLights = _lightPicker.directionalLights;
            len = dirLights.length;
            for (i = 0; i < len; ++i) {
                dirLight = dirLights[i];
                sceneDirection = dirLight.sceneDirection;
                _ambientLightR += dirLight._ambientR;
                _ambientLightG += dirLight._ambientG;
                _ambientLightB += dirLight._ambientB;
                this.dirLightSceneDirData[i * 4 + 0] = -sceneDirection.x;
                this.dirLightSceneDirData[i * 4 + 1] = -sceneDirection.y;
                this.dirLightSceneDirData[i * 4 + 2] = -sceneDirection.z;
                this.dirLightSceneDirData[i * 4 + 3] = 1;
                this.dirLightDiffuseData[i * 4 + 0] = dirLight._diffuseR;
                this.dirLightDiffuseData[i * 4 + 1] = dirLight._diffuseG;
                this.dirLightDiffuseData[i * 4 + 2] = dirLight._diffuseB;
                this.dirLightDiffuseData[i * 4 + 3] = 1;
                this.dirLightSpecularData[i * 4 + 0] = dirLight._specularR;
                this.dirLightSpecularData[i * 4 + 1] = dirLight._specularG;
                this.dirLightSpecularData[i * 4 + 2] = dirLight._specularB;
                this.dirLightSpecularData[i * 4 + 3] = 1;
            }
            var pointLights = _lightPicker.pointLights;
            len = pointLights.length;
            for (i = 0; i < len; ++i) {
                pointLight = pointLights[i];
                scenePosition = pointLight.scenePosition;
                _ambientLightR += pointLight._ambientR;
                _ambientLightG += pointLight._ambientG;
                _ambientLightB += pointLight._ambientB;
                this.pointLightScenePositionData[i * 4 + 0] = scenePosition.x;
                this.pointLightScenePositionData[i * 4 + 1] = scenePosition.y;
                this.pointLightScenePositionData[i * 4 + 2] = scenePosition.z;
                this.pointLightScenePositionData[i * 4 + 3] = 1;
                this.pointLightDiffuseData[i * 4 + 0] = pointLight._diffuseR;
                this.pointLightDiffuseData[i * 4 + 1] = pointLight._diffuseG;
                this.pointLightDiffuseData[i * 4 + 2] = pointLight._diffuseB;
                this.pointLightDiffuseData[i * 4 + 3] = pointLight._radius * pointLight._radius;
                this.pointLightSpecularData[i * 4 + 0] = pointLight._specularR;
                this.pointLightSpecularData[i * 4 + 1] = pointLight._specularG;
                this.pointLightSpecularData[i * 4 + 2] = pointLight._specularB;
                this.pointLightSpecularData[i * 4 + 3] = pointLight._fallOffFactor;
            }
        };
        return SuperShaderPass;
    }(feng3d.CompiledPass));
    feng3d.SuperShaderPass = SuperShaderPass;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    _Main_DepthMap;
    _Main_DepthMap;
    /**
     * 深度映射通道
     * @author feng 2015-5-29
     */
    var DepthMapPass = (function (_super) {
        __extends(DepthMapPass, _super);
        /**
         * 创建深度映射通道
         */
        function DepthMapPass() {
            _super.call(this);
            /**
             * 物体投影变换矩阵（模型空间坐标-->GPU空间坐标）
             */
            this.modelViewProjection = new Matrix3D();
            /**
             * 通用数据
             */
            this.depthCommonsData0 = number[]([1.0, 255.0, 255.0 * 255.0, 255.0 * 255.0 * 255.0]);
            /**
             * 通用数据
             */
            this.depthCommonsData1 = number[]([1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0]);
            /**
             * @inheritDoc
             */
            this.override = function render(renderable, stage3DProxy, camera, renderIndex) {
                //场景变换矩阵（物体坐标-->世界坐标）
                var sceneTransform = renderable.sourceEntity.getRenderSceneTransform(camera);
                //投影矩阵（世界坐标-->投影坐标）
                var projectionmatrix = camera.viewProjection;
                //物体投影变换矩阵
                this.modelViewProjection.identity();
                this.modelViewProjection.append(sceneTransform);
                this.modelViewProjection.append(projectionmatrix);
                _super.render.call(this, renderable, stage3DProxy, camera, renderIndex);
            };
        }
        Object.defineProperty(DepthMapPass.prototype, "depthMap", {
            /**
             * 深度图纹理
             */
            get: function () {
                return _depthMap;
            },
            set: function (value) {
                _depthMap = value;
                context3DBufferOwner.markBufferDirty(_.depthMap_oc);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        DepthMapPass.prototype.initBuffers = function () {
            _super.prototype.initBuffers.call(this);
            this.context3DBufferOwner.mapContext3DBuffer(this._.projection_vc_matrix, this.updateProjectionBuffer);
            this.context3DBufferOwner.mapContext3DBuffer(this._.depthCommonData0_fc_vector, this.updateDepthCommonData0Buffer);
            this.context3DBufferOwner.mapContext3DBuffer(this._.depthCommonData1_fc_vector, this.updateDepthCommonData1Buffer);
            this.context3DBufferOwner.mapContext3DBuffer(this._.depthMap_oc, this.updateTextureBuffer);
        };
        /**
         * 更新投影矩阵缓冲
         * @param projectionBuffer		投影矩阵缓冲
         */
        DepthMapPass.prototype.updateProjectionBuffer = function (projectionBuffer) {
            projectionBuffer.update(this.modelViewProjection, true);
        };
        /**
         * 更新深度顶点常数0 (1.0, 255.0, 65025.0, 16581375.0)
         * @param fcVectorBuffer
         */
        DepthMapPass.prototype.updateDepthCommonData0Buffer = function (fcVectorBuffer) {
            fcVectorBuffer.update(this.depthCommonsData0);
        };
        /**
         * 更新深度顶点常数1 (1.0/255.0, 1.0/255.0, 1.0/255.0, 0.0)
         * @param fcVectorBuffer
         */
        DepthMapPass.prototype.updateDepthCommonData1Buffer = function (fcVectorBuffer) {
            fcVectorBuffer.update(this.depthCommonsData1);
        };
        /**
         * 更新深度图纹理
         * @param textureBuffer
         */
        DepthMapPass.prototype.updateTextureBuffer = function (textureBuffer) {
            textureBuffer.update(this._depthMap);
        };
        /**
         * @inheritDoc
         */
        DepthMapPass.prototype.activate = function (camera, target) {
            if (target === void 0) { target = null; }
            //初始化渲染参数
            this.shaderParams.initParams();
            _super.prototype.activate.call(this, camera, target);
            this._depthMap = target;
        };
        /**
         * @inheritDoc
         */
        DepthMapPass.prototype.updateProgramBuffer = function (programBuffer) {
            var result = FagalRE.runShader(V_Main_DepthMap, F_Main_DepthMap);
            //上传程序
            programBuffer.update(result.vertexCode, result.fragmentCode);
        };
        return DepthMapPass;
    }(feng3d.MaterialPassBase));
    feng3d.DepthMapPass = DepthMapPass;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    _Main_PlanarShadow;
    _Main_PlanarShadow;
    /**
     * 平面阴影映射通道
     * @author feng 2015-5-29
     */
    var PlanarShadowPass = (function (_super) {
        __extends(PlanarShadowPass, _super);
        /**
         * 创建深度映射通道
         */
        function PlanarShadowPass() {
            _super.call(this);
            /**
             * 物体投影变换矩阵（模型空间坐标-->GPU空间坐标）
             */
            this.modelViewProjection = new Matrix3D();
            /**
             * 阴影颜色
             */
            this.shadowColorCommonsData = new number[](4);
            /**
             * @inheritDoc
             */
            this.override = function render(renderable, stage3DProxy, camera, renderIndex) {
                //场景变换矩阵（物体坐标-->世界坐标）
                var sceneTransform = renderable.sourceEntity.getRenderSceneTransform(camera);
                var shadowMatrix3D = this.getShadowMatrix3D();
                //投影矩阵（世界坐标-->投影坐标）
                var projectionmatrix = camera.viewProjection;
                //物体投影变换矩阵
                this.modelViewProjection.identity();
                this.modelViewProjection.append(sceneTransform);
                this.modelViewProjection.append(shadowMatrix3D);
                this.modelViewProjection.append(projectionmatrix);
                _super.render.call(this, renderable, stage3DProxy, camera, renderIndex);
            };
            this.shadowColorCommonsData = number[]([1, 0, 0, 1]);
        }
        /**
         * @inheritDoc
         */
        PlanarShadowPass.prototype.initBuffers = function () {
            _super.prototype.initBuffers.call(this);
            this.context3DBufferOwner.mapContext3DBuffer(this._.projection_vc_matrix, this.updateProjectionBuffer);
            this.context3DBufferOwner.mapContext3DBuffer(this._.shadowColorCommonsData_fc_vector, this.updateShadowColorCommonsDataBuffer);
        };
        /**
         * 更新投影矩阵缓冲
         * @param projectionBuffer		投影矩阵缓冲
         */
        PlanarShadowPass.prototype.updateProjectionBuffer = function (projectionBuffer) {
            projectionBuffer.update(this.modelViewProjection, true);
        };
        /**
         * 更新阴影颜色常数
         * @param fcVectorBuffer
         */
        PlanarShadowPass.prototype.updateShadowColorCommonsDataBuffer = function (fcVectorBuffer) {
            fcVectorBuffer.update(this.shadowColorCommonsData);
        };
        /**
         * 参考《实时阴影技术》P22
         * @return 平面投影矩阵
         */
        PlanarShadowPass.prototype.getShadowMatrix3D = function () {
            var _sunVector3D = new Vector3D(0, 10000, 0); //太阳的方向
            var l = _sunVector3D.clone();
            var n = new Vector3D(0, 1, 0);
            var nl = n.dotProduct(l);
            var d = -groundY;
            var mat1 = new Matrix3D(number[](//
            [nl + d - n.x * l.x, -n.y * l.x, -n.z * l.x, -d * l.x,
                -n.x * l.y, nl + d - n.y * l.y, -n.z * l.y, -d * l.y,
                -n.x * l.y, -n.y * l.z, nl + d - n.z * l.z, -d * l.z,
                -n.x, -n.y, -n.z, nl //
            ]));
            mat1.transpose();
            return mat1;
        };
        /**
         * @inheritDoc
         */
        PlanarShadowPass.prototype.updateProgramBuffer = function (programBuffer) {
            var result = FagalRE.runShader(V_Main_PlanarShadow, F_Main_PlanarShadow);
            //上传程序
            programBuffer.update(result.vertexCode, result.fragmentCode);
        };
        PlanarShadowPass.groundY = 50;
        return PlanarShadowPass;
    }(feng3d.MaterialPassBase));
    feng3d.PlanarShadowPass = PlanarShadowPass;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    _Segment;
    _Segment;
    /**
     * 线段渲染通道
     * @author feng 2014-4-16
     */
    var SegmentPass = (function (_super) {
        __extends(SegmentPass, _super);
        function SegmentPass(thickness) {
            /**
             * 常量数据
             */
            this.constants = new number[](4, true);
            /**
             * 摄像机坐标系到投影坐标系变换矩阵（c：camera，p：projection）
             */
            this.c2pMatrix = new Matrix3D();
            /**
             * 模型坐标系到摄像机坐标系变换矩阵（m：model，c：camera）
             */
            this.m2cMatrix = new Matrix3D();
            this._thickness = thickness;
            this.constants[1] = 1 / 255;
            _super.call(this);
        }
        /**
         * @inheritDoc
         */
        SegmentPass.prototype.initBuffers = function () {
            _super.prototype.initBuffers.call(this);
            this.context3DBufferOwner.mapContext3DBuffer(this._.segmentC2pMatrix_vc_matrix, this.updateC2pMatrixBuffer);
            this.context3DBufferOwner.mapContext3DBuffer(this._.segmentM2cMatrix_vc_matrix, this.updateM2cMatrixBuffer);
            this.context3DBufferOwner.mapContext3DBuffer(this._.segmentOne_vc_vector, this.updateOneBuffer);
            this.context3DBufferOwner.mapContext3DBuffer(this._.segmentFront_vc_vector, this.updateFrontBuffer);
            this.context3DBufferOwner.mapContext3DBuffer(this._.segmentConstants_vc_vector, this.updateConstantsBuffer);
        };
        SegmentPass.prototype.updateConstantsBuffer = function (constantsBuffer) {
            constantsBuffer.update(this.constants);
        };
        SegmentPass.prototype.updateFrontBuffer = function (frontBuffer) {
            frontBuffer.update(FRONT_VECTOR);
        };
        SegmentPass.prototype.updateOneBuffer = function (oneBuffer) {
            oneBuffer.update(ONE_VECTOR);
        };
        SegmentPass.prototype.updateC2pMatrixBuffer = function (c2pMatrixBuffer) {
            //设置摄像机投影矩阵
            c2pMatrixBuffer.update(this.c2pMatrix, true);
        };
        SegmentPass.prototype.updateM2cMatrixBuffer = function (m2cMatrixBuffer) {
            //设置投影矩阵
            m2cMatrixBuffer.update(this.m2cMatrix, true);
        };
        /**
         * @inheritDoc
         */
        SegmentPass.prototype.updateProgramBuffer = function (programBuffer) {
            var result = FagalRE.runShader(feng3d.V_Segment, feng3d.F_Segment);
            //上传程序
            programBuffer.update(result.vertexCode, result.fragmentCode);
        };
        /**
         * @inheritDoc
         */
        SegmentPass.prototype.updateConstantData = function (renderable, camera) {
            _super.prototype.updateConstantData.call(this, renderable, camera);
            //线段厚度
            this.constants[0] = this._thickness / 512;
            //摄像机最近距离
            this.constants[2] = camera.lens.near;
            //
            this.m2cMatrix.copyFrom(renderable.sourceEntity.sceneTransform);
            this.m2cMatrix.append(camera.inverseSceneTransform);
            this.c2pMatrix.copyFrom(camera.lens.matrix);
        };
        /**
         * (1,1,1,1)向量
         */
        SegmentPass.ONE_VECTOR = number[]([1, 1, 1, 1]);
        /**
         * 正面向量（Z轴负方向）
         */
        SegmentPass.FRONT_VECTOR = number[]([0, 0, -1, 0]);
        return SegmentPass;
    }(feng3d.MaterialPassBase));
    feng3d.SegmentPass = SegmentPass;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * The SingleObjectDepthPass provides a material pass that renders a single object to a depth map from the point
     * of view from a light.
     */
    var SingleObjectDepthPass = (function (_super) {
        __extends(SingleObjectDepthPass, _super);
        /**
         * Creates a new SingleObjectDepthPass object.
         * @param textureSize The size of the depth map texture to render to.
         * @param polyOffset The amount by which the rendered object will be inflated, to prevent depth map rounding errors.
         *
         * todo: provide custom vertex code to assembler
         */
        function SingleObjectDepthPass(textureSize, polyOffset) {
            if (textureSize === void 0) { textureSize = 512; }
            if (polyOffset === void 0) { polyOffset = 15; }
            _super.call(this);
            this._projectionTexturesInvalid = true;
            this._polyOffset = number[]([15, 0, 0, 0]);
            /**
             * 通用数据
             */
            this.depthCommonsData0 = number[]([1.0, 255.0, 65025.0, 16581375.0]);
            /**
             * 通用数据
             */
            this.depthCommonsData1 = number[]([1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0]);
            this.objectProjectionMatrix = new Matrix3D();
            this._textureSize = textureSize;
            this._polyOffset[0] = polyOffset;
            this._textures = {};
            this._projections = {};
            //			_enc = number[]([1.0, 255.0, 65025.0, 16581375.0, 1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0]);
            //			this.depthCommonsData0 = number[]([1.0, 255.0, 65025.0, 16581375.0]);
            //			this.depthCommonsData1 = number[]([1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0]);
            //			_animatableAttributes = string[](["va0", "va1"]);
            //			_animationTargetRegisters = string[](["vt0", "vt1"]);
        }
        SingleObjectDepthPass.prototype.initBuffers = function () {
            _super.prototype.initBuffers.call(this);
            this.context3DBufferOwner.mapContext3DBuffer(this._.SODP$polyOffset_vc_vector, this.updatePolyOffsetBuffer);
            this.context3DBufferOwner.mapContext3DBuffer(this._.SODP$objectProjection_vc_matrix, this.updateObjectProjectionBuffer);
            this.context3DBufferOwner.mapContext3DBuffer(this._.SODP$depthCommonsData0_fc_vector, this.updateDepthCommonsData0Buffer);
            this.context3DBufferOwner.mapContext3DBuffer(this._.SODP$depthCommonsData1_fc_vector, this.updateDepthCommonsData1Buffer);
        };
        SingleObjectDepthPass.prototype.updatePolyOffsetBuffer = function (vcVectorBuffer) {
            vcVectorBuffer.update(this._polyOffset);
        };
        SingleObjectDepthPass.prototype.updateObjectProjectionBuffer = function (vcMatrixBuffer) {
            vcMatrixBuffer.update(this.objectProjectionMatrix, true);
        };
        SingleObjectDepthPass.prototype.updateDepthCommonsData0Buffer = function (fcVectorBuffer) {
            fcVectorBuffer.update(this.depthCommonsData0);
        };
        SingleObjectDepthPass.prototype.updateDepthCommonsData1Buffer = function (fcVectorBuffer) {
            fcVectorBuffer.update(this.depthCommonsData1);
        };
        /**
         * @inheritDoc
         */
        SingleObjectDepthPass.prototype.dispose = function () {
            if (this._textures) {
                this._textures = null;
            }
        };
        /**
         * Updates the projection textures used to contain the depth renders.
         */
        SingleObjectDepthPass.prototype.updateProjectionTextures = function () {
            this._textures = {};
            this._projections = {};
            this._projectionTexturesInvalid = false;
        };
        /**
         * @inheritDoc
         */
        SingleObjectDepthPass.prototype.getVertexCode = function () {
            var _ =  * , FagalRE, instance, space;
            var vt7;
            var vt1;
            var vc4;
            var vt0;
            var vc0;
            var vt2;
            var op;
            var v0;
            // offset
            _.mul(vt7, vt1, vc4.x); //
            _.add(vt7, vt7, vt0); //
            _.mov(vt7.w, vt0.w);
            // project
            _.m44(vt2, vt7, vc0); //
            _.mov(op, vt2);
            // perspective divide
            _.div(v0, vt2, vt2.w);
        };
        /**
         * @inheritDoc
         */
        SingleObjectDepthPass.prototype.getFragmentCode = function (animationCode) {
            // encode float -> rgba
            var _ =  * , FagalRE, instance, space;
            var ft0;
            var fc0;
            var v0;
            var ft1;
            var fc1;
            var oc;
            _.mul(ft0, fc0, v0.z); //
            _.frc(ft0, ft0); //
            _.mul(ft1, ft0.yzww, fc1); //
            _.sub(ft0, ft0, ft1); //
            _.mov(oc, ft0);
        };
        /**
         * Gets the depth maps rendered for this object from all lights.
         * @param renderable The renderable for which to retrieve the depth maps.
         * @param stage3DProxy The Stage3DProxy object currently used for rendering.
         * @return A list of depth map textures for all supported lights.
         */
        SingleObjectDepthPass.prototype.getDepthMap = function (renderable) {
            this._textures || ;
            { }
            ;
            // todo: use texture proxy?
            var target = this._textures[renderable] || ;
            new feng3d.RenderTexture(this._textureSize, this._textureSize);
            //			stage3DProxy.setRenderTarget(target, true);
            //			context.clear(1.0, 1.0, 1.0);
            return this._textures[renderable];
        };
        /**
         * Retrieves the depth map projection maps for all lights.
         * @param renderable The renderable for which to retrieve the projection maps.
         * @return A list of projection maps for all supported lights.
         */
        SingleObjectDepthPass.prototype.getProjection = function (renderable) {
            var light;
            var lights = _lightPicker.allPickedLights;
            var matrix = this._projections[renderable] || ;
            new Matrix3D();
            // local position = enough
            light = lights[0];
            light.getObjectProjectionMatrix(renderable, matrix);
            this.objectProjectionMatrix.copyFrom(matrix);
            return this._projections[renderable];
        };
        /**
         * @inheritDoc
         */
        SingleObjectDepthPass.prototype.activate = function (camera, target) {
            if (target === void 0) { target = null; }
            if (this._projectionTexturesInvalid)
                this.updateProjectionTextures();
            // never scale
            _super.prototype.activate.call(this, camera, target);
        };
        return SingleObjectDepthPass;
    }(feng3d.MaterialPassBase));
    feng3d.SingleObjectDepthPass = SingleObjectDepthPass;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    _SkyBox;
    _SkyBox;
    /**
     * 天空盒通道
     * @author feng 2014-7-11
     */
    var SkyBoxPass = (function (_super) {
        __extends(SkyBoxPass, _super);
        /**
         * 创建一个天空盒通道
         */
        function SkyBoxPass() {
            _super.call(this);
            this.cameraPos = new number[](4);
            this.scaleSkybox = new number[](4);
            this.modelViewProjection = new Matrix3D();
        }
        /**
         * @inheritDoc
         */
        SkyBoxPass.prototype.initBuffers = function () {
            _super.prototype.initBuffers.call(this);
            this.context3DBufferOwner.mapContext3DBuffer(this._.skyboxTexture_fs, this.updateTextureBuffer);
            this.context3DBufferOwner.mapContext3DBuffer(this._.projection_vc_matrix, this.updateProjectionBuffer);
            this.context3DBufferOwner.mapContext3DBuffer(this._.camerapos_vc_vector, this.updateCameraPosBuffer);
            this.context3DBufferOwner.mapContext3DBuffer(this._.scaleSkybox_vc_vector, this.updateScaleSkyboxBuffer);
        };
        SkyBoxPass.prototype.updateProjectionBuffer = function (projectionBuffer) {
            projectionBuffer.update(this.modelViewProjection, true);
        };
        SkyBoxPass.prototype.updateCameraPosBuffer = function (cameraPosBuffer) {
            cameraPosBuffer.update(this.cameraPos);
        };
        SkyBoxPass.prototype.updateScaleSkyboxBuffer = function (scaleSkyboxBuffer) {
            scaleSkyboxBuffer.update(this.scaleSkybox);
        };
        SkyBoxPass.prototype.updateTextureBuffer = function (textureBuffer) {
            textureBuffer.update(this._cubeTexture);
        };
        /**
         * @inheritDoc
         */
        SkyBoxPass.prototype.updateDepthTestBuffer = function (depthTestBuffer) {
            _super.prototype.updateDepthTestBuffer.call(this, depthTestBuffer);
            depthTestBuffer.update(false, Context3DCompareMode.LESS);
        };
        Object.defineProperty(SkyBoxPass.prototype, "cubeTexture", {
            /**
             * 立方体纹理
             */
            get: function () {
                return _cubeTexture;
            },
            set: function (value) {
                _cubeTexture = value;
                context3DBufferOwner.markBufferDirty(_.skyboxTexture_fs);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        SkyBoxPass.prototype.updateProgramBuffer = function (programBuffer) {
            var result = FagalRE.runShader(feng3d.V_SkyBox, feng3d.F_SkyBox);
            //上传程序
            programBuffer.update(result.vertexCode, result.fragmentCode);
        };
        /**
         * @inheritDoc
         */
        SkyBoxPass.prototype.updateConstantData = function (renderable, camera) {
            _super.prototype.updateConstantData.call(this, renderable, camera);
            this.modelViewProjection.identity();
            this.modelViewProjection.append(renderable.sourceEntity.sceneTransform);
            this.modelViewProjection.append(camera.viewProjection);
        };
        /**
         * @inheritDoc
         */
        SkyBoxPass.prototype.activate = function (camera, target) {
            if (target === void 0) { target = null; }
            _super.prototype.activate.call(this, camera, target);
            var pos = camera.scenePosition;
            this.cameraPos[0] = pos.x;
            this.cameraPos[1] = pos.y;
            this.cameraPos[2] = pos.z;
            this.cameraPos[3] = 0;
            this.scaleSkybox[0] = this.scaleSkybox[1] = this.scaleSkybox[2] = camera.lens.far / Math.sqrt(4);
            this.scaleSkybox[3] = 1;
            //通用渲染参数
            this.shaderParams.addSampleFlags(this._.skyboxTexture_fs, this._cubeTexture, Context3DWrapMode.CLAMP);
        };
        return SkyBoxPass;
    }(feng3d.MaterialPassBase));
    feng3d.SkyBoxPass = SkyBoxPass;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 纹理代理基类
     * <p>处理纹理与stage3d的关系</p>
     * @author feng 2014-4-15
     */
    var TextureProxyBase = (function (_super) {
        __extends(TextureProxyBase, _super);
        /**
         * 创建一个纹理代理基类
         */
        function TextureProxyBase() {
            /**
             * 纹理格式
             */
            this._format = Context3DTextureFormat.BGRA;
            /**
             * 是否有miplevel
             */
            this._hasMipmaps = true;
            //			_namedAsset = new NamedAsset(this, AssetType.TEXTURE);
        }
        Object.defineProperty(TextureProxyBase.prototype, "hasMipMaps", {
            /**
             * 是否有miplevel
             */
            get: function () {
                return _hasMipmaps;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TextureProxyBase.prototype, "format", {
            /**
             * 纹理格式
             * @see flash.display3D.Context3DTextureFormat
             */
            get: function () {
                return _format;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TextureProxyBase.prototype, "width", {
            /**
             * 纹理宽度
             */
            get: function () {
                return _width;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TextureProxyBase.prototype, "height", {
            /**
             * 纹理高度
             */
            get: function () {
                return _height;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 设置纹理尺寸
         * @param width		纹理宽度
         * @param height	纹理高度
         */
        TextureProxyBase.prototype.setSize = function (width, height) {
            if (this._width != width || this._height != height)
                this.invalidateSize();
            this._width = width;
            this._height = height;
        };
        /**
         * 尺寸失效
         */
        TextureProxyBase.prototype.invalidateSize = function () {
        };
        /**
         * 纹理失效
         */
        TextureProxyBase.prototype.invalidateContent = function () {
        };
        return TextureProxyBase;
    }(feng3d.Component));
    feng3d.TextureProxyBase = TextureProxyBase;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 立方体纹理代理基类
     * @author feng 2014-7-12
     */
    var CubeTextureBase = (function (_super) {
        __extends(CubeTextureBase, _super);
        /**
         * 创建一个立方体纹理代理基类
         */
        function CubeTextureBase() {
            _super.call(this);
            this.type = feng3d.TextureType.TYPE_CUBE;
        }
        Object.defineProperty(CubeTextureBase.prototype, "size", {
            /**
             * 获取纹理尺寸
             */
            get: function () {
                return _width;
            },
            enumerable: true,
            configurable: true
        });
        return CubeTextureBase;
    }(feng3d.TextureProxyBase));
    feng3d.CubeTextureBase = CubeTextureBase;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 位图立方体纹理代理
     * @author feng 2014-7-12
     */
    var BitmapCubeTexture = (function (_super) {
        __extends(BitmapCubeTexture, _super);
        /**
         * 创建位图立方体纹理代理
         * @param posX			X正方向位图
         * @param negX			X负方向位图
         * @param posY			Y正方向位图
         * @param negY			Y负方向位图
         * @param posZ			Z正方向位图
         * @param negZ			Z负方向位图
         */
        function BitmapCubeTexture(posX, negX, posY, negY, posZ, negZ) {
            _super.call(this);
            this.optimizeForRenderToTexture = false;
            this.streamingLevels = 0;
            this._bitmapDatas = new BitmapData[](6, true);
            this.testSize(this._bitmapDatas[0] = posX);
            this.testSize(this._bitmapDatas[1] = negX);
            this.testSize(this._bitmapDatas[2] = posY);
            this.testSize(this._bitmapDatas[3] = negY);
            this.testSize(this._bitmapDatas[4] = posZ);
            this.testSize(this._bitmapDatas[5] = negZ);
            setSize(posX.width, posX.height);
        }
        Object.defineProperty(BitmapCubeTexture.prototype, "bitmapDatas", {
            /**
             * 位图列表
             */
            get: function () {
                return _bitmapDatas;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BitmapCubeTexture.prototype, "positiveX", {
            /**
             * 正X方向位图（右面位图）
             */
            get: function () {
                return _bitmapDatas[0];
            },
            set: function (value) {
                testSize(value);
                invalidateContent();
                setSize(value.width, value.height);
                _bitmapDatas[0] = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BitmapCubeTexture.prototype, "negativeX", {
            /**
             * 负X方向位图（左面位图）
             */
            get: function () {
                return _bitmapDatas[1];
            },
            set: function (value) {
                testSize(value);
                invalidateContent();
                setSize(value.width, value.height);
                _bitmapDatas[1] = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BitmapCubeTexture.prototype, "positiveY", {
            /**
             * 正Y方向位图（上面位图）
             */
            get: function () {
                return _bitmapDatas[2];
            },
            set: function (value) {
                testSize(value);
                invalidateContent();
                setSize(value.width, value.height);
                _bitmapDatas[2] = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BitmapCubeTexture.prototype, "negativeY", {
            /**
             * 负Y方向位图（下面位图）
             */
            get: function () {
                return _bitmapDatas[3];
            },
            set: function (value) {
                testSize(value);
                invalidateContent();
                setSize(value.width, value.height);
                _bitmapDatas[3] = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BitmapCubeTexture.prototype, "positiveZ", {
            /**
             * 正Z方向位图（前面位图）
             */
            get: function () {
                return _bitmapDatas[4];
            },
            set: function (value) {
                testSize(value);
                invalidateContent();
                setSize(value.width, value.height);
                _bitmapDatas[4] = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BitmapCubeTexture.prototype, "negativeZ", {
            /**
             * 负Z方向位图（后面位图）
             */
            get: function () {
                return _bitmapDatas[5];
            },
            set: function (value) {
                testSize(value);
                invalidateContent();
                setSize(value.width, value.height);
                _bitmapDatas[5] = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 检查位图尺寸
         * @param value		位图
         */
        BitmapCubeTexture.prototype.testSize = function (value) {
            if (value.width != value.height)
                throw new Error("BitmapData should have equal this.width and this.height!");
            if (!feng3d.TextureUtils.isBitmapDataValid(value))
                throw new Error("Invalid bitmapData: Width and this.height must be power of 2 and cannot exceed 2048");
        };
        return BitmapCubeTexture;
    }(feng3d.CubeTextureBase));
    feng3d.BitmapCubeTexture = BitmapCubeTexture;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 纹理基类
     * @author feng 2014-4-15
     */
    var Texture2DBase = (function (_super) {
        __extends(Texture2DBase, _super);
        function Texture2DBase() {
            _super.call(this);
            this.type = feng3d.TextureType.TYPE_2D;
        }
        return Texture2DBase;
    }(feng3d.TextureProxyBase));
    feng3d.Texture2DBase = Texture2DBase;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 位图纹理
     * @author feng 2014-3-24
     */
    var BitmapTexture = (function (_super) {
        __extends(BitmapTexture, _super);
        function BitmapTexture(bitmapData, generateMipmaps) {
            if (generateMipmaps === void 0) { generateMipmaps = true; }
            _super.call(this);
            this.bitmapData = bitmapData;
            this._generateMipmaps = generateMipmaps;
        }
        Object.defineProperty(BitmapTexture.prototype, "bitmapData", {
            get: function () {
                return _bitmapData;
            },
            set: function (value) {
                if (value == _bitmapData)
                    return;
                if (!feng3d.TextureUtils.isBitmapDataValid(value))
                    throw new Error("Invalid bitmapData: Width and height must be power of 2 and cannot exceed 2048");
                invalidateContent();
                setSize(value.width, value.height);
                _bitmapData = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BitmapTexture.prototype, "generateMipmaps", {
            get: function () {
                return _generateMipmaps;
            },
            set: function (value) {
                _generateMipmaps = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BitmapTexture.prototype, "mipMapHolder", {
            get: function () {
                return _mipMapHolder;
            },
            set: function (value) {
                _mipMapHolder = value;
            },
            enumerable: true,
            configurable: true
        });
        return BitmapTexture;
    }(feng3d.Texture2DBase));
    feng3d.BitmapTexture = BitmapTexture;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 渲染纹理
     * @author feng 2015-5-28
     */
    var RenderTexture = (function (_super) {
        __extends(RenderTexture, _super);
        /**
         * 创建一个渲染纹理
         * @param width			纹理宽度
         * @param height		纹理高度
         */
        function RenderTexture(width, height) {
            _super.call(this);
            setSize(width, height);
        }
        return RenderTexture;
    }(feng3d.Texture2DBase));
    feng3d.RenderTexture = RenderTexture;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 全局事件适配器
     * @author feng
     */
    var GlobalDispatcher = (function (_super) {
        __extends(GlobalDispatcher, _super);
        /**
         * 创建一个全局事件适配器
         * <p>此类为单例，只能构造一次，使用时请使用GlobalDispatcher.instance获取实例</p>
         */
        function GlobalDispatcher() {
            _super.call(this);
            if (GlobalDispatcher._instance)
                throw new Error("此类不允许外部创建，请用instance属性！");
            GlobalDispatcher._instance = this;
        }
        Object.defineProperty(GlobalDispatcher, "instance", {
            /**
             * 适配器实例
             */
            get: function () {
                return GlobalDispatcher._instance || new GlobalDispatcher();
            },
            enumerable: true,
            configurable: true
        });
        return GlobalDispatcher;
    }(feng3d.EventDispatcher));
    feng3d.GlobalDispatcher = GlobalDispatcher;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 完成一个任务单元时触发
     * @eventType me.feng.load.LoadUrlEvent
     */
    [feng3d.Event(name = "loadSingleComplete", type = "me.feng.load.LoadUrlEvent")][feng3d.Event(name = "loadComplete", type = "me.feng.load.LoadUrlEvent")];
    /**
     * 加载事件数据
     * @author feng 2015-5-27
     */
    var LoadModuleEventData = (function (_super) {
        __extends(LoadModuleEventData, _super);
        /**
         * 加载事件数据
         * @param urls		加载路径列表
         * @param data		自定义数据，可用于保存数据在加载资源后处理
         */
        function LoadModuleEventData(urls, data) {
            if (urls === void 0) { urls = null; }
            if (data === void 0) { data = null; }
            this.urls = urls;
            this.data = data;
        }
        Object.defineProperty(LoadModuleEventData.prototype, "urls", {
            /**
             * 加载路径列表
             */
            get: function () {
                return _urls;
            },
            /**
             * @private
             */
            set: function (value) {
                _urls = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LoadModuleEventData.prototype, "loadTaskItems", {
            /**
             * 加载任务列表
             * <p>该函数提供给加载模块内部使用，使用者并不需要知道</p>
             */
            get: function () {
                var _loadTaskItems = new feng3d.TaskItem[]();
                _loadTaskItems.length = 0;
                for (each(); ; )
                    var url;
                 in urls;
                {
                    _loadTaskItems.push(new feng3d.LoadTaskItem(url));
                }
                return _loadTaskItems;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LoadModuleEventData.prototype, "taskModuleEventData", {
            /**
             * 加载任务数据
             */
            get: function () {
                if (_taskModuleEventData == null) {
                    _taskModuleEventData = new feng3d.TaskModuleEventDispatchTaskData();
                    _taskModuleEventData.addEventListener(feng3d.TaskEvent.COMPLETEDITEM, onCompletedItem);
                    _taskModuleEventData.addEventListener(feng3d.TaskEvent.COMPLETED, onCompleted);
                }
                _taskModuleEventData.taskList = loadTaskItems;
                _taskModuleEventData.taskCollectionType = feng3d.TaskCollectionType.QUEUE;
                return _taskModuleEventData;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 处理完成加载单项事件
         */
        LoadModuleEventData.prototype.onCompletedItem = function (event) {
            var loadItemData = event.data;
            this.dispatchEvent(new feng3d.LoadUrlEvent(feng3d.LoadUrlEvent.LOAD_SINGLE_COMPLETE, loadItemData));
        };
        /**
         * 处理完成所有加载项事件
         */
        LoadModuleEventData.prototype.onCompleted = function (event) {
            this.dispatchEvent(new feng3d.LoadUrlEvent(feng3d.LoadUrlEvent.LOAD_COMPLETE));
        };
        return LoadModuleEventData;
    }(feng3d.EventDispatcher));
    feng3d.LoadModuleEventData = LoadModuleEventData;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 完成一个任务单元时触发
     * @eventType me.feng.events.TaskEvent
     */
    [feng3d.Event(name = "completedItem", type = "me.feng.task.TaskEvent")][feng3d.Event(name = "completed", type = "me.feng.task.TaskEvent")];
    /**
     * 任务模块事件数据
     * @author feng 2015-10-29
     */
    var TaskModuleEventDispatchTaskData = (function (_super) {
        __extends(TaskModuleEventDispatchTaskData, _super);
        function TaskModuleEventDispatchTaskData() {
            _super.apply(this, arguments);
            /**
             * 任务执行参数
             */
            this.params =  * ;
        }
        return TaskModuleEventDispatchTaskData;
    }(feng3d.EventDispatcher));
    feng3d.TaskModuleEventDispatchTaskData = TaskModuleEventDispatchTaskData;
    null;
    {
        this.taskList = taskList;
        this.taskCollectionType = taskCollectionType;
        this.params = params;
    }
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 完成任务时触发
     * @eventType me.feng.events.TaskEvent
     */
    [feng3d.Event(name = "completed", type = "me.feng.task.TaskEvent")];
    /**
     * 任务
     * @author feng 2015-5-27
     */
    var TaskItem = (function (_super) {
        __extends(TaskItem, _super);
        /**
         * 创建一个任务单元数据
         */
        function TaskItem() {
            /** 任务状态 */
            this._state = feng3d.TaskStateType.STATE_INIT;
            this._state = feng3d.TaskStateType.STATE_INIT;
        }
        Object.defineProperty(TaskItem.prototype, "state", {
            /**
             * 任务状态
             */
            get: function () {
                return _state;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 执行任务
         * @param params	执行参数
         */
        TaskItem.prototype.execute = ;
        return TaskItem;
    }(feng3d.EventDispatcher));
    feng3d.TaskItem = TaskItem;
    null;
    {
        this._state = feng3d.TaskStateType.STATE_EXECUTING;
    }
    doComplete();
    {
        this._state = feng3d.TaskStateType.STATE_COMPLETED;
        this.dispatchEvent(new feng3d.TaskEvent(feng3d.TaskEvent.COMPLETED));
    }
    destroy();
    {
    }
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 加载单元数据
     * @author feng 2015-5-27
     */
    var LoadTaskItem = (function (_super) {
        __extends(LoadTaskItem, _super);
        /**
         * 创建一个加载单元数据
         * @param url		加载路径信息
         */
        function LoadTaskItem(url) {
            if (url === void 0) { url =  * ; }
            this._url = null;
            this._type = null;
            if (url)
                is;
            string;
            {
                this._url = url;
            }
        }
        return LoadTaskItem;
    }(feng3d.TaskItem));
    feng3d.LoadTaskItem = LoadTaskItem;
    {
        this._type = url.type;
        this._url = url.url;
    }
})(feng3d || (feng3d = {}));
get;
loadingItem();
LoadingItem;
{
    return _loadingItem;
}
get;
type();
string;
{
    return _type;
}
get;
url();
string;
{
    return _url;
}
execute(param,  * , null);
{
    var loader = param;
    //加载资源
    if (!loader.hasItem(this._url)) {
        if (this._type) {
            loader.add(this._url, { this: .type, this: ._type });
        }
        else {
            loader.add(this._url);
        }
    }
    this._loadingItem = loader.get(this._url);
    if (this._loadingItem.isLoaded) {
        doComplete();
    }
    else {
        this._loadingItem.addEventListener(BulkLoader.COMPLETE, this.onLoadComplete);
    }
}
onLoadComplete(event, Event = null);
{
    this._loadingItem.removeEventListener(BulkLoader.COMPLETE, this.onLoadComplete);
    doComplete();
}
var feng3d;
(function (feng3d) {
    /**
     * 完成一个任务单元时触发
     * @eventType me.feng.events.TaskEvent
     */
    [feng3d.Event(name = "completedItem", type = "me.feng.task.TaskEvent")];
    /**
     * 任务集合，任务列表与任务队列等的基类
     * @author feng 2015-6-16
     */
    var TaskCollection = (function (_super) {
        __extends(TaskCollection, _super);
        /**
         * 创建一个任务集合
         * <p>该类为抽象类，无法直接被实例化，请使用其子类</p>
         */
        function TaskCollection() {
            feng3d.AbstractClassError.check(this);
            this.allItemList = new feng3d.TaskItem[]();
            this.executingItemList = new feng3d.TaskItem[]();
            this.completedItemList = new feng3d.TaskItem[]();
            _super.call(this);
        }
        Object.defineProperty(TaskCollection.prototype, "isComplete", {
            /**
             * 是否已经结束任务
             */
            get: function () {
                return completedItemList.length == allItemList.length;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        TaskCollection.prototype.execute = ;
        return TaskCollection;
    }(feng3d.TaskItem));
    feng3d.TaskCollection = TaskCollection;
    null;
    {
        _state = feng3d.TaskStateType.STATE_EXECUTING;
        this.waitingItemList = this.allItemList.concat();
        this.executingItemList.length = 0;
        this.completedItemList.length = 0;
        //判断是否已经完成任务
        if (this.isComplete) {
            doComplete();
            return;
        }
    }
    executeItem(taskItem, feng3d.TaskItem, params,  * );
    {
        this.executingItemList.push(taskItem);
        taskItem.execute(params);
    }
    addItem(item, feng3d.TaskItem);
    {
        if (this.allItemList.indexOf(item) == -1) {
            this.allItemList.push(item);
            item.addEventListener(feng3d.TaskEvent.COMPLETED, this.onCompletedItem);
            if (this.state == feng3d.TaskStateType.STATE_EXECUTING) {
                if (item.state == feng3d.TaskStateType.STATE_INIT || item.state == feng3d.TaskStateType.STATE_EXECUTING) {
                    this.executingItemList.push(item);
                }
                else if (item.state == feng3d.TaskStateType.STATE_COMPLETED) {
                    this.completedItemList.push(item);
                }
            }
        }
    }
    addItems(taskList, feng3d.TaskItem[]);
    {
        for (var i = 0; i < taskList.length; i++) {
            this.addItem(taskList[i]);
        }
    }
    removeItem(item, feng3d.TaskItem);
    {
        var index;
        index = this.allItemList.indexOf(item);
        if (index != -1) {
            this.allItemList.splice(index, 1);
            item.removeEventListener(feng3d.TaskEvent.COMPLETED, this.onCompletedItem);
        }
        index = this.executingItemList.indexOf(item);
        if (index != -1) {
            this.executingItemList.splice(index, 1);
        }
        index = this.completedItemList.indexOf(item);
        if (index != -1) {
            this.completedItemList.splice(index, 1);
        }
    }
    removeAllItem();
    {
        var item;
        while (this.allItemList.length > 0) {
            item = this.allItemList.pop();
            item.removeEventListener(feng3d.TaskEvent.COMPLETED, this.onCompletedItem);
            item.destroy();
        }
        this.waitingItemList.length = 0;
        this.executingItemList.length = 0;
        this.completedItemList.length = 0;
    }
    onCompletedItem(event, feng3d.TaskEvent);
    {
        var taskItem = event.currentTarget;
        var index = this.executingItemList.indexOf(taskItem);
        if (index != -1) {
            this.executingItemList.splice(index, 1);
        }
        else
            throw new Error("怎么会找不到" + taskItem + "呢？");
        this.completedItemList.push(taskItem);
        this.dispatchEvent(new feng3d.TaskEvent(feng3d.TaskEvent.COMPLETEDITEM, taskItem));
        this.checkComplete();
    }
    checkComplete();
    {
        if (this.isComplete) {
            doComplete();
        }
    }
    destroy();
    {
        _super.destroy.call(this);
        this.removeAllItem();
        this.allItemList = null;
        this.waitingItemList = null;
        this.executingItemList = null;
        this.completedItemList = null;
    }
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 任务列表
     * <p>所有子任务将会在同一时间开始执行</p>
     * @includeExample TaskListTest.as
     * @includeExample KeyDownTask.as
     *
     * @author feng 2014-7-24
     */
    var TaskList = (function (_super) {
        __extends(TaskList, _super);
        /**
         * 创建一个任务队列
         */
        function TaskList() {
            _super.call(this);
        }
        /**
         * 执行任务
         * @param params	执行参数
         */
        TaskList.prototype.execute = ;
        return TaskList;
    }(feng3d.TaskCollection));
    feng3d.TaskList = TaskList;
    null;
    {
        _super.execute.call(this, params);
        //执行所有子任务
        for (var i = 0; i < waitingItemList.length; i++) {
            executeItem(waitingItemList[i], params);
        }
        waitingItemList.length = 0;
    }
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 任务队列（按先后顺序依次完成子任务，只有完成当前任务才会开始下个任务）
     * @includeExample TaskQueueTest.as
     * @includeExample KeyDownTask.as
     * @author feng 2015-6-17
     */
    var TaskQueue = (function (_super) {
        __extends(TaskQueue, _super);
        /**
         * 创建任务队列
         */
        function TaskQueue() {
            _super.call(this);
            /**
             * 执行参数
             */
            this.executeParams =  * ;
        }
        /**
         * @inheritDoc
         */
        TaskQueue.prototype.execute = ;
        return TaskQueue;
    }(feng3d.TaskCollection));
    feng3d.TaskQueue = TaskQueue;
    null;
    {
        _super.execute.call(this, params);
        this.executeParams = params;
        this.executeNextTask();
    }
    executeNextTask();
    {
        if (waitingItemList.length > 0) {
            var taskItem = waitingItemList.shift();
            executeItem(taskItem, this.executeParams);
        }
    }
    onCompletedItem(event, feng3d.TaskEvent);
    {
        _super.onCompletedItem.call(this, event);
        this.executeNextTask();
    }
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 尝试获取可连接地址
     * @author feng 2015-12-15
     */
    var TryConnectURL = (function (_super) {
        __extends(TryConnectURL, _super);
        function TryConnectURL() {
            _super.apply(this, arguments);
        }
        TryConnectURL.prototype.tryConnect = function (urls) {
            this.connectedUrls = [];
            for (var i = 0; i < urls.length; i++) {
                this.addItem(new TryConnectURLTaskItem(urls[i]));
            }
            this.execute();
        };
        /**
         * @inheritDoc
         */
        TryConnectURL.prototype.onCompletedItem = function (event) {
            var taskItem = event.target;
            if (taskItem.result) {
                this.connectedUrls.push(taskItem.url);
            }
            _super.prototype.onCompletedItem.call(this, event);
        };
        return TryConnectURL;
    }(feng3d.TaskQueue));
    feng3d.TryConnectURL = TryConnectURL;
})(feng3d || (feng3d = {}));
/**
 * 尝试获取可连接地址
 * @author feng 2015-12-15
 */
var TryConnectURLTaskItem = (function (_super) {
    __extends(TryConnectURLTaskItem, _super);
    function TryConnectURLTaskItem() {
        _super.apply(this, arguments);
    }
    TryConnectURLTaskItem.prototype.constructorTaskItem = function (url) {
        this.url = url;
    };
    /**
     * @inheritDoc
     */
    TryConnectURLTaskItem.prototype.execute = ;
    return TryConnectURLTaskItem;
}(TaskItem));
null;
{
    this.tryConnect();
}
tryConnect();
{
    this.loader = new URLLoader();
    this.addListeners();
    var request = new URLRequest(this.url + "?version=" + Math.random());
    try {
        this.loader.load(request);
    }
    catch (error) {
        this.connectFailure();
    }
}
addListeners();
{
    this.loader.addEventListener(Event.COMPLETE, this.connectSucceed);
    this.loader.addEventListener(SecurityErrorEvent.SECURITY_ERROR, this.connectFailure);
    this.loader.addEventListener(IOErrorEvent.IO_ERROR, this.ioErrorHandler);
}
removeListeners();
{
    this.loader.removeEventListener(Event.COMPLETE, this.connectSucceed);
    this.loader.removeEventListener(SecurityErrorEvent.SECURITY_ERROR, this.connectFailure);
    this.loader.removeEventListener(IOErrorEvent.IO_ERROR, this.ioErrorHandler);
}
connectFailure.apply(void 0, args);
{
    this.result = false;
    this.connentEnd();
}
connectSucceed.apply(void 0, args);
{
    this.result = true;
    this.connentEnd();
}
connentEnd();
{
    this.removeListeners();
    this.loader = null;
    doComplete();
}
ioErrorHandler(event, IOErrorEvent);
{
    if (this.loader.bytesLoaded > 0) {
        this.connectSucceed();
    }
    else {
        this.connectFailure();
    }
}
var feng3d;
(function (feng3d) {
    /**
     * 摄像机镜头
     * @author feng 2014-10-14
     */
    var LensBase = (function (_super) {
        __extends(LensBase, _super);
        /**
         * 创建一个摄像机镜头
         */
        function LensBase() {
            this._scissorRect = new Rectangle();
            this._viewPort = new Rectangle();
            this._near = 20;
            this._far = 3000;
            this._aspectRatio = 1;
            this._matrixInvalid = true;
            this._frustumCorners = new number[](8 * 3, true);
            this._unprojectionInvalid = true;
            this._matrix = new Matrix3D();
            feng3d.AbstractClassError.check(this);
        }
        Object.defineProperty(LensBase.prototype, "frustumCorners", {
            /**
             * Retrieves the corner points of the lens frustum.
             */
            get: function () {
                return _frustumCorners;
            },
            set: function (frustumCorners) {
                _frustumCorners = frustumCorners;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LensBase.prototype, "matrix", {
            /**
             * 投影矩阵
             */
            get: function () {
                if (_matrixInvalid) {
                    updateMatrix();
                    _matrixInvalid = false;
                }
                return _matrix;
            },
            set: function (value) {
                _matrix = value;
                invalidateMatrix();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LensBase.prototype, "near", {
            /**
             * 最近距离
             */
            get: function () {
                return _near;
            },
            set: function (value) {
                if (value == _near)
                    return;
                _near = value;
                invalidateMatrix();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LensBase.prototype, "far", {
            /**
             * 最远距离
             */
            get: function () {
                return _far;
            },
            set: function (value) {
                if (value == _far)
                    return;
                _far = value;
                invalidateMatrix();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LensBase.prototype, "aspectRatio", {
            /**
             * 视窗缩放比例(width/height)，在渲染器中设置
             */
            get: function () {
                return _aspectRatio;
            },
            set: function (value) {
                if (_aspectRatio == value || (value * 0) != 0)
                    return;
                _aspectRatio = value;
                invalidateMatrix();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 场景坐标投影到屏幕坐标
         * @param point3d 场景坐标
         * @param v 屏幕坐标（输出）
         * @return 屏幕坐标
         */
        LensBase.prototype.project = function (point3d, v) {
            if (v === void 0) { v = null; }
            if (!v)
                v = new Vector3D();
            feng3d.Matrix3DUtils.transformVector(this.matrix, point3d, v);
            v.x = v.x / v.w;
            v.y = -v.y / v.w;
            //z is unaffected by transform
            v.z = point3d.z;
            return v;
        };
        Object.defineProperty(LensBase.prototype, "unprojectionMatrix", {
            /**
             * 投影逆矩阵
             */
            get: function () {
                if (_unprojectionInvalid) {
                    _unprojection || ;
                    new Matrix3D();
                    _unprojection.copyFrom(matrix);
                    _unprojection.invert();
                    _unprojectionInvalid = false;
                }
                return _unprojection;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 屏幕坐标投影到摄像机空间坐标
         * @param nX 屏幕坐标X -1（左） -> 1（右）
         * @param nY 屏幕坐标Y -1（上） -> 1（下）
         * @param sZ 到屏幕的距离
         * @param v 场景坐标（输出）
         * @return 场景坐标
         */
        LensBase.prototype.unproject = function (nX, nY, sZ, v) {
            if (v === void 0) { v = null; }
            throw new feng3d.AbstractMethodError();
        };
        /**
         * 投影矩阵失效
         */
        LensBase.prototype.invalidateMatrix = function () {
            this._matrixInvalid = true;
            this._unprojectionInvalid = true;
            // notify the camera that the lens this.matrix is changing. this will mark the 
            // viewProjectionMatrix in the camera as invalid, and force the this.matrix to
            // be re-queried from the lens, and therefore rebuilt.
            this.dispatchEvent(new feng3d.LensEvent(feng3d.LensEvent.MATRIX_CHANGED, this));
        };
        /**
         * 更新投影矩阵
         */
        LensBase.prototype.updateMatrix = function () {
            throw new feng3d.AbstractMethodError();
        };
        return LensBase;
    }(feng3d.EventDispatcher));
    feng3d.LensBase = LensBase;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     *
     * @author feng 2015-5-28
     */
    var FreeMatrixLens = (function (_super) {
        __extends(FreeMatrixLens, _super);
        function FreeMatrixLens() {
            _super.call(this);
        }
        FreeMatrixLens.prototype.updateMatrix = function () {
            _matrixInvalid = false;
        };
        return FreeMatrixLens;
    }(feng3d.LensBase));
    feng3d.FreeMatrixLens = FreeMatrixLens;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 透视摄像机镜头
     * @author feng 2014-10-14
     */
    var PerspectiveLens = (function (_super) {
        __extends(PerspectiveLens, _super);
        /**
         * 创建一个透视摄像机镜头
         * @param fieldOfView 视野
         * @param coordinateSystem 坐标系统类型
         */
        function PerspectiveLens(fieldOfView, coordinateSystem) {
            if (fieldOfView === void 0) { fieldOfView = 60; }
            if (coordinateSystem === void 0) { coordinateSystem = feng3d.CoordinateSystem.LEFT_HANDED; }
            _super.call(this);
            this.fieldOfView = fieldOfView;
            this.coordinateSystem = coordinateSystem;
        }
        Object.defineProperty(PerspectiveLens.prototype, "fieldOfView", {
            /**
             * 视野
             */
            get: function () {
                return _fieldOfView;
            },
            set: function (value) {
                if (value == _fieldOfView)
                    return;
                _fieldOfView = value;
                _focalLengthInv = Math.tan(_fieldOfView * Math.PI / 360);
                _focalLength = 1 / _focalLengthInv;
                invalidateMatrix();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PerspectiveLens.prototype, "focalLength", {
            /**
             * 焦距
             */
            get: function () {
                return _focalLength;
            },
            set: function (value) {
                if (value == _focalLength)
                    return;
                _focalLength = value;
                _focalLengthInv = 1 / _focalLength;
                _fieldOfView = Math.atan(_focalLengthInv) * 360 / Math.PI;
                invalidateMatrix();
            },
            enumerable: true,
            configurable: true
        });
        PerspectiveLens.prototype.unproject = function (nX, nY, sZ, v) {
            if (v === void 0) { v = null; }
            if (!v)
                v = new Vector3D();
            v.x = nX;
            v.y = -nY;
            v.z = sZ;
            v.w = 1;
            v.x *= sZ;
            v.y *= sZ;
            feng3d.Matrix3DUtils.transformVector(this.unprojectionMatrix, v, v);
            //z is unaffected by transform
            v.z = sZ;
            return v;
        };
        Object.defineProperty(PerspectiveLens.prototype, "coordinateSystem", {
            /**
             * 坐标系类型
             */
            get: function () {
                return _coordinateSystem;
            },
            set: function (value) {
                if (value == _coordinateSystem)
                    return;
                _coordinateSystem = value;
                invalidateMatrix();
            },
            enumerable: true,
            configurable: true
        });
        PerspectiveLens.prototype.updateMatrix = function () {
            var raw = feng3d.Matrix3DUtils.RAW_DATA_CONTAINER;
            this._yMax = _near * this._focalLengthInv;
            this._xMax = this._yMax * _aspectRatio;
            var left, right, top, bottom;
            if (_scissorRect.x == 0 && _scissorRect.y == 0 && _scissorRect.width == _viewPort.width && _scissorRect.height == _viewPort.height) {
                // assume unscissored frustum
                left = -this._xMax;
                right = this._xMax;
                top = -this._yMax;
                bottom = this._yMax;
                // assume unscissored frustum
                raw[number(0)] = _near / this._xMax;
                raw[number(5)] = _near / this._yMax;
                raw[number(10)] = _far / (_far - _near);
                raw[number(11)] = 1;
                raw[number(1)] = raw[number(2)] = raw[number(3)] = raw[number(4)] = raw[number(6)] = raw[number(7)] = raw[number(8)] = raw[number(9)] = raw[number(12)] = raw[number(13)] = raw[number(15)] = 0;
                raw[number(14)] = -_near * raw[number(10)];
            }
            else {
                // assume scissored frustum
                var xWidth = this._xMax * (_viewPort.width / _scissorRect.width);
                var yHgt = this._yMax * (_viewPort.height / _scissorRect.height);
                var center = this._xMax * (_scissorRect.x * 2 - _viewPort.width) / _scissorRect.width + this._xMax;
                var middle = -this._yMax * (_scissorRect.y * 2 - _viewPort.height) / _scissorRect.height - this._yMax;
                left = center - xWidth;
                right = center + xWidth;
                top = middle - yHgt;
                bottom = middle + yHgt;
                raw[number(0)] = 2 * _near / (right - left);
                raw[number(5)] = 2 * _near / (bottom - top);
                raw[number(8)] = (right + left) / (right - left);
                raw[number(9)] = (bottom + top) / (bottom - top);
                raw[number(10)] = (_far + _near) / (_far - _near);
                raw[number(11)] = 1;
                raw[number(1)] = raw[number(2)] = raw[number(3)] = raw[number(4)] = raw[number(6)] = raw[number(7)] = raw[number(12)] = raw[number(13)] = raw[number(15)] = 0;
                raw[number(14)] = -2 * _far * _near / (_far - _near);
            }
            // Switch projection transform from left to right handed.
            if (this._coordinateSystem == feng3d.CoordinateSystem.RIGHT_HANDED)
                raw[number(5)] = -raw[number(5)];
            _matrix.copyRawDataFrom(raw);
            var yMaxFar = _far * this._focalLengthInv;
            var xMaxFar = yMaxFar * _aspectRatio;
            _frustumCorners[0] = _frustumCorners[9] = left;
            _frustumCorners[3] = _frustumCorners[6] = right;
            _frustumCorners[1] = _frustumCorners[4] = top;
            _frustumCorners[7] = _frustumCorners[10] = bottom;
            _frustumCorners[12] = _frustumCorners[21] = -xMaxFar;
            _frustumCorners[15] = _frustumCorners[18] = xMaxFar;
            _frustumCorners[13] = _frustumCorners[16] = -yMaxFar;
            _frustumCorners[19] = _frustumCorners[22] = yMaxFar;
            _frustumCorners[2] = _frustumCorners[5] = _frustumCorners[8] = _frustumCorners[11] = _near;
            _frustumCorners[14] = _frustumCorners[17] = _frustumCorners[20] = _frustumCorners[23] = _far;
            _matrixInvalid = false;
        };
        return PerspectiveLens;
    }(feng3d.LensBase));
    feng3d.PerspectiveLens = PerspectiveLens;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * Fagal函数追加代码事件
     */
    [feng3d.Event(name = "fagalMathEventAppend", type = "me.feng3d.events.FagalMathEvent")];
    /**
     * Fagal数学运算
     * @author feng 2015-7-22
     */
    var FagalMath = (function (_super) {
        __extends(FagalMath, _super);
        function FagalMath() {
            _super.apply(this, arguments);
        }
        /**
         * destination=abs(source1):一个寄存器的绝对值，分量形式
         */
        FagalMath.prototype.abs = function (destination, source1) {
            var code = "this.abs " + destination + ", " + source1;
            this.append(code);
        };
        /**
         * destination=source1+source2:两个寄存器相加，分量形式
         */
        FagalMath.prototype.add = function (destination, source1, source2) {
            var code = "this.add " + destination + ", " + source1 + ", " + source2;
            this.append(code);
        };
        /**
         * destination=cos(source1):一个寄存器的余弦值，分量形式
         */
        FagalMath.prototype.cos = function (destination, source1) {
            var code = "this.cos " + destination + ", " + source1;
            this.append(code);
        };
        /**
         * crs:两个寄存器间的叉积
         * <p>destination.x=source1.y*source2.z-source1.z*source2.y</p>
         * <p>destination.y=source1.z*source2.x-source1.x*source2.z</p>
         * <p>destination.z=source1.x*source2.y-source1.y*source2.x</p>
         */
        FagalMath.prototype.crs = function (destination, source1, source2) {
            var code = "this.crs " + destination + ", " + source1 + ", " + source2;
            this.append(code);
        };
        /**
         * destination=source1/source2:两个寄存器相除，分量形式
         */
        FagalMath.prototype.div = function (destination, source1, source2) {
            var code = "this.div " + destination + ", " + source1 + ", " + source2;
            this.append(code);
        };
        /**
         * dp3:两个寄存器间的点积，3分量
         * <br/>
         * destination=source1.x*source2.x+source1.y*source2.y+source1.z*source2.z
         */
        FagalMath.prototype.dp3 = function (destination, source1, source2) {
            var code = "this.dp3 " + destination + ", " + source1 + ", " + source2;
            this.append(code);
        };
        /**
         * dp4:两个寄存器间的点积，4分量
         * <br/>
         * destination=source1.x*source2.x+source1.y*source2.y+source1.z*source2.z+source1.w+source2.w
         */
        FagalMath.prototype.dp4 = function (destination, source1, source2) {
            var code = "this.dp4 " + destination + ", " + source1 + ", " + source2;
            this.append(code);
        };
        /**
         * destination=2^source1:2的source1次方，分量形式
         */
        FagalMath.prototype.exp = function (destination, source1) {
            var code = "this.exp " + destination + ", " + source1;
            this.append(code);
        };
        /**
         * destination=source1-(float)floor(source1)一个寄存器的分数部分，分量形式
         */
        FagalMath.prototype.frc = function (destination, source1) {
            var code = "this.frc " + destination + ", " + source1;
            this.append(code);
        };
        /**
         * 如果寄存器有任意一个分量小于0，则丢弃该像素不进行绘制(只适用于片段着色器)
         */
        FagalMath.prototype.kil = function (source1) {
            var code = "this.kil " + source1;
            this.append(code);
        };
        /**
         * destination=log(source1)一个寄存器以2为底的对数，分量形式
         */
        FagalMath.prototype.log = function (destination, source1) {
            var code = "this.log " + destination + ", " + source1;
            this.append(code);
        };
        /**
         * m33:由一个3*3的矩阵对一个3分量的向量进行矩阵乘法
         * <br/>
         * destination.x=(source1.x*source2[0].x)+(source1.y*source2[0].y)+(source1.z*source2[0].z)
         * <br/>
         * destination.y=(source1.x*source2[1].x)+(source1.y*source2[1].y)+(source1.z*source2[1].z)
         * <br/>
         * destination.z=(source1.x*source2[2].x)+(source1.y*source2[2].y)+(source1.z*source2[2].z)

         */
        FagalMath.prototype.m33 = function (destination, source1, source2) {
            var code = "this.m33 " + destination + ", " + source1 + ", " + source2;
            this.append(code);
        };
        /**
         * m34:由一个3*4的矩阵对一个4分量的向量进行矩阵乘法
         * <br/>
         * destination.x=(source1.x*source2[0].x)+(source1.y*source2[0].y)+(source1.z*source2[0].z)+(source1.w*source2[0].w)
         * <br/>
         * destination.y=(source1.x*source2[1].x)+(source1.y*source2[1].y)+(source1.z*source2[1].z)+(source1.w*source2[1].w)
         * <br/>destination.z=(source1.x*source2[2].x)+(source1.y*source2[2].y)+(source1.z*source2[2].z)+(source1.w*source2[2].w)

         */
        FagalMath.prototype.m34 = function (destination, source1, source2) {
            var code = "this.m34 " + destination + ", " + source1 + ", " + source2;
            this.append(code);
        };
        /**
         * m44:由一个4*4的矩阵对一个4分量的向量进行矩阵乘法
         * <br/>
         * destination.x=(source1.x*source2[0].x)+(source1.y*source2[0].y)+(source1.z*source2[0].z)+(source1.w*source2[0].w)
         * <br/>
         * destination.y=(source1.x*source2[1].x)+(source1.y*source2[1].y)+(source1.z*source2[1].z)+(source1.w*source2[1].w)
         * <br/>
         * destination.z=(source1.x*source2[2].x)+(source1.y*source2[2].y)+(source1.z*source2[2].z)+(source1.w*source2[2].w)
         * <br/>
         * destination.w=(source1.x*source2[3].x)+(source1.y*source2[3].y)+(source1.z*source2[3].z)+(source1.w*source2[3].w)
         */
        FagalMath.prototype.m44 = function (destination, source1, source2) {
            var code = "this.m44 " + destination + ", " + source1 + ", " + source2;
            this.append(code);
        };
        /**
         * max:destination=max(source1 ，source2): 两个寄存器之间的较大值，分量形式
         */
        FagalMath.prototype.max = function (destination, source1, source2) {
            var code = "this.max " + destination + ", " + source1 + ", " + source2;
            this.append(code);
        };
        /**
         * min:destination=min(source1 ， source2) : 两个寄存器之间的较小值，分量形式
         */
        FagalMath.prototype.min = function (destination, source1, source2) {
            var code = "this.min " + destination + ", " + source1 + ", " + source2;
            this.append(code);
        };
        /**
         * mov:destination=source :将数据从源寄存器复制到目标寄存器
         */
        FagalMath.prototype.mov = function (destination, source1) {
            var code = "this.mov " + destination + ", " + source1;
            this.append(code);
        };
        /**
         * destination = source1 * source2:两个寄存器相乘，分量形式
         */
        FagalMath.prototype.mul = function (destination, source1, source2) {
            var code = "this.mul " + destination + ", " + source1 + ", " + source2;
            this.append(code);
        };
        /**
         * destination=-source1:一个寄存器取反，分量形式
         */
        FagalMath.prototype.neg = function (destination, source1) {
            var code = "this.neg " + destination + ", " + source1;
            this.append(code);
        };
        /**
         * destination=normalize(source1):将一个寄存器标准化为长度1的单位向量
         */
        FagalMath.prototype.nrm = function (destination, source1) {
            var code = "this.nrm " + destination + ", " + source1;
            this.append(code);
        };
        /**
         * destination=pow(source1 ，source2):source1的source2次冥，分量形式
         */
        FagalMath.prototype.pow = function (destination, source1, source2) {
            var code = "this.pow " + destination + ", " + source1 + ", " + source2;
            this.append(code);
        };
        /**
         * destination=1/source1:一个寄存器的倒数，分量形式
         */
        FagalMath.prototype.rcp = function (destination, source1) {
            var code = "this.rcp " + destination + ", " + source1;
            this.append(code);
        };
        /**
         * destination=1/sqrt(source) 一个寄存器的平方根倒数，分量形式
         */
        FagalMath.prototype.rsq = function (destination, source1) {
            var code = "this.rsq " + destination + ", " + source1;
            this.append(code);
        };
        /**
         * destination=max(min(source1,1),0):将一个寄存器锁0-1的范围里
         */
        FagalMath.prototype.sat = function (destination, source1) {
            var code = "this.sat " + destination + ", " + source1;
            this.append(code);
        };
        /**
         * destination= source1==source2 ? 1 : 0
         */
        FagalMath.prototype.seq = function (destination, source1, source2) {
            var code = "this.seq " + destination + ", " + source1 + ", " + source2;
            this.append(code);
        };
        /**
         * destination = source1>=source2 ? 1 : 0 类似三元操作符 分量形式
         */
        FagalMath.prototype.sge = function (destination, source1, source2) {
            var code = "this.sge " + destination + ", " + source1 + ", " + source2;
            this.append(code);
        };
        /**
         * destination=sin(source1):一个寄存器的正弦值，分量形式
         */
        FagalMath.prototype.sin = function (destination, source1) {
            var code = "this.sin " + destination + ", " + source1;
            this.append(code);
        };
        /**
         * destination = source1小于source2 ? 1 : 0
         */
        FagalMath.prototype.slt = function (destination, source1, source2) {
            var code = "this.slt " + destination + ", " + source1 + ", " + source2;
            this.append(code);
        };
        /**
         * destination=source1!=source2 ? 1:0
         */
        FagalMath.prototype.sne = function (destination, source1, source2) {
            var code = "this.sne " + destination + ", " + source1 + ", " + source2;
            this.append(code);
        };
        /**
         * destination=sqrt(source):一个寄存器的平方根，分量形式
         */
        FagalMath.prototype.sqt = function (destination, source1) {
            var code = "this.sqt " + destination + ", " + source1;
            this.append(code);
        };
        /**
         * destination=source1-source2:两个寄存器相减，分量形式
         */
        FagalMath.prototype.sub = function (destination, source1, source2) {
            var code = "this.sub " + destination + ", " + source1 + ", " + source2;
            this.append(code);
        };
        /**
         * 纹理取样
         * @param	colorReg	目标寄存器
         * @param	uvReg		UV坐标
         * @param	textureReg	纹理寄存器
         * @param	flags		取样参数
         */
        FagalMath.prototype.tex = function (colorReg, uvReg, textureReg) {
            var code = "this.tex " + colorReg + ", " + uvReg + ", " + textureReg;
            //获取法线纹理采样参数
            var flags = getSampleFlags(textureReg);
            if (flags && flags.length > 0) {
                code += " <" + flags.join(",") + ">";
            }
            this.append(code);
            /**
             * 获取取样参数
             * @param textureReg 纹理寄存器
             * @return 取样参数
             */
            function getSampleFlags(textureReg) {
                //抛出 获取取样标记 事件
                var shaderParams = FagalRE.instance.context3DCache.shaderParams;
                //提取 渲染标记
                var flags = shaderParams.getFlags(textureReg.regId);
                return flags;
            }
        };
        /**
         * 混合数据
         * <p>destination = source1 + (source2-source1) x factor</p>
         * @author feng 2015-7-4
         */
        FagalMath.prototype.blend = function (destination, source1, source2, factor) {
            this.sub(source2, source2, source1);
            this.mul(source2, source2, factor);
            this.add(destination, source1, source2);
        };
        /**
         * 添加注释
         */
        FagalMath.prototype.comment = function () {
            var remarks = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                remarks[_i - 0] = arguments[_i];
            }
            if (!feng3d.Debug.agalDebug)
                return;
            this.append(feng3d.FagalToken.COMMENT + remarks.join(" "));
        };
        /**
         * 添加代码
         */
        FagalMath.prototype.append = function (code) {
            this.dispatchEvent(new feng3d.FagalMathEvent(feng3d.FagalMathEvent.FAGALMATHEVENT_APPEND, code));
        };
        return FagalMath;
    }(feng3d.EventDispatcher));
    feng3d.FagalMath = FagalMath;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 解析基类
     * @author feng 2014-5-16
     */
    var ParserBase = (function (_super) {
        __extends(ParserBase, _super);
        function ParserBase(format) {
            this._data =  * ;
            this._materialMode = 0;
            this._dataFormat = format;
            this._dependencies = new feng3d.ResourceDependency[]();
            feng3d.AbstractClassError.check(this);
        }
        ParserBase.prototype.getTextData = function () {
            return feng3d.ParserUtil.toString(this._data);
        };
        ParserBase.prototype.getByteData = function () {
            return feng3d.ParserUtil.toByteArray(this._data);
        };
        Object.defineProperty(ParserBase.prototype, "materialMode", {
            get: function () {
                return _materialMode;
            },
            set: function (newMaterialMode) {
                _materialMode = newMaterialMode;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ParserBase.prototype, "dataFormat", {
            /** 数据格式 */
            get: function () {
                return _dataFormat;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 完成资源分析（派发资源事件）
         * @param asset 完成的资源
         * @param name 资源名称
         */
        ParserBase.prototype.finalizeAsset = function (asset, name) {
            if (name === void 0) { name = null; }
            var type_event;
            var type_name;
            if (name != null)
                asset.namedAsset.name = name;
            switch (asset.namedAsset.assetType) {
                case feng3d.AssetType.LIGHT_PICKER:
                    type_name = 'lightPicker';
                    type_event = feng3d.AssetEvent.LIGHTPICKER_COMPLETE;
                    break;
                case feng3d.AssetType.LIGHT:
                    type_name = 'light';
                    type_event = feng3d.AssetEvent.LIGHT_COMPLETE;
                    break;
                case feng3d.AssetType.ANIMATOR:
                    type_name = 'animator';
                    type_event = feng3d.AssetEvent.ANIMATOR_COMPLETE;
                    break;
                case feng3d.AssetType.ANIMATION_SET:
                    type_name = 'animationSet';
                    type_event = feng3d.AssetEvent.ANIMATION_SET_COMPLETE;
                    break;
                case feng3d.AssetType.ANIMATION_STATE:
                    type_name = 'animationState';
                    type_event = feng3d.AssetEvent.ANIMATION_STATE_COMPLETE;
                    break;
                case feng3d.AssetType.ANIMATION_NODE:
                    type_name = 'animationNode';
                    type_event = feng3d.AssetEvent.ANIMATION_NODE_COMPLETE;
                    break;
                case feng3d.AssetType.STATE_TRANSITION:
                    type_name = 'stateTransition';
                    type_event = feng3d.AssetEvent.STATE_TRANSITION_COMPLETE;
                    break;
                case feng3d.AssetType.TEXTURE:
                    type_name = 'texture';
                    type_event = feng3d.AssetEvent.TEXTURE_COMPLETE;
                    break;
                case feng3d.AssetType.TEXTURE_PROJECTOR:
                    type_name = 'textureProjector';
                    type_event = feng3d.AssetEvent.TEXTURE_PROJECTOR_COMPLETE;
                    break;
                case feng3d.AssetType.CONTAINER:
                    type_name = 'container';
                    type_event = feng3d.AssetEvent.CONTAINER_COMPLETE;
                    break;
                case feng3d.AssetType.GEOMETRY:
                    type_name = 'geometry';
                    type_event = feng3d.AssetEvent.GEOMETRY_COMPLETE;
                    break;
                case feng3d.AssetType.MATERIAL:
                    type_name = 'material';
                    type_event = feng3d.AssetEvent.MATERIAL_COMPLETE;
                    break;
                case feng3d.AssetType.MESH:
                    type_name = 'mesh';
                    type_event = feng3d.AssetEvent.MESH_COMPLETE;
                    break;
                case feng3d.AssetType.SKELETON:
                    type_name = 'skeleton';
                    type_event = feng3d.AssetEvent.SKELETON_COMPLETE;
                    break;
                case feng3d.AssetType.SKELETON_POSE:
                    type_name = 'skelpose';
                    type_event = feng3d.AssetEvent.SKELETON_POSE_COMPLETE;
                    break;
                case feng3d.AssetType.ENTITY:
                    type_name = 'entity';
                    type_event = feng3d.AssetEvent.ENTITY_COMPLETE;
                    break;
                case feng3d.AssetType.SKYBOX:
                    type_name = 'skybox';
                    type_event = feng3d.AssetEvent.SKYBOX_COMPLETE;
                    break;
                case feng3d.AssetType.CAMERA:
                    type_name = 'camera';
                    type_event = feng3d.AssetEvent.CAMERA_COMPLETE;
                    break;
                case feng3d.AssetType.SEGMENT_SET:
                    type_name = 'segmentSet';
                    type_event = feng3d.AssetEvent.SEGMENT_SET_COMPLETE;
                    break;
                case feng3d.AssetType.EFFECTS_METHOD:
                    type_name = 'effectsMethod';
                    type_event = feng3d.AssetEvent.EFFECTMETHOD_COMPLETE;
                    break;
                case feng3d.AssetType.SHADOW_MAP_METHOD:
                    type_name = 'effectsMethod';
                    type_event = feng3d.AssetEvent.SHADOWMAPMETHOD_COMPLETE;
                    break;
                default:
                    throw new Error('Unhandled asset type ' + asset.namedAsset.assetType + '. Report as bug!');
                    break;
            }
            //默认资源名为类型名
            if (!asset.namedAsset.name)
                asset.namedAsset.name = type_name;
            this.dispatchEvent(new feng3d.AssetEvent(feng3d.AssetEvent.ASSET_COMPLETE, asset));
            this.dispatchEvent(new feng3d.AssetEvent(type_event, asset));
        };
        /**
         * 解决依赖
         * @param resourceDependency 依赖资源
         */
        ParserBase.prototype.resolveDependency = function (resourceDependency) {
            throw new feng3d.AbstractMethodError();
        };
        /**
         * 解决依赖失败
         * @param resourceDependency 依赖资源
         */
        ParserBase.prototype.resolveDependencyFailure = function (resourceDependency) {
            throw new feng3d.AbstractMethodError();
        };
        ParserBase.prototype.resolveDependencyName = function (resourceDependency, asset) {
            return asset.namedAsset.name;
        };
        /**
         * 是否在解析中
         */
        ParserBase.prototype.proceedParsing = function () {
            throw new feng3d.AbstractMethodError();
        };
        Object.defineProperty(ParserBase.prototype, "parsingPaused", {
            /**
             * 是否暂停解析
             */
            get: function () {
                return _parsingPaused;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ParserBase.prototype, "parsingComplete", {
            /**
             * 是否解析完成
             */
            get: function () {
                return _parsingComplete;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 异步解析数据
         * @param data 数据
         * @param frameLimit 帧时间限制
         */
        ParserBase.prototype.parseAsync = function (data, frameLimit) {
            if (data === void 0) { data =  * ; }
            if (frameLimit === void 0) { frameLimit = 30; }
            this._data = data;
            this.startParsing(frameLimit);
        };
        Object.defineProperty(ParserBase.prototype, "dependencies", {
            /**
             * A list of dependencies that need to be loaded and resolved for the object being parsed.
             */
            get: function () {
                return _dependencies;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 是否还有时间
         */
        ParserBase.prototype.hasTime = function () {
            return ((getTimer() - this._lastFrameTime) < this._frameLimit);
        };
        /**
         * 开始解析数据
         * @param frameLimit 帧时间限制
         */
        ParserBase.prototype.startParsing = function (frameLimit) {
            this._frameLimit = frameLimit;
            this._timer = new Timer(this._frameLimit, 0);
            this._timer.addEventListener(TimerEvent.TIMER, this.onInterval);
            this._timer.start();
        };
        /**
         * 触发解析
         * @param event
         */
        ParserBase.prototype.onInterval = function (event) {
            if (event === void 0) { event = null; }
            this._lastFrameTime = getTimer();
            if (this.proceedParsing() && !this._parsingFailure)
                this.finishParsing();
        };
        /**
         * 暂停解析，去准备依赖项
         */
        ParserBase.prototype.pauseAndRetrieveDependencies = function () {
            //			if (this._timer)
            //				this._timer.stop();
            //			this._parsingPaused = true;
            //			this.dispatchEvent(new ParserEvent(ParserEvent.READY_FOR_DEPENDENCIES));
        };
        /**
         * 继续解析，准备好依赖项后
         */
        ParserBase.prototype.resumeParsingAfterDependencies = function () {
            this._parsingPaused = false;
            if (this._timer)
                this._timer.start();
        };
        /**
         * 完成解析
         */
        ParserBase.prototype.finishParsing = function () {
            if (this._timer) {
                this._timer.removeEventListener(TimerEvent.TIMER, this.onInterval);
                this._timer.stop();
            }
            this._timer = null;
            this._parsingComplete = true;
            this.dispatchEvent(new feng3d.ParserEvent(feng3d.ParserEvent.PARSE_COMPLETE));
        };
        /**
         * 添加依赖项
         * @param id 编号
         * @param req url请求
         * @param retrieveAsRawData
         * @param data
         * @param suppressErrorEvents
         */
        ParserBase.prototype.addDependency = ;
        ParserBase.PARSING_DONE = true;
        ParserBase.MORE_TO_PARSE = false;
        return ParserBase;
    }(feng3d.EventDispatcher));
    feng3d.ParserBase = ParserBase;
    null, suppressErrorEvents;
    boolean = false;
    {
        this._dependencies.push(new feng3d.ResourceDependency(id, req, data, this, retrieveAsRawData, suppressErrorEvents));
    }
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * ImageParser provides a "parser" for natively supported image types (jpg, png). While it simply loads bytes into
     * a loader object, it wraps it in a BitmapDataResource so resource management can happen consistently without
     * exception cases.
     */
    var ImageParser = (function (_super) {
        __extends(ImageParser, _super);
        /**
         * Creates a new ImageParser object.
         * @param uri The url or id of the data or file to be parsed.
         * @param extra The holder for extra contextual data that the parser might need.
         */
        function ImageParser() {
            _super.call(this, feng3d.ParserDataFormat.BINARY);
            /**
             * @inheritDoc
             */
            this.override = function proceedParsing() {
                var asset =  * ;
                if (_data)
                    is;
                Bitmap;
                {
                    asset = new feng3d.BitmapTexture(Bitmap(_data).bitmapData);
                    finalizeAsset(asset, this._fileName);
                    return PARSING_DONE;
                }
                if (_data)
                    is;
                BitmapData;
                {
                    asset = new feng3d.BitmapTexture(_data);
                    finalizeAsset(asset, this._fileName);
                    return PARSING_DONE;
                }
                return this._doneParsing;
            };
        }
        /**
         * Indicates whether or not a given file extension is supported by the parser.
         * @param extension The file extension of a potential file to be parsed.
         * @return Whether or not the given file type is supported.
         */
        ImageParser.supportsType = function (extension) {
            extension = extension.toLowerCase();
            return extension == "jpg" || extension == "jpeg" || extension == "png" || extension == "gif" || extension == "bmp" || extension == "atf";
        };
        /**
         * Tests whether a data block can be parsed by the parser.
         * @param data The data block to potentially be parsed.
         * @return Whether or not the given data is supported.
         */
        ImageParser.supportsData = function (data) {
            if (data === void 0) { data =  * ; }
            //shortcut if asset is IFlexAsset
            if (data)
                is;
            Bitmap;
            return true;
            if (data)
                is;
            BitmapData;
            return true;
            if (!(data))
                is;
            ByteArray;
            return false;
            var ba = data;
            ba.position = 0;
            if (ba.readUnsignedShort() == 0xffd8)
                return true; // JPEG, maybe check for "JFIF" as well?
            ba.position = 0;
            if (ba.readShort() == 0x424D)
                return true; // BMP
            ba.position = 1;
            if (ba.readUTFBytes(3) == 'PNG')
                return true;
            ba.position = 0;
            if (ba.readUTFBytes(3) == 'GIF' && ba.readShort() == 0x3839 && ba.readByte() == 0x61)
                return true;
            ba.position = 0;
            if (ba.readUTFBytes(3) == 'ATF')
                return true;
            return false;
        };
        return ImageParser;
    }(feng3d.ParserBase));
    feng3d.ImageParser = ImageParser;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 该类提供md5anim类型数据的解析，提供一个MD5类型的动画序列
     */
    var MD5AnimParser = (function (_super) {
        __extends(MD5AnimParser, _super);
        /**
         * 创建一个MD5动画解析类
         * @param additionalRotationAxis 附加旋转轴
         * @param additionalRotationRadians 附加旋转角度
         */
        function MD5AnimParser(additionalRotationAxis, additionalRotationRadians) {
            if (additionalRotationAxis === void 0) { additionalRotationAxis = null; }
            if (additionalRotationRadians === void 0) { additionalRotationRadians = 0; }
            _super.call(this, feng3d.ParserDataFormat.PLAIN_TEXT);
            this.override = function proceedParsing() {
                var token;
                if (!this._startedParsing) {
                    this._textData = getTextData();
                    this._startedParsing = true;
                }
                while (hasTime()) {
                    token = this.getNextToken();
                    switch (token) {
                        case COMMENT_TOKEN:
                            this.ignoreLine();
                            break;
                        case "":
                            // can occur at the end of a file
                            break;
                        case VERSION_TOKEN:
                            this._version = this.getNextInt();
                            if (this._version != 10)
                                throw new Error("Unknown version number encountered!");
                            break;
                        case COMMAND_LINE_TOKEN:
                            this.parseCMD();
                            break;
                        case NUM_FRAMES_TOKEN:
                            this._numFrames = this.getNextInt();
                            this._bounds = new BoundsData[]();
                            this._frameData = new FrameData[]();
                            break;
                        case NUM_JOINTS_TOKEN:
                            this._numJoints = this.getNextInt();
                            this._hierarchy = new HierarchyData[](this._numJoints, true);
                            this._baseFrameData = new BaseFrameData[](this._numJoints, true);
                            break;
                        case FRAME_RATE_TOKEN:
                            this._frameRate = this.getNextInt();
                            break;
                        case NUM_ANIMATED_COMPONENTS_TOKEN:
                            this._numAnimatedComponents = this.getNextInt();
                            break;
                        case HIERARCHY_TOKEN:
                            this.parseHierarchy();
                            break;
                        case BOUNDS_TOKEN:
                            this.parseBounds();
                            break;
                        case BASE_FRAME_TOKEN:
                            this.parseBaseFrame();
                            break;
                        case FRAME_TOKEN:
                            this.parseFrame();
                            break;
                        default:
                            if (!this._reachedEOF)
                                this.sendUnknownKeywordError();
                    }
                    //解析出 骨骼动画数据
                    if (this._reachedEOF) {
                        this._clip = new feng3d.SkeletonClipNode();
                        this.translateClip();
                        finalizeAsset(this._clip);
                        return feng3d.ParserBase.PARSING_DONE;
                    }
                }
                return feng3d.ParserBase.MORE_TO_PARSE;
            };
            //初始化旋转四元素
            this._rotationQuat = new Quaternion();
            var t1 = new Quaternion();
            var t2 = new Quaternion();
            t1.fromAxisAngle(Vector3D.X_AXIS, -Math.PI * .5);
            t2.fromAxisAngle(Vector3D.Y_AXIS, -Math.PI * .5);
            this._rotationQuat.multiply(t2, t1);
            if (additionalRotationAxis) {
                this._rotationQuat.multiply(t2, t1);
                t1.fromAxisAngle(additionalRotationAxis, additionalRotationRadians);
                this._rotationQuat.multiply(t1, this._rotationQuat);
            }
        }
        /**
         * 判断是否支持解析
         * @param extension 文件类型
         * @return
         */
        MD5AnimParser.supportsType = function (extension) {
            extension = extension.toLowerCase();
            return extension == "md5anim";
        };
        /**
         * 判断是否支持该数据的解析
         * @param data 需要解析的数据
         * @return
         */
        MD5AnimParser.supportsData = function (data) {
            if (data === void 0) { data =  * ; }
            data = data;
            return false;
        };
        /**
         * 收集所有的关键帧数据
         */
        MD5AnimParser.prototype.translateClip = function () {
            for (var i = 0; i < this._numFrames; ++i)
                this._clip.addFrame(this.translatePose(this._frameData[i]), 1000 / this._frameRate);
        };
        /**
         * 将一个关键帧数据转换为SkeletonPose
         * @param frameData 帧数据
         * @return 包含帧数据的SkeletonPose对象
         */
        MD5AnimParser.prototype.translatePose = function (frameData) {
            var hierarchy;
            var pose;
            var base;
            var flags;
            var j;
            //偏移量
            var translate = new Vector3D();
            //旋转四元素
            var orientation = new Quaternion();
            var components = frameData.components;
            //骨骼pose数据
            var skelPose = new feng3d.SkeletonPose();
            //骨骼pose列表
            var jointPoses = skelPose.jointPoses;
            for (var i = 0; i < this._numJoints; ++i) {
                //通过原始帧数据与层级数据计算出当前骨骼pose数据
                j = 0;
                //层级数据
                hierarchy = this._hierarchy[i];
                //基础帧数据
                base = this._baseFrameData[i];
                //层级标记
                flags = hierarchy.flags;
                translate.x = base.position.x;
                translate.y = base.position.y;
                translate.z = base.position.z;
                orientation.x = base.orientation.x;
                orientation.y = base.orientation.y;
                orientation.z = base.orientation.z;
                //调整位移与角度数据
                if (flags & 1)
                    translate.x = components[hierarchy.startIndex + (j++)];
                if (flags & 2)
                    translate.y = components[hierarchy.startIndex + (j++)];
                if (flags & 4)
                    translate.z = components[hierarchy.startIndex + (j++)];
                if (flags & 8)
                    orientation.x = components[hierarchy.startIndex + (j++)];
                if (flags & 16)
                    orientation.y = components[hierarchy.startIndex + (j++)];
                if (flags & 32)
                    orientation.z = components[hierarchy.startIndex + (j++)];
                //计算四元素w值
                var w = 1 - orientation.x * orientation.x - orientation.y * orientation.y - orientation.z * orientation.z;
                orientation.w = w < 0 ? 0 : -Math.sqrt(w);
                //创建关节pose数据
                pose = new feng3d.JointPose();
                if (hierarchy.parentIndex < 0) {
                    pose.orientation.multiply(this._rotationQuat, orientation);
                    pose.translation = this._rotationQuat.rotatePoint(translate);
                }
                else {
                    pose.orientation.copyFrom(orientation);
                    pose.translation.x = translate.x;
                    pose.translation.y = translate.y;
                    pose.translation.z = translate.z;
                }
                pose.orientation.y = -pose.orientation.y;
                pose.orientation.z = -pose.orientation.z;
                pose.translation.x = -pose.translation.x;
                jointPoses[i] = pose;
            }
            return skelPose;
        };
        /**
         * 解析骨骼的层级数据
         */
        MD5AnimParser.prototype.parseHierarchy = function () {
            var ch;
            var data;
            var token = this.getNextToken();
            var i = 0;
            if (token != "{")
                this.sendUnknownKeywordError();
            do {
                if (this._reachedEOF)
                    this.sendEOFError();
                data = new HierarchyData();
                data.name = this.parseLiteralString();
                data.parentIndex = this.getNextInt();
                data.flags = this.getNextInt();
                data.startIndex = this.getNextInt();
                this._hierarchy[i++] = data;
                ch = this.getNextChar();
                if (ch == "/") {
                    this.putBack();
                    ch = this.getNextToken();
                    if (ch == COMMENT_TOKEN)
                        this.ignoreLine();
                    ch = this.getNextChar();
                }
                if (ch != "}")
                    this.putBack();
            } while (ch != "}");
        };
        /**
         * 解析帧边界
         */
        MD5AnimParser.prototype.parseBounds = function () {
            var ch;
            var data;
            var token = this.getNextToken();
            var i = 0;
            if (token != "{")
                this.sendUnknownKeywordError();
            do {
                if (this._reachedEOF)
                    this.sendEOFError();
                data = new BoundsData();
                data.min = this.parseVector3D();
                data.max = this.parseVector3D();
                this._bounds[i++] = data;
                ch = this.getNextChar();
                if (ch == "/") {
                    this.putBack();
                    ch = this.getNextToken();
                    if (ch == COMMENT_TOKEN)
                        this.ignoreLine();
                    ch = this.getNextChar();
                }
                if (ch != "}")
                    this.putBack();
            } while (ch != "}");
        };
        /**
         * 解析基础帧
         */
        MD5AnimParser.prototype.parseBaseFrame = function () {
            var ch;
            var data;
            var token = this.getNextToken();
            var i = 0;
            if (token != "{")
                this.sendUnknownKeywordError();
            do {
                if (this._reachedEOF)
                    this.sendEOFError();
                data = new BaseFrameData();
                data.position = this.parseVector3D();
                data.orientation = this.parseQuaternion();
                this._baseFrameData[i++] = data;
                ch = this.getNextChar();
                if (ch == "/") {
                    this.putBack();
                    ch = this.getNextToken();
                    if (ch == COMMENT_TOKEN)
                        this.ignoreLine();
                    ch = this.getNextChar();
                }
                if (ch != "}")
                    this.putBack();
            } while (ch != "}");
        };
        /**
         * 解析帧
         */
        MD5AnimParser.prototype.parseFrame = function () {
            var ch;
            var data;
            var token;
            var frameIndex;
            frameIndex = this.getNextInt();
            token = this.getNextToken();
            if (token != "{")
                this.sendUnknownKeywordError();
            do {
                if (this._reachedEOF)
                    this.sendEOFError();
                data = new FrameData();
                data.components = new number[](this._numAnimatedComponents, true);
                for (var i = 0; i < this._numAnimatedComponents; ++i)
                    data.components[i] = this.getNextNumber();
                this._frameData[frameIndex] = data;
                ch = this.getNextChar();
                if (ch == "/") {
                    this.putBack();
                    ch = this.getNextToken();
                    if (ch == COMMENT_TOKEN)
                        this.ignoreLine();
                    ch = this.getNextChar();
                }
                if (ch != "}")
                    this.putBack();
            } while (ch != "}");
        };
        /**
         * 返回到上个字符位置
         */
        MD5AnimParser.prototype.putBack = function () {
            this._parseIndex--;
            this._charLineIndex--;
            this._reachedEOF = this._parseIndex >= this._textData.length;
        };
        /**
         * 获取下个关键字
         */
        MD5AnimParser.prototype.getNextToken = function () {
            var ch;
            var token = "";
            while (!this._reachedEOF) {
                ch = this.getNextChar();
                if (ch == " " || ch == "\r" || ch == "\n" || ch == "\t") {
                    if (token != COMMENT_TOKEN)
                        this.skipWhiteSpace();
                    if (token != "")
                        return token;
                }
                else
                    token += ch;
                if (token == COMMENT_TOKEN)
                    return token;
            }
            return token;
        };
        /**
         * 跳过空白
         */
        MD5AnimParser.prototype.skipWhiteSpace = function () {
            var ch;
            do
                ch = this.getNextChar();
            while (ch == "\n" || ch == " " || ch == "\r" || ch == "\t");
            this.putBack();
        };
        /**
         * 忽略该行
         */
        MD5AnimParser.prototype.ignoreLine = function () {
            var ch;
            while (!this._reachedEOF && ch != "\n")
                ch = this.getNextChar();
        };
        /**
         * 读取下个字符
         */
        MD5AnimParser.prototype.getNextChar = function () {
            var ch = this._textData.charAt(this._parseIndex++);
            if (ch == "\n") {
                ++this._line;
                this._charLineIndex = 0;
            }
            else if (ch != "\r")
                ++this._charLineIndex;
            if (this._parseIndex == this._textData.length)
                this._reachedEOF = true;
            return ch;
        };
        /**
         * 读取下个number
         */
        MD5AnimParser.prototype.getNextInt = function () {
            var i = parseInt(this.getNextToken());
            if (isNaN(i))
                this.sendParseError("number type");
            return i;
        };
        /**
         * 读取下个number
         */
        MD5AnimParser.prototype.getNextNumber = function () {
            var f = parseFloat(this.getNextToken());
            if (isNaN(f))
                this.sendParseError("float type");
            return f;
        };
        /**
         * 解析3d向量
         */
        MD5AnimParser.prototype.parseVector3D = function () {
            var vec = new Vector3D();
            var ch = this.getNextToken();
            if (ch != "(")
                this.sendParseError("(");
            vec.x = this.getNextNumber();
            vec.y = this.getNextNumber();
            vec.z = this.getNextNumber();
            if (this.getNextToken() != ")")
                this.sendParseError(")");
            return vec;
        };
        /**
         * 解析四元素
         */
        MD5AnimParser.prototype.parseQuaternion = function () {
            var quat = new Quaternion();
            var ch = this.getNextToken();
            if (ch != "(")
                this.sendParseError("(");
            quat.x = this.getNextNumber();
            quat.y = this.getNextNumber();
            quat.z = this.getNextNumber();
            // quat supposed to be unit length
            var t = 1 - (quat.x * quat.x) - (quat.y * quat.y) - (quat.z * quat.z);
            quat.w = t < 0 ? 0 : -Math.sqrt(t);
            if (this.getNextToken() != ")")
                this.sendParseError(")");
            return quat;
        };
        /**
         * 解析命令行数据
         */
        MD5AnimParser.prototype.parseCMD = function () {
            // just ignore the command line property
            this.parseLiteralString();
        };
        /**
         * 解析带双引号的字符串
         */
        MD5AnimParser.prototype.parseLiteralString = function () {
            this.skipWhiteSpace();
            var ch = this.getNextChar();
            var str = "";
            if (ch != "\"")
                this.sendParseError("\"");
            do {
                if (this._reachedEOF)
                    this.sendEOFError();
                ch = this.getNextChar();
                if (ch != "\"")
                    str += ch;
            } while (ch != "\"");
            return str;
        };
        /**
         * 抛出一个文件尾过早结束文件时遇到错误
         */
        MD5AnimParser.prototype.sendEOFError = function () {
            throw new Error("Unexpected end of file");
        };
        /**
         * 遇到了一个意想不到的令牌时将抛出一个错误。
         * @param expected 发生错误的标记
         */
        MD5AnimParser.prototype.sendParseError = function (expected) {
            throw new Error("Unexpected token at line " + (this._line + 1) + ", character " + this._charLineIndex + ". " + expected + " expected, but " + this._textData.charAt(this._parseIndex - 1) + " encountered");
        };
        /**
         * 发生未知关键字错误
         */
        MD5AnimParser.prototype.sendUnknownKeywordError = function () {
            throw new Error("Unknown keyword at line " + (this._line + 1) + ", character " + this._charLineIndex + ". ");
        };
        //md5anim文件关键字
        MD5AnimParser.VERSION_TOKEN = "MD5Version";
        MD5AnimParser.COMMAND_LINE_TOKEN = "commandline";
        MD5AnimParser.NUM_FRAMES_TOKEN = "numFrames";
        MD5AnimParser.NUM_JOINTS_TOKEN = "numJoints";
        MD5AnimParser.FRAME_RATE_TOKEN = "frameRate";
        MD5AnimParser.NUM_ANIMATED_COMPONENTS_TOKEN = "numAnimatedComponents";
        MD5AnimParser.HIERARCHY_TOKEN = "hierarchy";
        MD5AnimParser.BOUNDS_TOKEN = "bounds";
        MD5AnimParser.BASE_FRAME_TOKEN = "baseframe";
        MD5AnimParser.FRAME_TOKEN = "frame";
        MD5AnimParser.COMMENT_TOKEN = "//";
        return MD5AnimParser;
    }(feng3d.ParserBase));
    feng3d.MD5AnimParser = MD5AnimParser;
})(feng3d || (feng3d = {}));
/**
 * 层级数据
 */
var HierarchyData = (function () {
    function HierarchyData() {
    }
    HierarchyData.prototype.HierarchyData = function () {
    };
    return HierarchyData;
}());
/**
 * 包围盒信息
 */
var BoundsData = (function () {
    function BoundsData() {
    }
    BoundsData.prototype.BoundsData = function () {
    };
    return BoundsData;
}());
/**
 * 基础帧数据
 */
var BaseFrameData = (function () {
    function BaseFrameData() {
    }
    BaseFrameData.prototype.BaseFrameData = function () {
    };
    return BaseFrameData;
}());
/**
 * 帧数据
 */
var FrameData = (function () {
    function FrameData() {
    }
    FrameData.prototype.FrameData = function () {
    };
    return FrameData;
}());
var feng3d;
(function (feng3d) {
    /**
     * MD5Mesh文件解析类
     */
    var MD5MeshParser = (function (_super) {
        __extends(MD5MeshParser, _super);
        /**
         * 创建一个MD5Mesh解析对象
         */
        function MD5MeshParser(additionalRotationAxis, additionalRotationRadians) {
            if (additionalRotationAxis === void 0) { additionalRotationAxis = null; }
            if (additionalRotationRadians === void 0) { additionalRotationRadians = 0; }
            _super.call(this, feng3d.ParserDataFormat.PLAIN_TEXT);
            this.override = function proceedParsing() {
                var token;
                //标记开始解析
                if (!this._startedParsing) {
                    this._textData = getTextData();
                    this._startedParsing = true;
                }
                while (hasTime()) {
                    //获取关键字
                    token = this.getNextToken();
                    switch (token) {
                        case COMMENT_TOKEN:
                            this.ignoreLine();
                            break;
                        case VERSION_TOKEN:
                            this._version = this.getNextInt();
                            if (this._version != 10)
                                throw new Error("Unknown version number encountered!");
                            break;
                        case COMMAND_LINE_TOKEN:
                            this.parseCMD();
                            break;
                        case NUM_JOINTS_TOKEN:
                            this._numJoints = this.getNextInt();
                            this._bindPoses = new Matrix3D[](this._numJoints, true);
                            break;
                        case NUM_MESHES_TOKEN:
                            this._numMeshes = this.getNextInt();
                            break;
                        case JOINTS_TOKEN:
                            this.parseJoints();
                            break;
                        case MESH_TOKEN:
                            this.parseMesh();
                            break;
                        default:
                            if (!this._reachedEOF)
                                this.sendUnknownKeywordError();
                    }
                    //解析结束后 生成引擎相关对象
                    if (this._reachedEOF) {
                        this.calculateMaxJointCount();
                        this._animationSet = new feng3d.SkeletonAnimationSet(this._maxJointCount);
                        //生成引擎所需网格对象
                        var _mesh = new feng3d.Mesh(new feng3d.Geometry(), null);
                        var _geometry = _mesh.geometry;
                        for (var i = 0; i < this._meshData.length; ++i)
                            _geometry.addSubGeometry(this.translateGeom(this._meshData[i].vertexData, this._meshData[i].weightData, this._meshData[i].indices));
                        finalizeAsset(_geometry);
                        finalizeAsset(_mesh);
                        finalizeAsset(this._skeleton);
                        finalizeAsset(this._animationSet);
                        return feng3d.ParserBase.PARSING_DONE;
                    }
                }
                return feng3d.ParserBase.MORE_TO_PARSE;
            };
            //初始化 旋转四元素
            this._rotationQuat = new Quaternion();
            this._rotationQuat.fromAxisAngle(Vector3D.X_AXIS, -Math.PI * .5);
            if (additionalRotationAxis) {
                var quat = new Quaternion();
                quat.fromAxisAngle(additionalRotationAxis, additionalRotationRadians);
                this._rotationQuat.multiply(this._rotationQuat, quat);
            }
        }
        /**
         * 判断是否支持解析
         * @param extension 文件类型
         * @return
         */
        MD5MeshParser.supportsType = function (extension) {
            extension = extension.toLowerCase();
            return extension == "md5mesh";
        };
        /**
         * 判断是否支持该数据的解析
         * @param data 需要解析的数据
         * @return
         */
        MD5MeshParser.supportsData = function (data) {
            if (data === void 0) { data =  * ; }
            data = data;
            return false;
        };
        /**
         * 计算最大关节数量
         */
        MD5MeshParser.prototype.calculateMaxJointCount = function () {
            this._maxJointCount = 0;
            //遍历所有的网格数据
            var numMeshData = this._meshData.length;
            for (var i = 0; i < numMeshData; ++i) {
                var meshData = this._meshData[i];
                var vertexData = meshData.vertexData;
                var numVerts = vertexData.length;
                //遍历每个顶点 寻找关节关联最大数量
                for (var j = 0; j < numVerts; ++j) {
                    var zeroWeights = this.countZeroWeightJoints(vertexData[j], meshData.weightData);
                    var totalJoints = vertexData[j].countWeight - zeroWeights;
                    if (totalJoints > this._maxJointCount)
                        this._maxJointCount = totalJoints;
                }
            }
        };
        /**
         * 计算0权重关节数量
         * @param vertex 顶点数据
         * @param weights 关节权重数组
         * @return
         */
        MD5MeshParser.prototype.countZeroWeightJoints = function (vertex, weights) {
            var start = vertex.startWeight;
            var end = vertex.startWeight + vertex.countWeight;
            var count = 0;
            var weight;
            for (var i = start; i < end; ++i) {
                weight = weights[i].bias;
                if (weight == 0)
                    ++count;
            }
            return count;
        };
        /**
         * 解析关节
         */
        MD5MeshParser.prototype.parseJoints = function () {
            var ch;
            var joint;
            var pos;
            var quat;
            var i = 0;
            var token = this.getNextToken();
            if (token != "{")
                this.sendUnknownKeywordError();
            //解析骨骼数据
            this._skeleton = new feng3d.Skeleton();
            do {
                if (this._reachedEOF)
                    this.sendEOFError();
                //解析骨骼关节数据
                joint = new feng3d.SkeletonJoint();
                joint.name = this.parseLiteralString();
                joint.parentIndex = this.getNextInt();
                //关节坐标
                pos = this.parseVector3D();
                pos = this._rotationQuat.rotatePoint(pos);
                quat = this.parseQuaternion();
                // 计算bindpose下该节点(关节)的真正变换矩阵
                this._bindPoses[i] = quat.toMatrix3D();
                this._bindPoses[i].appendTranslation(pos.x, pos.y, pos.z);
                var inv = this._bindPoses[i].clone();
                inv.invert();
                joint.inverseBindPose = inv.rawData;
                //收集关节数据
                this._skeleton.joints[i++] = joint;
                ch = this.getNextChar();
                if (ch == "/") {
                    this.putBack();
                    ch = this.getNextToken();
                    if (ch == COMMENT_TOKEN)
                        this.ignoreLine();
                    ch = this.getNextChar();
                }
                if (ch != "}")
                    this.putBack();
            } while (ch != "}");
        };
        /**
         * 返回到上个字符位置
         */
        MD5MeshParser.prototype.putBack = function () {
            this._parseIndex--;
            this._charLineIndex--;
            this._reachedEOF = this._parseIndex >= this._textData.length;
        };
        /**
         * 解析网格几何体
         */
        MD5MeshParser.prototype.parseMesh = function () {
            var token = this.getNextToken();
            var ch;
            var vertexData;
            var weights;
            var indices;
            if (token != "{")
                this.sendUnknownKeywordError();
            this._shaders || ;
            new string[]();
            while (ch != "}") {
                ch = this.getNextToken();
                switch (ch) {
                    case COMMENT_TOKEN:
                        this.ignoreLine();
                        break;
                    case MESH_SHADER_TOKEN:
                        //材质数据
                        this._shaders.push(this.parseLiteralString());
                        break;
                    case MESH_NUM_VERTS_TOKEN:
                        //顶点数据
                        vertexData = new VertexData[](this.getNextInt(), true);
                        break;
                    case MESH_NUM_TRIS_TOKEN:
                        //根据三角形个数 创建顶点数组
                        indices = new number[](this.getNextInt() * 3, true);
                        break;
                    case MESH_NUM_WEIGHTS_TOKEN:
                        //创建关节数据
                        weights = new WeightData[](this.getNextInt(), true);
                        break;
                    case MESH_VERT_TOKEN:
                        //解析一个顶点数据
                        this.parseVertex(vertexData);
                        break;
                    case MESH_TRI_TOKEN:
                        this.parseTri(indices);
                        break;
                    case MESH_WEIGHT_TOKEN:
                        this.parseJoint(weights);
                        break;
                }
            }
            //保存网格数据
            this._meshData || ;
            new MeshData[]();
            var i = this._meshData.length;
            this._meshData[i] = new MeshData();
            this._meshData[i].vertexData = vertexData;
            this._meshData[i].weightData = weights;
            this._meshData[i].indices = indices;
        };
        /**
         * 转换网格数据为SkinnedSubGeometry实例
         * @param vertexData 网格顶点数据
         * @param weights 每个顶点的关节权重数据
         * @param indices 顶点索引数据
         * @return 包含所有几何体数据的SkinnedSubGeometry实例
         */
        MD5MeshParser.prototype.translateGeom = function (vertexData, weights, indices) {
            var len = vertexData.length;
            var v1, v2, v3;
            var vertex;
            var weight;
            var bindPose;
            var pos;
            var subGeom = new feng3d.SubGeometry();
            var skinnedsubGeom = new feng3d.SkinnedSubGeometry(this._maxJointCount);
            subGeom.addComponent(skinnedsubGeom);
            //uv数据
            var uvs = new number[](len * 2, true);
            //顶点位置数据
            var vertices = new number[](len * 3, true);
            //关节索引数据
            var jointIndices = new number[](len * this._maxJointCount, true);
            //关节权重数据
            var jointWeights = new number[](len * this._maxJointCount, true);
            var l;
            //0权重个数
            var nonZeroWeights;
            for (var i = 0; i < len; ++i) {
                vertex = vertexData[i];
                v1 = vertex.index * 3;
                v2 = v1 + 1;
                v3 = v1 + 2;
                vertices[v1] = vertices[v2] = vertices[v3] = 0;
                /**
                 * 参考 http://blog.csdn.net/summerhust/article/details/17421213
                 * VertexPos = (MJ-0 * weight[index0].pos * weight[index0].bias) + ... + (MJ-N * weight[indexN].pos * weight[indexN].bias)
                 * 变量对应 :
                 * MJ-N -> bindPose; 第J个关节的变换矩阵
                 * weight[indexN].pos -> weight.pos;
                 * weight[indexN].bias -> weight.bias;
                 */
                nonZeroWeights = 0;
                for (var j = 0; j < vertex.countWeight; ++j) {
                    weight = weights[vertex.startWeight + j];
                    if (weight.bias > 0) {
                        bindPose = this._bindPoses[weight.joint];
                        pos = bindPose.transformVector(weight.pos);
                        vertices[v1] += pos.x * weight.bias;
                        vertices[v2] += pos.y * weight.bias;
                        vertices[v3] += pos.z * weight.bias;
                        // indices need to be multiplied by 3 (amount of matrix registers)
                        jointIndices[l] = weight.joint * 3;
                        jointWeights[l++] = weight.bias;
                        ++nonZeroWeights;
                    }
                }
                for (j = nonZeroWeights; j < this._maxJointCount; ++j) {
                    jointIndices[l] = 0;
                    jointWeights[l++] = 0;
                }
                v1 = vertex.index << 1;
                uvs[v1++] = vertex.u;
                uvs[v1] = vertex.v;
            }
            //更新索引数据
            subGeom.updateIndexData(indices);
            subGeom.numVertices = vertices.length / 3;
            //更新顶点坐标与uv数据
            subGeom.fromVectors(vertices, uvs);
            // cause explicit updates
            subGeom.addComponent(new feng3d.AutoDeriveVertexNormals());
            subGeom.addComponent(new feng3d.AutoDeriveVertexTangents());
            subGeom.vertexNormalData;
            subGeom.vertexTangentData;
            //更新关节索引与权重索引
            skinnedsubGeom.updateJointIndexData(jointIndices);
            skinnedsubGeom.updateJointWeightsData(jointWeights);
            return subGeom;
        };
        /**
         * 解析三角形数据
         * @param indices 索引数据
         */
        MD5MeshParser.prototype.parseTri = function (indices) {
            var index = this.getNextInt() * 3;
            indices[index] = this.getNextInt();
            indices[index + 1] = this.getNextInt();
            indices[index + 2] = this.getNextInt();
        };
        /**
         * 解析关节数据
         * @param weights 权重数据列表
         */
        MD5MeshParser.prototype.parseJoint = function (weights) {
            var weight = new WeightData();
            weight.index = this.getNextInt();
            weight.joint = this.getNextInt();
            weight.bias = this.getNextNumber();
            weight.pos = this.parseVector3D();
            weights[weight.index] = weight;
        };
        /**
         * 解析一个顶点
         * @param vertexData 顶点数据列表
         */
        MD5MeshParser.prototype.parseVertex = function (vertexData) {
            var vertex = new VertexData();
            vertex.index = this.getNextInt();
            this.parseUV(vertex);
            vertex.startWeight = this.getNextInt();
            vertex.countWeight = this.getNextInt();
            vertexData[vertex.index] = vertex;
        };
        /**
         * 解析uv坐标
         * @param vertexData 包含uv坐标的顶点数据
         */
        MD5MeshParser.prototype.parseUV = function (vertexData) {
            var ch = this.getNextToken();
            if (ch != "(")
                this.sendParseError("(");
            vertexData.u = this.getNextNumber();
            vertexData.v = this.getNextNumber();
            if (this.getNextToken() != ")")
                this.sendParseError(")");
        };
        /**
         * 获取下个关键字
         */
        MD5MeshParser.prototype.getNextToken = function () {
            var ch;
            var token = "";
            while (!this._reachedEOF) {
                ch = this.getNextChar();
                if (ch == " " || ch == "\r" || ch == "\n" || ch == "\t") {
                    if (token != COMMENT_TOKEN)
                        this.skipWhiteSpace();
                    if (token != "")
                        return token;
                }
                else
                    token += ch;
                if (token == COMMENT_TOKEN)
                    return token;
            }
            return token;
        };
        /**
         * 跳过空白
         */
        MD5MeshParser.prototype.skipWhiteSpace = function () {
            var ch;
            do
                ch = this.getNextChar();
            while (ch == "\n" || ch == " " || ch == "\r" || ch == "\t");
            this.putBack();
        };
        /**
         * 忽略该行
         */
        MD5MeshParser.prototype.ignoreLine = function () {
            var ch;
            while (!this._reachedEOF && ch != "\n")
                ch = this.getNextChar();
        };
        /**
         * 读取下个字符
         */
        MD5MeshParser.prototype.getNextChar = function () {
            var ch = this._textData.charAt(this._parseIndex++);
            if (ch == "\n") {
                ++this._line;
                this._charLineIndex = 0;
            }
            else if (ch != "\r")
                ++this._charLineIndex;
            if (this._parseIndex >= this._textData.length)
                this._reachedEOF = true;
            return ch;
        };
        /**
         * 读取下个number
         */
        MD5MeshParser.prototype.getNextInt = function () {
            var i = parseInt(this.getNextToken());
            if (isNaN(i))
                this.sendParseError("number type");
            return i;
        };
        /**
         * 读取下个number
         */
        MD5MeshParser.prototype.getNextNumber = function () {
            var f = parseFloat(this.getNextToken());
            if (isNaN(f))
                this.sendParseError("float type");
            return f;
        };
        /**
         * 解析3d向量
         */
        MD5MeshParser.prototype.parseVector3D = function () {
            var vec = new Vector3D();
            var ch = this.getNextToken();
            if (ch != "(")
                this.sendParseError("(");
            vec.x = -this.getNextNumber();
            vec.y = this.getNextNumber();
            vec.z = this.getNextNumber();
            if (this.getNextToken() != ")")
                this.sendParseError(")");
            return vec;
        };
        /**
         * 解析四元素
         */
        MD5MeshParser.prototype.parseQuaternion = function () {
            var quat = new Quaternion();
            var ch = this.getNextToken();
            if (ch != "(")
                this.sendParseError("(");
            quat.x = this.getNextNumber();
            quat.y = -this.getNextNumber();
            quat.z = -this.getNextNumber();
            // quat supposed to be unit length
            var t = 1 - quat.x * quat.x - quat.y * quat.y - quat.z * quat.z;
            quat.w = t < 0 ? 0 : -Math.sqrt(t);
            if (this.getNextToken() != ")")
                this.sendParseError(")");
            var rotQuat = new Quaternion();
            rotQuat.multiply(this._rotationQuat, quat);
            return rotQuat;
        };
        /**
         * 解析命令行数据
         */
        MD5MeshParser.prototype.parseCMD = function () {
            //忽略命令行数据
            this.parseLiteralString();
        };
        /**
         * 解析带双引号的字符串
         */
        MD5MeshParser.prototype.parseLiteralString = function () {
            this.skipWhiteSpace();
            var ch = this.getNextChar();
            var str = "";
            if (ch != "\"")
                this.sendParseError("\"");
            do {
                if (this._reachedEOF)
                    this.sendEOFError();
                ch = this.getNextChar();
                if (ch != "\"")
                    str += ch;
            } while (ch != "\"");
            return str;
        };
        /**
         * 抛出一个文件尾过早结束文件时遇到错误
         */
        MD5MeshParser.prototype.sendEOFError = function () {
            throw new Error("Unexpected end of file");
        };
        /**
         * 遇到了一个意想不到的令牌时将抛出一个错误。
         * @param expected 发生错误的标记
         */
        MD5MeshParser.prototype.sendParseError = function (expected) {
            throw new Error("Unexpected token at line " + (this._line + 1) + ", character " + this._charLineIndex + ". " + expected + " expected, but " + this._textData.charAt(this._parseIndex - 1) + " encountered");
        };
        /**
         * 发生未知关键字错误
         */
        MD5MeshParser.prototype.sendUnknownKeywordError = function () {
            throw new Error("Unknown keyword at line " + (this._line + 1) + ", character " + this._charLineIndex + ". ");
        };
        MD5MeshParser.VERSION_TOKEN = "MD5Version";
        MD5MeshParser.COMMAND_LINE_TOKEN = "commandline";
        MD5MeshParser.NUM_JOINTS_TOKEN = "numJoints";
        MD5MeshParser.NUM_MESHES_TOKEN = "numMeshes";
        MD5MeshParser.COMMENT_TOKEN = "//";
        MD5MeshParser.JOINTS_TOKEN = "joints";
        MD5MeshParser.MESH_TOKEN = "mesh";
        MD5MeshParser.MESH_SHADER_TOKEN = "shader";
        MD5MeshParser.MESH_NUM_VERTS_TOKEN = "numverts";
        MD5MeshParser.MESH_VERT_TOKEN = "vert";
        MD5MeshParser.MESH_NUM_TRIS_TOKEN = "numtris";
        MD5MeshParser.MESH_TRI_TOKEN = "tri";
        MD5MeshParser.MESH_NUM_WEIGHTS_TOKEN = "numweights";
        MD5MeshParser.MESH_WEIGHT_TOKEN = "weight";
        return MD5MeshParser;
    }(feng3d.ParserBase));
    feng3d.MD5MeshParser = MD5MeshParser;
})(feng3d || (feng3d = {}));
/**
 * 顶点数据
 */
var VertexData = (function () {
    function VertexData() {
    }
    VertexData.prototype.VertexData = function () {
    };
    return VertexData;
}());
/**
 * 关节权重数据
 */
var WeightData = (function () {
    function WeightData() {
    }
    WeightData.prototype.WeightData = function () {
    };
    return WeightData;
}());
/**
 * 网格数据
 */
var MeshData = (function () {
    function MeshData() {
    }
    MeshData.prototype.MeshData = function () {
    };
    return MeshData;
}());
var feng3d;
(function (feng3d) {
    /**
     * Max3DSParser provides a parser for the 3ds data type.
     */
    var Max3DSParser = (function (_super) {
        __extends(Max3DSParser, _super);
        /**
         * Creates a new <code>Max3DSParser</code> object.
         *
         * @param useSmoothingGroups Determines whether the parser looks for smoothing groups in the 3ds file or assumes uniform smoothing. Defaults to true.
         */
        function Max3DSParser(useSmoothingGroups) {
            if (useSmoothingGroups === void 0) { useSmoothingGroups = true; }
            _super.call(this, feng3d.ParserDataFormat.BINARY);
            /**
             * @inheritDoc
             */
            this.override = function resolveDependency(resourceDependency) {
                if (resourceDependency.assets.length == 1) {
                    var asset;
                    asset = resourceDependency.assets[0];
                    if (asset.namedAsset.assetType == feng3d.AssetType.TEXTURE) {
                        var tex;
                        tex = this._textures[resourceDependency.id];
                        tex.texture = asset;
                    }
                }
            };
            /**
             * @inheritDoc
             */
            this.override = function resolveDependencyFailure(resourceDependency) {
                // TODO: Implement
            };
            /**
             * @inheritDoc
             */
            this.override = function startParsing(frameLimit) {
                _super.startParsing.call(this, frameLimit);
                this._byteData = feng3d.ParserUtil.toByteArray(_data);
                this._byteData.position = 0;
                this._byteData.endian = Endian.LITTLE_ENDIAN;
                this._textures = {};
                this._materials = {};
                this._unfinalized_objects = {};
            };
            /**
             * @inheritDoc
             */
            this.override = function proceedParsing() {
                // TODO: With this construct, the loop will run no-op for as long
                // as there is time once file has finished reading. Consider this.a nice
                // way to stop loop when byte array is empty, without putting it in
                // the while-conditional, which will prevent finalizations from
                // happening after the last chunk.
                while (hasTime()) {
                    // If we are currently working on an object, and the most recent chunk was
                    // the last one in that object, finalize the current object.
                    if (this._cur_mat && this._byteData.position >= this._cur_mat_end)
                        this.finalizeCurrentMaterial();
                    else if (this._cur_obj && this._byteData.position >= this._cur_obj_end) {
                        // Can't finalize at this point, because we have to wait until the full
                        // animation section has been parsed for any potential pivot definitions
                        this._unfinalized_objects[this._cur_obj.name] = this._cur_obj;
                        this._cur_obj_end = number.MAX_VALUE;
                        this._cur_obj = null;
                    }
                    if (this._byteData.bytesAvailable) {
                        var cid;
                        var len;
                        var end;
                        cid = this._byteData.readUnsignedShort();
                        len = this._byteData.readUnsignedInt();
                        end = this._byteData.position + (len - 6);
                        switch (cid) {
                            case 0x4D4D: // MAIN3DS
                            case 0x3D3D: // EDIT3DS
                            case 0xB000:
                                // This types are "container chunks" and contain only
                                // sub-chunks (no data on their own.) This means that
                                // there is nothing more to parse at this point, and 
                                // instead we should progress to the next chunk, which
                                // will be the first sub-chunk of this one.
                                continue;
                                break;
                            case 0xAFFF:
                                this._cur_mat_end = end;
                                this._cur_mat = this.parseMaterial();
                                break;
                            case 0x4000:
                                this._cur_obj_end = end;
                                this._cur_obj = new ObjectVO();
                                this._cur_obj.name = this.readNulTermString();
                                this._cur_obj.materials = new string[]();
                                this._cur_obj.materialFaces = {};
                                break;
                            case 0x4100:
                                this._cur_obj.type = feng3d.AssetType.MESH;
                                break;
                            case 0x4110:
                                this.parseVertexList();
                                break;
                            case 0x4120:
                                this.parseFaceList();
                                break;
                            case 0x4140:
                                this.parseUVList();
                                break;
                            case 0x4130:
                                this.parseFaceMaterialList();
                                break;
                            case 0x4160:
                                this._cur_obj.transform = this.readTransform();
                                break;
                            case 0xB002:
                                this.parseObjectAnimation(end);
                                break;
                            case 0x4150:
                                this.parseSmoothingGroups();
                                break;
                            default:
                                // Skip this (unknown) chunk
                                this._byteData.position += (len - 6);
                                break;
                        }
                    }
                }
                // More parsing is required if the entire byte array has not yet
                // been read, or if there is this.a currently non-finalized object in
                // the pipeline.
                if (this._byteData.bytesAvailable || this._cur_obj || this._cur_mat)
                    return MORE_TO_PARSE;
                else {
                    var name;
                    // Finalize any remaining objects before ending.
                    for (name in this._unfinalized_objects) {
                        var obj;
                        obj = this.constructObject(this._unfinalized_objects[name]);
                        if (obj)
                            finalizeAsset(obj, name);
                    }
                    return PARSING_DONE;
                }
            };
            this._useSmoothingGroups = useSmoothingGroups;
        }
        /**
         * Indicates whether or not a given file extension is supported by the parser.
         * @param extension The file extension of a potential file to be parsed.
         * @return Whether or not the given file type is supported.
         */
        Max3DSParser.supportsType = function (extension) {
            extension = extension.toLowerCase();
            return extension == "3ds";
        };
        /**
         * Tests whether a data block can be parsed by the parser.
         * @param data The data block to potentially be parsed.
         * @return Whether or not the given data is supported.
         */
        Max3DSParser.supportsData = function (data) {
            if (data === void 0) { data =  * ; }
            var ba;
            ba = feng3d.ParserUtil.toByteArray(data);
            if (ba) {
                ba.position = 0;
                if (ba.readShort() == 0x4d4d)
                    return true;
            }
            return false;
        };
        Max3DSParser.prototype.parseMaterial = function () {
            var mat;
            mat = new MaterialVO();
            while (this._byteData.position < this._cur_mat_end) {
                var cid;
                var len;
                var end;
                cid = this._byteData.readUnsignedShort();
                len = this._byteData.readUnsignedInt();
                end = this._byteData.position + (len - 6);
                switch (cid) {
                    case 0xA000:
                        mat.name = this.readNulTermString();
                        break;
                    case 0xA010:
                        mat.ambientColor = this.readColor();
                        break;
                    case 0xA020:
                        mat.diffuseColor = this.readColor();
                        break;
                    case 0xA030:
                        mat.specularColor = this.readColor();
                        break;
                    case 0xA081:
                        mat.twoSided = true;
                        break;
                    case 0xA200:
                        mat.colorMap = this.parseTexture(end);
                        break;
                    case 0xA204:
                        mat.specularMap = this.parseTexture(end);
                        break;
                    default:
                        this._byteData.position = end;
                        break;
                }
            }
            return mat;
        };
        Max3DSParser.prototype.parseTexture = function (end) {
            var tex;
            tex = new TextureVO();
            while (this._byteData.position < end) {
                var cid;
                var len;
                cid = this._byteData.readUnsignedShort();
                len = this._byteData.readUnsignedInt();
                switch (cid) {
                    case 0xA300:
                        tex.url = this.readNulTermString();
                        break;
                    default:
                        // Skip this unknown this.texture sub-chunk
                        this._byteData.position += (len - 6);
                        break;
                }
            }
            this._textures[tex.url] = tex;
            addDependency(tex.url, new URLRequest(tex.url));
            return tex;
        };
        Max3DSParser.prototype.parseVertexList = function () {
            var i;
            var len;
            var count;
            count = this._byteData.readUnsignedShort();
            this._cur_obj.verts = new number[](count * 3, true);
            i = 0;
            len = this._cur_obj.verts.length;
            while (i < len) {
                var x;
                this.y;
                number, this.z;
                number;
                x = this._byteData.readFloat();
                this.y = this._byteData.readFloat();
                this.z = this._byteData.readFloat();
                this._cur_obj.verts[i++] = x;
                this._cur_obj.verts[i++] = this.z;
                this._cur_obj.verts[i++] = this.y;
            }
        };
        Max3DSParser.prototype.parseFaceList = function () {
            var i;
            var len;
            var count;
            count = this._byteData.readUnsignedShort();
            this._cur_obj.indices = new number[](count * 3, true);
            i = 0;
            len = this._cur_obj.indices.length;
            while (i < len) {
                var i0, i1, i2;
                i0 = this._byteData.readUnsignedShort();
                i1 = this._byteData.readUnsignedShort();
                i2 = this._byteData.readUnsignedShort();
                this._cur_obj.indices[i++] = i0;
                this._cur_obj.indices[i++] = i2;
                this._cur_obj.indices[i++] = i1;
                // Skip "face info", irrelevant in Away3D
                this._byteData.position += 2;
            }
            this._cur_obj.smoothingGroups = new number[](count, true);
        };
        Max3DSParser.prototype.parseSmoothingGroups = function () {
            var len = this._cur_obj.indices.length / 3;
            var i = 0;
            while (i < len) {
                this._cur_obj.smoothingGroups[i] = this._byteData.readUnsignedInt();
                i++;
            }
        };
        Max3DSParser.prototype.parseUVList = function () {
            var i;
            var len;
            var count;
            count = this._byteData.readUnsignedShort();
            this._cur_obj.uvs = new number[](count * 2, true);
            i = 0;
            len = this._cur_obj.uvs.length;
            while (i < len) {
                this._cur_obj.uvs[i++] = this._byteData.readFloat();
                this._cur_obj.uvs[i++] = 1.0 - this._byteData.readFloat();
            }
        };
        Max3DSParser.prototype.parseFaceMaterialList = function () {
            var mat;
            var count;
            var i;
            var faces;
            mat = this.readNulTermString();
            count = this._byteData.readUnsignedShort();
            faces = new number[](count, true);
            i = 0;
            while (i < faces.length)
                faces[i++] = this._byteData.readUnsignedShort();
            this._cur_obj.materials.push(mat);
            this._cur_obj.materialFaces[mat] = faces;
        };
        Max3DSParser.prototype.parseObjectAnimation = function (end) {
            var vo;
            var obj;
            var pivot;
            var name;
            var hier;
            // Pivot defaults to origin
            pivot = new Vector3D;
            while (this._byteData.position < end) {
                var cid;
                var len;
                cid = this._byteData.readUnsignedShort();
                len = this._byteData.readUnsignedInt();
                switch (cid) {
                    case 0xb010:
                        name = this.readNulTermString();
                        this._byteData.position += 4;
                        hier = this._byteData.readShort();
                        break;
                    case 0xb013:
                        pivot.x = this._byteData.readFloat();
                        pivot.z = this._byteData.readFloat();
                        pivot.y = this._byteData.readFloat();
                        break;
                    default:
                        this._byteData.position += (len - 6);
                        break;
                }
            }
            // If name is "$$$DUMMY" this is an empty object (e.g. this.a container)
            // and will be ignored in this version of the parser
            // TODO: Implement containers in 3DS parser.
            if (name != '$$$DUMMY' && this._unfinalized_objects.hasOwnProperty(name)) {
                vo = this._unfinalized_objects[name];
                obj = this.constructObject(vo, pivot);
                if (obj)
                    finalizeAsset(obj, vo.name);
                delete this._unfinalized_objects[name];
            }
        };
        Max3DSParser.prototype.constructObject = function (obj, pivot) {
            if (pivot === void 0) { pivot = null; }
            if (obj.type == feng3d.AssetType.MESH) {
                var i;
                var subs;
                var geom;
                var mat;
                var mesh;
                var mtx;
                var vertices;
                var faces;
                if (obj.materials.length > 1)
                    trace('The Away3D 3DS parser does not support multiple this.materials per mesh at this point.');
                // Ignore empty objects
                if (!obj.indices || obj.indices.length == 0)
                    return null;
                vertices = new VertexVO[](obj.verts.length / 3, false);
                faces = new FaceVO[](obj.indices.length / 3, true);
                this.prepareData(vertices, faces, obj);
                if (this._useSmoothingGroups)
                    this.applySmoothGroups(vertices, faces);
                obj.verts = new number[](vertices.length * 3, true);
                for (i = 0; i < vertices.length; i++) {
                    obj.verts[i * 3] = vertices[i].x;
                    obj.verts[i * 3 + 1] = vertices[i].y;
                    obj.verts[i * 3 + 2] = vertices[i].z;
                }
                obj.indices = new number[](faces.length * 3, true);
                for (i = 0; i < faces.length; i++) {
                    obj.indices[i * 3] = faces[i].a;
                    obj.indices[i * 3 + 1] = faces[i].b;
                    obj.indices[i * 3 + 2] = faces[i].c;
                }
                if (obj.uvs) {
                    // If the object had UVs to start with, use UVs generated by
                    // smoothing group splitting algorithm. Otherwise those UVs
                    // will be nonsense and should be skipped.
                    obj.uvs = new number[](vertices.length * 2, true);
                    for (i = 0; i < vertices.length; i++) {
                        obj.uvs[i * 2] = vertices[i].u;
                        obj.uvs[i * 2 + 1] = vertices[i].v;
                    }
                }
                geom = new feng3d.Geometry();
                // Construct sub-geometries (potentially splitting buffers)
                // and add them to geometry.
                subs = feng3d.GeomUtil.fromVectors(obj.verts, obj.indices, obj.uvs, null, null);
                for (i = 0; i < subs.length; i++)
                    geom.subGeometries.push(subs[i]);
                if (obj.materials.length > 0) {
                    var mname;
                    mname = obj.materials[0];
                    mat = this._materials[mname].material;
                }
                // Apply pivot translation to geometry if this.a pivot was
                // found while parsing the keyframe chunk earlier.
                if (pivot) {
                    if (obj.transform) {
                        // If this.a this.transform was found while parsing the
                        // object chunk, use it to find the local pivot vector
                        var dat = obj.transform.concat();
                        dat[12] = 0;
                        dat[13] = 0;
                        dat[14] = 0;
                        mtx = new Matrix3D(dat);
                        pivot = mtx.transformVector(pivot);
                    }
                    pivot.scaleBy(-1);
                    mtx = new Matrix3D();
                    mtx.appendTranslation(pivot.x, pivot.y, pivot.z);
                    geom.applyTransformation(mtx);
                }
                // Apply transformation to geometry if this.a transformation
                // was found while parsing the object chunk earlier.
                if (obj.transform) {
                    mtx = new Matrix3D(obj.transform);
                    mtx.invert();
                    geom.applyTransformation(mtx);
                }
                // Final this.transform applied to geometry. Finalize the geometry,
                // which will no longer be modified after this point.
                finalizeAsset(geom, obj.name.concat('_geom'));
                // Build mesh and return it
                mesh = new feng3d.Mesh(geom, mat);
                mesh.transform3D.transform = new Matrix3D(obj.transform);
                return mesh;
            }
            // If reached, unknown
            return null;
        };
        Max3DSParser.prototype.prepareData = function (vertices, faces, obj) {
            // convert raw ObjectVO's data to structured VertexVO and FaceVO
            var i;
            var j;
            var k;
            var len = obj.verts.length;
            for (i = 0, j = 0, k = 0; i < len;) {
                var v = new VertexVO;
                v.x = obj.verts[i++];
                v.y = obj.verts[i++];
                v.z = obj.verts[i++];
                if (obj.uvs) {
                    v.u = obj.uvs[j++];
                    v.v = obj.uvs[j++];
                }
                vertices[k++] = v;
            }
            len = obj.indices.length;
            for (i = 0, k = 0; i < len;) {
                var f = new FaceVO();
                f.a = obj.indices[i++];
                f.b = obj.indices[i++];
                f.c = obj.indices[i++];
                f.smoothGroup = obj.smoothingGroups[k];
                faces[k++] = f;
            }
        };
        Max3DSParser.prototype.applySmoothGroups = function (vertices, faces) {
            // clone vertices according to following rule:
            // clone if vertex's in faces from groups 1+2 and 3
            // don't clone if vertex's in faces from groups 1+2, 3 and 1+3
            var i;
            var j;
            var k;
            var l;
            var len;
            var numVerts = vertices.length;
            var numFaces = faces.length;
            // extract groups data for vertices
            var vGroups = new Vector.(numVerts, true);
            for (i = 0; i < numVerts; i++)
                vGroups[i] = new number[];
            for (i = 0; i < numFaces; i++) {
                var face = FaceVO(faces[i]);
                for (j = 0; j < 3; j++) {
                    var groups = vGroups[(j == 0) ? face.a : ((j == 1) ? face.b : face.c)];
                    var group = face.smoothGroup;
                    for (k = groups.length - 1; k >= 0; k--) {
                        if ((group & groups[k]) > 0) {
                            group |= groups[k];
                            groups.splice(k, 1);
                            k = groups.length - 1;
                        }
                    }
                    groups.push(group);
                }
            }
            // clone vertices
            var vClones = new Vector.(numVerts, true);
            for (i = 0; i < numVerts; i++) {
                if ((len = vGroups[i].length) < 1)
                    continue;
                var clones = new number[](len, true);
                vClones[i] = clones;
                clones[0] = i;
                var v0 = vertices[i];
                for (j = 1; j < len; j++) {
                    var v1 = new VertexVO;
                    v1.x = v0.x;
                    v1.y = v0.y;
                    v1.z = v0.z;
                    v1.u = v0.u;
                    v1.v = v0.v;
                    clones[j] = vertices.length;
                    vertices.push(v1);
                }
            }
            numVerts = vertices.length;
            for (i = 0; i < numFaces; i++) {
                face = FaceVO(faces[i]);
                group = face.smoothGroup;
                for (j = 0; j < 3; j++) {
                    k = (j == 0) ? face.a : ((j == 1) ? face.b : face.c);
                    groups = vGroups[k];
                    len = groups.length;
                    clones = vClones[k];
                    for (l = 0; l < len; l++) {
                        if (((group == 0) && (groups[l] == 0)) || ((group & groups[l]) > 0)) {
                            var index = clones[l];
                            if (group == 0) {
                                // vertex is unique if no this.smoothGroup found
                                groups.splice(l, 1);
                                clones.splice(l, 1);
                            }
                            if (j == 0)
                                face.a = index;
                            else if (j == 1)
                                face.b = index;
                            else
                                face.c = index;
                            l = len;
                        }
                    }
                }
            }
        };
        Max3DSParser.prototype.finalizeCurrentMaterial = function () {
            var mat;
            if (this.materialMode < 2) {
                if (this._cur_mat.colorMap)
                    mat = new feng3d.TextureMaterial(this._cur_mat.colorMap.texture || feng3d.DefaultMaterialManager.getDefaultTexture());
                else
                    mat = new feng3d.ColorMaterial(this._cur_mat.diffuseColor);
                feng3d.SinglePassMaterialBase(mat).ambientColor = this._cur_mat.ambientColor;
                feng3d.SinglePassMaterialBase(mat).specularColor = this._cur_mat.specularColor;
            }
            else {
                if (this._cur_mat.colorMap)
                    mat = new feng3d.TextureMultiPassMaterial(this._cur_mat.colorMap.texture || feng3d.DefaultMaterialManager.getDefaultTexture());
                else
                    mat = new feng3d.ColorMultiPassMaterial(this._cur_mat.diffuseColor);
            }
            mat.bothSides = this._cur_mat.twoSided;
            finalizeAsset(mat, this._cur_mat.name);
            this._materials[this._cur_mat.name] = this._cur_mat;
            this._cur_mat.material = mat;
            this._cur_mat = null;
        };
        Max3DSParser.prototype.readNulTermString = function () {
            var chr;
            var str = new string();
            while ((chr = this._byteData.readUnsignedByte()) > 0)
                str += string.fromCharCode(chr);
            return str;
        };
        Max3DSParser.prototype.readTransform = function () {
            var data;
            data = new number[](16, true);
            // X axis
            data[0] = this._byteData.readFloat(); // X
            data[2] = this._byteData.readFloat(); // Z
            data[1] = this._byteData.readFloat(); // Y
            data[3] = 0;
            // Z axis
            data[8] = this._byteData.readFloat(); // X
            data[10] = this._byteData.readFloat(); // Z
            data[9] = this._byteData.readFloat(); // Y
            data[11] = 0;
            // Y Axis
            data[4] = this._byteData.readFloat(); // X 
            data[6] = this._byteData.readFloat(); // Z
            data[5] = this._byteData.readFloat(); // Y
            data[7] = 0;
            // Translation
            data[12] = this._byteData.readFloat(); // X
            data[14] = this._byteData.readFloat(); // Z
            data[13] = this._byteData.readFloat(); // Y
            data[15] = 1;
            return data;
        };
        Max3DSParser.prototype.readColor = function () {
            var cid;
            var len;
            var r, g;
            this.b;
            number;
            cid = this._byteData.readUnsignedShort();
            len = this._byteData.readUnsignedInt();
            switch (cid) {
                case 0x0010:
                    r = this._byteData.readFloat() * 255;
                    g = this._byteData.readFloat() * 255;
                    this.b = this._byteData.readFloat() * 255;
                    break;
                case 0x0011:
                    r = this._byteData.readUnsignedByte();
                    g = this._byteData.readUnsignedByte();
                    this.b = this._byteData.readUnsignedByte();
                    break;
                default:
                    this._byteData.position += (len - 6);
                    break;
            }
            return (r << 16) | (g << 8) | this.b;
        };
        return Max3DSParser;
    }(feng3d.ParserBase));
    feng3d.Max3DSParser = Max3DSParser;
})(feng3d || (feng3d = {}));
internal;
var TextureVO = (function () {
    function TextureVO() {
    }
    TextureVO.prototype.TextureVO = function () {
    };
    return TextureVO;
}());
internal;
var MaterialVO = (function () {
    function MaterialVO() {
    }
    MaterialVO.prototype.MaterialVO = function () {
    };
    return MaterialVO;
}());
internal;
var ObjectVO = (function () {
    function ObjectVO() {
    }
    ObjectVO.prototype.ObjectVO = function () {
    };
    return ObjectVO;
}());
internal;
var VertexVO = (function () {
    function VertexVO() {
    }
    VertexVO.prototype.VertexVO = function () {
    };
    return VertexVO;
}());
internal;
var FaceVO = (function () {
    function FaceVO() {
    }
    FaceVO.prototype.FaceVO = function () {
    };
    return FaceVO;
}());
var feng3d;
(function (feng3d) {
    /**
     * Obj模型解析者
     */
    var OBJParser = (function (_super) {
        __extends(OBJParser, _super);
        /**
         * 创建Obj模型解析对象
         * @param scale 缩放比例
         */
        function OBJParser(scale) {
            if (scale === void 0) { scale = 1; }
            _super.call(this, feng3d.ParserDataFormat.PLAIN_TEXT);
            /** 材质库是否已加载 */
            this._mtlLibLoaded = true;
            /** 活动材质编号 */
            this._activeMaterialID = "";
            this._scale = scale;
        }
        /**
         * 判断是否支持解析
         * @param extension 文件类型
         * @return
         */
        OBJParser.supportsType = function (extension) {
            extension = extension.toLowerCase();
            return extension == "obj";
        };
        /**
         * 判断是否支持该数据的解析
         * @param data 需要解析的数据
         * @return
         */
        OBJParser.supportsData = function (data) {
            if (data === void 0) { data =  * ; }
            var content = feng3d.ParserUtil.toString(data);
            var hasV;
            var hasF;
            if (content) {
                hasV = content.indexOf("\nv ") != -1;
                hasF = content.indexOf("\nf ") != -1;
            }
            return hasV && hasF;
        };
        OBJParser.prototype.resolveDependency = function (resourceDependency) {
            if (resourceDependency.id == 'mtl') {
                var str = feng3d.ParserUtil.toString(resourceDependency.data);
                this.parseMtl(str);
            }
            else {
                var asset;
                if (resourceDependency.assets.length != 1)
                    return;
                asset = resourceDependency.assets[0];
                if (asset.namedAsset.assetType == feng3d.AssetType.TEXTURE) {
                    var lm = new LoadedMaterial();
                    lm.materialID = resourceDependency.id;
                    lm.texture = asset;
                    this._materialLoaded.push(lm);
                    if (this._meshes.length > 0)
                        this.applyMaterial(lm);
                }
            }
        };
        OBJParser.prototype.resolveDependencyFailure = function (resourceDependency) {
            if (resourceDependency.id == "mtl") {
                this._mtlLib = false;
                this._mtlLibLoaded = false;
            }
            else {
                var lm = new LoadedMaterial();
                lm.materialID = resourceDependency.id;
                this._materialLoaded.push(lm);
            }
            if (this._meshes.length > 0)
                this.applyMaterial(lm);
        };
        OBJParser.prototype.proceedParsing = function () {
            //单行数据
            var line;
            //换行符
            var creturn = string.fromCharCode(10);
            var trunk;
            if (!this._startedParsing) {
                this._textData = getTextData();
                // Merge linebreaks that are immediately preceeded by
                // the "escape" backward slash into single lines.
                this._textData = this._textData.replace(/\\[\r\n]+\s*/gm, ' ');
            }
            if (this._textData.indexOf(creturn) == -1)
                creturn = string.fromCharCode(13);
            //初始化数据
            if (!this._startedParsing) {
                this._startedParsing = true;
                this._vertices = new feng3d.Vertex[]();
                this._vertexNormals = new feng3d.Vertex[]();
                this._materialIDs = new string[]();
                this._materialLoaded = new LoadedMaterial[]();
                this._meshes = new feng3d.Mesh[]();
                this._uvs = new feng3d.UV[]();
                this._stringLength = this._textData.length;
                this._charIndex = this._textData.indexOf(creturn, 0);
                this._oldIndex = 0;
                this._objects = new ObjectGroup[]();
                this._objectIndex = 0;
            }
            //判断是否解析完毕与是否还有时间
            while (this._charIndex < this._stringLength && hasTime()) {
                this._charIndex = this._textData.indexOf(creturn, this._oldIndex);
                if (this._charIndex == -1)
                    this._charIndex = this._stringLength;
                //获取单行数据 整理数据格式
                line = this._textData.substring(this._oldIndex, this._charIndex);
                line = line.split('\r').join("");
                line = line.replace("  ", " ");
                trunk = line.split(" ");
                this._oldIndex = this._charIndex + 1;
                //解析该行数据
                this.parseLine(trunk);
                //处理暂停
                if (this.parsingPaused)
                    return MORE_TO_PARSE;
            }
            //数据解析到文件未
            if (this._charIndex >= this._stringLength) {
                //判断是否还需要等待材质解析
                if (this._mtlLib && !this._mtlLibLoaded)
                    return MORE_TO_PARSE;
                this.translate();
                this.applyMaterials();
                return PARSING_DONE;
            }
            return MORE_TO_PARSE;
        };
        /**
         * 解析行
         */
        OBJParser.prototype.parseLine = function (trunk) {
            switch (trunk[0]) {
                case "mtllib":
                    this._mtlLib = true;
                    this._mtlLibLoaded = false;
                    this.loadMtl(trunk[1]);
                    break;
                case "g":
                    this.createGroup(trunk);
                    break;
                case "o":
                    this.createObject(trunk);
                    break;
                case "usemtl":
                    if (this._mtlLib) {
                        if (!trunk[1])
                            trunk[1] = "def000";
                        this._materialIDs.push(trunk[1]);
                        this._activeMaterialID = trunk[1];
                        if (this._currentGroup)
                            this._currentGroup.materialID = this._activeMaterialID;
                    }
                    break;
                case "v":
                    this.parseVertex(trunk);
                    break;
                case "vt":
                    this.parseUV(trunk);
                    break;
                case "vn":
                    this.parseVertexNormal(trunk);
                    break;
                case "f":
                    this.parseFace(trunk);
            }
        };
        /**
         * 把解析出来的数据转换成引擎使用的数据结构
         */
        OBJParser.prototype.translate = function () {
            for (var objIndex = 0; objIndex < this._objects.length; ++objIndex) {
                var groups = this._objects[objIndex].groups;
                var numGroups = groups.length;
                var materialGroups;
                var numMaterialGroups;
                var geometry;
                var mesh;
                var m;
                var sm;
                var bmMaterial;
                for (var g = 0; g < numGroups; ++g) {
                    geometry = new feng3d.Geometry();
                    materialGroups = groups[g].materialGroups;
                    numMaterialGroups = materialGroups.length;
                    //添加子网格
                    for (m = 0; m < numMaterialGroups; ++m)
                        this.translateMaterialGroup(materialGroups[m], geometry);
                    if (geometry.subGeometries.length == 0)
                        continue;
                    //完成几何体资源解析
                    finalizeAsset(geometry, "");
                    if (this.materialMode < 2)
                        bmMaterial = new feng3d.TextureMaterial(feng3d.DefaultMaterialManager.getDefaultTexture());
                    else
                        bmMaterial = new feng3d.TextureMultiPassMaterial(feng3d.DefaultMaterialManager.getDefaultTexture());
                    //创建网格
                    mesh = new feng3d.Mesh(geometry, bmMaterial);
                    //网格命名
                    if (this._objects[objIndex].name) {
                        //使用'o'标签给网格命名
                        mesh.name = this._objects[objIndex].name;
                    }
                    else if (groups[g].name) {
                        //使用'g'标签给网格命名
                        mesh.name = groups[g].name;
                    }
                    else {
                        mesh.name = "";
                    }
                    this._meshes.push(mesh);
                    //给材质命名
                    if (groups[g].materialID != "")
                        bmMaterial.name = groups[g].materialID + "~" + mesh.name;
                    else
                        bmMaterial.name = this._lastMtlID + "~" + mesh.name;
                    //子网使用材质
                    if (mesh.subMeshes.length > 1) {
                        for (sm = 1; sm < mesh.subMeshes.length; ++sm)
                            mesh.subMeshes[sm].material = bmMaterial;
                    }
                    finalizeAsset(mesh);
                }
            }
        };
        /**
         * 转换材质组为子网格
         * @param materialGroup 材质组网格数据
         * @param geometry 解析出子网格的父网格
         */
        OBJParser.prototype.translateMaterialGroup = function (materialGroup, geometry) {
            var faces = materialGroup.faces;
            var face;
            var numFaces = faces.length;
            var numVerts;
            var subs;
            var vertices = new number[]();
            var uvs = new number[]();
            var normals = new number[]();
            var indices = new number[]();
            this._realIndices = [];
            this._vertexIndex = 0;
            //解析面数据
            var j;
            for (var i = 0; i < numFaces; ++i) {
                face = faces[i];
                numVerts = face.indexIds.length - 1;
                //兼容多边形(拆分成N-1个三角形)
                for (j = 1; j < numVerts; ++j) {
                    this.translateVertexData(face, j, vertices, uvs, indices, normals);
                    this.translateVertexData(face, 0, vertices, uvs, indices, normals);
                    this.translateVertexData(face, j + 1, vertices, uvs, indices, normals);
                }
            }
            //创建 子网格
            if (vertices.length > 0) {
                subs = feng3d.GeomUtil.fromVectors(vertices, indices, uvs, null, null);
                for (i = 0; i < subs.length; i++)
                    geometry.addSubGeometry(subs[i]);
            }
        };
        /**
         * 把面数据转换为顶点等数据
         * @param face
         * @param vertexIndex
         * @param vertices
         * @param uvs
         * @param indices
         * @param normals
         */
        OBJParser.prototype.translateVertexData = function (face, vertexIndex, vertices, uvs, indices, normals) {
            var index;
            var vertex;
            var vertexNormal;
            var uv;
            if (!this._realIndices[face.indexIds[vertexIndex]]) {
                index = this._vertexIndex;
                this._realIndices[face.indexIds[vertexIndex]] = ++this._vertexIndex;
                vertex = this._vertices[face.vertexIndices[vertexIndex] - 1];
                vertices.push(vertex.x * this._scale, vertex.y * this._scale, vertex.z * this._scale);
                if (face.normalIndices.length > 0) {
                    vertexNormal = this._vertexNormals[face.normalIndices[vertexIndex] - 1];
                    normals.push(vertexNormal.x, vertexNormal.y, vertexNormal.z);
                }
                if (face.uvIndices.length > 0) {
                    try {
                        uv = this._uvs[face.uvIndices[vertexIndex] - 1];
                        uvs.push(uv.u, uv.v);
                    }
                    catch (e) {
                        switch (vertexIndex) {
                            case 0:
                                uvs.push(0, 1);
                                break;
                            case 1:
                                uvs.push(.5, 0);
                                break;
                            case 2:
                                uvs.push(1, 1);
                        }
                    }
                }
            }
            else
                index = this._realIndices[face.indexIds[vertexIndex]] - 1;
            indices.push(index);
        };
        /**
         * 创建对象组
         * @param trunk 包含材料标记的数据块和它的参数
         */
        OBJParser.prototype.createObject = function (trunk) {
            this._currentGroup = null;
            this._currentMaterialGroup = null;
            this._objects.push(this._currentObject = new ObjectGroup());
            if (trunk)
                this._currentObject.name = trunk[1];
        };
        /**
         * 创建一个组
         * @param trunk 包含材料标记的数据块和它的参数
         */
        OBJParser.prototype.createGroup = function (trunk) {
            if (!this._currentObject)
                this.createObject(null);
            this._currentGroup = new Group();
            this._currentGroup.materialID = this._activeMaterialID;
            if (trunk)
                this._currentGroup.name = trunk[1];
            this._currentObject.groups.push(this._currentGroup);
            this.createMaterialGroup(null);
        };
        /**
         * 创建材质组
         * @param trunk 包含材料标记的数据块和它的参数
         */
        OBJParser.prototype.createMaterialGroup = function (trunk) {
            this._currentMaterialGroup = new MaterialGroup();
            if (trunk)
                this._currentMaterialGroup.url = trunk[1];
            this._currentGroup.materialGroups.push(this._currentMaterialGroup);
        };
        /**
         * 解析顶点坐标数据
         * @param trunk 坐标数据
         */
        OBJParser.prototype.parseVertex = function (trunk) {
            if (trunk.length > 4) {
                var nTrunk = [];
                var val;
                for (var i = 1; i < trunk.length; ++i) {
                    val = parseFloat(trunk[i]);
                    if (!isNaN(val))
                        nTrunk.push(val);
                }
                this._vertices.push(new feng3d.Vertex(nTrunk[0], nTrunk[1], -nTrunk[2]));
            }
            else
                this._vertices.push(new feng3d.Vertex(parseFloat(trunk[1]), parseFloat(trunk[2]), -parseFloat(trunk[3])));
        };
        /**
         * 解析uv
         * @param trunk uv数据
         */
        OBJParser.prototype.parseUV = function (trunk) {
            if (trunk.length > 3) {
                var nTrunk = [];
                var val;
                //获取有效数字
                for (var i = 1; i < trunk.length; ++i) {
                    val = parseFloat(trunk[i]);
                    if (!isNaN(val))
                        nTrunk.push(val);
                }
                this._uvs.push(new feng3d.UV(nTrunk[0], 1 - nTrunk[1]));
            }
            else
                this._uvs.push(new feng3d.UV(parseFloat(trunk[1]), 1 - parseFloat(trunk[2])));
        };
        /**
         * 解析顶点法线
         * @param trunk 法线数据
         */
        OBJParser.prototype.parseVertexNormal = function (trunk) {
            if (trunk.length > 4) {
                var nTrunk = [];
                var val;
                //获取有效数字
                for (var i = 1; i < trunk.length; ++i) {
                    val = parseFloat(trunk[i]);
                    if (!isNaN(val))
                        nTrunk.push(val);
                }
                this._vertexNormals.push(new feng3d.Vertex(nTrunk[0], nTrunk[1], -nTrunk[2]));
            }
            else
                this._vertexNormals.push(new feng3d.Vertex(parseFloat(trunk[1]), parseFloat(trunk[2]), -parseFloat(trunk[3])));
        };
        /**
         * 解析面
         * @param trunk 面数据
         */
        OBJParser.prototype.parseFace = function (trunk) {
            var len = trunk.length;
            var face = new FaceData();
            if (!this._currentGroup)
                this.createGroup(null);
            var indices;
            for (var i = 1; i < len; ++i) {
                if (trunk[i] == "")
                    continue;
                //解析单个面数据，分离出顶点坐标左右、uv索引、法线索引
                indices = trunk[i].split("/");
                face.vertexIndices.push(this.parseIndex(parseInt(indices[0]), this._vertices.length));
                if (indices[1] && string(indices[1]).length > 0)
                    face.uvIndices.push(this.parseIndex(parseInt(indices[1]), this._uvs.length));
                if (indices[2] && string(indices[2]).length > 0)
                    face.normalIndices.push(this.parseIndex(parseInt(indices[2]), this._vertexNormals.length));
                face.indexIds.push(trunk[i]);
            }
            this._currentMaterialGroup.faces.push(face);
        };
        /**
         * This is a hack around negative face coords
         */
        OBJParser.prototype.parseIndex = function (index, length) {
            if (index < 0)
                return index + length + 1;
            else
                return index;
        };
        /**
         * 解析材质数据
         * @param data 材质数据
         */
        OBJParser.prototype.parseMtl = function (data) {
            var materialDefinitions = data.split('newmtl');
            var lines;
            var trunk;
            var j;
            var basicSpecularMethod;
            var useSpecular;
            var useColor;
            var diffuseColor;
            var ambientColor;
            var specularColor;
            var specular;
            var alpha;
            var mapkd;
            for (var i = 0; i < materialDefinitions.length; ++i) {
                lines = materialDefinitions[i].split('\r').join("").split('\n');
                if (lines.length == 1)
                    lines = materialDefinitions[i].split(string.fromCharCode(13));
                diffuseColor = ambientColor = specularColor = 0xFFFFFF;
                specular = 0;
                useSpecular = false;
                useColor = false;
                alpha = 1;
                mapkd = "";
                for (j = 0; j < lines.length; ++j) {
                    lines[j] = lines[j].replace(/\s+$/, "");
                    if (lines[j].substring(0, 1) != "#" && (j == 0 || lines[j] != "")) {
                        trunk = lines[j].split(" ");
                        if (string(trunk[0]).charCodeAt(0) == 9 || string(trunk[0]).charCodeAt(0) == 32)
                            trunk[0] = trunk[0].substring(1, trunk[0].length);
                        if (j == 0) {
                            this._lastMtlID = trunk.join("");
                            this._lastMtlID = (this._lastMtlID == "") ? "def000" : this._lastMtlID;
                        }
                        else {
                            switch (trunk[0]) {
                                case "Ka":
                                    if (trunk[1] && !isNaN(number(trunk[1])) && trunk[2] && !isNaN(number(trunk[2])) && trunk[3] && !isNaN(number(trunk[3])))
                                        ambientColor = trunk[1] * 255 << 16 | trunk[2] * 255 << 8 | trunk[3] * 255;
                                    break;
                                case "Ks":
                                    if (trunk[1] && !isNaN(number(trunk[1])) && trunk[2] && !isNaN(number(trunk[2])) && trunk[3] && !isNaN(number(trunk[3]))) {
                                        specularColor = trunk[1] * 255 << 16 | trunk[2] * 255 << 8 | trunk[3] * 255;
                                        useSpecular = true;
                                    }
                                    break;
                                case "Ns":
                                    if (trunk[1] && !isNaN(number(trunk[1])))
                                        specular = number(trunk[1]) * 0.001;
                                    if (specular == 0)
                                        useSpecular = false;
                                    break;
                                case "Kd":
                                    if (trunk[1] && !isNaN(number(trunk[1])) && trunk[2] && !isNaN(number(trunk[2])) && trunk[3] && !isNaN(number(trunk[3]))) {
                                        diffuseColor = trunk[1] * 255 << 16 | trunk[2] * 255 << 8 | trunk[3] * 255;
                                        useColor = true;
                                    }
                                    break;
                                case "tr":
                                case "d":
                                    if (trunk[1] && !isNaN(number(trunk[1])))
                                        alpha = number(trunk[1]);
                                    break;
                                case "map_Kd":
                                    mapkd = this.parseMapKdString(trunk);
                                    mapkd = mapkd.replace(/\\/g, "/");
                            }
                        }
                    }
                }
                if (mapkd != "") {
                    if (useSpecular) {
                        basicSpecularMethod = new feng3d.BasicSpecularMethod();
                        basicSpecularMethod.specularColor = specularColor;
                        basicSpecularMethod.specular = specular;
                        var specularData = new SpecularData();
                        specularData.alpha = alpha;
                        specularData.basicSpecularMethod = basicSpecularMethod;
                        specularData.materialID = this._lastMtlID;
                        if (!this._materialSpecularData)
                            this._materialSpecularData = new SpecularData[]();
                        this._materialSpecularData.push(specularData);
                    }
                    //添加材质依赖性
                    addDependency(this._lastMtlID, new URLRequest(mapkd));
                }
                else if (useColor && !isNaN(diffuseColor)) {
                    var lm = new LoadedMaterial();
                    lm.materialID = this._lastMtlID;
                    if (alpha == 0)
                        trace("Warning: an alpha value of 0 was found in mtl color tag (Tr or d) ref:" + this._lastMtlID + ", mesh(es) using it will be invisible!");
                    var cm;
                    if (this.materialMode < 2) {
                        cm = new feng3d.ColorMaterial(diffuseColor);
                        feng3d.ColorMaterial(cm).alpha = alpha;
                        feng3d.ColorMaterial(cm).ambientColor = ambientColor;
                        feng3d.ColorMaterial(cm).repeat = true;
                        if (useSpecular) {
                            feng3d.ColorMaterial(cm).specularColor = specularColor;
                            feng3d.ColorMaterial(cm).specular = specular;
                        }
                    }
                    else {
                        cm = new feng3d.ColorMultiPassMaterial(diffuseColor);
                        feng3d.ColorMultiPassMaterial(cm).ambientColor = ambientColor;
                        feng3d.ColorMultiPassMaterial(cm).repeat = true;
                        if (useSpecular) {
                            feng3d.ColorMultiPassMaterial(cm).specularColor = specularColor;
                            feng3d.ColorMultiPassMaterial(cm).specular = specular;
                        }
                    }
                    lm.cm = cm;
                    this._materialLoaded.push(lm);
                    if (this._meshes.length > 0)
                        this.applyMaterial(lm);
                }
            }
            this._mtlLibLoaded = true;
        };
        OBJParser.prototype.parseMapKdString = function (trunk) {
            var url = "";
            var i;
            var breakflag;
            for (i = 1; i < trunk.length;) {
                switch (trunk[i]) {
                    case "-blendu":
                    case "-blendv":
                    case "-cc":
                    case "-clamp":
                    case "-texres":
                        i += 2; //Skip ahead 1 attribute
                        break;
                    case "-mm":
                        i += 3; //Skip ahead 2 attributes
                        break;
                    case "-o":
                    case "-s":
                    case "-t":
                        i += 4; //Skip ahead 3 attributes
                        continue;
                    default:
                        breakflag = true;
                        break;
                }
                if (breakflag)
                    break;
            }
            //Reconstruct URL/filename
            for (i; i < trunk.length; i++) {
                url += trunk[i];
                url += " ";
            }
            //Remove the extraneous space and/or newline from the right side
            url = url.replace(/\s+$/, "");
            return url;
        };
        /**
         * 加载材质
         * @param mtlurl 材质地址
         */
        OBJParser.prototype.loadMtl = function (mtlurl) {
            //添加 材质 资源依赖，暂停解析
            addDependency('mtl', new URLRequest(mtlurl), true);
            pauseAndRetrieveDependencies();
        };
        /**
         * 应用材质
         * @param lm 加载到的材质
         */
        OBJParser.prototype.applyMaterial = function (lm) {
            var decomposeID;
            var mesh;
            var mat;
            var j;
            var specularData;
            for (var i = 0; i < this._meshes.length; ++i) {
                mesh = this._meshes[i];
                decomposeID = mesh.material.name.split("~");
                if (decomposeID[0] == lm.materialID) {
                    if (lm.cm) {
                        if (mesh.material)
                            mesh.material = null;
                        mesh.material = lm.cm;
                    }
                    else if (lm.texture) {
                        if (this.materialMode < 2) {
                            mat = feng3d.TextureMaterial(mesh.material);
                            feng3d.TextureMaterial(mat).texture = lm.texture;
                            feng3d.TextureMaterial(mat).ambientColor = lm.ambientColor;
                            feng3d.TextureMaterial(mat).alpha = lm.alpha;
                            feng3d.TextureMaterial(mat).repeat = true;
                            if (lm.specularMethod) {
                                // By setting the this.specularMethod property to null before assigning
                                // the actual method instance, we avoid having the properties of
                                // the new method being overridden with the settings from the old
                                // one, which is default behavior of the setter.
                                feng3d.TextureMaterial(mat).specularMethod = null;
                                feng3d.TextureMaterial(mat).specularMethod = lm.specularMethod;
                            }
                            else if (this._materialSpecularData) {
                                for (j = 0; j < this._materialSpecularData.length; ++j) {
                                    specularData = this._materialSpecularData[j];
                                    if (specularData.materialID == lm.materialID) {
                                        feng3d.TextureMaterial(mat).specularMethod = null; // Prevent property overwrite (see above)
                                        feng3d.TextureMaterial(mat).specularMethod = specularData.basicSpecularMethod;
                                        feng3d.TextureMaterial(mat).ambientColor = specularData.ambientColor;
                                        feng3d.TextureMaterial(mat).alpha = specularData.alpha;
                                        break;
                                    }
                                }
                            }
                        }
                        else {
                            mat = feng3d.TextureMultiPassMaterial(mesh.material);
                            feng3d.TextureMultiPassMaterial(mat).texture = lm.texture;
                            feng3d.TextureMultiPassMaterial(mat).ambientColor = lm.ambientColor;
                            feng3d.TextureMultiPassMaterial(mat).repeat = true;
                            if (lm.specularMethod) {
                                // By setting the this.specularMethod property to null before assigning
                                // the actual method instance, we avoid having the properties of
                                // the new method being overridden with the settings from the old
                                // one, which is default behavior of the setter.
                                feng3d.TextureMultiPassMaterial(mat).specularMethod = null;
                                feng3d.TextureMultiPassMaterial(mat).specularMethod = lm.specularMethod;
                            }
                            else if (this._materialSpecularData) {
                                for (j = 0; j < this._materialSpecularData.length; ++j) {
                                    specularData = this._materialSpecularData[j];
                                    if (specularData.materialID == lm.materialID) {
                                        feng3d.TextureMultiPassMaterial(mat).specularMethod = null; // Prevent property overwrite (see above)
                                        feng3d.TextureMultiPassMaterial(mat).specularMethod = specularData.basicSpecularMethod;
                                        feng3d.TextureMultiPassMaterial(mat).ambientColor = specularData.ambientColor;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    mesh.material.name = decomposeID[1] ? decomposeID[1] : decomposeID[0];
                    this._meshes.splice(i, 1);
                    --i;
                }
            }
            if (lm.cm || mat)
                finalizeAsset(lm.cm || mat);
        };
        /**
         * 应用材质
         */
        OBJParser.prototype.applyMaterials = function () {
            if (this._materialLoaded.length == 0)
                return;
            for (var i = 0; i < this._materialLoaded.length; ++i)
                this.applyMaterial(this._materialLoaded[i]);
        };
        return OBJParser;
    }(feng3d.ParserBase));
    feng3d.OBJParser = OBJParser;
})(feng3d || (feng3d = {}));
var ObjectGroup = (function () {
    function ObjectGroup() {
        /** 组列表（子网格列表） */
        this.groups = new Group[]();
    }
    ObjectGroup.prototype.ObjectGroup = function () {
    };
    return ObjectGroup;
}());
var Group = (function () {
    function Group() {
        this.materialGroups = new MaterialGroup[]();
    }
    Group.prototype.Group = function () {
    };
    return Group;
}());
/**
 * 材质组
 */
var MaterialGroup = (function () {
    function MaterialGroup() {
        this.faces = new FaceData[]();
    }
    MaterialGroup.prototype.MaterialGroup = function () {
    };
    return MaterialGroup;
}());
var SpecularData = (function () {
    function SpecularData() {
        this.ambientColor = 0xFFFFFF;
        this.alpha = 1;
    }
    SpecularData.prototype.SpecularData = function () {
    };
    return SpecularData;
}());
/**
 * 加载的材质
 */
var LoadedMaterial = (function () {
    function LoadedMaterial() {
        this.ambientColor = 0xFFFFFF;
        this.alpha = 1;
    }
    LoadedMaterial.prototype.LoadedMaterial = function () {
    };
    return LoadedMaterial;
}());
/**
 * 面数据
 */
var FaceData = (function () {
    function FaceData() {
        /** 顶点坐标索引数组 */
        this.vertexIndices = new number[]();
        /** 顶点uv索引数组 */
        this.uvIndices = new number[]();
        /** 顶点法线索引数组 */
        this.normalIndices = new number[]();
        /** 顶点Id(原本该值存放了顶点索引、uv索引、发现索引，已经被解析为上面3个数组，剩下的就当做ID使用) */
        this.indexIds = new string[](); // 
    }
    FaceData.prototype.FaceData = function () {
    };
    return FaceData;
}());
var feng3d;
(function (feng3d) {
    /**
     * 加载模块类
     * @author feng 2014-7-25
     */
    var Load = (function () {
        function Load() {
        }
        /**
         * 初始化加载模块
         */
        Load.init = function () {
            loadManager || (loadManager = new feng3d.LoadManager());
            feng3d.assert(feng3d.Task.isInit, "加载模块依赖任务模块，请先初始化任务模块");
        };
        Object.defineProperty(Load, "loader", {
            /**
             * 加载器
             */
            get: function () {
                return loadManager.loader;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 根据类名获取类定义
         * @param className			类名
         * @return					类定义
         */
        Load.getDefinitionByName = function (className) {
            for (each(); ; )
                var loadingItem;
             in loader.items;
            {
                var imageItem = loadingItem;
                if (imageItem && imageItem.content) {
                    if (imageItem.getDefinitionByName(className))
                        return imageItem.getDefinitionByName(className);
                }
            }
            return null;
        };
        /**
         * 根据类名获取实例
         * @param className		类名
         * @return 				实例
         */
        Load.getInstance = ;
        Load.prototype. = function () {
            var cls = getDefinitionByName(className);
            if (cls)
                return new cls();
            return null;
        };
        return Load;
    }());
    feng3d.Load = Load;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 任务集合类型
     * @author feng 2015-10-29
     */
    var TaskCollectionType = (function () {
        function TaskCollectionType() {
        }
        /**
         * 列表
         * <p>所有任务全部执行</p>
         */
        TaskCollectionType.LIST = "list";
        /**
         * 队列
         * <p>按照队列中的顺序一个一个依次执行</p>
         */
        TaskCollectionType.QUEUE = "queue";
        return TaskCollectionType;
    }());
    feng3d.TaskCollectionType = TaskCollectionType;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 任务模块类
     * @includeExample TaskModuleTest.as
     *
     * @author feng 2015-5-27
     */
    var Task = (function () {
        function Task() {
        }
        Object.defineProperty(Task, "isInit", {
            /**
             * 模块是否初始化
             */
            get: function () {
                return _isInit;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 初始化模块
         */
        Task.init = function () {
            taskManager || (taskManager = new feng3d.TaskManager());
            _isInit = true;
        };
        Task._isInit = false;
        return Task;
    }());
    feng3d.Task = Task;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 任务状态
     * @author feng 2015-6-16
     */
    var TaskStateType = (function () {
        function TaskStateType() {
        }
        /** 初始状态 */
        TaskStateType.STATE_INIT = 0;
        /** 任务正在执行 */
        TaskStateType.STATE_EXECUTING = 1;
        /** 任务已完成 */
        TaskStateType.STATE_COMPLETED = 2;
        return TaskStateType;
    }());
    feng3d.TaskStateType = TaskStateType;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     *
     * @author feng 2015-11-22
     */
    var ArrayUtils = (function () {
        function ArrayUtils() {
        }
        /**
         * Array <-> Vector
         * @param source			源数据(Array || Vector);in
         * @param target			目标数据(Array || Vector);in-out
         * @param targetType		目标类型(Array || Vector);default:Array
         */
        ArrayUtils.toArray = ;
        return ArrayUtils;
    }());
    feng3d.ArrayUtils = ArrayUtils;
    null, targetType;
    Class = null;
     *
        {
            if: function (target) {
                if (target === void 0) { target =  == null; }
                targetType || ;
                Array;
                target = new targetType();
            },
            if: function (target, length) {
                if (length === void 0) { length =  != source.length; }
                var hasFixed = ("fixed" in target);
                var fixedValue;
                if (hasFixed) {
                    fixedValue = target.fixed;
                    target.fixed = false;
                }
                target.length = source.length;
                if (hasFixed) {
                    target.fixed = fixedValue;
                }
            },
            for: function () { }, var: i, number: number, i: function () { } }++;
    {
        target[i] = source[i];
    }
    return target;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 类工具
     * @author feng 2015-4-27
     */
    var ClassUtils = (function () {
        function ClassUtils() {
        }
        /**
         * 获取类定义
         * @param obj
         * @return
         */
        ClassUtils.getClass = function (obj) {
            if (obj === void 0) { obj =  * ; }
            if (obj)
                is;
            string;
            {
                try {
                    return getDefinitionByName(obj);
                }
                catch (error) {
                    return null;
                }
            }
            var cla = obj;
            var className = getQualifiedClassName(obj);
            if (className == "null" || className == "void") {
                return null;
            }
            if (cla == null) {
                cla = getDefinitionByName(className);
            }
            return cla;
        };
        /**
         * 获取类实例
         * @param obj
         * @return
         */
        ClassUtils.getInstance = ;
        ClassUtils.prototype. = function () {
            if (obj)
                is;
            Class;
            {
                return new obj();
            }
            if (obj)
                is;
            string;
            {
                var cla = getClass(obj);
                return new cla;
            }
            return obj;
        };
        /**
         * 构造实例
         * @param cla						类定义
         * @param params					构造参数
         * @return							构造出的实例
         */
        ClassUtils.structureInstance = ;
        ClassUtils.prototype. = function () {
            if (params == null) {
                return new cla();
            }
            var paramNum = params.length;
            switch (paramNum) {
                case 0:
                    return new cla();
                    break;
                case 1:
                    return new cla(params[0]);
                    break;
                case 2:
                    return new cla(params[0], params[1]);
                    break;
                case 3:
                    return new cla(params[0], params[1], params[2]);
                    break;
                case 4:
                    return new cla(params[0], params[1], params[2], params[3]);
                    break;
                case 5:
                    return new cla(params[0], params[1], params[2], params[3], params[4]);
                    break;
                case 6:
                    return new cla(params[0], params[1], params[2], params[3], params[4], params[5]);
                    break;
                case 7:
                    return new cla(params[0], params[1], params[2], params[3], params[4], params[5], params[6]);
                    break;
                case 8:
                    return new cla(params[0], params[1], params[2], params[3], params[4], params[5], params[6], params[7]);
                    break;
                case 9:
                    return new cla(params[0], params[1], params[2], params[3], params[4], params[5], params[6], params[7], params[8]);
                    break;
                case 10:
                    return new cla(params[0], params[1], params[2], params[3], params[4], params[5], params[6], params[7], params[8], params[9]);
                    break;
                default:
                    throw new Error("不支持" + paramNum + "个参数的类构造");
                    break;
            }
            return null;
        };
        /**
         * 构造实例
         * @param space						运行空间
         * @param funcName					函数名称
         * @param params					函数参数
         * @return							函数返回值
         */
        ClassUtils.call = ;
        ClassUtils.prototype. = function () {
            var func = space[funcName];
            var result =  * , func, apply = (null, params);
            return result;
        };
        /**
         * 编码参数
         * @param params		参数数组
         */
        ClassUtils.encodeParams = function (params) {
            for (var i = 0; i < params.length; i++) {
                var item = params[i];
                var paramType = getQualifiedClassName(item);
                params[i] = { paramType: paramType, paramValue: item };
            }
        };
        /**
         * 解码参数
         * @param params		参数数组
         */
        ClassUtils.decodeParams = function (params) {
            for (var i = 0; i < params.length; i++) {
                var item = params[i];
                if (item.hasOwnProperty("paramType") && item.hasOwnProperty("paramValue")) {
                    var obj;
                    if (item.paramType == "flash.geom::Matrix3D") {
                        obj = new Matrix3D(number[](item.paramValue.rawData));
                    }
                    else {
                        obj = ClassUtils.getInstance(item.paramType);
                        if (isBaseType(item.paramValue)) {
                            obj = item.paramValue;
                        }
                        else {
                            copyValue(obj, item.paramValue);
                        }
                    }
                    params[i] = obj;
                }
            }
        };
        /**
         * 拷贝数据
         * @param obj			需要赋值的对象
         * @param value			拥有数据的对象
         */
        ClassUtils.copyValue = function (obj, value) {
            for (var key in value) {
                var attrValue =  * , value = [key];
                var attrType = getQualifiedClassName(attrValue);
                var baseType = isBaseType(value[key]);
                if (baseType) {
                    obj[key] = value[key];
                }
                else {
                    copyValue(obj[key], value[key]);
                }
            }
        };
        /**
         * 判断对象是否为基础类型
         * @param obj			对象
         * @return				true为基础类型，false为复杂类型
         */
        ClassUtils.isBaseType = function (obj) {
            var type = getQualifiedClassName(obj);
            var index = BASETYPES.indexOf(type);
            return index != -1;
        };
        /**
         * 获取对象默认名称
         * @param obj				对象
         * @return					对象默认名称
         */
        ClassUtils.getDefaultName = function (obj) {
            return getQualifiedClassName(obj).split("::").pop();
        };
        /**
         * 判断两个对象的完全限定类名是否相同
         * @param obj1			对象1
         * @param obj2			对象2
         * @return
         */
        ClassUtils.isSameClass = function (obj1, obj2) {
            if (obj1 === void 0) { obj1 =  * ; }
            if (obj2 === void 0) { obj2 =  * ; }
            var className1 = getQualifiedClassName(obj1);
            var className2 = getQualifiedClassName(obj2);
            return className1 == className2;
        };
        /**
         * 基础类型列表
         */
        ClassUtils.BASETYPES = ["number", "boolean", "number", "number", "string", "null"];
        return ClassUtils;
    }());
    feng3d.ClassUtils = ClassUtils;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 格式化输出字符串
     * @param format		需要格式化的字符串
     * @param ...args		传入一个或多个需要替换的参数
     *
     * @example
     * <pre>
        trace(formatString("[{0} type=\"{1}\" bubbles={2}  cancelable={3}]", "MouseEvent", "click", true, false));

         // trace output
         [MouseEvent type="click" bubbles=true  cancelable=false]
     * </pre>
     * @author feng 2014-5-7
     */
    constructor.apply(void 0, [format, string].concat(args));
    string;
    {
        for (var i = 0; i < args.length; ++i)
            format = format.replace(new RegExp("\\{" + i + "\\}", "g"), args[i]);
        return format;
    }
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 动画状态基类
     * @author feng 2015-9-18
     */
    var AnimationStateBase = (function () {
        function AnimationStateBase() {
            this._rootDelta = new Vector3D();
            this._positionDeltaDirty = true;
        }
        Object.defineProperty(AnimationStateBase.prototype, "positionDelta", {
            /**
             * @inheritDoc
             */
            get: function () {
                if (_positionDeltaDirty)
                    updatePositionDelta();
                return _rootDelta;
            },
            enumerable: true,
            configurable: true
        });
        return AnimationStateBase;
    }());
    feng3d.AnimationStateBase = AnimationStateBase;
    /**
     * 创建动画状态基类
     * @param animator				动画
     * @param animationNode			动画节点
     */
    function AnimationStateBase(animator, animationNode) {
        _animator = animator;
        _animationNode = animationNode;
    }
    offset(startTime, number);
    {
        this._startTime = startTime;
        this._positionDeltaDirty = true;
    }
    update(time, number);
    {
        if (this._time == time - this._startTime)
            return;
        this.updateTime(time);
    }
    phase(value, number);
    {
    }
    updateTime(time, number);
    {
        this._time = time - this._startTime;
        this._positionDeltaDirty = true;
    }
    updatePositionDelta();
    {
    }
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 动画剪辑状态
     * @author feng 2015-9-18
     */
    var AnimationClipState = (function (_super) {
        __extends(AnimationClipState, _super);
        function AnimationClipState() {
            _super.apply(this, arguments);
            this._framesDirty = true;
        }
        Object.defineProperty(AnimationClipState.prototype, "blendWeight", {
            /**
             * 混合权重	(0[当前帧],1[下一帧])
             * @see #currentFrame
             * @see #nextFrame
             */
            get: function () {
                if (_framesDirty)
                    updateFrames();
                return _blendWeight;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AnimationClipState.prototype, "currentFrame", {
            /**
             * 当前帧
             */
            get: function () {
                if (_framesDirty)
                    updateFrames();
                return _currentFrame;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AnimationClipState.prototype, "nextFrame", {
            /**
             * 下一帧
             */
            get: function () {
                if (_framesDirty)
                    updateFrames();
                return _nextFrame;
            },
            enumerable: true,
            configurable: true
        });
        return AnimationClipState;
    }(feng3d.AnimationStateBase));
    feng3d.AnimationClipState = AnimationClipState;
    /**
     * 创建一个帧动画状态
     * @param animator				动画
     * @param animationClipNode		帧动画节点
     */
    function AnimationClipState(animator, animationClipNode) {
        _super.call(this, animator, animationClipNode);
        _animationClipNode = animationClipNode;
    }
    update(time, number);
    {
        if (!this._animationClipNode.looping) {
            if (time > _startTime + this._animationClipNode.totalDuration)
                time = _startTime + this._animationClipNode.totalDuration;
            else if (time < _startTime)
                time = _startTime;
        }
        if (_time == time - _startTime)
            return;
        this.updateTime(time);
    }
    phase(value, number);
    {
        var time = value * this._animationClipNode.totalDuration + _startTime;
        if (_time == time - _startTime)
            return;
        this.updateTime(time);
    }
    updateTime(time, number);
    {
        this._framesDirty = true;
        this._timeDir = (time - _startTime > _time) ? 1 : -1;
        _super.updateTime.call(this, time);
    }
    updateFrames();
    {
        this._framesDirty = false;
        var looping = this._animationClipNode.looping;
        var totalDuration = this._animationClipNode.totalDuration;
        var lastFrame = this._animationClipNode.lastFrame;
        var time = _time;
        //trace("time", time, totalDuration)
        if (looping && (time >= totalDuration || time < 0)) {
            time %= totalDuration;
            if (time < 0)
                time += totalDuration;
        }
        if (!looping && time >= totalDuration) {
            this.notifyPlaybackComplete();
            this._currentFrame = lastFrame;
            this._nextFrame = lastFrame;
            this._blendWeight = 0;
        }
        else if (!looping && time <= 0) {
            this._currentFrame = 0;
            this._nextFrame = 0;
            this._blendWeight = 0;
        }
        else if (this._animationClipNode.fixedFrameRate) {
            var t = time / totalDuration * lastFrame;
            this._currentFrame = t;
            this._blendWeight = t - this._currentFrame;
            this._nextFrame = this._currentFrame + 1;
        }
        else {
            this._currentFrame = 0;
            this._nextFrame = 0;
            var dur = 0, frameTime;
            var durations = this._animationClipNode.durations;
            do {
                frameTime = dur;
                dur += durations[this.nextFrame];
                this._currentFrame = this._nextFrame++;
            } while (time > dur);
            if (this._currentFrame == lastFrame) {
                this._currentFrame = 0;
                this._nextFrame = 1;
            }
            this._blendWeight = (time - frameTime) / durations[this._currentFrame];
        }
    }
    notifyPlaybackComplete();
    {
        this._animationClipNode.dispatchEvent(new feng3d.AnimationStateEvent(feng3d.AnimationStateEvent.PLAYBACK_COMPLETE, _animator, this, this._animationClipNode));
    }
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 骨骼剪辑状态
     * @author feng 2015-9-18
     */
    var SkeletonClipState = (function (_super) {
        __extends(SkeletonClipState, _super);
        function SkeletonClipState() {
            _super.apply(this, arguments);
            this._rootPos = new Vector3D();
            this._skeletonPose = new feng3d.SkeletonPose();
            this._skeletonPoseDirty = true;
        }
        Object.defineProperty(SkeletonClipState.prototype, "currentPose", {
            /**
             * 当前骨骼姿势
             */
            get: function () {
                if (_framesDirty)
                    updateFrames();
                return _currentPose;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SkeletonClipState.prototype, "nextPose", {
            /**
             * 下个姿势
             */
            get: function () {
                if (_framesDirty)
                    updateFrames();
                return _nextPose;
            },
            enumerable: true,
            configurable: true
        });
        return SkeletonClipState;
    }(feng3d.AnimationClipState));
    feng3d.SkeletonClipState = SkeletonClipState;
    /**
     * 创建骨骼剪辑状态实例
     * @param animator				动画
     * @param skeletonClipNode		骨骼剪辑节点
     */
    function SkeletonClipState(animator, skeletonClipNode) {
        _super.call(this, animator, skeletonClipNode);
        _skeletonClipNode = skeletonClipNode;
        _frames = _skeletonClipNode.frames;
    }
    getSkeletonPose(skeleton, feng3d.Skeleton);
    feng3d.SkeletonPose;
    {
        if (this._skeletonPoseDirty)
            this.updateSkeletonPose(skeleton);
        return this._skeletonPose;
    }
    updateTime(time, number);
    {
        this._skeletonPoseDirty = true;
        _super.updateTime.call(this, time);
    }
    updateFrames();
    {
        _super.updateFrames.call(this);
        this._currentPose = this._frames[_currentFrame];
        if (this._skeletonClipNode.looping && _nextFrame >= this._skeletonClipNode.lastFrame) {
            this._nextPose = this._frames[0];
            feng3d.SkeletonAnimator(_animator).dispatchCycleEvent();
        }
        else
            this._nextPose = this._frames[_nextFrame];
    }
    updateSkeletonPose(skeleton, feng3d.Skeleton);
    {
        this._skeletonPoseDirty = false;
        if (!this._skeletonClipNode.totalDuration)
            return;
        if (_framesDirty)
            this.updateFrames();
        var currentPose = this._currentPose.jointPoses;
        var nextPose = this._nextPose.jointPoses;
        var numJoints = skeleton.numJoints;
        var p1, p2;
        var pose1, pose2;
        var showPoses = this._skeletonPose.jointPoses;
        var showPose;
        var tr;
        //调整当前显示关节姿势数量
        if (showPoses.length != numJoints)
            showPoses.length = numJoints;
        if ((numJoints != currentPose.length) || (numJoints != nextPose.length))
            throw new Error("joint counts don't match!");
        for (var i = 0; i < numJoints; ++i) {
            showPose = showPoses[i] || ;
            new feng3d.JointPose();
            pose1 = currentPose[i];
            pose2 = nextPose[i];
            p1 = pose1.translation;
            p2 = pose2.translation;
            //根据前后两个关节姿势计算出当前显示关节姿势
            showPose.orientation.lerp(pose1.orientation, pose2.orientation, _blendWeight);
            //计算显示的关节位置
            if (i > 0) {
                tr = showPose.translation;
                tr.x = p1.x + _blendWeight * (p2.x - p1.x);
                tr.y = p1.y + _blendWeight * (p2.y - p1.y);
                tr.z = p1.z + _blendWeight * (p2.z - p1.z);
            }
        }
    }
    updatePositionDelta();
    {
        _positionDeltaDirty = false;
        if (_framesDirty)
            this.updateFrames();
        var p1, p2, p3;
        var totalDelta = this._skeletonClipNode.totalDelta;
        //跳过最后，重置位置
        if ((_timeDir > 0 && _nextFrame < _oldFrame) || (_timeDir < 0 && _nextFrame > _oldFrame)) {
            this._rootPos.x -= totalDelta.x * _timeDir;
            this._rootPos.y -= totalDelta.y * _timeDir;
            this._rootPos.z -= totalDelta.z * _timeDir;
        }
        /** 保存骨骼根节点原位置 */
        var dx = this._rootPos.x;
        var dy = this._rootPos.y;
        var dz = this._rootPos.z;
        //计算骨骼根节点位置
        if (this._skeletonClipNode.stitchFinalFrame && _nextFrame == this._skeletonClipNode.lastFrame) {
            p1 = this._frames[0].jointPoses[0].translation;
            p2 = this._frames[1].jointPoses[0].translation;
            p3 = this._currentPose.jointPoses[0].translation;
            this._rootPos.x = p3.x + p1.x + _blendWeight * (p2.x - p1.x);
            this._rootPos.y = p3.y + p1.y + _blendWeight * (p2.y - p1.y);
            this._rootPos.z = p3.z + p1.z + _blendWeight * (p2.z - p1.z);
        }
        else {
            p1 = this._currentPose.jointPoses[0].translation;
            p2 = this._frames[_nextFrame].jointPoses[0].translation; //cover the instances where we wrap the pose but still want the final frame translation values
            this._rootPos.x = p1.x + _blendWeight * (p2.x - p1.x);
            this._rootPos.y = p1.y + _blendWeight * (p2.y - p1.y);
            this._rootPos.z = p1.z + _blendWeight * (p2.z - p1.z);
        }
        //计算骨骼根节点偏移量
        _rootDelta.x = this._rootPos.x - dx;
        _rootDelta.y = this._rootPos.y - dy;
        _rootDelta.z = this._rootPos.z - dz;
        //保存旧帧编号
        _oldFrame = _nextFrame;
    }
})(feng3d || (feng3d = {}));
var feng3dSheet;
(function (feng3dSheet) {
    /**
     * sprite动画状态
     * @author feng 2015-9-18
     */
    var SpriteSheetAnimationState = (function (_super) {
        __extends(SpriteSheetAnimationState, _super);
        function SpriteSheetAnimationState() {
            _super.apply(this, arguments);
            this._currentFrameID = 0;
        }
        return SpriteSheetAnimationState;
    }(AnimationClipState));
    feng3dSheet.SpriteSheetAnimationState = SpriteSheetAnimationState;
    /**
     * 创建sprite动画状态实例
     * @param animator			动画
     * @param clipNode			动画剪辑节点
     */
    function SpriteSheetAnimationState(animator, clipNode) {
        _super.call(this, animator, clipNode);
        _clipNode = clipNode;
        _frames = _clipNode.frames;
    }
    set;
    reverse(b, boolean);
    {
        _reverse = b;
    }
    set;
    backAndForth(b, boolean);
    {
        if (b)
            _reverse = false;
        _backAndForth = b;
    }
    get;
    currentFrameData();
    feng3dSheet.SpriteSheetAnimationFrame;
    {
        if (_framesDirty)
            updateFrames();
        return _frames[_currentFrameID];
    }
    get;
    currentFrameNumber();
    number;
    {
        return _currentFrameID;
    }
    set;
    currentFrameNumber(frameNumber, number);
    {
        _currentFrameID = (frameNumber > _frames.length - 1) ? _frames.length - 1 : frameNumber;
        _forcedFrame = true;
    }
    get;
    totalFrames();
    number;
    {
        return (!_frames) ? 0 : _frames.length;
    }
    updateFrames();
    {
        if (this._forcedFrame) {
            this._forcedFrame = false;
            return;
        }
        _super.updateFrames.call(this);
        if (this._reverse) {
            if (this._currentFrameID - 1 > -1)
                this._currentFrameID--;
            else {
                if (this._clipNode.looping) {
                    if (this._backAndForth) {
                        this._reverse = false;
                        this._currentFrameID++;
                    }
                    else
                        this._currentFrameID = this._frames.length - 1;
                }
                feng3dSheet.SpriteSheetAnimator(_animator).dispatchCycleEvent();
            }
        }
        else {
            if (this._currentFrameID < this._frames.length - 1)
                this._currentFrameID++;
            else {
                if (this._clipNode.looping) {
                    if (this._backAndForth) {
                        this._reverse = true;
                        this._currentFrameID--;
                    }
                    else
                        this._currentFrameID = 0;
                }
                feng3dSheet.SpriteSheetAnimator(_animator).dispatchCycleEvent();
            }
        }
    }
})(feng3dSheet || (feng3dSheet = {}));
var feng3d;
(function (feng3d) {
    /**
     * UV动画剪辑状态
     * @author feng 2015-9-18
     */
    var UVClipState = (function (_super) {
        __extends(UVClipState, _super);
        function UVClipState() {
            _super.apply(this, arguments);
        }
        Object.defineProperty(UVClipState.prototype, "currentUVFrame", {
            /**
             * @inheritDoc
             */
            get: function () {
                if (_framesDirty)
                    updateFrames();
                return _currentUVFrame;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UVClipState.prototype, "nextUVFrame", {
            /**
             * @inheritDoc
             */
            get: function () {
                if (_framesDirty)
                    updateFrames();
                return _nextUVFrame;
            },
            enumerable: true,
            configurable: true
        });
        return UVClipState;
    }(feng3d.AnimationClipState));
    feng3d.UVClipState = UVClipState;
    /**
     * 创建UVClipState实例
     * @param animator				动画
     * @param uvClipNode			UV动画剪辑节点
     */
    function UVClipState(animator, uvClipNode) {
        _super.call(this, animator, uvClipNode);
        _uvClipNode = uvClipNode;
        _frames = _uvClipNode.frames;
    }
    updateFrames();
    {
        _super.updateFrames.call(this);
        if (this._frames.length > 0) {
            if (this._frames.length == 2 && _currentFrame == 0) {
                this._currentUVFrame = this._frames[1];
                this._nextUVFrame = this._frames[0];
            }
            else {
                this._currentUVFrame = this._frames[_currentFrame];
                if (this._uvClipNode.looping && _nextFrame >= this._uvClipNode.lastFrame)
                    this._nextUVFrame = this._frames[0];
                else
                    this._nextUVFrame = this._frames[_nextFrame];
            }
        }
    }
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 顶点动画剪辑状态
     * @author feng 2015-9-18
     */
    var VertexClipState = (function (_super) {
        __extends(VertexClipState, _super);
        function VertexClipState() {
            _super.apply(this, arguments);
        }
        Object.defineProperty(VertexClipState.prototype, "currentGeometry", {
            /**
             * @inheritDoc
             */
            get: function () {
                if (_framesDirty)
                    updateFrames();
                return _currentGeometry;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(VertexClipState.prototype, "nextGeometry", {
            /**
             * @inheritDoc
             */
            get: function () {
                if (_framesDirty)
                    updateFrames();
                return _nextGeometry;
            },
            enumerable: true,
            configurable: true
        });
        return VertexClipState;
    }(feng3d.AnimationClipState));
    feng3d.VertexClipState = VertexClipState;
    /**
     * 创建VertexClipState实例
     * @param animator				动画
     * @param vertexClipNode		顶点动画节点
     */
    function VertexClipState(animator, vertexClipNode) {
        _super.call(this, animator, vertexClipNode);
        _vertexClipNode = vertexClipNode;
        _frames = _vertexClipNode.frames;
    }
    updateFrames();
    {
        _super.updateFrames.call(this);
        this._currentGeometry = this._frames[_currentFrame];
        if (this._vertexClipNode.looping && _nextFrame >= this._vertexClipNode.lastFrame) {
            this._nextGeometry = this._frames[0];
            feng3d.VertexAnimator(_animator).dispatchCycleEvent();
        }
        else
            this._nextGeometry = this._frames[_nextFrame];
    }
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 粒子状态基类
     * @author feng 2014-5-20
     */
    var ParticleStateBase = (function (_super) {
        __extends(ParticleStateBase, _super);
        /**
         * 创建粒子状态基类
         * @param animator				粒子动画
         * @param particleNode			粒子节点
         * @param needUpdateTime		是否需要更新时间
         */
        function ParticleStateBase(animator, particleNode, needUpdateTime) {
            if (needUpdateTime === void 0) { needUpdateTime = false; }
            _super.call(this, animator, particleNode);
            this._dynamicProperties = new Vector3D[]();
            this._dynamicPropertiesDirty = new Dictionary(true);
            this._particleNode = particleNode;
            this._needUpdateTime = needUpdateTime;
        }
        Object.defineProperty(ParticleStateBase.prototype, "needUpdateTime", {
            /**
             * 是否需要更新时间
             */
            get: function () {
                return _needUpdateTime;
            },
            enumerable: true,
            configurable: true
        });
        return ParticleStateBase;
    }(feng3d.AnimationStateBase));
    feng3d.ParticleStateBase = ParticleStateBase;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 骨骼线性插值状态接口
     * @author feng 2015-9-18
     */
    var SkeletonBinaryLERPState = (function (_super) {
        __extends(SkeletonBinaryLERPState, _super);
        function SkeletonBinaryLERPState() {
            _super.apply(this, arguments);
            this._blendWeight = 0;
            this._skeletonPose = new feng3d.SkeletonPose();
            this._skeletonPoseDirty = true;
        }
        Object.defineProperty(SkeletonBinaryLERPState.prototype, "blendWeight", {
            /**
             * 混合权重	(0[inputA],1[inputB])
             */
            get: function () {
                return _blendWeight;
            },
            set: function (value) {
                _blendWeight = value;
                _positionDeltaDirty = true;
                _skeletonPoseDirty = true;
            },
            enumerable: true,
            configurable: true
        });
        return SkeletonBinaryLERPState;
    }(feng3d.AnimationStateBase));
    feng3d.SkeletonBinaryLERPState = SkeletonBinaryLERPState;
    /**
     * 创建SkeletonBinaryLERPState实例
     * @param animator						动画
     * @param skeletonAnimationNode			骨骼动画节点
     */
    function SkeletonBinaryLERPState(animator, skeletonAnimationNode) {
        _super.call(this, animator, skeletonAnimationNode);
        _skeletonAnimationNode = skeletonAnimationNode;
        _inputA = animator.getAnimationState(_skeletonAnimationNode.inputA);
        _inputB = animator.getAnimationState(_skeletonAnimationNode.inputB);
    }
    phase(value, number);
    {
        this._skeletonPoseDirty = true;
        _positionDeltaDirty = true;
        this._inputA.phase(value);
        this._inputB.phase(value);
    }
    updateTime(time, number);
    {
        this._skeletonPoseDirty = true;
        this._inputA.update(time);
        this._inputB.update(time);
        _super.updateTime.call(this, time);
    }
    getSkeletonPose(skeleton, feng3d.Skeleton);
    feng3d.SkeletonPose;
    {
        if (this._skeletonPoseDirty)
            this.updateSkeletonPose(skeleton);
        return this._skeletonPose;
    }
    updatePositionDelta();
    {
        _positionDeltaDirty = false;
        var deltA = this._inputA.positionDelta;
        var deltB = this._inputB.positionDelta;
        _rootDelta.x = deltA.x + this._blendWeight * (deltB.x - deltA.x);
        _rootDelta.y = deltA.y + this._blendWeight * (deltB.y - deltA.y);
        _rootDelta.z = deltA.z + this._blendWeight * (deltB.z - deltA.z);
    }
    updateSkeletonPose(skeleton, feng3d.Skeleton);
    {
        this._skeletonPoseDirty = false;
        var endPose;
        var endPoses = this._skeletonPose.jointPoses;
        var poses1 = this._inputA.getSkeletonPose(skeleton).jointPoses;
        var poses2 = this._inputB.getSkeletonPose(skeleton).jointPoses;
        var pose1, pose2;
        var p1, p2;
        var tr;
        var numJoints = skeleton.numJoints;
        // :s
        if (endPoses.length != numJoints)
            endPoses.length = numJoints;
        for (var i = 0; i < numJoints; ++i) {
            endPose = endPoses[i] || ;
            new feng3d.JointPose();
            pose1 = poses1[i];
            pose2 = poses2[i];
            p1 = pose1.translation;
            p2 = pose2.translation;
            endPose.orientation.lerp(pose1.orientation, pose2.orientation, this._blendWeight);
            tr = endPose.translation;
            tr.x = p1.x + this._blendWeight * (p2.x - p1.x);
            tr.y = p1.y + this._blendWeight * (p2.y - p1.y);
            tr.z = p1.z + this._blendWeight * (p2.z - p1.z);
        }
    }
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 淡入淡出变换状态
     * @author feng 2015-9-18
     */
    var CrossfadeTransitionState = (function (_super) {
        __extends(CrossfadeTransitionState, _super);
        function CrossfadeTransitionState() {
            _super.apply(this, arguments);
        }
        return CrossfadeTransitionState;
    }(feng3d.SkeletonBinaryLERPState));
    feng3d.CrossfadeTransitionState = CrossfadeTransitionState;
    /**
     * 创建淡入淡出变换状态实例
     * @param animator						动画
     * @param skeletonAnimationNode			骨骼动画节点
     */
    function CrossfadeTransitionState(animator, skeletonAnimationNode) {
        _super.call(this, animator, skeletonAnimationNode);
        _skeletonAnimationNode = skeletonAnimationNode;
    }
    updateTime(time, number);
    {
        this.blendWeight = Math.abs(time - this._skeletonAnimationNode.startBlend) / (1000 * this._skeletonAnimationNode.blendSpeed);
        if (this.blendWeight >= 1) {
            this.blendWeight = 1;
            this._skeletonAnimationNode.dispatchEvent(this._animationStateTransitionComplete || , new feng3d.AnimationStateEvent(feng3d.AnimationStateEvent.TRANSITION_COMPLETE, _animator, this, this._skeletonAnimationNode));
        }
        _super.updateTime.call(this, time);
    }
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    positionDelta();
    Vector3D;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * ...
     */
    var ParticleAnimationData = (function () {
        function ParticleAnimationData(index, startTime, duration, delay, particle) {
            this.index = index;
            this.startTime = startTime;
            this.totalTime = duration + delay;
            this.duration = duration;
            this.delay = delay;
            this.startVertexIndex = particle.startVertexIndex;
            this.numVertices = particle.numVertices;
        }
        return ParticleAnimationData;
    }());
    feng3d.ParticleAnimationData = ParticleAnimationData;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 粒子属性
     * @author feng 2014-11-13
     */
    dynamic;
    var ParticleProperties = (function () {
        function ParticleProperties() {
        }
        return ParticleProperties;
    }());
    feng3d.ParticleProperties = ParticleProperties;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 粒子属性模型
     * @author feng 2014-11-13
     */
    var ParticlePropertiesMode = (function () {
        function ParticlePropertiesMode() {
        }
        /**
         * 全局粒子属性，数据将上传至常量寄存器中
         */
        ParticlePropertiesMode.GLOBAL = 0;
        /**
         * 本地静态粒子属性，数据将上传顶点属性寄存器
         */
        ParticlePropertiesMode.LOCAL_STATIC = 1;
        return ParticlePropertiesMode;
    }());
    feng3d.ParticlePropertiesMode = ParticlePropertiesMode;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 关节pose
     * @author feng 2014-5-20
     */
    var JointPose = (function () {
        function JointPose() {
            /** 旋转信息 */
            this.orientation = new Quaternion();
            /** 位移信息 */
            this.translation = new Vector3D();
        }
        /**
         * Converts the transformation to a Matrix3D representation.
         *
         * @param target An optional target matrix to store the transformation. If not provided, it will create a new instance.
         * @return The transformation matrix of the pose.
         */
        JointPose.prototype.toMatrix3D = function (target) {
            if (target === void 0) { target = null; }
            target || ;
            new Matrix3D();
            this.orientation.toMatrix3D(target);
            target.appendTranslation(this.translation.x, this.translation.y, this.translation.z);
            return target;
        };
        return JointPose;
    }());
    feng3d.JointPose = JointPose;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 骨骼关节数据
     * @author feng 2014-5-20
     */
    var SkeletonJoint = (function () {
        function SkeletonJoint() {
            /** 父关节索引 （-1说明本身是总父节点，这个序号其实就是行号了，譬如上面”origin“节点的序号就是0，无父节点； "body"节点序号是1，父节点序号是0，也就是说父节点是”origin“）*/
            this.parentIndex = -1;
        }
        return SkeletonJoint;
    }());
    feng3d.SkeletonJoint = SkeletonJoint;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
})(feng3d || (feng3d = {}));
var feng3dSheet;
(function (feng3dSheet) {
    currentFrameData();
    feng3dSheet.SpriteSheetAnimationFrame;
    currentFrameNumber();
    number;
})(feng3dSheet || (feng3dSheet = {}));
var feng3dSheet;
(function (feng3dSheet) {
    /**
     * sprite动画帧
     * @author feng 2015-9-18
     * @see me.feng3d.animators.uv.UVAnimationFrame
     */
    var SpriteSheetAnimationFrame = (function () {
        /**
         * 创建<code>SpriteSheetAnimationFrame</code>实例
         *
         * @param offsetU			U元素偏移
         * @param offsetV			V元素偏移
         * @param scaleU			U元素缩放
         * @param scaleV			V元素缩放
         * @param mapID				映射编号
         */
        function SpriteSheetAnimationFrame(offsetU, offsetV, scaleU, scaleV, mapID) {
            if (offsetU === void 0) { offsetU = 0; }
            if (offsetV === void 0) { offsetV = 0; }
            if (scaleU === void 0) { scaleU = 1; }
            if (scaleV === void 0) { scaleV = 1; }
            if (mapID === void 0) { mapID = 0; }
            this.offsetU = offsetU;
            this.offsetV = offsetV;
            this.scaleU = scaleU;
            this.scaleV = scaleV;
            this.mapID = mapID;
        }
        return SpriteSheetAnimationFrame;
    }());
    feng3dSheet.SpriteSheetAnimationFrame = SpriteSheetAnimationFrame;
})(feng3dSheet || (feng3dSheet = {}));
var feng3d;
(function (feng3d) {
    /**
     * 淡入淡出变换
     * @author feng 2015-9-18
     */
    var CrossfadeTransition = (function () {
        /**
         * 创建淡入淡出变换实例
         * @param blendSpeed			混合速度
         */
        function CrossfadeTransition(blendSpeed) {
            this.blendSpeed = 0.5;
            this.blendSpeed = blendSpeed;
        }
        /**
         * @inheritDoc
         */
        CrossfadeTransition.prototype.getAnimationNode = function (animator, startNode, endNode, startBlend) {
            var crossFadeTransitionNode = new feng3d.CrossfadeTransitionNode();
            crossFadeTransitionNode.inputA = startNode;
            crossFadeTransitionNode.inputB = endNode;
            crossFadeTransitionNode.blendSpeed = this.blendSpeed;
            crossFadeTransitionNode.startBlend = startBlend;
            return crossFadeTransitionNode;
        };
        return CrossfadeTransition;
    }());
    feng3d.CrossfadeTransition = CrossfadeTransition;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    currentUVFrame();
    feng3d.UVAnimationFrame;
    nextUVFrame();
    feng3d.UVAnimationFrame;
    blendWeight();
    number;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * UV动画帧
     * @author feng 2015-9-18
     * @see me.feng3d.animators.spriteSheet.SpriteSheetAnimationFrame
     */
    var UVAnimationFrame = (function () {
        /**
         * 创建<code>UVAnimationFrame</code>实例
         *
         * @param offsetU			U元素偏移
         * @param offsetV			V元素偏移
         * @param scaleU			U元素缩放
         * @param scaleV			V元素缩放
         * @param rotation			旋转角度（度数）
         */
        function UVAnimationFrame(offsetU, offsetV, scaleU, scaleV, rotation) {
            if (offsetU === void 0) { offsetU = 0; }
            if (offsetV === void 0) { offsetV = 0; }
            if (scaleU === void 0) { scaleU = 1; }
            if (scaleV === void 0) { scaleV = 1; }
            if (rotation === void 0) { rotation = 0; }
            this.offsetU = offsetU;
            this.offsetV = offsetV;
            this.scaleU = scaleU;
            this.scaleV = scaleV;
            this.rotation = rotation;
        }
        return UVAnimationFrame;
    }());
    feng3d.UVAnimationFrame = UVAnimationFrame;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    currentGeometry();
    feng3d.Geometry;
    nextGeometry();
    feng3d.Geometry;
    blendWeight();
    number;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    usesCPU();
    boolean;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 包围盒基类
     * @author feng 2014-4-27
     */
    var BoundingVolumeBase = (function () {
        /**
         * 创建包围盒
         */
        function BoundingVolumeBase() {
            this._aabbPointsDirty = true;
            this._min = new Vector3D();
            this._max = new Vector3D();
            feng3d.AbstractClassError.check(this);
        }
        Object.defineProperty(BoundingVolumeBase.prototype, "max", {
            /**
             * The maximum extreme of the bounds
             */
            get: function () {
                return _max;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BoundingVolumeBase.prototype, "min", {
            /**
             * The minimum extreme of the bounds
             */
            get: function () {
                return _min;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BoundingVolumeBase.prototype, "boundingRenderable", {
            /**
             * 渲染实体
             */
            get: function () {
                if (!_boundingRenderable) {
                    _boundingRenderable = createBoundingRenderable();
                    updateBoundingRenderable();
                }
                return _boundingRenderable;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 销毁渲染实体
         */
        BoundingVolumeBase.prototype.disposeRenderable = function () {
            this._boundingRenderable = null;
        };
        /**
         * 更新边界渲染实体
         */
        BoundingVolumeBase.prototype.updateBoundingRenderable = function () {
            throw new feng3d.AbstractMethodError();
        };
        /**
         * 创建渲染边界
         */
        BoundingVolumeBase.prototype.createBoundingRenderable = function () {
            throw new feng3d.AbstractMethodError();
        };
        /**
         * 根据几何结构更新边界
         */
        BoundingVolumeBase.prototype.fromGeometry = function (geometry) {
            var subGeoms = geometry.subGeometries;
            var numSubGeoms = subGeoms.length;
            var minX, minY, minZ;
            var maxX, maxY, maxZ;
            if (numSubGeoms > 0) {
                var subGeom = subGeoms[0];
                var vertices = subGeom.vertexPositionData;
                var i = 0;
                minX = maxX = vertices[i];
                minY = maxY = vertices[i + 1];
                minZ = maxZ = vertices[i + 2];
                var j = 0;
                while (j < numSubGeoms) {
                    subGeom = subGeoms[j++];
                    vertices = subGeom.vertexPositionData;
                    var vertexDataLen = vertices.length;
                    i = 0;
                    var stride = subGeom.vertexPositionStride;
                    while (i < vertexDataLen) {
                        var v = vertices[i];
                        if (v < minX)
                            minX = v;
                        else if (v > maxX)
                            maxX = v;
                        v = vertices[i + 1];
                        if (v < minY)
                            minY = v;
                        else if (v > maxY)
                            maxY = v;
                        v = vertices[i + 2];
                        if (v < minZ)
                            minZ = v;
                        else if (v > maxZ)
                            maxZ = v;
                        i += stride;
                    }
                }
                this.fromExtremes(minX, minY, minZ, maxX, maxY, maxZ);
            }
            else
                this.fromExtremes(0, 0, 0, 0, 0, 0);
        };
        /**
         * 根据所给极值设置边界
         * @param minX 边界最小X坐标
         * @param minY 边界最小Y坐标
         * @param minZ 边界最小Z坐标
         * @param maxX 边界最大X坐标
         * @param maxY 边界最大Y坐标
         * @param maxZ 边界最大Z坐标
         */
        BoundingVolumeBase.prototype.fromExtremes = function (minX, minY, minZ, maxX, maxY, maxZ) {
            this._min.x = minX;
            this._min.y = minY;
            this._min.z = minZ;
            this._max.x = maxX;
            this._max.y = maxY;
            this._max.z = maxZ;
            if (this._boundingRenderable)
                this.updateBoundingRenderable();
        };
        /**
         * 检测射线是否与边界交叉
         * @param ray3D						射线
         * @param targetNormal				交叉点法线值
         * @return							射线起点到交点距离
         */
        BoundingVolumeBase.prototype.rayIntersection = function (ray3D, targetNormal) {
            return -1;
        };
        /**
         * 检测是否包含指定点
         * @param position 		被检测点
         * @return				true：包含指定点
         */
        BoundingVolumeBase.prototype.containsPoint = function (position) {
            return false;
        };
        /**
         * 测试是否出现在摄像机视锥体内
         * @param planes 		视锥体面向量
         * @param numPlanes		面数
         * @return 				true：出现在视锥体内
         */
        BoundingVolumeBase.prototype.isInFrustum = function (planes, numPlanes) {
            throw new feng3d.AbstractMethodError();
        };
        /**
         * 对包围盒进行变换
         * @param bounds		包围盒
         * @param matrix		变换矩阵
         */
        BoundingVolumeBase.prototype.transformFrom = function (bounds, matrix) {
            throw new feng3d.AbstractMethodError();
        };
        /**
         * 从给出的球体设置边界
         * @param center 		球心坐标
         * @param radius 		球体半径
         */
        BoundingVolumeBase.prototype.fromSphere = function (center, radius) {
            this.fromExtremes(center.x - radius, center.y - radius, center.z - radius, center.x + radius, center.y + radius, center.z + radius);
        };
        return BoundingVolumeBase;
    }());
    feng3d.BoundingVolumeBase = BoundingVolumeBase;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 轴对其包围盒
     * @author feng 2014-4-27
     */
    var AxisAlignedBoundingBox = (function (_super) {
        __extends(AxisAlignedBoundingBox, _super);
        /**
         * 创建轴对其包围盒
         */
        function AxisAlignedBoundingBox() {
            _super.call(this);
            this._centerX = 0;
            this._centerY = 0;
            this._centerZ = 0;
            this._halfExtentsX = 0;
            this._halfExtentsY = 0;
            this._halfExtentsZ = 0;
        }
        /**
         * 创建渲染边界
         */
        AxisAlignedBoundingBox.prototype.createBoundingRenderable = function () {
            return new feng3d.WireframeCube(1, 1, 1, 0xffffff, 0.5);
        };
        /**
         * 测试轴对其包围盒是否出现在摄像机视锥体内
         * @param planes 		视锥体面向量
         * @return 				true：出现在视锥体内
         * @see me.feng3d.cameras.Camera3D.updateFrustum()
         */
        AxisAlignedBoundingBox.prototype.isInFrustum = function (planes, numPlanes) {
            for (var i = 0; i < numPlanes; ++i) {
                var plane = planes[i];
                var a = plane.a;
                var b = plane.b;
                var c = plane.c;
                //最可能出现在平面内的点，即距离最可能大于0的点 (如果这个点都不在平面内的话，其他的点肯定会不在平面内)
                var flippedExtentX = a < 0 ? -this._halfExtentsX : this._halfExtentsX;
                var flippedExtentY = b < 0 ? -this._halfExtentsY : this._halfExtentsY;
                var flippedExtentZ = c < 0 ? -this._halfExtentsZ : this._halfExtentsZ;
                var projDist = a * (this._centerX + flippedExtentX) + b * (this._centerY + flippedExtentY) + c * (this._centerZ + flippedExtentZ) - plane.d;
                //小于0表示包围盒8个点都在平面内，同时就表面不存在点在视锥体内。注：视锥体6个平面朝内
                if (projDist < 0)
                    return false;
            }
            return true;
        };
        /**
         * @inheritDoc
         */
        AxisAlignedBoundingBox.prototype.updateBoundingRenderable = function () {
            var transform3D = _boundingRenderable.transform3D;
            transform3D.scaleX = Math.max(this._halfExtentsX * 2, 0.001);
            transform3D.scaleY = Math.max(this._halfExtentsY * 2, 0.001);
            transform3D.scaleZ = Math.max(this._halfExtentsZ * 2, 0.001);
            transform3D.x = this._centerX;
            transform3D.y = this._centerY;
            transform3D.z = this._centerZ;
        };
        /**
         * @inheritDoc
         */
        AxisAlignedBoundingBox.prototype.fromExtremes = function (minX, minY, minZ, maxX, maxY, maxZ) {
            this._centerX = (maxX + minX) * .5;
            this._centerY = (maxY + minY) * .5;
            this._centerZ = (maxZ + minZ) * .5;
            this._halfExtentsX = (maxX - minX) * .5;
            this._halfExtentsY = (maxY - minY) * .5;
            this._halfExtentsZ = (maxZ - minZ) * .5;
            _super.prototype.fromExtremes.call(this, minX, minY, minZ, maxX, maxY, maxZ);
        };
        /**
         * @inheritDoc
         */
        AxisAlignedBoundingBox.prototype.rayIntersection = function (ray3D, targetNormal) {
            var position = ray3D.position;
            var direction = ray3D.direction;
            if (this.containsPoint(position))
                return 0;
            var px = position.x - this._centerX, py = position.y - this._centerY, pz = position.z - this._centerZ;
            var vx = direction.x, vy = direction.y, vz = direction.z;
            var ix, iy, iz;
            var rayEntryDistance;
            // ray-plane tests
            var intersects;
            if (vx < 0) {
                rayEntryDistance = (this._halfExtentsX - px) / vx;
                if (rayEntryDistance > 0) {
                    iy = py + rayEntryDistance * vy;
                    iz = pz + rayEntryDistance * vz;
                    if (iy > -this._halfExtentsY && iy < this._halfExtentsY && iz > -this._halfExtentsZ && iz < this._halfExtentsZ) {
                        targetNormal.x = 1;
                        targetNormal.y = 0;
                        targetNormal.z = 0;
                        intersects = true;
                    }
                }
            }
            if (!intersects && vx > 0) {
                rayEntryDistance = (-this._halfExtentsX - px) / vx;
                if (rayEntryDistance > 0) {
                    iy = py + rayEntryDistance * vy;
                    iz = pz + rayEntryDistance * vz;
                    if (iy > -this._halfExtentsY && iy < this._halfExtentsY && iz > -this._halfExtentsZ && iz < this._halfExtentsZ) {
                        targetNormal.x = -1;
                        targetNormal.y = 0;
                        targetNormal.z = 0;
                        intersects = true;
                    }
                }
            }
            if (!intersects && vy < 0) {
                rayEntryDistance = (this._halfExtentsY - py) / vy;
                if (rayEntryDistance > 0) {
                    ix = px + rayEntryDistance * vx;
                    iz = pz + rayEntryDistance * vz;
                    if (ix > -this._halfExtentsX && ix < this._halfExtentsX && iz > -this._halfExtentsZ && iz < this._halfExtentsZ) {
                        targetNormal.x = 0;
                        targetNormal.y = 1;
                        targetNormal.z = 0;
                        intersects = true;
                    }
                }
            }
            if (!intersects && vy > 0) {
                rayEntryDistance = (-this._halfExtentsY - py) / vy;
                if (rayEntryDistance > 0) {
                    ix = px + rayEntryDistance * vx;
                    iz = pz + rayEntryDistance * vz;
                    if (ix > -this._halfExtentsX && ix < this._halfExtentsX && iz > -this._halfExtentsZ && iz < this._halfExtentsZ) {
                        targetNormal.x = 0;
                        targetNormal.y = -1;
                        targetNormal.z = 0;
                        intersects = true;
                    }
                }
            }
            if (!intersects && vz < 0) {
                rayEntryDistance = (this._halfExtentsZ - pz) / vz;
                if (rayEntryDistance > 0) {
                    ix = px + rayEntryDistance * vx;
                    iy = py + rayEntryDistance * vy;
                    if (iy > -this._halfExtentsY && iy < this._halfExtentsY && ix > -this._halfExtentsX && ix < this._halfExtentsX) {
                        targetNormal.x = 0;
                        targetNormal.y = 0;
                        targetNormal.z = 1;
                        intersects = true;
                    }
                }
            }
            if (!intersects && vz > 0) {
                rayEntryDistance = (-this._halfExtentsZ - pz) / vz;
                if (rayEntryDistance > 0) {
                    ix = px + rayEntryDistance * vx;
                    iy = py + rayEntryDistance * vy;
                    if (iy > -this._halfExtentsY && iy < this._halfExtentsY && ix > -this._halfExtentsX && ix < this._halfExtentsX) {
                        targetNormal.x = 0;
                        targetNormal.y = 0;
                        targetNormal.z = -1;
                        intersects = true;
                    }
                }
            }
            return intersects ? rayEntryDistance : -1;
        };
        /**
         * @inheritDoc
         */
        AxisAlignedBoundingBox.prototype.containsPoint = function (position) {
            var px = position.x - this._centerX, py = position.y - this._centerY, pz = position.z - this._centerZ;
            return px <= this._halfExtentsX && px >= -this._halfExtentsX && py <= this._halfExtentsY && py >= -this._halfExtentsY && pz <= this._halfExtentsZ && pz >= -this._halfExtentsZ;
        };
        /**
         * 对包围盒进行变换
         * @param bounds		包围盒
         * @param matrix		变换矩阵
         * @see http://www.cppblog.com/lovedday/archive/2008/02/23/43122.html
         */
        AxisAlignedBoundingBox.prototype.transformFrom = function (bounds, matrix) {
            var aabb = AxisAlignedBoundingBox(bounds);
            var cx = aabb._centerX;
            var cy = aabb._centerY;
            var cz = aabb._centerZ;
            var raw = feng3d.Matrix3DUtils.RAW_DATA_CONTAINER;
            matrix.copyRawDataTo(raw);
            var m11 = raw[0], m12 = raw[4], m13 = raw[8], m14 = raw[12];
            var m21 = raw[1], m22 = raw[5], m23 = raw[9], m24 = raw[13];
            var m31 = raw[2], m32 = raw[6], m33 = raw[10], m34 = raw[14];
            this._centerX = cx * m11 + cy * m12 + cz * m13 + m14;
            this._centerY = cx * m21 + cy * m22 + cz * m23 + m24;
            this._centerZ = cx * m31 + cy * m32 + cz * m33 + m34;
            if (m11 < 0)
                m11 = -m11;
            if (m12 < 0)
                m12 = -m12;
            if (m13 < 0)
                m13 = -m13;
            if (m21 < 0)
                m21 = -m21;
            if (m22 < 0)
                m22 = -m22;
            if (m23 < 0)
                m23 = -m23;
            if (m31 < 0)
                m31 = -m31;
            if (m32 < 0)
                m32 = -m32;
            if (m33 < 0)
                m33 = -m33;
            var hx = aabb._halfExtentsX;
            var hy = aabb._halfExtentsY;
            var hz = aabb._halfExtentsZ;
            this._halfExtentsX = hx * m11 + hy * m12 + hz * m13;
            this._halfExtentsY = hx * m21 + hy * m22 + hz * m23;
            this._halfExtentsZ = hx * m31 + hy * m32 + hz * m33;
            _min.x = this._centerX - this._halfExtentsX;
            _min.y = this._centerY - this._halfExtentsY;
            _min.z = this._centerZ - this._halfExtentsZ;
            _max.x = this._centerX + this._halfExtentsX;
            _max.y = this._centerY + this._halfExtentsY;
            _max.z = this._centerZ + this._halfExtentsZ;
            _aabbPointsDirty = true;
        };
        return AxisAlignedBoundingBox;
    }(feng3d.BoundingVolumeBase));
    feng3d.AxisAlignedBoundingBox = AxisAlignedBoundingBox;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 无空间包围盒，用于表示一直处于视锥体内或之外
     * <p>用于某些一直处于视锥体的实体，例如方向光源、天空盒等</p>
     * @author feng 2015-3-21
     */
    var NullBounds = (function (_super) {
        __extends(NullBounds, _super);
        /**
         * 构建空无空间包围盒
         * @param alwaysIn				是否总在视锥体内
         * @param renderable			渲染实体
         */
        function NullBounds(alwaysIn, renderable) {
            if (alwaysIn === void 0) { alwaysIn = true; }
            if (renderable === void 0) { renderable = null; }
            _super.call(this);
            this._alwaysIn = alwaysIn;
            this._renderable = renderable;
            _max.x = _max.y = _max.z = number.POSITIVE_INFINITY;
            _min.x = _min.y = _min.z = this._alwaysIn ? number.NEGATIVE_INFINITY : number.POSITIVE_INFINITY;
        }
        /**
         * @inheritDoc
         */
        NullBounds.prototype.createBoundingRenderable = function () {
            return this._renderable || new feng3d.WireframeSphere(100, 16, 12, 0xffffff, 0.5);
        };
        /**
         * @inheritDoc
         */
        NullBounds.prototype.isInFrustum = function (planes, numPlanes) {
            planes = planes;
            numPlanes = numPlanes;
            return this._alwaysIn;
        };
        /**
         * @inheritDoc
         */
        NullBounds.prototype.fromGeometry = function (geometry) {
        };
        /**
         * @inheritDoc
         */
        NullBounds.prototype.fromExtremes = function (minX, minY, minZ, maxX, maxY, maxZ) {
        };
        /**
         * @inheritDoc
         */
        NullBounds.prototype.transformFrom = function (bounds, matrix) {
            matrix = matrix;
            this._alwaysIn = NullBounds(bounds)._alwaysIn;
        };
        return NullBounds;
    }(feng3d.BoundingVolumeBase));
    feng3d.NullBounds = NullBounds;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 坐标系统类型
     * @author feng 2014-10-14
     */
    var CoordinateSystem = (function () {
        function CoordinateSystem() {
        }
        /**
         * 默认坐标系统，左手坐标系统
         */
        CoordinateSystem.LEFT_HANDED = 0;
        /**
         * 右手坐标系统
         */
        CoordinateSystem.RIGHT_HANDED = 1;
        return CoordinateSystem;
    }());
    feng3d.CoordinateSystem = CoordinateSystem;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 3D缓冲编号配置
     * @author feng 2015-7-21
     */
    var Context3DBufferIDConfig = (function () {
        function Context3DBufferIDConfig() {
        }
        /**
         * 缓冲编号配置
         */
        Context3DBufferIDConfig.bufferIdConfigs = [
            //----------------------------------------------------------
            ["normal_va_3", "法线数据"],
            ["tangent_va_3", "切线数据"],
            ["camerapos_vc_vector", " 摄像机位置静态数据 "],
            ["sceneTransform_vc_matrix", " 场景变换矩阵(模型空间转场景空间) "],
            ["normalSceneTransform_vc_matrix", " 法线场景变换矩阵(模型空间转场景空间) "],
            ["wordProjection_vc_matrix", " 世界投影矩阵(世界坐标转context3D的2D坐标) "],
            ["normal_ft_4", " 法线临时片段寄存器 "],
            ["globalPosition_vt_4", " 顶点世界坐标 "],
            ["cameraPosition_vc_vector", " 摄像机世界坐标 "],
            ["normal_v", " 法线变量寄存器 "],
            ["tangent_v", " 切线变量寄存器 "],
            ["bitangent_v", " 双切线变量寄存器 "],
            ["viewDir_v", " 视线变量寄存器 "],
            ["globalPos_v", " 世界坐标变量 "],
            ["viewDir_ft_4", " 视线方向片段临时数据 "],
            ["tangent_ft_4", " 切线片段临时寄存器 "],
            ["biTangent_ft_4", " 双切线片段临时寄存器 "],
            ["normalTexture_fs", " 法线纹理寄存器 "],
            ["normalTexData_ft_4", " 法线纹理数据临时寄存器 "],
            ["specularTexData_ft_4", " 光泽纹理数据片段临时寄存器 "],
            ["finalColor_ft_4", " 最终颜色寄存器（输出到oc寄存器的颜色） "],
            //---------------------------- 常用寄存器数据类型 ------------------------------
            ["index", "索引数据"],
            ["position_va_3", "顶点坐标数据"],
            ["color_va_3", "顶点颜色数据"],
            ["color_v", "颜色变量寄存器"],
            ["uv_va_2", "uv数据"],
            ["projection_vc_matrix", "顶点程序投影矩阵静态数据"],
            ["uv_v", "uv变量数据"],
            ["texture_fs", "片段程序的纹理"],
            ["skyboxTexture_fs", "天空盒立方体纹理"],
            ["color_fc_vector", "颜色静态数据"],
            ["program", "渲染程序"],
            ["culling", "三角形剔除模式"],
            ["blendFactors", "颜色混合"],
            ["depthTest", "深度测试模式"],
            ["commonsData_fc_vector", "公用数据片段常量数据"],
            ["_op", "顶点输出寄存器"],
            ["_oc", "片段输出寄存器"],
            //---------------------------- 常用寄存器数据类型 ------------------------------
            ["animated_va_3", "骨骼动画计算完成后的顶点坐标数据"],
            ["position0_va_3", "顶点动画第0个坐标数据"],
            ["position1_va_3", "顶点动画第1个坐标数据"],
            ["animatedPosition_vt_4", "动画后的顶点坐标数据"],
            ["jointindex_va_x", "关节索引数据"],
            ["jointweights_va_x", "关节权重数据"],
            ["weights_vc_vector", "顶点程序权重向量静态数据"],
            ["globalmatrices_vc_vector", "骨骼全局变换矩阵静态数据"],
            //---------------------------- 灯光相关寄存器数据类型 ------------------------------
            ["ambientColor_fc_vector", "环境颜色数据"],
            ["ambientTexture_fs", "环境纹理数据"],
            ["diffuseInput_fc_vector", "漫反射输入静态数据"],
            ["alphaThreshold_fc_vector", "漫反射透明度阀值数据"],
            ["dirLightSceneDir_fc_vector", "方向光源场景方向"],
            ["dirLightDiffuse_fc_vector", "方向光源漫反射光颜色"],
            ["dirLightSpecular_fc_vector", "方向光源镜面反射颜色"],
            ["pointLightScenePos_fc_vector", "点光源场景位置"],
            ["pointLightDiffuse_fc_vector", "点光源漫反射光颜色"],
            ["pointLightSpecular_fc_vector", "点光源镜面反射颜色"],
            ["specularData_fc_vector", "材质镜面反射光数据"],
            ["specularColor_ft_4", "镜面反射光临时片段寄存器"],
            ["mDiff_ft", "材质的漫反射颜色"],
            ["ambient_ft", "环境光因子临时变量"],
            ["totalDiffuseLightColor_ft_4", "总漫反射颜色寄存器"],
            ["totalSpecularLightColor_ft_4", "总镜面反射颜色寄存器"],
            ["specularTexture_fs", "光泽纹理寄存器"],
            //---------------------------- 阴影相关寄存器数据类型 ------------------------------
            ["depthMap_oc", "深度映射纹理(该纹理由片段着色器输出)"],
            ["depthMap_fs", "深度映射纹理"],
            ["depthMap_vc_matrix", "深度映射矩阵"],
            ["depthCommonData0_fc_vector", "深度顶点常数0 (1.0, 255.0, 65025.0, 16581375.0)"],
            ["depthCommonData1_fc_vector", "深度顶点常数1 (1.0/255.0, 1.0/255.0, 1.0/255.0, 0.0)"],
            ["positionProjected_v", "投影后的顶点坐标 变量数据"],
            ["depthMapCoord_v", "深度映射uv坐标 变量数据"],
            ["shadowCommondata0_vc_vector", "阴影函数顶点常数0 (0.5,-0.5,0,1) 用于深度值转换为uv值"],
            ["shadowCommondata0_fc_vector", "阴影函数片段常数0 (1.0,1.0/255,1.0/255/255,1.0/255/255/255) 用于颜色值转换为深度值"],
            ["shadowCommondata1_fc_vector", "阴影函数片段常数1"],
            ["shadowCommondata2_fc_vector", "阴影函数片段常数2 保存有深度图尺寸"],
            ["secondary_fc_vector", "用于计算阴影相对于观察者距离不同而作衰减"],
            ["shadowValue_ft_4", "阴影值临时变量寄存器"],
            ["shadowColorCommonsData_fc_vector", "平面阴影颜色片段常数"],
            //---------------------------- 天空盒相关寄存器数据类型 ------------------------------
            ["scaleSkybox_vc_vector", "天空盒缩放静态数据"],
            //---------------------------- 地形相关寄存器数据类型 ------------------------------
            ["blendingtexture_fs", "混合纹理"],
            ["terrainTextures_fs_array", "地形纹理数组"],
            ["tile_fc_vector", "地形常量"],
            //---------------------------- 粒子相关寄存器数据类型 ------------------------------
            ["particleCommon_vc_vector", "粒子常数数据[0,1,2,0]"],
            ["particleBillboard_vc_matrix", "广告牌旋转矩阵"],
            ["particleScale_vc_vector", "粒子缩放常数数据"],
            ["particleTime_va_4", "粒子时间数据"],
            ["particleTime_vc_vector", "粒子时间常量数据"],
            ["particleVelocity_va_3", "粒子速度数据"],
            ["particleVelocity_vc_vector", "粒子速度常数数据"],
            ["particleStartColorMultiplier_vc_vector", "粒子颜色乘数因子起始值，用于计算粒子颜色乘数因子"],
            ["particleDeltaColorMultiplier_vc_vector", "粒子颜色乘数因子增量值，用于计算粒子颜色乘数因子"],
            ["particleStartColorOffset_vc_vector", "粒子颜色偏移起始值，用于计算粒子颜色偏移值"],
            ["particleDeltaColorOffset_vc_vector", "粒子颜色偏移增量值，用于计算粒子颜色偏移值"],
            ["particleColorMultiplier_v", "粒子颜色乘数因子，用于乘以纹理上的颜色值"],
            ["particleColorOffset_v", "粒子颜色乘数因子，用于乘以纹理上的颜色值"],
            ["particlePositionTemp_vt_4", "粒子顶点坐标数据"],
            ["particleColorOffset_vt_4", "粒子颜色偏移值，在片段渲染的最终颜色值上偏移"],
            ["particleColorMultiplier_vt_4", "粒子颜色乘数因子，用于乘以纹理上的颜色值"],
            ["inCycleTime_vt_4", "粒子周期内时间临时寄存器"],
            //---------------------------- 线段相关寄存器数据类型 ------------------------------
            ["segmentStart_va_3", "线段起点坐标数据"],
            ["segmentEnd_va_3", "线段终点坐标数据"],
            ["segmentThickness_va_1", "线段厚度数据"],
            ["segmentColor_va_4", "线段颜色数据"],
            ["segmentC2pMatrix_vc_matrix", "摄像机坐标系到投影坐标系变换矩阵静态数据"],
            ["segmentM2cMatrix_vc_matrix", "模型坐标系到摄像机坐标系变换矩阵静态数据"],
            ["segmentOne_vc_vector", "常数1"],
            ["segmentFront_vc_vector", "常数前向量"],
            ["segmentConstants_vc_vector", "常量数据"],
            //---------------------------- 烟雾相关寄存器数据类型 ------------------------------
            ["fogColor_fc_vector", "雾颜色常量数据"],
            ["fogCommonData_fc_vector", "雾通用常量数据"],
            //---------------------------- uv动画相关寄存器数据类型 ------------------------------
            ["uvAnimatorTranslate_vc_vector", "uv偏移值（uv动画）"],
            ["uvAnimatorMatrix2d_vc_vector", "uv变换矩阵（uv动画）"],
            ["spriteSheetVectorFrame_vc_vector", "常量数据（spriteSheet动画）"],
            //---------------------------- EnvMap相关寄存器数据类型 ------------------------------
            ["envMapcubeTexture_fs", "立方体纹理（EnvMap）"],
            ["envMapMaskTexture_fs", "遮罩纹理（EnvMap）"],
            ["envMapData_fc_vector", "片段数据（EnvMap）"],
            //----------------------------  ------------------------------
            ["fresnelSpecularData_fc_vector", "片段数据（FresnelSpecular）"],
            //----------------------------  ------------------------------
            ["SSD$ToTex_vc_vector", "SubsurfaceScatteringDiffuseMethod"],
            ["SSD$f$ColorData_vc_vector", "SubsurfaceScatteringDiffuseMethod"],
            ["SSD$fragmentData0_vc_vector", "SubsurfaceScatteringDiffuseMethod"],
            ["SSD$fragmentData1_vc_vector", "SubsurfaceScatteringDiffuseMethod"],
            ["SSD$depthMap_fs", "SubsurfaceScatteringDiffuseMethod"],
            ["SSD$LightProjection_vc_matrix", "SubsurfaceScatteringDiffuseMethod"],
            //----------------------------  ------------------------------
            ["SODP$polyOffset_vc_vector", "SingleObjectDepthPass"],
            ["SODP$objectProjection_vc_matrix", "SingleObjectDepthPass"],
            ["SODP$depthCommonsData0_fc_vector", "SingleObjectDepthPass"],
            ["SODP$depthCommonsData1_fc_vector", "SingleObjectDepthPass"],
        ];
        return Context3DBufferIDConfig;
    }());
    feng3d.Context3DBufferIDConfig = Context3DBufferIDConfig;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 3D视图
     * @author feng 2014-3-17
     */
    var View3D = (function (_super) {
        __extends(View3D, _super);
        /**
         * 创建一个3D视图
         * @param scene 				场景
         * @param camera 				摄像机
         * @param renderer				渲染器
         * @param forceSoftware			是否强行使用软件渲染
         * @param profile				指定 Flash Player 支持低级别 GPU 的范围
         */
        function View3D(scene, camera, renderer, forceSoftware, profile) {
            if (scene === void 0) { scene = null; }
            if (camera === void 0) { camera = null; }
            if (renderer === void 0) { renderer = null; }
            if (forceSoftware === void 0) { forceSoftware = false; }
            if (profile === void 0) { profile = Context3DProfile.STANDARD; }
            this._width = 0;
            this._height = 0;
            this._localPos = new Point();
            this._globalPos = new Point();
            this._backBufferInvalid = true;
            this._backgroundColor = 0x000000;
            this._backgroundAlpha = 1;
            this._scissorRectDirty = true;
            this._viewportDirty = true;
            this._shareContext = false;
            this._scene = scene || new feng3d.Scene3D();
            this._camera = camera || new feng3d.Camera3D();
            this._renderer = renderer || new feng3d.DefaultRenderer();
            this._forceSoftware = forceSoftware;
            this._profile = profile;
            this._entityCollector = this._renderer.createEntityCollector();
            this._entityCollector.camera = this._camera;
            this.initHitField();
            this._mouse3DManager = new feng3d.Mouse3DManager();
            this._mouse3DManager.enableMouseListeners(this);
            this.addEventListener(feng3d.Event.ADDED_TO_STAGE, this.onAddedToStage, false, 0, true);
            this.addEventListener(feng3d.Event.ADDED, this.onAdded, false, 0, true);
            this.addEventListener(feng3d.Event.REMOVED_FROM_STAGE, this.onRemoveFromeStage, false, 0, true);
            this._camera.partition = this._scene.partition;
        }
        Object.defineProperty(View3D.prototype, "x", {
            set: function (value) {
                if (x == value)
                    return;
                _localPos.x = _super.prototype.x = value;
                _globalPos.x = parent ? parent.localToGlobal(_localPos).x : value;
                _globalPosDirty = true;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(View3D.prototype, "y", {
            set: function (value) {
                if (y == value)
                    return;
                _localPos.y = _super.prototype.y = value;
                _globalPos.y = parent ? parent.localToGlobal(_localPos).y : value;
                _globalPosDirty = true;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(View3D.prototype, "visible", {
            set: function (value) {
                _super.prototype.visible = value;
                if (_stage3DProxy && !_shareContext)
                    _stage3DProxy.visible = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(View3D.prototype, "antiAlias", {
            /**
             * The amount of anti-aliasing to be used.
             */
            get: function () {
                return _antiAlias;
            },
            set: function (value) {
                _antiAlias = value;
                _backBufferInvalid = true;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(View3D.prototype, "camera", {
            /**
             * 摄像机
             */
            get: function () {
                return _camera;
            },
            set: function (value) {
                _camera.removeEventListener(feng3d.CameraEvent.LENS_CHANGED, onLensChanged);
                _camera = value;
                _entityCollector.camera = _camera;
                if (_scene)
                    _camera.partition = _scene.partition;
                _camera.addEventListener(feng3d.CameraEvent.LENS_CHANGED, onLensChanged);
                _scissorRectDirty = true;
                _viewportDirty = true;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 处理镜头改变事件
         */
        View3D.prototype.onLensChanged = function (event) {
            this._scissorRectDirty = true;
            this._viewportDirty = true;
        };
        /**
         * 处理添加到舞台事件
         */
        View3D.prototype.onAddedToStage = function (event) {
            this._addedToStage = true;
            if (!this._stage3DProxy) {
                this._stage3DProxy = feng3d.Stage3DManager.getInstance(this.stage).getFreeStage3DProxy(this._forceSoftware, this._profile);
                //				this._stage3DProxy.addEventListener(Stage3DEvent.VIEWPORT_UPDATED, onViewportUpdated);
                this._stage3DProxy.addEventListener(feng3d.Stage3DEvent.CONTEXT3D_RECREATED, this.onContext3DRecreated);
            }
            this._stage3DProxy.visible = true;
            if (this._width == 0)
                this.width = this.stage.stageWidth;
            if (this._height == 0)
                this.height = this.stage.stageHeight;
        };
        /**
         * 添加事件
         * @param event
         */
        View3D.prototype.onAdded = function (event) {
            this._parentIsStage = (this.parent == this.stage);
            this._globalPos = this.parent.localToGlobal(this._localPos);
            this._globalPosDirty = true;
        };
        /**
         * 处理3D环境被重建事件
         */
        View3D.prototype.onContext3DRecreated = function (event) {
            //			_depthTextureInvalid = true;
        };
        /**
         * 处理从舞台移除事件
         */
        View3D.prototype.onRemoveFromeStage = function (event) {
            this._stage3DProxy.visible = false;
        };
        /**
         * 初始化点击区域
         */
        View3D.prototype.initHitField = function () {
            this._hitField = new Sprite();
            this._hitField.alpha = 0;
            this._hitField.doubleClickEnabled = true;
            this._hitField.graphics.beginFill(0x000000);
            this._hitField.graphics.drawRect(0, 0, 100, 100);
            this.addChild(this._hitField);
        };
        /**
         * 添加源码地址
         * @param url
         */
        View3D.prototype.addSourceURL = function (url) {
        };
        /**
         * 渲染3D视图
         */
        View3D.prototype.render = function () {
            //当3D环境被系统释放，不能进行渲染
            if (!this.stage3DProxy.recoverFromDisposal()) {
                this._backBufferInvalid = true;
                return;
            }
            //重置渲染设置
            if (this._backBufferInvalid)
                this.updateBackBuffer();
            if (!this._parentIsStage) {
                var globalPos = this.parent.localToGlobal(this._localPos);
                if (this._globalPos.x != globalPos.x || this._globalPos.y != globalPos.y) {
                    this._globalPos = globalPos;
                    this._globalPosDirty = true;
                }
            }
            if (this._globalPosDirty)
                this.updateGlobalPos();
            this._entityCollector.clear();
            //收集渲染实体
            this._scene.traversePartitions(this._entityCollector);
            this._renderer.shareContext = this._shareContext;
            //渲染收集的实体对象
            this._renderer.render(this.stage3DProxy, this._entityCollector);
            //收集场景显示对象
            this._scene.collectMouseCollisionEntitys();
            if (!this._shareContext) {
                this.stage3DProxy.present();
                //获取鼠标射线
                var mouseRay3D = this.getMouseRay3D();
                //更新鼠标碰撞
                this._mouse3DManager.fireMouseEvents(mouseRay3D, this._scene.mouseCollisionEntitys);
            }
            // register that a view has been rendered
            this.stage3DProxy.bufferClear = false;
        };
        Object.defineProperty(View3D.prototype, "scene", {
            /** 3d场景 */
            get: function () {
                return _scene;
            },
            /**
             * @private
             */
            set: function (value) {
                _scene = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(View3D.prototype, "stage3DProxy", {
            /**
             * 3D舞台代理
             */
            get: function () {
                return _stage3DProxy;
            },
            set: function (value) {
                _stage3DProxy = value;
                _stage3DProxy = stage3DProxy;
                _globalPosDirty = true;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(View3D.prototype, "width", {
            /**
             * 宽度
             */
            get: function () {
                return _width;
            },
            set: function (value) {
                //限制软件渲染时最大宽度
                if (_stage3DProxy && _stage3DProxy.usesSoftwareRendering && value > 2048)
                    value = 2048;
                if (_width == value)
                    return;
                _hitField.width = value;
                _width = value;
                _aspectRatio = _width / _height;
                _camera.lens.aspectRatio = _aspectRatio;
                _backBufferInvalid = true;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(View3D.prototype, "height", {
            /**
             * 高度
             */
            get: function () {
                return _height;
            },
            set: function (value) {
                //限制软件渲染时最大高度
                if (_stage3DProxy && _stage3DProxy.usesSoftwareRendering && value > 2048)
                    value = 2048;
                if (_height == value)
                    return;
                _hitField.height = value;
                _height = value;
                _aspectRatio = _width / _height;
                _camera.lens.aspectRatio = _aspectRatio;
                _backBufferInvalid = true;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(View3D.prototype, "renderedFacesCount", {
            /**
             * 渲染面数
             */
            get: function () {
                return 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(View3D.prototype, "shareContext", {
            /**
             * Defers control of Context3D clear() and present() calls to Stage3DProxy, enabling multiple Stage3D frameworks
             * to share the same Context3D object.
             */
            get: function () {
                return _shareContext;
            },
            set: function (value) {
                if (_shareContext == value)
                    return;
                _shareContext = value;
                _globalPosDirty = true;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 更新背景缓冲大小
         */
        View3D.prototype.updateBackBuffer = function () {
            if (this._stage3DProxy.context3D && !this._shareContext) {
                if (this._width && this._height) {
                    if (this._stage3DProxy.usesSoftwareRendering) {
                        if (this._width > 2048)
                            this._width = 2048;
                        if (this._height > 2048)
                            this._height = 2048;
                    }
                    this._stage3DProxy.configureBackBuffer(this._width, this._height, this._antiAlias);
                    this._backBufferInvalid = false;
                }
                else {
                    this.width = this.stage.stageWidth;
                    this.height = this.stage.stageHeight;
                }
            }
        };
        /**
         * 更新全局坐标
         */
        View3D.prototype.updateGlobalPos = function () {
            this._globalPosDirty = false;
            if (!this._stage3DProxy)
                return;
            this._stage3DProxy.x = this._globalPos.x;
            this._stage3DProxy.y = this._globalPos.y;
        };
        Object.defineProperty(View3D.prototype, "backgroundColor", {
            /**
             * 背景颜色
             */
            set: function (value) {
                _backgroundColor = value;
                _renderer.backgroundColor = _backgroundColor;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 投影坐标（世界坐标转换为3D视图坐标）
         * @param point3d 世界坐标
         * @return 屏幕的绝对坐标
         */
        View3D.prototype.project = function (point3d) {
            var v = this._camera.project(point3d);
            v.x = (v.x + 1.0) * this._width / 2.0;
            v.y = (v.y + 1.0) * this._height / 2.0;
            return v;
        };
        /**
         * 屏幕坐标投影到场景坐标
         * @param nX 屏幕坐标X ([0-width])
         * @param nY 屏幕坐标Y ([0-height])
         * @param sZ 到屏幕的距离
         * @param v 场景坐标（输出）
         * @return 场景坐标
         */
        View3D.prototype.unproject = function (sX, sY, sZ, v) {
            if (v === void 0) { v = null; }
            var gpuPos = this.screenToGpuPosition(new Point(sX, sY));
            return this._camera.unproject(gpuPos.x, gpuPos.y, sZ, v);
        };
        /**
         * 屏幕坐标转GPU坐标
         * @param screenPos 屏幕坐标 (x:[0-width],y:[0-height])
         * @return GPU坐标 (x:[-1,1],y:[-1-1])
         */
        View3D.prototype.screenToGpuPosition = function (screenPos) {
            var gpuPos = new Point();
            gpuPos.x = (screenPos.x * 2 - this._width) / this._stage3DProxy.width;
            gpuPos.y = (screenPos.y * 2 - this._height) / this._stage3DProxy.height;
            return gpuPos;
        };
        /**
         * 获取鼠标射线（与鼠标重叠的摄像机射线）
         */
        View3D.prototype.getMouseRay3D = function () {
            return this.getRay3D(this.mouseX, this.mouseY);
        };
        /**
         * 获取与坐标重叠的射线
         * @param x view3D上的X坐标
         * @param y view3D上的X坐标
         * @return
         */
        View3D.prototype.getRay3D = function (x, y) {
            //摄像机坐标
            var rayPosition = this.unproject(x, y, 0, tempRayPosition);
            //摄像机前方1处坐标
            var rayDirection = this.unproject(x, y, 1, tempRayDirection);
            //射线方向
            rayDirection.x = rayDirection.x - rayPosition.x;
            rayDirection.y = rayDirection.y - rayPosition.y;
            rayDirection.z = rayDirection.z - rayPosition.z;
            rayDirection.normalize();
            //定义射线
            var ray3D = new feng3d.Ray3D(rayPosition, rayDirection);
            return ray3D;
        };
        Object.defineProperty(View3D.prototype, "renderer", {
            /**
             * 渲染器
             */
            get: function () {
                return _renderer;
            },
            set: function (value) {
                _renderer.dispose();
                _renderer = value;
                _entityCollector = _renderer.createEntityCollector();
                _entityCollector.camera = _camera;
                _renderer.backgroundColor = _backgroundColor;
                _renderer.backgroundAlpha = _backgroundAlpha;
                _renderer.viewWidth = _width;
                _renderer.viewHeight = _height;
                _backBufferInvalid = true;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 射线坐标临时变量
         */
        View3D.tempRayPosition = new Vector3D();
        /**
         * 射线方向临时变量
         */
        View3D.tempRayDirection = new Vector3D();
        return View3D;
    }(Sprite));
    feng3d.View3D = View3D;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 控制器
     * @author feng 2014-10-10
     */
    var ControllerBase = (function () {
        /**
         * 创建控制器
         * @param targetObject 被控制对象
         */
        function ControllerBase(targetObject) {
            if (targetObject === void 0) { targetObject = null; }
            this._autoUpdate = true;
            this.targetObject = targetObject;
            feng3d.AbstractClassError.check(this);
        }
        Object.defineProperty(ControllerBase.prototype, "targetObject", {
            /**
             * 被控制对象
             */
            get: function () {
                return _targetObject;
            },
            set: function (val) {
                if (_targetObject == val)
                    return;
                if (_targetObject && _autoUpdate)
                    _targetObject._controller = null;
                _targetObject = val;
                if (_targetObject && _autoUpdate)
                    _targetObject._controller = this;
                notifyUpdate();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 通知被控制对象更新
         */
        ControllerBase.prototype.notifyUpdate = function () {
            this.update();
            //
            if (this._targetObject && this._targetObject.implicitPartition && this._autoUpdate)
                this._targetObject.implicitPartition.markForUpdate(this._targetObject);
        };
        /**
         * 更新被控制对象状态
         */
        ControllerBase.prototype.update = function () {
            throw new feng3d.AbstractMethodError();
        };
        return ControllerBase;
    }());
    feng3d.ControllerBase = ControllerBase;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 注视点控制器
     * @author feng 2014-10-10
     */
    var LookAtController = (function (_super) {
        __extends(LookAtController, _super);
        /**
         * 创建注视点控制器
         * @param targetObject 控制对象
         * @param lookAtObject 被注视对象
         */
        function LookAtController(targetObject, lookAtObject) {
            if (targetObject === void 0) { targetObject = null; }
            if (lookAtObject === void 0) { lookAtObject = null; }
            _super.call(this, targetObject);
            this._upAxis = Vector3D.Y_AXIS;
            this._pos = new Vector3D();
            if (lookAtObject)
                this.lookAtObject = lookAtObject;
            else
                this.lookAtPosition = new Vector3D();
        }
        Object.defineProperty(LookAtController.prototype, "upAxis", {
            /**
             * 目标对象的上朝向
             */
            get: function () {
                return _upAxis;
            },
            set: function (upAxis) {
                _upAxis = upAxis;
                notifyUpdate();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LookAtController.prototype, "lookAtPosition", {
            /**
             * 被注视目标所在位置
             */
            get: function () {
                return _lookAtPosition;
            },
            set: function (val) {
                if (_lookAtObject) {
                    _lookAtObject.removeEventListener(feng3d.Transform3DEvent.SCENETRANSFORM_CHANGED, onLookAtObjectChanged);
                    _lookAtObject = null;
                }
                _lookAtPosition = val;
                notifyUpdate();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LookAtController.prototype, "lookAtObject", {
            /**
             * 被注视目标
             */
            get: function () {
                return _lookAtObject;
            },
            set: function (val) {
                if (_lookAtPosition)
                    _lookAtPosition = null;
                if (_lookAtObject == val)
                    return;
                if (_lookAtObject)
                    _lookAtObject.removeEventListener(feng3d.Transform3DEvent.SCENETRANSFORM_CHANGED, onLookAtObjectChanged);
                _lookAtObject = val;
                if (_lookAtObject)
                    _lookAtObject.addEventListener(feng3d.Transform3DEvent.SCENETRANSFORM_CHANGED, onLookAtObjectChanged);
                notifyUpdate();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 处理注视目标变化事件
         */
        LookAtController.prototype.onLookAtObjectChanged = function (event) {
            notifyUpdate();
        };
        /**
         * @inheritDoc
         */
        LookAtController.prototype.update = function () {
            if (_targetObject) {
                if (this._lookAtPosition) {
                    _targetObject.transform3D.lookAt(this._lookAtPosition, this._upAxis);
                }
                else if (this._lookAtObject) {
                    if (_targetObject.parent && this._lookAtObject.parent) {
                        if (_targetObject.parent != this._lookAtObject.parent) {
                            this._pos.x = this._lookAtObject.scenePosition.x;
                            this._pos.y = this._lookAtObject.scenePosition.y;
                            this._pos.z = this._lookAtObject.scenePosition.z;
                            //
                            feng3d.Matrix3DUtils.transformVector(_targetObject.parent.inverseSceneTransform, this._pos, this._pos);
                        }
                        else {
                            feng3d.Matrix3DUtils.getTranslation(this._lookAtObject.transform3D.transform, this._pos);
                        }
                    }
                    else if (this._lookAtObject.scene) {
                        this._pos.x = this._lookAtObject.scenePosition.x;
                        this._pos.y = this._lookAtObject.scenePosition.y;
                        this._pos.z = this._lookAtObject.scenePosition.z;
                    }
                    else {
                        feng3d.Matrix3DUtils.getTranslation(this._lookAtObject.transform3D.transform, this._pos);
                    }
                    _targetObject.transform3D.lookAt(this._pos, this._upAxis);
                }
            }
        };
        return LookAtController;
    }(feng3d.ControllerBase));
    feng3d.LookAtController = LookAtController;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 盘旋控制器
     * @author feng 2014-10-10
     */
    var HoverController = (function (_super) {
        __extends(HoverController, _super);
        /**
         * 创建盘旋控制器
         * @param targetObject 控制对象
         * @param lookAtObject 被注视对象
         * @param panAngle 摄像机以Y轴旋转的角度
         * @param tiltAngle 摄像机以X轴旋转的角度
         * @param distance 与注视对象的距离
         * @param minTiltAngle 以X轴旋转的最小角度。
         * @param maxTiltAngle 以X轴旋转的最大角度。
         * @param minPanAngle 以Y轴旋转的最小角度。
         * @param maxPanAngle 以Y轴旋转的最大角度。
         * @param yFactor
         * @param wrapPanAngle 是否把角度约束在0到360度
         */
        function HoverController(targetObject, lookAtObject, panAngle, tiltAngle, distance, minTiltAngle, maxTiltAngle, minPanAngle, maxPanAngle, yFactor, wrapPanAngle) {
            if (targetObject === void 0) { targetObject = null; }
            if (lookAtObject === void 0) { lookAtObject = null; }
            if (panAngle === void 0) { panAngle = 0; }
            if (tiltAngle === void 0) { tiltAngle = 90; }
            if (distance === void 0) { distance = 1000; }
            if (minTiltAngle === void 0) { minTiltAngle = -90; }
            if (maxTiltAngle === void 0) { maxTiltAngle = 90; }
            if (minPanAngle === void 0) { minPanAngle = NaN; }
            if (maxPanAngle === void 0) { maxPanAngle = NaN; }
            if (yFactor === void 0) { yFactor = 2; }
            if (wrapPanAngle === void 0) { wrapPanAngle = false; }
            _super.call(this, targetObject, lookAtObject);
            this._currentPanAngle = 0;
            this._currentTiltAngle = 90;
            this._origin = new Vector3D(0.0, 0.0, 0.0);
            this._panAngle = 0;
            this._tiltAngle = 90;
            this._distance = 1000;
            this._minPanAngle = -Infinity;
            this._maxPanAngle = Infinity;
            this._minTiltAngle = -90;
            this._maxTiltAngle = 90;
            this._yFactor = 2;
            this._wrapPanAngle = false;
            this._pos = new Vector3D();
            /**
             * 更新当前倾斜与摆动角度
             * @see    #tiltAngle
             * @see    #panAngle
             * @see    #steps
             */
            this.override = function update() {
                if (this._tiltAngle != this._currentTiltAngle || this._panAngle != this._currentPanAngle) {
                    if (this._wrapPanAngle) {
                        if (this._panAngle < 0) {
                            this._currentPanAngle += this._panAngle % 360 + 360 - this._panAngle;
                            this._panAngle = this._panAngle % 360 + 360;
                        }
                        else {
                            this._currentPanAngle += this._panAngle % 360 - this._panAngle;
                            this._panAngle = this._panAngle % 360;
                        }
                        while (this._panAngle - this._currentPanAngle < -180)
                            this._currentPanAngle -= 360;
                        while (this._panAngle - this._currentPanAngle > 180)
                            this._currentPanAngle += 360;
                    }
                    this._currentPanAngle = this._panAngle;
                    this._currentTiltAngle = this._tiltAngle;
                    //snap coords if angle differences are close
                    if ((Math.abs(this.tiltAngle - this._currentTiltAngle) < 0.01) && (Math.abs(this._panAngle - this._currentPanAngle) < 0.01)) {
                        this._currentTiltAngle = this._tiltAngle;
                        this._currentPanAngle = this._panAngle;
                    }
                }
                if (!_targetObject)
                    return;
                if (_lookAtPosition) {
                    this._pos.x = _lookAtPosition.x;
                    this._pos.y = _lookAtPosition.y;
                    this._pos.z = _lookAtPosition.z;
                }
                else if (_lookAtObject) {
                    if (_targetObject.parent && _lookAtObject.parent) {
                        if (_targetObject.parent != _lookAtObject.parent) {
                            this._pos.x = _lookAtObject.scenePosition.x;
                            this._pos.y = _lookAtObject.scenePosition.y;
                            this._pos.z = _lookAtObject.scenePosition.z;
                            feng3d.Matrix3DUtils.transformVector(_targetObject.parent.inverseSceneTransform, this._pos, this._pos);
                        }
                        else {
                            feng3d.Matrix3DUtils.getTranslation(_lookAtObject.transform3D.transform, this._pos);
                        }
                    }
                    else if (_lookAtObject.scene) {
                        this._pos.x = _lookAtObject.scenePosition.x;
                        this._pos.y = _lookAtObject.scenePosition.y;
                        this._pos.z = _lookAtObject.scenePosition.z;
                    }
                    else {
                        feng3d.Matrix3DUtils.getTranslation(_lookAtObject.transform3D.transform, this._pos);
                    }
                }
                else {
                    this._pos.x = this._origin.x;
                    this._pos.y = this._origin.y;
                    this._pos.z = this._origin.z;
                }
                _targetObject.transform3D.x = this._pos.x + this._distance * Math.sin(this._currentPanAngle * feng3d.MathConsts.DEGREES_TO_RADIANS) * Math.cos(this._currentTiltAngle * feng3d.MathConsts.DEGREES_TO_RADIANS);
                _targetObject.transform3D.z = this._pos.z + this._distance * Math.cos(this._currentPanAngle * feng3d.MathConsts.DEGREES_TO_RADIANS) * Math.cos(this._currentTiltAngle * feng3d.MathConsts.DEGREES_TO_RADIANS);
                _targetObject.transform3D.y = this._pos.y + this._distance * Math.sin(this._currentTiltAngle * feng3d.MathConsts.DEGREES_TO_RADIANS) * this._yFactor;
                _super.update.call(this);
            };
            this.distance = distance;
            this.panAngle = panAngle;
            this.tiltAngle = tiltAngle;
            this.minPanAngle = minPanAngle || -Infinity;
            this.maxPanAngle = maxPanAngle || Infinity;
            this.minTiltAngle = minTiltAngle;
            this.maxTiltAngle = maxTiltAngle;
            this.yFactor = yFactor;
            this.wrapPanAngle = wrapPanAngle;
            //values passed in contrustor are applied immediately
            _currentPanAngle = _panAngle;
            _currentTiltAngle = _tiltAngle;
        }
        Object.defineProperty(HoverController.prototype, "distance", {
            /**
             * 与注视目标的距离
             */
            get: function () {
                return _distance;
            },
            set: function (val) {
                if (_distance == val)
                    return;
                _distance = val;
                notifyUpdate();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HoverController.prototype, "minPanAngle", {
            /**
             * 最小摆动角度
             */
            get: function () {
                return _minPanAngle;
            },
            set: function (val) {
                if (_minPanAngle == val)
                    return;
                _minPanAngle = val;
                panAngle = Math.max(_minPanAngle, Math.min(_maxPanAngle, _panAngle));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HoverController.prototype, "maxPanAngle", {
            /**
             * 最大摆动角度
             */
            get: function () {
                return _maxPanAngle;
            },
            set: function (val) {
                if (_maxPanAngle == val)
                    return;
                _maxPanAngle = val;
                panAngle = Math.max(_minPanAngle, Math.min(_maxPanAngle, _panAngle));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HoverController.prototype, "tiltAngle", {
            /**
             * 倾斜角度
             */
            get: function () {
                return _tiltAngle;
            },
            set: function (val) {
                val = Math.max(_minTiltAngle, Math.min(_maxTiltAngle, val));
                if (_tiltAngle == val)
                    return;
                _tiltAngle = val;
                notifyUpdate();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HoverController.prototype, "minTiltAngle", {
            /**
             * 最小倾斜角度
             */
            get: function () {
                return _minTiltAngle;
            },
            set: function (val) {
                if (_minTiltAngle == val)
                    return;
                _minTiltAngle = val;
                tiltAngle = Math.max(_minTiltAngle, Math.min(_maxTiltAngle, _tiltAngle));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HoverController.prototype, "maxTiltAngle", {
            /**
             * 最大倾斜角度
             */
            get: function () {
                return _maxTiltAngle;
            },
            set: function (val) {
                if (_maxTiltAngle == val)
                    return;
                _maxTiltAngle = val;
                tiltAngle = Math.max(_minTiltAngle, Math.min(_maxTiltAngle, _tiltAngle));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HoverController.prototype, "yFactor", {
            /**
             * y因子，用于体现摄像机水平与垂直旋转的差异
             * @see #distance
             */
            get: function () {
                return _yFactor;
            },
            set: function (val) {
                if (_yFactor == val)
                    return;
                _yFactor = val;
                notifyUpdate();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HoverController.prototype, "wrapPanAngle", {
            /**
             * 是否把角度约束在0到360度
             */
            get: function () {
                return _wrapPanAngle;
            },
            set: function (val) {
                if (_wrapPanAngle == val)
                    return;
                _wrapPanAngle = val;
                notifyUpdate();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HoverController.prototype, "panAngle", {
            /**
             * 摆动角度
             */
            get: function () {
                return _panAngle;
            },
            set: function (val) {
                val = Math.max(_minPanAngle, Math.min(_maxPanAngle, val));
                if (_panAngle == val)
                    return;
                _panAngle = val;
                notifyUpdate();
            },
            enumerable: true,
            configurable: true
        });
        return HoverController;
    }(feng3d.LookAtController));
    feng3d.HoverController = HoverController;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * Face value object.
     */
    var Face = (function () {
        function Face() {
        }
        return Face;
    }());
    feng3d.Face = Face;
    /**
     * Creates a new <code>Face</code> value object.
     *
     * @param    vertices        [optional] 9 entries long Vector.&lt;number&gt; representing the x, y and z of v0, v1, and v2 of a face
     * @param    uvs            [optional] 6 entries long Vector.&lt;number&gt; representing the u and v of uv0, uv1, and uv2 of a face
     */
    function Face(vertices, uvs) {
        if (vertices === void 0) { vertices = null; }
        if (uvs === void 0) { uvs = null; }
        _vertices = vertices || number[]([0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]);
        _uvs = uvs || number[]([0.0, 0.0, 0.0, 0.0, 0.0, 0.0]);
    }
    setUVat(index, number, u, number, v, number);
    {
        var ind = (index * 2);
        this._uvs[ind] = u;
        this._uvs[ind + 1] = v;
    }
    set;
    faceIndex(ind, number);
    {
        _faceIndex = ind;
    }
    get;
    faceIndex();
    number;
    {
        return _faceIndex;
    }
    set;
    uv0Index(ind, number);
    {
        _uv0Index = ind;
    }
    get;
    uv0Index();
    number;
    {
        return _uv0Index;
    }
    setUv0Value(u, number, v, number);
    {
        this._uvs[0] = u;
        this._uvs[1] = v;
    }
    get;
    uv0u();
    number;
    {
        return _uvs[0];
    }
    get;
    uv0v();
    number;
    {
        return _uvs[1];
    }
    set;
    uv1Index(ind, number);
    {
        _uv1Index = ind;
    }
    get;
    uv1Index();
    number;
    {
        return _uv1Index;
    }
    setUv1Value(u, number, v, number);
    {
        this._uvs[2] = u;
        this._uvs[3] = v;
    }
    get;
    uv1u();
    number;
    {
        return _uvs[2];
    }
    get;
    uv1v();
    number;
    {
        return _uvs[3];
    }
    set;
    uv2Index(ind, number);
    {
        _uv2Index = ind;
    }
    get;
    uv2Index();
    number;
    {
        return _uv2Index;
    }
    setUv2Value(u, number, v, number);
    {
        this._uvs[4] = u;
        this._uvs[5] = v;
    }
    get;
    uv2u();
    number;
    {
        return _uvs[4];
    }
    get;
    uv2v();
    number;
    {
        return _uvs[5];
    }
    setVertexAt(index, number, x, number, y, number, z, number);
    {
        var ind = (index * 3);
        this._vertices[ind] = x;
        this._vertices[ind + 1] = y;
        this._vertices[ind + 2] = z;
    }
    set;
    v0Index(ind, number);
    {
        _v0Index = ind;
    }
    get;
    v0Index();
    number;
    {
        return _v0Index;
    }
    get;
    v0();
    number[];
    {
        return number[]([_vertices[0], _vertices[1], _vertices[2]]);
    }
    get;
    v0x();
    number;
    {
        return _vertices[0];
    }
    get;
    v0y();
    number;
    {
        return _vertices[1];
    }
    get;
    v0z();
    number;
    {
        return _vertices[2];
    }
    set;
    v1Index(ind, number);
    {
        _v1Index = ind;
    }
    get;
    v1Index();
    number;
    {
        return _v1Index;
    }
    get;
    v1();
    number[];
    {
        return number[]([_vertices[3], _vertices[4], _vertices[5]]);
    }
    get;
    v1x();
    number;
    {
        return _vertices[3];
    }
    get;
    v1y();
    number;
    {
        return _vertices[4];
    }
    get;
    v1z();
    number;
    {
        return _vertices[5];
    }
    set;
    v2Index(ind, number);
    {
        _v2Index = ind;
    }
    get;
    v2Index();
    number;
    {
        return _v2Index;
    }
    get;
    v2();
    number[];
    {
        return number[]([_vertices[6], _vertices[7], _vertices[8]]);
    }
    get;
    v2x();
    number;
    {
        return _vertices[6];
    }
    get;
    v2y();
    number;
    {
        return _vertices[7];
    }
    get;
    v2z();
    number;
    {
        return _vertices[8];
    }
    clone();
    Face;
    {
        var nVertices = number[]([this._vertices[0], this._vertices[1], this._vertices[2],
            this._vertices[3], this._vertices[4], this._vertices[5],
            this._vertices[6], this._vertices[7], this._vertices[8]]);
        var nUvs = number[]([this._uvs[0], this._uvs[1],
            this._uvs[2], this._uvs[3],
            this._uvs[4], this._uvs[5]]);
        return new Face(nVertices, nUvs);
    }
    getBarycentricCoords(point, Vector3D, target, Point = null);
    Point;
    {
        var v0x = this._vertices[0];
        var v0y = this._vertices[1];
        var v0z = this._vertices[2];
        var dx0 = point.x - v0x;
        var dy0 = point.y - v0y;
        var dz0 = point.z - v0z;
        var dx1 = this._vertices[3] - v0x;
        var dy1 = this._vertices[4] - v0y;
        var dz1 = this._vertices[5] - v0z;
        var dx2 = this._vertices[6] - v0x;
        var dy2 = this._vertices[7] - v0y;
        var dz2 = this._vertices[8] - v0z;
        var dot01 = dx1 * dx0 + dy1 * dy0 + dz1 * dz0;
        var dot02 = dx2 * dx0 + dy2 * dy0 + dz2 * dz0;
        var dot11 = dx1 * dx1 + dy1 * dy1 + dz1 * dz1;
        var dot22 = dx2 * dx2 + dy2 * dy2 + dz2 * dz2;
        var dot12 = dx2 * dx1 + dy2 * dy1 + dz2 * dz1;
        var invDenom = 1 / (dot22 * dot11 - dot12 * dot12);
        target || ;
        new Point();
        target.x = (dot22 * dot01 - dot12 * dot02) * invDenom;
        target.y = (dot11 * dot02 - dot12 * dot01) * invDenom;
        return target;
    }
    containsPoint(point, Vector3D, maxDistanceToPlane, number = .007);
    boolean;
    {
        if (!this.planeContains(point, maxDistanceToPlane))
            return false;
        this.getBarycentricCoords(point, _calcPoint || , new Point());
        var s = _calcPoint.x;
        var t = _calcPoint.y;
        return s >= 0.0 && t >= 0.0 && (s + t) <= 1.0;
    }
    planeContains(point, Vector3D, epsilon, number = .007);
    boolean;
    {
        var v0x = this._vertices[0];
        var v0y = this._vertices[1];
        var v0z = this._vertices[2];
        var d1x = this._vertices[3] - v0x;
        var d1y = this._vertices[4] - v0y;
        var d1z = this._vertices[5] - v0z;
        var d2x = this._vertices[6] - v0x;
        var d2y = this._vertices[7] - v0y;
        var d2z = this._vertices[8] - v0z;
        var a = d1y * d2z - d1z * d2y;
        var b = d1z * d2x - d1x * d2z;
        var c = d1x * d2y - d1y * d2x;
        var len = 1 / Math.sqrt(a * a + b * b + c * c);
        a *= len;
        b *= len;
        c *= len;
        var dist = a * (point.x - v0x) + b * (point.y - v0y) + c * (point.z - v0z);
        trace(dist);
        return dist > -epsilon && dist < epsilon;
    }
    getUVAtPoint(point, Vector3D, target, feng3d.UV = null);
    feng3d.UV;
    {
        this.getBarycentricCoords(point, _calcPoint || , new Point());
        var s = _calcPoint.x;
        var t = _calcPoint.y;
        if (s >= 0.0 && t >= 0.0 && (s + t) <= 1.0) {
            var u0 = this._uvs[0];
            var v0 = this._uvs[1];
            target || ;
            new feng3d.UV();
            target.u = u0 + t * (this._uvs[4] - u0) + s * (this._uvs[2] - u0);
            target.v = v0 + t * (this._uvs[5] - v0) + s * (this._uvs[3] - v0);
            return target;
        }
        else
            return null;
    }
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 单个粒子数据
     * @author feng 2014-12-9
     */
    var ParticleData = (function () {
        function ParticleData() {
        }
        return ParticleData;
    }());
    feng3d.ParticleData = ParticleData;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * Texture coordinates value object.
     */
    var UV = (function () {
        /**
         * Creates a new <code>UV</code> object.
         *
         * @param    u        [optional]    The horizontal coordinate of the texture value. Defaults to 0.
         * @param    v        [optional]    The vertical coordinate of the texture value. Defaults to 0.
         */
        function UV(u, v) {
            if (u === void 0) { u = 0; }
            if (v === void 0) { v = 0; }
            this._u = u;
            this._v = v;
        }
        Object.defineProperty(UV.prototype, "v", {
            /**
             * Defines the vertical coordinate of the texture value.
             */
            get: function () {
                return _v;
            },
            set: function (value) {
                _v = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UV.prototype, "u", {
            /**
             * Defines the horizontal coordinate of the texture value.
             */
            get: function () {
                return _u;
            },
            set: function (value) {
                _u = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * returns a new UV value Object
         */
        UV.prototype.clone = function () {
            return new UV(this._u, this._v);
        };
        /**
         * returns the value object as a string for trace/debug purpose
         */
        UV.prototype.toString = function () {
            return this._u + "," + this._v;
        };
        return UV;
    }());
    feng3d.UV = UV;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 顶点
     */
    var Vertex = (function () {
        /**
         *
         * @param x X轴坐标
         * @param y Y轴坐标
         * @param z Z轴坐标
         * @param index 顶点索引
         */
        function Vertex(x, y, z, index) {
            if (x === void 0) { x = 0; }
            if (y === void 0) { y = 0; }
            if (z === void 0) { z = 0; }
            if (index === void 0) { index = 0; }
            this._x = x;
            this._y = y;
            this._z = z;
            this._index = index;
        }
        Object.defineProperty(Vertex.prototype, "index", {
            get: function () {
                return _index;
            },
            /**
             * To define/store the index of value object
             * @param    ind        The index
             */
            set: function (ind) {
                _index = ind;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Vertex.prototype, "x", {
            get: function () {
                return _x;
            },
            set: function (value) {
                _x = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Vertex.prototype, "y", {
            get: function () {
                return _y;
            },
            set: function (value) {
                _y = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Vertex.prototype, "z", {
            get: function () {
                return _z;
            },
            set: function (value) {
                _z = value;
            },
            enumerable: true,
            configurable: true
        });
        Vertex.prototype.clone = function () {
            return new Vertex(this._x, this._y, this._z);
        };
        Vertex.prototype.toString = function () {
            return this._x + "," + this._y + "," + this._z;
        };
        return Vertex;
    }());
    feng3d.Vertex = Vertex;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    mouseEnabled();
    boolean;
    numTriangles();
    number;
    context3dCache();
    feng3d.Context3DCache;
    sourceEntity();
    feng3d.Entity;
    castsShadows();
    boolean;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    dynamic;
    var Context3DBufferID = (function () {
        /**
         * 创建3D环境缓冲编号集合
         */
        function Context3DBufferID() {
        }
        Object.defineProperty(Context3DBufferID, "instance", {
            get: function () {
                return _instance || ;
                new Context3DBufferID();
            },
            enumerable: true,
            configurable: true
        });
        return Context3DBufferID;
    }());
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    material();
    feng3d.MaterialBase;
    animator();
    feng3d.AnimatorBase;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     *
     * @author feng 2014-8-26
     */
    var IndexBufferItem = (function () {
        function IndexBufferItem(context3D, numIndices) {
            /** 是否无效 */
            this.invalid = true;
            this.context3D = context3D;
            this.indexBuffer3D = context3D.createIndexBuffer(numIndices);
            this.invalid = true;
        }
        IndexBufferItem.prototype.uploadFromVector = function (data, startOffset, count) {
            this.indexBuffer3D.uploadFromVector(data, startOffset, count);
            this.invalid = false;
        };
        IndexBufferItem.prototype.drawTriangles = function (firstIndex, numTriangles) {
            if (firstIndex === void 0) { firstIndex = 0; }
            if (numTriangles === void 0) { numTriangles = -1; }
            context3D.drawTriangles(indexBuffer3D, firstIndex, numTriangles);
        };
        return IndexBufferItem;
    }());
    feng3d.IndexBufferItem = IndexBufferItem;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 顶点VA数据缓冲
     * @author feng 2014-8-28
     */
    var VADataBuffer = (function () {
        /**
         * 创建顶点VA数据缓冲
         */
        function VADataBuffer() {
            /** 缓存字典 可在多个寄存器共享数据缓存时使用同一个 */
            this.bufferItemDic = {};
            /** 是否无效 */
            this.invalid = true;
            /** 缓存是否无效 */
            this.bufferInvalid = true;
        }
        /**
         * 获取顶点缓冲项
         * @param context3D		3d环境
         * @return 				顶点缓冲项
         */
        VADataBuffer.prototype.getBufferItem = function (context3D) {
            var vertexBufferItem;
            //处理 缓存无效标记
            if (this.bufferInvalid) {
                for (each(vertexBufferItem in this.bufferItemDic); {
                    vertexBufferItem: vertexBufferItem
                }; this.bufferItemDic = {})
                    ;
                this.bufferInvalid = false;
                this.invalid = false;
            }
            //处理 数据无效标记
            if (this.invalid) {
                for (each(vertexBufferItem in this.bufferItemDic); {
                    vertexBufferItem: .invalid = true
                }; this.invalid = false)
                    ;
            }
            vertexBufferItem = this.bufferItemDic[context3D];
            if (vertexBufferItem == null) {
                vertexBufferItem = this.bufferItemDic[context3D] = new feng3d.VertexBufferItem(context3D, this.numVertices, this.data32PerVertex);
            }
            if (vertexBufferItem.invalid) {
                vertexBufferItem.uploadFromVector(this.data, 0, this.numVertices);
            }
            return vertexBufferItem;
        };
        /**
         * 更新数据
         * @param data 				顶点数据
         * @param numVertices 		要在缓存区中存储的顶点数量。单个缓存区中的最大顶点数为 65535。
         * @param data32PerVertex 	与每个顶点关联的 32 位（4 字节）数据值的数量。每个顶点的 32 位数据元素数量最多为 64 个（或 256 个字节）。请注意，顶点着色器程序在任何给定时间只能访问 8 个属性寄存器。使用 SetVertextBufferAt() 在顶点缓存区内选择属性。
         */
        VADataBuffer.prototype.update = function (data, numVertices, data32PerVertex) {
            if (!data || numVertices == 0)
                throw new Error("顶点缓存不接收空数组");
            this.invalid = true;
            if (!this.data || this.data.length != data.length) {
                this.bufferInvalid = true;
            }
            this.data = data;
            this.numVertices = numVertices;
            this.data32PerVertex = data32PerVertex;
        };
        return VADataBuffer;
    }());
    feng3d.VADataBuffer = VADataBuffer;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 顶点缓冲项
     * @author feng 2014-8-26
     */
    var VertexBufferItem = (function () {
        /**
         * 创建顶点缓冲项
         * @param context3D
         * @param numVertices			要在缓冲区中存储的顶点数量。单个缓冲区中的最大顶点数为 65535。
         * @param data32PerVertex		与每个顶点关联的 32 位（4 字节）数据值的数量。每个顶点的 32 位数据元素数量最多为 64 个（或 256 个字节）。请注意，顶点着色器程序在任何给定时间只能访问 8 个属性寄存器。使用 SetVertextBufferAt() 在顶点缓冲区内选择属性。
         */
        function VertexBufferItem(context3D, numVertices, data32PerVertex) {
            /** 是否无效 */
            this.invalid = true;
            this.context3D = context3D;
            this.vertexBuffer3D = context3D.createVertexBuffer(numVertices, data32PerVertex);
            this.invalid = true;
        }
        /**
         * 从矢量数组上载一组顶点的数据到渲染上下文。
         * @param data					位值的矢量。单个顶点由许多按顺序存储在矢量中的值组成。顶点中的值数量在创建缓冲区时使用 Context3D createVertexBuffer3D() 方法的 data32PerVertex 参数指定。矢量的长度必须为每个顶点的值数量乘以顶点数量。
         * @param startVertex			要加载的第一个顶点的索引。startVertex 的非零值可用于加载顶点数据的子区域。
         * @param numVertices			data 表示的顶点数量。
         */
        VertexBufferItem.prototype.uploadFromVector = function (data, startVertex, numVertices) {
            this.vertexBuffer3D.uploadFromVector(data, startVertex, numVertices);
            this.invalid = false;
        };
        /**
         * 指定与单个着色器程序输入相对应的顶点数据组件。
         * <p>使用 setVertexBufferAt 方法来标识 VertexBuffer3D 缓冲区中每个顶点定义的哪些数据组件属于顶点程序的哪些输入。顶点程序的开发人员会确定每个顶点需要的数据量。该数据从 1 个或多个 VertexBuffer3D 流映射到顶点着色器程序的属性寄存器中。</p>
         * <p>顶点着色器所使用数据的最小单位为 32 位数据。距顶点流的偏移量以 32 位的倍数指定。</p>
         * 举例来说，编程人员可以使用以下数据定义每个顶点：
         * <pre>
         * position:	x    float32
         * 		y    float32
         * 		z    float32
         * color:	r    unsigned byte
         *		g    unsigned byte
         *		b    unsigned byte
         *		a    unsigned byte
         * </pre>
         * 假定在 VertexBuffer3D 对象中定义了名为 buffer 的对象，则可使用以下代码将其分配给顶点着色器：
         * <pre>
         * setVertexBufferAt( 0, buffer, 0, Context3DVertexBufferFormat.FLOAT_3 );   // attribute #0 will contain the position information
         * setVertexBufferAt( 1, buffer, 3, Context3DVertexBufferFormat.BYTES_4 );    // attribute #1 will contain the color information
         * </pre>
         *
         * @param index				顶点着色器中的属性寄存器的索引（0 到 7）。
         * @param bufferOffset		单个顶点的起始数据偏移量，从此处开始读取此属性。在上例中，位置数据的偏移量为 0，因为它是第一个属性；颜色的偏移量为 3，因为颜色属性跟在 3 个 32 位位置值之后。以 32 位为单位指定偏移量。
         * @param format			来自<code>Context3DVertexBufferFormat</code>类的值，指定此属性的数据类型。
         */
        VertexBufferItem.prototype.setVertexBufferAt = function (index, bufferOffset, format) {
            this.context3D.setVertexBufferAt(index, this.vertexBuffer3D, bufferOffset, format);
        };
        return VertexBufferItem;
    }());
    feng3d.VertexBufferItem = VertexBufferItem;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * Context3D可执行的数据缓存
     * @author feng 2014-6-9
     */
    var Context3DBuffer = (function () {
        /**
         * 创建一个Context3D可执行的数据缓存
         * @param dataTypeId 		数据缓存编号
         * @param updateFunc 		更新回调函数
         */
        function Context3DBuffer(dataTypeId, updateFunc) {
            /** 数据脏了 */
            this._dataDirty = true;
            this._dataTypeId = dataTypeId;
            this._updateFunc = updateFunc;
            feng3d.AbstractClassError.check(this);
        }
        /**
         * 使缓存无效
         */
        Context3DBuffer.prototype.invalid = function () {
            this._dataDirty = true;
        };
        /**
         * 运行更新回调函数
         */
        Context3DBuffer.prototype.doUpdateFunc = function () {
            if (this._updateFunc != null && this._dataDirty) {
                this._updateFunc(this);
                this._dataDirty = false;
            }
        };
        Object.defineProperty(Context3DBuffer.prototype, "dataTypeId", {
            /**
             * 缓存类型编号
             */
            get: function () {
                return _dataTypeId;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 执行Context3DBuffer
         * <p><b>注：</b>该函数为虚函数</p>
         *
         * @param context3D		3d环境
         *
         * @see me.feng3d.core.buffer.Context3DCache
         */
        Context3DBuffer.prototype.doBuffer = function (context3D) {
            throw new feng3d.AbstractMethodError();
        };
        /**
         * 字符串描述
         */
        Context3DBuffer.prototype.toString = function () {
            return formatString("[{0} dataType=\"{1}\"]", getQualifiedClassName(this).split("::").pop(), this._dataTypeId);
        };
        return Context3DBuffer;
    }());
    feng3d.Context3DBuffer = Context3DBuffer;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 混合因素缓存
     * @author feng 2014-8-28
     */
    var BlendFactorsBuffer = (function (_super) {
        __extends(BlendFactorsBuffer, _super);
        /**
         * 创建混合因素缓存
         * @param dataTypeId	数据缓存编号
         * @param updateFunc	更新回调函数
         */
        function BlendFactorsBuffer(dataTypeId, updateFunc) {
            _super.call(this, dataTypeId, updateFunc);
        }
        /**
         * 更新混合因素缓存
         * @param sourceFactor 用于与源颜色相乘的系数。默认为 Context3DBlendFactor.ONE。
         * @param destinationFactor 用于与目标颜色相乘的系数。默认为 Context3DBlendFactor.ZERO。
         * @see flash.display3D.Context3D
         * @see flash.display3D.Context3D.setBlendFactors
         */
        BlendFactorsBuffer.prototype.update = function (sourceFactor, destinationFactor) {
            this.sourceFactor = sourceFactor;
            this.destinationFactor = destinationFactor;
        };
        /**
         * 执行混合因素缓存
         * @param context3D		3d环境
         */
        BlendFactorsBuffer.prototype.doBuffer = function (context3D) {
            doUpdateFunc();
            context3D.setBlendFactors(this.sourceFactor, this.destinationFactor);
        };
        return BlendFactorsBuffer;
    }(feng3d.Context3DBuffer));
    feng3d.BlendFactorsBuffer = BlendFactorsBuffer;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 三角形剔除模式缓存
     * @author feng 2014-8-14
     */
    var CullingBuffer = (function (_super) {
        __extends(CullingBuffer, _super);
        /**
         * 创建一个三角形剔除模式缓存
         * @param dataTypeId 		数据缓存编号
         * @param updateFunc 		更新回调函数
         */
        function CullingBuffer(dataTypeId, updateFunc) {
            _super.call(this, dataTypeId, updateFunc);
        }
        /**
         * @inheritDoc
         */
        CullingBuffer.prototype.doBuffer = function (context3D) {
            doUpdateFunc();
            context3D.setCulling(this.triangleFaceToCull);
        };
        /**
         * 更新
         * @param triangleFaceToCull
         */
        CullingBuffer.prototype.update = function (triangleFaceToCull) {
            this.triangleFaceToCull = triangleFaceToCull;
        };
        return CullingBuffer;
    }(feng3d.Context3DBuffer));
    feng3d.CullingBuffer = CullingBuffer;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 深度测试缓存
     * @author feng 2014-8-28
     */
    var DepthTestBuffer = (function (_super) {
        __extends(DepthTestBuffer, _super);
        /**
         * 创建一个深度测试缓存
         * @param dataTypeId 		数据缓存编号
         * @param updateFunc 		更新回调函数
         */
        function DepthTestBuffer(dataTypeId, updateFunc) {
            _super.call(this, dataTypeId, updateFunc);
        }
        /**
         * @inheritDoc
         */
        DepthTestBuffer.prototype.doBuffer = function (context3D) {
            doUpdateFunc();
            context3D.setDepthTest(this.depthMask, this.passCompareMode);
        };
        /**
         * 更新
         * @param depthMask
         * @param passCompareMode
         */
        DepthTestBuffer.prototype.update = function (depthMask, passCompareMode) {
            this.depthMask = depthMask;
            this.passCompareMode = passCompareMode;
        };
        return DepthTestBuffer;
    }(feng3d.Context3DBuffer));
    feng3d.DepthTestBuffer = DepthTestBuffer;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 索引缓存
     * @author feng 2014-8-21
     */
    var IndexBuffer = (function (_super) {
        __extends(IndexBuffer, _super);
        /**
         * 创建一个索引缓存
         * @param dataTypeId 		数据缓存编号
         * @param updateFunc 		更新回调函数
         */
        function IndexBuffer(dataTypeId, updateFunc) {
            _super.call(this, dataTypeId, updateFunc);
            this._bufferItemDic = {};
            this.firstIndex = 0;
            this.numTriangles = -1;
            /** 是否无效 */
            this.dicInvalid = true;
            /** 缓存无效 */
            this.bufferInvalid = true;
        }
        /**
         * @inheritDoc
         */
        IndexBuffer.prototype.doBuffer = function (context3D) {
            doUpdateFunc();
            var indexBufferItem;
            //处理 缓存无效标记
            if (this.bufferInvalid) {
                for (each(indexBufferItem in this._bufferItemDic); {
                    indexBufferItem: indexBufferItem
                }; this._bufferItemDic = {})
                    ;
                this.bufferInvalid = false;
                this.dicInvalid = false;
            }
            //处理 数据无效标记
            if (this.dicInvalid) {
                for (each(indexBufferItem in this._bufferItemDic); {
                    indexBufferItem: .invalid = true
                }; this.dicInvalid = false)
                    ;
            }
            indexBufferItem = this._bufferItemDic[context3D];
            if (indexBufferItem == null) {
                indexBufferItem = this._bufferItemDic[context3D] = new feng3d.IndexBufferItem(context3D, this.numIndices);
            }
            if (indexBufferItem.invalid) {
                indexBufferItem.uploadFromVector(this.data, this._startOffset, this.count);
            }
            indexBufferItem.drawTriangles(this.firstIndex, this.numTriangles);
        };
        /**
         * 销毁数据
         */
        IndexBuffer.prototype.dispose = function () {
            this.data = null;
            this._bufferItemDic = null;
        };
        /**
         * 更新数据
         * @param data 顶点索引的矢量。仅使用每个索引值的低 16 位。矢量的长度必须大于或等于 count。
         * @param numIndices 要在缓存区中存储的顶点数量。单个缓存区中的最大索引数为 524287。
         * @param count data 中索引的数量。
         */
        IndexBuffer.prototype.update = function (data, numIndices, count, firstIndex, numTriangles) {
            if (firstIndex === void 0) { firstIndex = 0; }
            if (numTriangles === void 0) { numTriangles = -1; }
            if (!data)
                throw new Error("顶点索引不接收空数组");
            this.dicInvalid = true;
            if (!this.data || this.data.length != data.length) {
                this.bufferInvalid = true;
            }
            this.data = data;
            this.numIndices = numIndices;
            this.count = count;
            this.firstIndex = firstIndex;
            this.numTriangles = numTriangles;
        };
        return IndexBuffer;
    }(feng3d.Context3DBuffer));
    feng3d.IndexBuffer = IndexBuffer;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 渲染程序缓存
     * @author feng 2014-8-14
     */
    var ProgramBuffer = (function (_super) {
        __extends(ProgramBuffer, _super);
        /**
         * 创建一个渲染程序缓存
         * @param dataTypeId 		数据缓存编号
         * @param updateFunc 		更新回调函数
         */
        function ProgramBuffer(dataTypeId, updateFunc) {
            _super.call(this, dataTypeId, updateFunc);
            this.bufferItemDic = {};
            /** 是否无效 */
            this.bufferInvalid = true;
        }
        /**
         * @inheritDoc
         */
        ProgramBuffer.prototype.doUpdateFunc = function () {
            if (_updateFunc != null && _dataDirty) {
                feng3d.ShaderRegisterCache.invalid();
                _updateFunc(this);
                _dataDirty = false;
                this.dataRegisterDic = feng3d.ShaderRegisterCache.instance.dataRegisterDic;
            }
        };
        ProgramBuffer.prototype.doBuffer = function (context3D) {
            this.doUpdateFunc();
            var program3D;
            if (this.bufferInvalid) {
                for (var key =  *  in this.bufferItemDic) {
                    var contextTemp = key;
                    feng3d.AGALProgram3DCache.getInstance(contextTemp).freeProgram3D(this.bufferItemDic[contextTemp]);
                }
                this.bufferItemDic = {};
                this.bufferInvalid = false;
            }
            var oldProgram3D = this.bufferItemDic[context3D];
            program3D = this.bufferItemDic[context3D] = feng3d.AGALProgram3DCache.getInstance(context3D).getProgram3D(oldProgram3D, this.vertexCode, this.fragmentCode);
            context3D.setProgram(program3D);
        };
        ProgramBuffer.prototype.update = function (vertexCode, fragmentCode) {
            this.bufferInvalid = true;
            this.vertexCode = vertexCode;
            this.fragmentCode = fragmentCode;
        };
        return ProgramBuffer;
    }(feng3d.Context3DBuffer));
    feng3d.ProgramBuffer = ProgramBuffer;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * Context3D关联寄存器的数据缓存
     * @author feng 2014-8-14
     */
    var RegisterBuffer = (function (_super) {
        __extends(RegisterBuffer, _super);
        /**
         * 创建寄存器数据缓存
         * @param dataTypeId 		数据编号
         * @param updateFunc 		数据更新回调函数
         */
        function RegisterBuffer(dataTypeId, updateFunc) {
            _super.call(this, dataTypeId, updateFunc);
            /** 需要寄存器的个数 */
            this.numRegisters = 1;
        }
        return RegisterBuffer;
    }(feng3d.Context3DBuffer));
    feng3d.RegisterBuffer = RegisterBuffer;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 3d环境常量数据缓存
     * @author feng 2014-8-20
     */
    var ConstantsBuffer = (function (_super) {
        __extends(ConstantsBuffer, _super);
        /**
         * 创建3d环境常量数据缓存
         * @param dataTypeId 		数据编号
         * @param updateFunc 		数据更新回调函数
         */
        function ConstantsBuffer(dataTypeId, updateFunc) {
            _super.call(this, dataTypeId, updateFunc);
        }
        return ConstantsBuffer;
    }(feng3d.RegisterBuffer));
    feng3d.ConstantsBuffer = ConstantsBuffer;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * Context3D 片段字节数组常量数据缓存
     * @author feng 2014-8-20
     */
    var FCByteArrayBuffer = (function (_super) {
        __extends(FCByteArrayBuffer, _super);
        /**
         * 创建一个片段字节数组常量数据缓存
         * @param dataTypeId		数据编号
         * @param updateFunc		数据更新回调函数
         */
        function FCByteArrayBuffer(dataTypeId, updateFunc) {
            _super.call(this, dataTypeId, updateFunc);
        }
        /**
         * @inheritDoc
         */
        FCByteArrayBuffer.prototype.doBuffer = function (context3D) {
            doUpdateFunc();
            context3D.setProgramConstantsFromByteArray(Context3DProgramType.FRAGMENT, this.firstRegister, 1, this.data, this.data.position);
        };
        return FCByteArrayBuffer;
    }(feng3d.ConstantsBuffer));
    feng3d.FCByteArrayBuffer = FCByteArrayBuffer;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * Context3D 片段矩阵常量数据缓存
     * @author feng 2014-8-20
     */
    var FCMatrixBuffer = (function (_super) {
        __extends(FCMatrixBuffer, _super);
        /**
         * 创建片段矩阵常量数据缓存
         * @param dataTypeId 		数据编号
         * @param updateFunc 		数据更新回调函数
         */
        function FCMatrixBuffer(dataTypeId, updateFunc) {
            _super.call(this, dataTypeId, updateFunc);
        }
        /**
         * @inheritDoc
         */
        FCMatrixBuffer.prototype.doBuffer = function (context3D) {
            doUpdateFunc();
            context3D.setProgramConstantsFromMatrix(Context3DProgramType.FRAGMENT, this.firstRegister, this.matrix, false);
        };
        /**
         * 更新
         * @param matrix
         * @param transposedMatrix
         */
        FCMatrixBuffer.prototype.update = function (matrix, transposedMatrix) {
            if (transposedMatrix === void 0) { transposedMatrix = false; }
            this.matrix = matrix;
            this.transposedMatrix = transposedMatrix;
        };
        return FCMatrixBuffer;
    }(feng3d.ConstantsBuffer));
    feng3d.FCMatrixBuffer = FCMatrixBuffer;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * Context3D 片段向量常量数据缓存
     * @author feng 2014-8-20
     */
    var FCVectorBuffer = (function (_super) {
        __extends(FCVectorBuffer, _super);
        /**
         * 创建片段向量常量数据缓存
         * @param dataTypeId 		数据编号
         * @param updateFunc 		数据更新回调函数
         */
        function FCVectorBuffer(dataTypeId, updateFunc) {
            _super.call(this, dataTypeId, updateFunc);
        }
        /**
         * @inheritDoc
         */
        FCVectorBuffer.prototype.doBuffer = function (context3D) {
            doUpdateFunc();
            context3D.setProgramConstantsFromVector(Context3DProgramType.FRAGMENT, this.firstRegister, this.data, this.numRegisters);
        };
        /**
         * 更新数据
         * @param data
         * @param numRegisters
         *
         */
        FCVectorBuffer.prototype.update = function (data, numRegisters) {
            if (numRegisters === void 0) { numRegisters = -1; }
            feng3d.assert(data.length % 4 == 0, "常量数据个数必须为4的倍数！");
            this.data = data;
            this.numRegisters = numRegisters;
        };
        return FCVectorBuffer;
    }(feng3d.ConstantsBuffer));
    feng3d.FCVectorBuffer = FCVectorBuffer;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * Context3D 顶点字节数组常量数据缓存
     * @author feng 2014-8-20
     */
    var VCByteArrayBuffer = (function (_super) {
        __extends(VCByteArrayBuffer, _super);
        /**
         * 创建一个顶点字节数组常量数据缓存
         * @param dataTypeId		数据编号
         * @param updateFunc		数据更新回调函数
         */
        function VCByteArrayBuffer(dataTypeId, updateFunc) {
            _super.call(this, dataTypeId, updateFunc);
        }
        /**
         * @inheritDoc
         */
        VCByteArrayBuffer.prototype.doBuffer = function (context3D) {
            doUpdateFunc();
            context3D.setProgramConstantsFromByteArray(Context3DProgramType.VERTEX, this.firstRegister, 1, this.data, this.data.position);
        };
        return VCByteArrayBuffer;
    }(feng3d.ConstantsBuffer));
    feng3d.VCByteArrayBuffer = VCByteArrayBuffer;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * Context3D 顶点矩阵常量数据缓存
     * @author feng 2014-8-20
     */
    var VCMatrixBuffer = (function (_super) {
        __extends(VCMatrixBuffer, _super);
        /**
         * 创建顶点矩阵常量数据缓存
         * @param dataTypeId 		数据编号
         * @param updateFunc 		数据更新回调函数
         */
        function VCMatrixBuffer(dataTypeId, updateFunc) {
            _super.call(this, dataTypeId, updateFunc);
        }
        /**
         * @inheritDoc
         */
        VCMatrixBuffer.prototype.doBuffer = function (context3D) {
            doUpdateFunc();
            context3D.setProgramConstantsFromMatrix(Context3DProgramType.VERTEX, this.firstRegister, this.matrix, this.transposedMatrix);
        };
        /**
         * 更新数据
         * @param matrix					静态矩阵数据
         * @param transposedMatrix			如果为 true，则将按颠倒顺序将矩阵条目复制到寄存器中。默认值为 false。
         */
        VCMatrixBuffer.prototype.update = function (matrix, transposedMatrix) {
            if (transposedMatrix === void 0) { transposedMatrix = false; }
            this.matrix = matrix;
            this.transposedMatrix = transposedMatrix;
        };
        return VCMatrixBuffer;
    }(feng3d.ConstantsBuffer));
    feng3d.VCMatrixBuffer = VCMatrixBuffer;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * Context3D 顶点向量常量数据缓存
     * @author feng 2014-8-20
     */
    var VCVectorBuffer = (function (_super) {
        __extends(VCVectorBuffer, _super);
        /**
         * 创建一个顶点向量常量数据缓存
         * @param dataTypeId		数据编号
         * @param updateFunc		数据更新回调函数
         */
        function VCVectorBuffer(dataTypeId, updateFunc) {
            _super.call(this, dataTypeId, updateFunc);
        }
        /**
         * @inheritDoc
         */
        VCVectorBuffer.prototype.doBuffer = function (context3D) {
            doUpdateFunc();
            context3D.setProgramConstantsFromVector(Context3DProgramType.VERTEX, this.firstRegister, this.data, this.numRegisters);
        };
        /**
         * 更新顶点常量数据
         * @param data				静态向量数据
         * @param numRegisters		需要寄存器的个数
         */
        VCVectorBuffer.prototype.update = function (data, numRegisters) {
            if (numRegisters === void 0) { numRegisters = -1; }
            feng3d.assert(data.length % 4 == 0, "常量数据个数必须为4的倍数！");
            this.data = data;
            this.numRegisters = numRegisters;
        };
        return VCVectorBuffer;
    }(feng3d.ConstantsBuffer));
    feng3d.VCVectorBuffer = VCVectorBuffer;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 纹理数组缓存（解决类似地形多纹理混合）
     * @author feng 2014-11-6
     */
    var FSArrayBuffer = (function (_super) {
        __extends(FSArrayBuffer, _super);
        /**
         * 创建纹理数组缓存
         * @param dataTypeId 数据编号
         * @param updateFunc 数据更新回调函数
         * @param textureFlags	取样参数回调函数
         */
        function FSArrayBuffer(dataTypeId, updateFunc) {
            _super.call(this, dataTypeId, updateFunc);
        }
        /**
         * @inheritDoc
         */
        FSArrayBuffer.prototype.doBuffer = function (context3D) {
            doUpdateFunc();
            for (var i = 0; i < this.textures.length; i++) {
                //从纹理缓存中获取纹理
                var textureBase = feng3d.TextureCenter.getTexture(context3D, this.textures[i]);
                context3D.setTextureAt(this.firstRegister + i, textureBase);
            }
        };
        /**
         * 更新纹理
         * @param textures		纹理数组
         */
        FSArrayBuffer.prototype.update = function (textures) {
            this.textures = textures;
        };
        return FSArrayBuffer;
    }(feng3d.RegisterBuffer));
    feng3d.FSArrayBuffer = FSArrayBuffer;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 纹理缓存
     * @author feng 2014-8-14
     */
    var FSBuffer = (function (_super) {
        __extends(FSBuffer, _super);
        /**
         * 创建纹理数据缓存
         * @param dataTypeId 	数据编号
         * @param updateFunc 	数据更新回调函数
         * @param textureFlags	取样参数回调函数
         */
        function FSBuffer(dataTypeId, updateFunc) {
            _super.call(this, dataTypeId, updateFunc);
        }
        /**
         * @inheritDoc
         */
        FSBuffer.prototype.doBuffer = function (context3D) {
            doUpdateFunc();
            //从纹理缓存中获取纹理
            var textureBase = feng3d.TextureCenter.getTexture(context3D, this.texture);
            context3D.setTextureAt(this.firstRegister, textureBase);
        };
        /**
         * 更新纹理数据
         * @param texture
         */
        FSBuffer.prototype.update = function (texture) {
            this.texture = texture;
        };
        return FSBuffer;
    }(feng3d.RegisterBuffer));
    feng3d.FSBuffer = FSBuffer;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 输出纹理缓冲
     * @author feng 2015-6-3
     */
    var OCBuffer = (function (_super) {
        __extends(OCBuffer, _super);
        /**
         * 创建一个输出纹理缓冲
         * @param dataTypeId 		数据缓存编号
         * @param updateFunc 		更新回调函数
         */
        function OCBuffer(dataTypeId, updateFunc) {
            _super.call(this, dataTypeId, updateFunc);
            this.enableDepthAndStencil = true;
            this.surfaceSelector = 0;
            this._antiAlias = 0;
        }
        /**
         * @inheritDoc
         */
        OCBuffer.prototype.doBuffer = function (context3D) {
            doUpdateFunc();
            //从纹理缓存中获取纹理
            var textureBase = feng3d.TextureCenter.getTexture(context3D, this.texture);
            context3D.setRenderToTexture(textureBase, true, 0, 0, this.firstRegister);
        };
        /**
         * 更新纹理数据
         * @param texture
         */
        OCBuffer.prototype.update = function (texture) {
            this.texture = texture;
        };
        return OCBuffer;
    }(feng3d.RegisterBuffer));
    feng3d.OCBuffer = OCBuffer;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 顶点数据缓冲
     * @author feng 2014-8-14
     */
    var VABuffer = (function (_super) {
        __extends(VABuffer, _super);
        /**
         * 创建顶点数据缓存
         * @param dataTypeId 数据编号
         * @param updateFunc 数据更新回调函数
         */
        function VABuffer(dataTypeId, updateFunc) {
            _super.call(this, dataTypeId, updateFunc);
            /** 顶点数据缓存(真正的数据缓存) */
            this.dataBuffer = new feng3d.VADataBuffer();
        }
        Object.defineProperty(VABuffer.prototype, "format", {
            /**
             * 来自 Context3DVertexBufferFormat 类的值，指定此属性的数据类型。
             */
            get: function () {
                return _format;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        VABuffer.prototype.doBuffer = function (context3D) {
            doUpdateFunc();
            var vertexBufferItem = this.dataBuffer.getBufferItem(context3D);
            vertexBufferItem.setVertexBufferAt(this.firstRegister, 0, this.format);
        };
        /**
         * 更新数据
         * @param data 				顶点数据
         * @param numVertices 		要在缓存区中存储的顶点数量。单个缓存区中的最大顶点数为 65535。
         * @param data32PerVertex 	与每个顶点关联的 32 位（4 字节）数据值的数量。每个顶点的 32 位数据元素数量最多为 64 个（或 256 个字节）。请注意，顶点着色器程序在任何给定时间只能访问 8 个属性寄存器。使用 SetVertextBufferAt() 在顶点缓存区内选择属性。
         */
        VABuffer.prototype.update = function (data, numVertices, data32PerVertex) {
            feng3d.assert(1 <= data32PerVertex && data32PerVertex <= 4);
            this._format = bufferFormats[data32PerVertex];
            this.dataBuffer.update(data, numVertices, data32PerVertex);
        };
        /**
         * 顶点数据缓冲格式数组
         */
        VABuffer.bufferFormats = string[]([null, Context3DVertexBufferFormat.FLOAT_1, Context3DVertexBufferFormat.FLOAT_2, Context3DVertexBufferFormat.FLOAT_3, Context3DVertexBufferFormat.FLOAT_4]);
        return VABuffer;
    }(feng3d.RegisterBuffer));
    feng3d.VABuffer = VABuffer;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 3D环境缓冲编号集合实例
     * @author feng 2015-7-21
     */
    constructor();
    Context3DBufferID;
    {
        return Context3DBufferID.instance;
    }
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 3d缓存类型
     * @author feng 2014-8-20
     */
    var Context3DBufferType = (function () {
        function Context3DBufferType() {
        }
        return Context3DBufferType;
    }());
    feng3d.Context3DBufferType = Context3DBufferType;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * AGAL程序缓冲
     * @author feng 2014-8-20
     */
    var AGALProgram3DCache = (function () {
        /**
         * 创建AGAL程序缓冲
         * @param context3D			3D环境
         */
        function AGALProgram3DCache(context3D) {
            if (_instanceDic[context3D])
                throw new Error("已经存在对应的实例，请使用GetInstance方法获取。");
            _instanceDic[context3D] = this;
            this._context3D = context3D;
            this._program3Ds = {};
            this._usages = {};
            this._keys = {};
        }
        /**
         * 获取AGAL程序缓冲实例
         * @param context3D			3D环境
         * @return					AGAL程序缓冲实例
         */
        AGALProgram3DCache.getInstance = function (context3D) {
            return _instanceDic[context3D] || ;
            new AGALProgram3DCache(context3D);
        };
        /**
         * 销毁
         */
        AGALProgram3DCache.prototype.dispose = function () {
            for (var key in this._program3Ds)
                this.destroyProgram(key);
            this._keys = null;
            this._program3Ds = null;
            this._usages = null;
        };
        /**
         * 获取渲染程序
         * @param oldProgram3D			原来的渲染程序
         * @param vertexCode			顶点渲染代码
         * @param fragmentCode			片段渲染代码
         * @return						渲染程序
         */
        AGALProgram3DCache.prototype.getProgram3D = function (oldProgram3D, vertexCode, fragmentCode) {
            var key = this.getKey(vertexCode, fragmentCode);
            var program = this._program3Ds[key];
            if (program == null) {
                program = this._context3D.createProgram();
                var vertexByteCode = this.getVertexByteCode(vertexCode);
                var fragmentByteCode = this.getFragmentByteCode(fragmentCode);
                program.upload(vertexByteCode, fragmentByteCode);
                this._program3Ds[key] = program;
                this._keys[program] = key;
                this._usages[program] = 0;
            }
            if (oldProgram3D != program) {
                if (oldProgram3D)
                    this.freeProgram3D(oldProgram3D);
                this._usages[program]++;
            }
            return program;
        };
        /**
         * 获取片段渲染二进制
         * @param fragmentCode		片段渲染代码
         * @return					片段渲染二进制
         */
        AGALProgram3DCache.prototype.getFragmentByteCode = function (fragmentCode) {
            var noCommentCode = this.filterComment(fragmentCode);
            return shaderByteCodeDic[fragmentCode] || ;
            new feng3d.AGALMiniAssembler(feng3d.Debug.agalDebug).assemble(Context3DProgramType.FRAGMENT, noCommentCode);
        };
        /**
         * 获取顶点渲染二进制
         * @param vertexCode		顶点渲染代码
         * @return 					顶点渲染二进制
         */
        AGALProgram3DCache.prototype.getVertexByteCode = function (vertexCode) {
            var noCommentCode = this.filterComment(vertexCode);
            return shaderByteCodeDic[vertexCode] || ;
            new feng3d.AGALMiniAssembler(feng3d.Debug.agalDebug).assemble(Context3DProgramType.VERTEX, noCommentCode);
        };
        /**
         * 过滤代码中的注释
         * @param code			渲染代码
         * @return				没有注释的渲染代码
         */
        AGALProgram3DCache.prototype.filterComment = function (code) {
            //			return code;
            var codes = code.split(feng3d.FagalToken.BREAK);
            var line;
            var newCode = "";
            for (var i = 0; i < codes.length; i++) {
                line = codes[i];
                if (line.length > 0 && line.substr(0, feng3d.FagalToken.COMMENT.length) != feng3d.FagalToken.COMMENT) {
                    if (newCode.length > 0 && newCode.substr(-feng3d.FagalToken.BREAK.length) != feng3d.FagalToken.BREAK)
                        newCode += feng3d.FagalToken.BREAK;
                    newCode += line;
                }
            }
            return newCode;
        };
        /**
         * 释放渲染程序
         * @param program3D		被释放的渲染程序
         */
        AGALProgram3DCache.prototype.freeProgram3D = function (program3D) {
            this._usages[program3D]--;
            if (this._usages[program3D] == 0)
                this.destroyProgram(this._keys[program3D]);
        };
        /**
         * 销毁渲染程序
         * @param key		渲染代码
         */
        AGALProgram3DCache.prototype.destroyProgram = function (key) {
            this._program3Ds[key].dispose();
            this._program3Ds[key] = null;
            delete this._program3Ds[key];
        };
        /**
         * 获取渲染代码键值
         * @param vertexCode			顶点渲染代码
         * @param fragmentCode			片段渲染代码
         * @return						渲染代码键值
         */
        AGALProgram3DCache.prototype.getKey = function (vertexCode, fragmentCode) {
            return vertexCode + "---" + fragmentCode;
        };
        /**
         * 实例字典
         */
        AGALProgram3DCache._instanceDic = {};
        /**
         * 字符串与二进制字典
         */
        AGALProgram3DCache.shaderByteCodeDic = {};
        return AGALProgram3DCache;
    }());
    feng3d.AGALProgram3DCache = AGALProgram3DCache;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 3D环境缓冲收集器
     * @author feng 2015-7-18
     */
    var Context3DBufferCollector = (function () {
        /**
         * 创建3D环境缓冲收集器
         * @bufferOwner		缓冲拥有者
         */
        function Context3DBufferCollector() {
            /** 所有数据缓存 */
            this.bufferDic = {};
        }
        Object.defineProperty(Context3DBufferCollector.prototype, "rootBufferOwner", {
            /**
             * 根3D环境缓冲拥有者
             */
            get: function () {
                if (_rootBufferOwner == null) {
                    _rootBufferOwner = new feng3d.Context3DBufferOwner();
                    //添加事件
                    _rootBufferOwner.addEventListener(feng3d.Context3DBufferOwnerEvent.ADD_CONTEXT3DBUFFER, onAddContext3DBuffer);
                    _rootBufferOwner.addEventListener(feng3d.Context3DBufferOwnerEvent.REMOVE_CONTEXT3DBUFFER, onRemoveContext3DBuffer);
                    _rootBufferOwner.addEventListener(feng3d.Context3DBufferOwnerEvent.ADDCHILD_CONTEXT3DBUFFEROWNER, onAddChildContext3DBufferOwner);
                    _rootBufferOwner.addEventListener(feng3d.Context3DBufferOwnerEvent.REMOVECHILD_CONTEXT3DBUFFEROWNER, onRemoveChildContext3DBufferOwner);
                }
                return _rootBufferOwner;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 添加子项缓存拥有者
         * @param childBufferOwner
         */
        Context3DBufferCollector.prototype.addChildBufferOwner = function (childBufferOwner) {
            this.rootBufferOwner.addChildBufferOwner(childBufferOwner);
        };
        /**
         * 移除子项缓存拥有者
         * @param childBufferOwner
         */
        Context3DBufferCollector.prototype.removeChildBufferOwner = function (childBufferOwner) {
            this.rootBufferOwner.removeChildBufferOwner(childBufferOwner);
        };
        /**
         * 添加数据缓存
         * @param context3DDataBuffer 数据缓存
         */
        Context3DBufferCollector.prototype.addDataBuffer = function (context3DDataBuffer) {
            var dataTypeId = context3DDataBuffer.dataTypeId;
            if (this.bufferDic[dataTypeId])
                trace("重复提交数据" + context3DDataBuffer);
            this.bufferDic[dataTypeId] = context3DDataBuffer;
        };
        /**
         * 移除数据缓存
         * @param dataTypeId 数据缓存类型编号
         */
        Context3DBufferCollector.prototype.removeDataBuffer = function (context3DDataBuffer) {
            var dataTypeId = context3DDataBuffer.dataTypeId;
            if (this.bufferDic[dataTypeId] != context3DDataBuffer)
                throw new Error("移除数据缓存错误");
            delete this.bufferDic[dataTypeId];
        };
        /**
         * 处理添加缓冲拥有者事件
         */
        Context3DBufferCollector.prototype.onAddChildContext3DBufferOwner = function (event) {
            this.addContext3DBufferOwer(event.data);
        };
        /**
         * 处理移除缓冲拥有者事件
         */
        Context3DBufferCollector.prototype.onRemoveChildContext3DBufferOwner = function (event) {
            this.removeContext3DBufferOwer(event.data);
        };
        /**
         * 处理添加缓冲事件
         */
        Context3DBufferCollector.prototype.onAddContext3DBuffer = function (event) {
            this.addDataBuffer(event.data);
        };
        /**
         * 处理移除缓冲事件
         */
        Context3DBufferCollector.prototype.onRemoveContext3DBuffer = function (event) {
            this.removeDataBuffer(event.data);
        };
        /**
         * 添加缓冲拥有者
         * @param bufferOwer		缓冲拥有者
         */
        Context3DBufferCollector.prototype.addContext3DBufferOwer = function (bufferOwer) {
            var allBufferList = bufferOwer.getAllBufferList();
            for (var i = 0; i < allBufferList.length; i++) {
                this.addDataBuffer(allBufferList[i]);
            }
        };
        /**
         * 移除缓冲拥有者
         * @param bufferOwer		缓冲拥有者
         */
        Context3DBufferCollector.prototype.removeContext3DBufferOwer = function (bufferOwer) {
            var allBufferList = bufferOwer.getAllBufferList();
            for (var i = 0; i < allBufferList.length; i++) {
                this.removeDataBuffer(allBufferList[i]);
            }
        };
        /**
         * 销毁
         */
        Context3DBufferCollector.prototype.dispose = function () {
            //移除事件
            if (this._rootBufferOwner != null) {
                this._rootBufferOwner.removeEventListener(feng3d.Context3DBufferOwnerEvent.ADD_CONTEXT3DBUFFER, this.onAddContext3DBuffer);
                this._rootBufferOwner.removeEventListener(feng3d.Context3DBufferOwnerEvent.REMOVE_CONTEXT3DBUFFER, this.onRemoveContext3DBuffer);
                this._rootBufferOwner.removeEventListener(feng3d.Context3DBufferOwnerEvent.ADDCHILD_CONTEXT3DBUFFEROWNER, this.onAddChildContext3DBufferOwner);
                this._rootBufferOwner.removeEventListener(feng3d.Context3DBufferOwnerEvent.REMOVECHILD_CONTEXT3DBUFFEROWNER, this.onRemoveChildContext3DBufferOwner);
            }
            this._rootBufferOwner = null;
        };
        return Context3DBufferCollector;
    }());
    feng3d.Context3DBufferCollector = Context3DBufferCollector;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 3D环境缓存类(方便调试与管理渲染操作)
     * @author feng 2014-6-6
     */
    var Context3DCache = (function (_super) {
        __extends(Context3DCache, _super);
        /**
         * 创建3D环境缓存类
         */
        function Context3DCache() {
            _super.call(this);
            /** 寄存器数据缓存 */
            this.regBufferDic = {};
            /** 其他数据缓存 */
            this.otherBufferDic = {};
            /**
             * @inheritDoc
             */
            this.override = function addDataBuffer(context3DDataBuffer) {
                _super.addDataBuffer.call(this, context3DDataBuffer);
                var dataTypeId = context3DDataBuffer.dataTypeId;
                if (context3DDataBuffer)
                    is;
                feng3d.RegisterBuffer;
                this.regBufferDic[dataTypeId] = context3DDataBuffer;
                if (context3DDataBuffer)
                    is;
                feng3d.ProgramBuffer;
                this.programBuffer = context3DDataBuffer;
                if (context3DDataBuffer)
                    is;
                feng3d.IndexBuffer;
                this.indexBuffer = context3DDataBuffer;
            };
        }
        return Context3DCache;
    }(feng3d.Context3DBufferCollector));
    feng3d.Context3DCache = Context3DCache;
    this.otherBufferDic[dataTypeId] = context3DDataBuffer;
})(feng3d || (feng3d = {}));
override;
function removeDataBuffer(context3DDataBuffer) {
    _super.removeDataBuffer.call(this, context3DDataBuffer);
    var dataTypeId = context3DDataBuffer.dataTypeId;
    delete this.regBufferDic[dataTypeId];
    delete this.otherBufferDic[dataTypeId];
    if (context3DDataBuffer)
        is;
    ProgramBuffer;
    {
        this.programBuffer = null;
    }
}
render(context3D, Context3D, renderIndex, number = 0);
{
    //更新渲染程序（标记使用寄存器）
    this.fagalRE.context3DCache = this;
    this.programBuffer.doBuffer(context3D);
    this.fagalRE.context3DCache = null;
    this.dataRegisterDic = this.programBuffer.dataRegisterDic;
    //处理 其他数据缓存
    for (each(); ; )
        var context3DDataBuffer;
     in this.otherBufferDic;
    {
        context3DDataBuffer.doBuffer(context3D);
    }
    //处理 需要执行的寄存器数据缓存
    for (each(); ; )
        var registerBuffer;
     in this.runRegBufferList;
    {
        registerBuffer.doBuffer(context3D);
    }
    if (this.ocBuffer != null) {
        this.ocBuffer.doBuffer(context3D);
        if (renderIndex == 0) {
            context3D.clear(1, 1, 1);
        }
    }
    //执行索引数据缓存
    this.indexBuffer.doBuffer(context3D);
    if (this.ocBuffer != null) {
        context3D.setRenderToBackBuffer();
    }
    //清理缓存
    this.clearContext3D(context3D);
}
get;
dataRegisterDic();
{
    return _dataRegisterDic;
}
set;
dataRegisterDic(value);
{
    if (_dataRegisterDic != value) {
        _dataRegisterDic = value;
        mapRegister();
    }
}
clearContext3D(context3D, Context3D);
{
    for (var i = 0; i < 8; ++i) {
        context3D.setVertexBufferAt(i, null);
        context3D.setTextureAt(i, null);
    }
}
mapRegister();
{
    this.ocBuffer = null;
    this.runRegBufferList = [];
    for (each(); ; )
        var register;
     in this.dataRegisterDic;
    {
        var registerBuffer = this.regBufferDic[register.dataTypeId];
        //输入数据寄存器必须有对应的数据缓存
        if (RegisterType.isInputDataRegister(register.regType)) {
            if (registerBuffer == null) {
                throw new Error("缺少【" + register.dataTypeId + "】寄存器数据缓存");
            }
        }
        if (registerBuffer != null) {
            if (registerBuffer)
                is;
            OCBuffer;
            {
                this.ocBuffer = registerBuffer;
            }
            {
                registerBuffer.firstRegister = register.index;
                this.runRegBufferList.push(registerBuffer);
            }
        }
    }
    this.runRegBufferList.sortOn("dataTypeId");
}
get;
fagalRE();
FagalRE;
{
    return FagalRE.instance;
}
var feng3d;
(function (feng3d) {
    /**
     * 3d环境缓存类型管理者
     * @author feng 2014-9-3
     */
    var Context3DBufferTypeManager = (function () {
        /**
         * 创建3d环境缓存类型管理者
         */
        function Context3DBufferTypeManager() {
            if (_instance)
                throw new Error("单例模式");
            _instance = this;
            this.bufferTypeDic = {};
            this.typeClassDic = {};
        }
        Context3DBufferTypeManager.prototype.instance = function () {
            return _instance || new Context3DBufferTypeManager();
        };
        /**
         * 获取或创建3d缓存类型
         * @param typeId 		3d缓存类型编号
         * @return				3d缓存类型实例
         */
        Context3DBufferTypeManager.getBufferType = function (typeId) {
            return instance.getBufferType(typeId);
        };
        /**
         * 获取3d缓存类定义
         * @param typeId 		3d缓存类型编号
         * @return				3d缓存类定义
         */
        Context3DBufferTypeManager.getBufferClass = function (typeId) {
            return instance.getBufferClass(typeId);
        };
        /**
         * 获取或创建3d缓存类型
         * @param typeId 		3d缓存类型编号
         * @return				3d缓存类型实例
         */
        Context3DBufferTypeManager.prototype.getBufferType = function (typeId) {
            var bufferType = this.bufferTypeDic[typeId];
            if (bufferType)
                return bufferType;
            this.bufferTypeDic[typeId] = bufferType = new feng3d.Context3DBufferType();
            var types = typeId.split("_");
            bufferType.registerType = types[1];
            bufferType.dataType = types[2];
            return bufferType;
        };
        /**
         * 获取3d缓存类定义
         * @param typeId 		3d缓存类型编号
         * @return				3d缓存类定义
         */
        Context3DBufferTypeManager.prototype.getBufferClass = function (typeId) {
            var cls = this.typeClassDic[typeId];
            if (cls == null) {
                for (var i = 0; i < config.length; i++) {
                    var result = typeId.match(config[i][0]);
                    if (result != null && result.input == result[0]) {
                        return config[i][1];
                    }
                }
            }
            throw new Error("无法为" + typeId + "匹配到3d缓存类");
        };
        Context3DBufferTypeManager.NAME_REGEXP = "[a-zA-Z0-9$]";
        Context3DBufferTypeManager.config = [
            ["blendFactors", feng3d.BlendFactorsBuffer],
            ["culling", feng3d.CullingBuffer],
            ["depthTest", feng3d.DepthTestBuffer],
            ["(" + NAME_REGEXP + "+)?_fc_bytes", feng3d.FCByteArrayBuffer],
            ["(" + NAME_REGEXP + "+)?_fc_matrix", feng3d.FCMatrixBuffer],
            ["(" + NAME_REGEXP + "+)?_fc_vector", feng3d.FCVectorBuffer],
            ["(" + NAME_REGEXP + "+)?_fs_array", feng3d.FSArrayBuffer],
            ["(" + NAME_REGEXP + "+)?_fs", feng3d.FSBuffer],
            ["index", feng3d.IndexBuffer],
            ["(" + NAME_REGEXP + "+)?_oc", feng3d.OCBuffer],
            ["program", feng3d.ProgramBuffer],
            ["(" + NAME_REGEXP + "+)?_va_([1-4x])", feng3d.VABuffer],
            ["(" + NAME_REGEXP + "+)?_vc_bytes", feng3d.VCByteArrayBuffer],
            ["(" + NAME_REGEXP + "+)?_vc_matrix", feng3d.VCMatrixBuffer],
            ["(" + NAME_REGEXP + "+)?_vc_vector", feng3d.VCVectorBuffer],
        ];
        /**
         * 3d环境缓存类型管理者实例
         */
        Context3DBufferTypeManager.function = get;
        return Context3DBufferTypeManager;
    }());
    feng3d.Context3DBufferTypeManager = Context3DBufferTypeManager;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 寄存器数据类型
     * @author feng 2014-8-20
     */
    var RgisterDataType = (function () {
        function RgisterDataType() {
        }
        /** 字节数组(ByteArray) */
        RgisterDataType.BYTEARRAY = "byteArray";
        /** 向量(Vector) */
        RgisterDataType.VECTOR = "vector";
        /** 矩阵（Matrix3D ） */
        RgisterDataType.MATRIX = "matrix";
        /**
         * 寄存器数组
         */
        RgisterDataType.ARRAY = "array";
        return RgisterDataType;
    }());
    feng3d.RgisterDataType = RgisterDataType;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 纹理缓存中心
     * @author feng 2014-8-14
     */
    var TextureCenter = (function () {
        /**
         * 创建一个纹理缓存中心
         */
        function TextureCenter() {
        }
        /**
         * 获取纹理
         * @param context3D		3D环境
         * @param texture		纹理代理
         * @return				纹理
         */
        TextureCenter.getTexture = function (context3D, texture) {
            //冲缓存中取纹理
            var textureBase = $getTexture(context3D, texture);
            if (textureBase)
                return textureBase;
            //创建位图纹理
            var bitmapTexture = texture;
            if (bitmapTexture)
                return createTexture(context3D, bitmapTexture);
            //创建立方体纹理
            var bitmapCubeTexture = texture;
            if (bitmapCubeTexture)
                return createCubeTexture(context3D, bitmapCubeTexture);
            var renderTexture = texture;
            if (renderTexture)
                return createRenderTexture(context3D, renderTexture);
            return null;
        };
        /** 纹理字典 */
        TextureCenter.textureDic = {};
        /**
         * 获取纹理
         * @param context3D		3D环境
         * @param texture		纹理代理
         * @return				纹理
         */
        TextureCenter.function = $getTexture(context3D, Context3D, texture, feng3d.TextureProxyBase);
        return TextureCenter;
    }());
    feng3d.TextureCenter = TextureCenter;
    {
        if (textureDic[texture] == null || textureDic[texture][context3D] == null) {
            return null;
        }
        return textureDic[texture][context3D];
    }
    /**
     * 创建纹理
     * @param context3D				3D环境
     * @param bitmapTexture			位图纹理代理
     * @return						纹理
     */
    function createTexture(context3D, bitmapTexture) {
        var texture = context3D.createTexture(bitmapTexture.width, bitmapTexture.height, bitmapTexture.format, true);
        if (bitmapTexture.generateMipmaps)
            feng3d.MipmapGenerator.generateMipMaps(bitmapTexture.bitmapData, texture, bitmapTexture.mipMapHolder, true);
        else
            texture.uploadFromBitmapData(bitmapTexture.bitmapData, 0);
        saveTextureBuffer(bitmapTexture, context3D, texture);
        return texture;
    }
    /**
     * 创建纹理
     * @param context3D				3D环境
     * @param renderTexture			渲染纹理代理
     * @return						纹理
     */
    function createRenderTexture(context3D, renderTexture) {
        var texture = context3D.createTexture(renderTexture.width, renderTexture.height, renderTexture.format, true);
        var bmp = new BitmapData(renderTexture.width, renderTexture.height, false, 0xff0000);
        feng3d.MipmapGenerator.generateMipMaps(bmp, texture);
        bmp.dispose();
        saveTextureBuffer(renderTexture, context3D, texture);
        return texture;
    }
    /**
     * 创建立方体纹理
     * @param context3D				3D环境
     * @param bitmapTexture			位图立方体纹理代理
     * @return						立方体纹理
     */
    function createCubeTexture(context3D, bitmapTexture) {
        var texture = context3D["createCubeTexture"](bitmapTexture.size, bitmapTexture.format, bitmapTexture.optimizeForRenderToTexture, bitmapTexture.streamingLevels);
        var _bitmapDatas = bitmapTexture.bitmapDatas;
        for (var i = 0; i < 6; ++i)
            feng3d.MipmapGenerator.generateMipMaps(_bitmapDatas[i], texture, null, _bitmapDatas[i].transparent, i);
        saveTextureBuffer(bitmapTexture, context3D, texture);
        return texture;
    }
    /**
     * 保存纹理缓存
     * @param texture				纹理代理
     * @param context3D				3D环境
     * @param textureBase			纹理
     */
    function saveTextureBuffer(texture, context3D, textureBase) {
        var textureDic1 = textureDic[texture];
        if (textureDic1 == null)
            textureDic1 = textureDic[texture] = {};
        textureDic1[context3D] = textureBase;
    }
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 实体列表元素池
     * @author feng 2015-3-6
     */
    var EntityListItemPool = (function () {
        /**
         * 创建一个实体列表元素池
         */
        function EntityListItemPool() {
        }
        /**
         * 释放所有
         */
        EntityListItemPool.prototype.freeAll = function () {
            this._index = 0;
        };
        return EntityListItemPool;
    }());
    feng3d.EntityListItemPool = EntityListItemPool;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 可渲染元素链表（元素）
     * @author feng 2015-3-6
     */
    var RenderableListItem = (function () {
        /**
         * 创建一个可渲染列表
         */
        function RenderableListItem() {
        }
        return RenderableListItem;
    }());
    feng3d.RenderableListItem = RenderableListItem;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 可渲染列表元素池
     * @author feng 2015-3-6
     */
    var RenderableListItemPool = (function () {
        /**
         * 创建可渲染列表元素池
         */
        function RenderableListItemPool() {
            this._pool = new feng3d.RenderableListItem[]();
        }
        /**
         * 获取 可渲染列表元
         */
        RenderableListItemPool.prototype.getItem = function () {
            if (this._index == this._poolSize) {
                var item = new feng3d.RenderableListItem();
                this._pool[this._index++] = item;
                ++this._poolSize;
                return item;
            }
            else
                return this._pool[this._index++];
        };
        /**
         * 释放所有
         */
        RenderableListItemPool.prototype.freeAll = function () {
            this._index = 0;
        };
        return RenderableListItemPool;
    }());
    feng3d.RenderableListItemPool = RenderableListItemPool;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 鼠标事件管理
     * @author feng 2014-4-29
     */
    var Mouse3DManager = (function () {
        function Mouse3DManager() {
            /** 射线采集器(采集射线穿过场景中物体的列表) */
            this._mousePicker = new feng3d.RaycastPicker(false);
            /** 收集的鼠标事件列表 */
            this.mouseEventList = new string[]();
            /** 是否开启鼠标事件检测 */
            this.mouseEventOpen = false;
            if (eventMap == null) {
                eventMap = {};
                eventMap[MouseEvent.CLICK] = feng3d.MouseEvent3D.CLICK;
                eventMap[MouseEvent.DOUBLE_CLICK] = feng3d.MouseEvent3D.DOUBLE_CLICK;
                eventMap[MouseEvent.MOUSE_DOWN] = feng3d.MouseEvent3D.MOUSE_DOWN;
                eventMap[MouseEvent.MOUSE_MOVE] = feng3d.MouseEvent3D.MOUSE_MOVE;
                eventMap[MouseEvent.MOUSE_OUT] = feng3d.MouseEvent3D.MOUSE_OUT;
                eventMap[MouseEvent.MOUSE_OVER] = feng3d.MouseEvent3D.MOUSE_OVER;
                eventMap[MouseEvent.MOUSE_UP] = feng3d.MouseEvent3D.MOUSE_UP;
                eventMap[MouseEvent.MOUSE_WHEEL] = feng3d.MouseEvent3D.MOUSE_WHEEL;
            }
        }
        /**
         * 开启鼠标事件
         */
        Mouse3DManager.prototype.enableMouseListeners = function (view) {
            view.addEventListener(MouseEvent.MOUSE_OVER, this.onMouseOver);
            view.addEventListener(MouseEvent.MOUSE_OUT, this.onMouseOut);
        };
        Mouse3DManager.prototype.onMouseOver = function (event) {
            var view = event.currentTarget;
            for (var eventType in eventMap) {
                view.addEventListener(eventType, this.onMouseEvent);
            }
            this.mouseEventList.length = 0;
            this.mouseEventOpen = true;
        };
        Mouse3DManager.prototype.onMouseOut = function (event) {
            var view = event.currentTarget;
            for (var eventType in eventMap) {
                view.removeEventListener(eventType, this.onMouseEvent);
            }
            this.mouseEventOpen = false;
        };
        /**
         * 收集玩家触发的鼠标事件
         */
        Mouse3DManager.prototype.onMouseEvent = function (event) {
            this.mouseEventList.push(event.type);
        };
        /**
         * 处理玩家触发的鼠标事件
         */
        Mouse3DManager.prototype.fireMouseEvents = function (mouseRay3D, mouseCollisionEntitys) {
            //玩家未触发鼠标事件时，直接返回
            if (!this.mouseEventOpen) {
                return;
            }
            var mouseEvent3DList = new feng3d.MouseEvent3D[]();
            //计算得到鼠标射线相交的物体
            this._collidingObject = this._mousePicker.getViewCollision(mouseRay3D, mouseCollisionEntitys);
            //处理3d对象的Over与Out事件
            var mouseEventType;
            var mouseEvent3D;
            if (this._collidingObject != this._previousCollidingObject) {
                if (this._previousCollidingObject) {
                    mouseEvent3D = this.createMouseEvent3D(MouseEvent.MOUSE_OUT, this._previousCollidingObject);
                    mouseEvent3DList.push(mouseEvent3D);
                }
                if (this._collidingObject) {
                    mouseEvent3D = this.createMouseEvent3D(MouseEvent.MOUSE_OVER, this._collidingObject);
                    mouseEvent3DList.push(mouseEvent3D);
                }
            }
            //遍历收集的鼠标事件
            while (this._collidingObject && this.mouseEventList.length > 0) {
                mouseEventType = this.mouseEventList.pop();
                //处理鼠标事件
                mouseEvent3D = this.createMouseEvent3D(mouseEventType, this._collidingObject);
                mouseEvent3DList.push(mouseEvent3D);
            }
            this.dispatchAllEvent(mouseEvent3DList);
            this.mouseEventList.length = 0;
            mouseEvent3DList.length = 0;
            this._previousCollidingObject = this._collidingObject;
        };
        /**
         * 抛出所有3D鼠标事件
         * @param mouseEvent3DList
         */
        Mouse3DManager.prototype.dispatchAllEvent = function (mouseEvent3DList) {
            var mouseEvent3D;
            var dispatcher;
            while (mouseEvent3DList.length > 0) {
                mouseEvent3D = mouseEvent3DList.pop();
                if (mouseEvent3D && mouseEvent3D.object) {
                    dispatcher = mouseEvent3D.object;
                    if (dispatcher) {
                        dispatcher.dispatchEvent(mouseEvent3D);
                    }
                }
            }
        };
        /**
         * 创建3D鼠标事件
         * @param sourceEvent 2d鼠标事件
         * @param collider 碰撞信息
         * @return 3D鼠标事件
         */
        Mouse3DManager.prototype.createMouseEvent3D = function (sourceEventType, collider) {
            if (collider === void 0) { collider = null; }
            var mouseEvent3DType = eventMap[sourceEventType];
            if (mouseEvent3DType == null)
                return null;
            var mouseEvent3D = new feng3d.MouseEvent3D(mouseEvent3DType);
            mouseEvent3D.object = collider.firstEntity;
            mouseEvent3D.collider = collider;
            return mouseEvent3D;
        };
        return Mouse3DManager;
    }());
    feng3d.Mouse3DManager = Mouse3DManager;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * The Stage3DManager class provides a multiton object that handles management for Stage3D objects. Stage3D objects
     * should not be requested directly, but are exposed by a Stage3DProxy.
     *
     * @see away3d.core.managers.Stage3DProxy
     */
    var Stage3DManager = (function () {
        /**
         * Creates a new Stage3DManager class.
         * @param stage The Stage object that contains the Stage3D objects to be managed.
         * @private
         */
        function Stage3DManager(stage, Stage3DManagerSingletonEnforcer) {
            if (!Stage3DManagerSingletonEnforcer)
                throw new Error("This class is a multiton and cannot be instantiated manually. Use Stage3DManager.getInstance instead.");
            this._stage = stage;
            if (!_stageProxies)
                _stageProxies = new feng3d.Stage3DProxy[](this._stage.stage3Ds.length, true);
        }
        /**
         * Gets a Stage3DManager instance for the given Stage object.
         * @param stage The Stage object that contains the Stage3D objects to be managed.
         * @return The Stage3DManager instance for the given Stage object.
         */
        Stage3DManager.getInstance = function (stage) {
            return (_instances || ) = {};
            [stage] || ;
            new Stage3DManager(stage, new Stage3DManagerSingletonEnforcer());
        };
        /**
         * Requests the Stage3DProxy for the given index.
         * @param index The index of the requested Stage3D.
         * @param forceSoftware Whether to force software mode even if hardware acceleration is available.
         * @param profile The compatibility profile, an enumeration of Context3DProfile
         * @return The Stage3DProxy for the given index.
         */
        Stage3DManager.prototype.getStage3DProxy = function (index, forceSoftware, profile) {
            if (forceSoftware === void 0) { forceSoftware = false; }
            if (profile === void 0) { profile = "baseline"; }
            if (!_stageProxies[index]) {
                _numStageProxies++;
                _stageProxies[index] = new feng3d.Stage3DProxy(index, this._stage.stage3Ds[index], this, forceSoftware, profile);
            }
            return _stageProxies[index];
        };
        /**
         * Removes a Stage3DProxy from the manager.
         * @param stage3DProxy
         * @private
         */
        Stage3DManager.prototype.removeStage3DProxy = function (stage3DProxy) {
            _numStageProxies--;
            _stageProxies[stage3DProxy.stage3DIndex] = null;
        };
        /**
         * Get the next available stage3DProxy. An error is thrown if there are no Stage3DProxies available
         * @param forceSoftware Whether to force software mode even if hardware acceleration is available.
         * @param profile The compatibility profile, an enumeration of Context3DProfile
         * @return The allocated stage3DProxy
         */
        Stage3DManager.prototype.getFreeStage3DProxy = function (forceSoftware, profile) {
            if (forceSoftware === void 0) { forceSoftware = false; }
            if (profile === void 0) { profile = Context3DProfile.STANDARD; }
            var i;
            var len = _stageProxies.length;
            while (i < len) {
                if (!_stageProxies[i]) {
                    this.getStage3DProxy(i, forceSoftware, profile);
                    _stageProxies[i].width = this._stage.stageWidth;
                    _stageProxies[i].height = this._stage.stageHeight;
                    return _stageProxies[i];
                }
                ++i;
            }
            throw new Error("Too many Stage3D instances used!");
            return null;
        };
        Object.defineProperty(Stage3DManager.prototype, "hasFreeStage3DProxy", {
            /**
             * Checks if a new stage3DProxy can be created and managed by the class.
             * @return true if there is one slot free for a new stage3DProxy
             */
            get: function () {
                return _numStageProxies < _stageProxies.length ? true : false;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Stage3DManager.prototype, "numProxySlotsFree", {
            /**
             * Returns the amount of stage3DProxy objects that can be created and managed by the class
             * @return the amount of free slots
             */
            get: function () {
                return _stageProxies.length - _numStageProxies;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Stage3DManager.prototype, "numProxySlotsUsed", {
            /**
             * Returns the amount of Stage3DProxy objects currently managed by the class.
             * @return the amount of slots used
             */
            get: function () {
                return _numStageProxies;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Stage3DManager.prototype, "numProxySlotsTotal", {
            /**
             * Returns the maximum amount of Stage3DProxy objects that can be managed by the class
             * @return the maximum amount of Stage3DProxy objects that can be managed by the class
             */
            get: function () {
                return _stageProxies.length;
            },
            enumerable: true,
            configurable: true
        });
        Stage3DManager._numStageProxies = 0;
        return Stage3DManager;
    }());
    feng3d.Stage3DManager = Stage3DManager;
})(feng3d || (feng3d = {}));
var Stage3DManagerSingletonEnforcer = (function () {
    function Stage3DManagerSingletonEnforcer() {
    }
    return Stage3DManagerSingletonEnforcer;
}());
var feng3d;
(function (feng3d) {
    /**
     * 分区节点基类
     * @author feng 2015-3-8
     */
    var NodeBase = (function () {
        /**
         * 创建一个分区节点基类
         */
        function NodeBase() {
            this._childNodes = new NodeBase[]();
        }
        Object.defineProperty(NodeBase.prototype, "parent", {
            /**
             * 父分区节点
             */
            get: function () {
                return _parent;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NodeBase.prototype, "showDebugBounds", {
            /**
             * 是否显示调试边界
             */
            get: function () {
                return _debugPrimitive != null;
            },
            /**
             * @private
             */
            set: function (value) {
                if (boolean(_debugPrimitive) == value)
                    return;
                if (value)
                    _debugPrimitive = createDebugBounds();
                else {
                    //				_debugPrimitive.dispose();
                    _debugPrimitive = null;
                }
                for (var i = 0; i < _numChildNodes; ++i)
                    _childNodes[i].showDebugBounds = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 添加节点
         * @param node	节点
         */
        NodeBase.prototype.addNode = function (node) {
            node._parent = this;
            this._numEntities += node._numEntities;
            this._childNodes[this._numChildNodes++] = node;
            node.showDebugBounds = this._debugPrimitive != null;
            var numEntities = node._numEntities;
            node = this;
            do
                node._numEntities += numEntities;
            while ((node = node._parent) != null);
        };
        /**
         * 移除节点
         * @param node 节点
         */
        NodeBase.prototype.removeNode = function (node) {
            var index = this._childNodes.indexOf(node);
            this._childNodes[index] = this._childNodes[--this._numChildNodes];
            this._childNodes.pop();
            var numEntities = node._numEntities;
            node = this;
            do
                node._numEntities -= numEntities;
            while ((node = node._parent) != null);
        };
        /**
         * 为给定实体查找分区节点
         * @param entity		实体
         * @return 				实体所在分区节点
         */
        NodeBase.prototype.findPartitionForEntity = function (entity) {
            entity = entity;
            return this;
        };
        /**
         * 接受横越者
         * @param traverser		访问节点的横越者
         */
        NodeBase.prototype.acceptTraverser = function (traverser) {
            if (this._numEntities == 0 && !this._debugPrimitive)
                return;
            if (traverser.enterNode(this)) {
                var i;
                while (i < this._numChildNodes)
                    this._childNodes[i++].acceptTraverser(traverser);
                if (this._debugPrimitive)
                    traverser.applyRenderable(this._debugPrimitive);
            }
        };
        /**
         * 创建调试边界
         */
        NodeBase.prototype.createDebugBounds = function () {
            return null;
        };
        /**
         * 更新多个实体
         * @param value 数量
         */
        NodeBase.prototype.updateNumEntities = function (value) {
            var diff = value - this._numEntities;
            var node = this;
            do
                node._numEntities += diff;
            while ((node = node._parent) != null);
        };
        /**
         * 测试是否出现在摄像机视锥体内
         * @param planes		视锥体面向量
         * @param numPlanes		面数
         * @return 				true：在视锥体内
         */
        NodeBase.prototype.isInFrustum = function (planes, numPlanes) {
            return true;
        };
        return NodeBase;
    }());
    feng3d.NodeBase = NodeBase;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 实体分区节点
     * @author feng 2015-3-8
     */
    var EntityNode = (function (_super) {
        __extends(EntityNode, _super);
        /**
         * 创建一个实体分区节点
         * @param entity		实体
         */
        function EntityNode(entity) {
            _super.call(this);
            this._entity = entity;
            this._numEntities = 1;
        }
        /**
         * 从父节点中移除
         */
        EntityNode.prototype.removeFromParent = function () {
            if (this._parent)
                this._parent.removeNode(this);
            this._parent = null;
        };
        Object.defineProperty(EntityNode.prototype, "entity", {
            /**
             * 实体
             */
            get: function () {
                return _entity;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        EntityNode.prototype.isInFrustum = function (planes, numPlanes) {
            if (!this._entity.sceneVisible)
                return false;
            return this._entity.worldBounds.isInFrustum(planes, numPlanes);
        };
        return EntityNode;
    }(feng3d.NodeBase));
    feng3d.EntityNode = EntityNode;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 摄像机分区节点
     * @author feng 2015-3-21
     */
    var CameraNode = (function (_super) {
        __extends(CameraNode, _super);
        /**
         * 创建一个摄像机分区节点
         * @param camera		摄像机
         */
        function CameraNode(camera) {
            _super.call(this, camera);
        }
        /**
         * @inheritDoc
         */
        CameraNode.prototype.acceptTraverser = function (traverser) {
        };
        return CameraNode;
    }(feng3d.EntityNode));
    feng3d.CameraNode = CameraNode;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 方向光分区节点
     * @author feng 2015-3-21
     */
    var DirectionalLightNode = (function (_super) {
        __extends(DirectionalLightNode, _super);
        /**
         * 创建一个方向光分区节点
         * @param light 		方向光
         */
        function DirectionalLightNode(light) {
            _super.call(this, light);
            this._light = light;
        }
        Object.defineProperty(DirectionalLightNode.prototype, "light", {
            /**
             * 方向光
             */
            get: function () {
                return _light;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        DirectionalLightNode.prototype.acceptTraverser = function (traverser) {
            if (traverser.enterNode(this)) {
                _super.prototype.acceptTraverser.call(this, traverser);
                traverser.applyDirectionalLight(this._light);
            }
        };
        return DirectionalLightNode;
    }(feng3d.EntityNode));
    feng3d.DirectionalLightNode = DirectionalLightNode;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 网格分区节点
     * @author feng 2015-3-8
     */
    var MeshNode = (function (_super) {
        __extends(MeshNode, _super);
        /**
         * 创建一个网格分区节点
         * @param mesh		网格
         */
        function MeshNode(mesh) {
            _super.call(this, mesh);
            this._mesh = mesh;
        }
        /**
         * @inheritDoc
         */
        MeshNode.prototype.acceptTraverser = function (traverser) {
            if (traverser.enterNode(this)) {
                _super.prototype.acceptTraverser.call(this, traverser);
                var subs = this._mesh.subMeshes;
                var i;
                var len = subs.length;
                while (i < len)
                    traverser.applyRenderable(subs[i++].renderableBase);
            }
        };
        return MeshNode;
    }(feng3d.EntityNode));
    feng3d.MeshNode = MeshNode;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 点光源分区节点
     * @author feng 2015-3-23
     */
    var PointLightNode = (function (_super) {
        __extends(PointLightNode, _super);
        /**
         * 创建一个点光源分区节点
         * @param light		点光源
         */
        function PointLightNode(light) {
            _super.call(this, light);
            this._light = light;
        }
        Object.defineProperty(PointLightNode.prototype, "light", {
            /**
             * 点光源
             */
            get: function () {
                return _light;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        PointLightNode.prototype.acceptTraverser = function (traverser) {
            if (traverser.enterNode(this)) {
                _super.prototype.acceptTraverser.call(this, traverser);
                traverser.applyPointLight(this._light);
            }
        };
        return PointLightNode;
    }(feng3d.EntityNode));
    feng3d.PointLightNode = PointLightNode;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * RenderableNode is a space partitioning leaf node that contains any Entity that is itself a IRenderable
     * object. This excludes Mesh (since the renderable objects are its SubMesh children).
     */
    var RenderableNode = (function (_super) {
        __extends(RenderableNode, _super);
        /**
         * Creates a new RenderableNode object.
         * @param mesh The mesh to be contained in the node.
         */
        function RenderableNode(renderable) {
            _super.call(this, feng3d.Entity(renderable));
            this._renderable = renderable; // also keep a stronger typed reference
        }
        /**
         * @inheritDoc
         */
        RenderableNode.prototype.acceptTraverser = function (traverser) {
            if (traverser.enterNode(this)) {
                _super.prototype.acceptTraverser.call(this, traverser);
                traverser.applyRenderable(this._renderable);
            }
        };
        return RenderableNode;
    }(feng3d.EntityNode));
    feng3d.RenderableNode = RenderableNode;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 天空盒分区节点
     * @author feng 2015-3-8
     */
    var SkyBoxNode = (function (_super) {
        __extends(SkyBoxNode, _super);
        /**
         * 创建SkyBoxNode实例
         * @param skyBox		天空盒实例
         */
        function SkyBoxNode(skyBox) {
            _super.call(this, skyBox);
            this._skyBox = skyBox;
        }
        /**
         * @inheritDoc
         */
        SkyBoxNode.prototype.acceptTraverser = function (traverser) {
            if (traverser.enterNode(this)) {
                _super.prototype.acceptTraverser.call(this, traverser);
                traverser.applySkyBox(this._skyBox);
            }
        };
        /**
         * @inheritDoc
         */
        SkyBoxNode.prototype.isInFrustum = function (planes, numPlanes) {
            planes = planes;
            numPlanes = numPlanes;
            return true;
        };
        return SkyBoxNode;
    }(feng3d.EntityNode));
    feng3d.SkyBoxNode = SkyBoxNode;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 空分区节点
     * @author feng 2015-3-9
     */
    var NullNode = (function (_super) {
        __extends(NullNode, _super);
        /**
         * 创建一个空分区节点
         */
        function NullNode() {
            _super.call(this);
        }
        return NullNode;
    }(feng3d.NodeBase));
    feng3d.NullNode = NullNode;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 3D空间分区
     * <p>用于把3D空间分区，便于搜索出有必要渲染的对象，从而优化性能</p>
     * @author feng 2015-3-5
     */
    var Partition3D = (function () {
        /**
         * 创建一个3D空间分区
         * @param rootNode	根节点
         */
        function Partition3D(rootNode) {
            this._rootNode = rootNode || new feng3d.NullNode();
        }
        /**
         * 发送一个横越者穿过分区
         * @param traverser		横越者
         */
        Partition3D.prototype.traverse = function (traverser) {
            if (this._updatesMade)
                this.updateEntities();
            //更新收集标记
            ++feng3d.PartitionTraverser._collectionMark;
            //接受一个穿越者来收集实体
            this._rootNode.acceptTraverser(traverser);
        };
        /**
         * 从分区树种移除实体
         * @param entity 被移除实体
         */
        Partition3D.prototype.removeEntity = function (entity) {
            var node = entity.getEntityPartitionNode();
            var t;
            //从父节点中移除
            node.removeFromParent();
            //链表中移除节点
            if (node == this._updateQueue)
                this._updateQueue = node._updateQueueNext;
            else {
                t = this._updateQueue;
                while (t && t._updateQueueNext != node)
                    t = t._updateQueueNext;
                //连接删除节点的前节点与后节点
                if (t)
                    t._updateQueueNext = node._updateQueueNext;
            }
            //清空删除节点的next指针
            node._updateQueueNext = null;
            if (!this._updateQueue)
                this._updatesMade = false;
        };
        /**
         * 标记为待更新节点，把新节点添加到待更新节点链表表头
         * @param entity	更新的实体
         */
        Partition3D.prototype.markForUpdate = function (entity) {
            var node = entity.getEntityPartitionNode();
            //链表中添加节点到表头
            var t = this._updateQueue;
            //判断节点是否已经存在链表中
            while (t) {
                if (node == t)
                    return;
                t = t._updateQueueNext;
            }
            //把表头添加到新节点的next指针
            node._updateQueueNext = this._updateQueue;
            //把新节点设置为表头
            this._updateQueue = node;
            this._updatesMade = true;
        };
        /**
         * 更新待更新节点中的实体
         */
        Partition3D.prototype.updateEntities = function () {
            var node = this._updateQueue;
            var targetNode;
            var t;
            //为了重新标记实体，清除更新队列
            this._updateQueue = null;
            this._updatesMade = false;
            do {
                targetNode = this._rootNode.findPartitionForEntity(node.entity);
                // 更新 待更新链表中节点的父节点
                if (node.parent != targetNode) {
                    if (node)
                        node.removeFromParent();
                    targetNode.addNode(node);
                }
                //获取链表中下个节点
                t = node._updateQueueNext;
                node._updateQueueNext = null;
                //调用节点实体的内部更新
                node.entity.internalUpdate();
            } while ((node = t) != null);
        };
        return Partition3D;
    }());
    feng3d.Partition3D = Partition3D;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     *
     * @author feng 2014-4-30
     */
    var PickingColliderBase = (function () {
        function PickingColliderBase() {
        }
        /**
         * 获取碰撞法线
         * @param indexData 顶点索引数据
         * @param vertexData 顶点数据
         * @param triangleIndex 三角形索引
         * @param normal 碰撞法线
         * @return 碰撞法线
         *
         */
        PickingColliderBase.prototype.getCollisionNormal = function (indexData, vertexData, triangleIndex, normal) {
            if (normal === void 0) { normal = null; }
            var i0 = indexData[triangleIndex] * 3;
            var i1 = indexData[triangleIndex + 1] * 3;
            var i2 = indexData[triangleIndex + 2] * 3;
            var side0x = vertexData[i1] - vertexData[i0];
            var side0y = vertexData[i1 + 1] - vertexData[i0 + 1];
            var side0z = vertexData[i1 + 2] - vertexData[i0 + 2];
            var side1x = vertexData[i2] - vertexData[i0];
            var side1y = vertexData[i2 + 1] - vertexData[i0 + 1];
            var side1z = vertexData[i2 + 2] - vertexData[i0 + 2];
            if (!normal)
                normal = new Vector3D();
            normal.x = side0y * side1z - side0z * side1y;
            normal.y = side0z * side1x - side0x * side1z;
            normal.z = side0x * side1y - side0y * side1x;
            normal.w = 1;
            normal.normalize();
            return normal;
        };
        /**
         * 获取碰撞uv
         * @param indexData 顶点数据
         * @param uvData uv数据
         * @param triangleIndex 三角形所有
         * @param v
         * @param w
         * @param u
         * @param uvOffset
         * @param uvStride
         * @param uv uv坐标
         * @return 碰撞uv
         */
        PickingColliderBase.prototype.getCollisionUV = function (indexData, uvData, triangleIndex, v, w, u, uvOffset, uvStride, uv) {
            if (uv === void 0) { uv = null; }
            var uIndex = indexData[triangleIndex] * uvStride + uvOffset;
            var uv0x = uvData[uIndex];
            var uv0y = uvData[uIndex + 1];
            uIndex = indexData[triangleIndex + 1] * uvStride + uvOffset;
            var uv1x = uvData[uIndex];
            var uv1y = uvData[uIndex + 1];
            uIndex = indexData[triangleIndex + 2] * uvStride + uvOffset;
            var uv2x = uvData[uIndex];
            var uv2y = uvData[uIndex + 1];
            if (!uv)
                uv = new Point();
            uv.x = u * uv0x + v * uv1x + w * uv2x;
            uv.y = u * uv0y + v * uv1y + w * uv2y;
            return uv;
        };
        /**
         * 设置碰撞射线
         */
        PickingColliderBase.prototype.setLocalRay = function (ray3D) {
            this.ray3D = ray3D;
        };
        return PickingColliderBase;
    }());
    feng3d.PickingColliderBase = PickingColliderBase;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 使用纯AS3计算与实体相交
     */
    var AS3PickingCollider = (function (_super) {
        __extends(AS3PickingCollider, _super);
        /**
         * 创建一个AS碰撞检测器
         * @param findClosestCollision 是否查找最短距离碰撞
         */
        function AS3PickingCollider(findClosestCollision) {
            if (findClosestCollision === void 0) { findClosestCollision = false; }
            this._findClosestCollision = findClosestCollision;
        }
        AS3PickingCollider.prototype.testSubMeshCollision = function (subMesh, pickingCollisionVO, shortestCollisionDistance, bothSides) {
            if (bothSides === void 0) { bothSides = true; }
            var t;
            var i0, i1, i2;
            var rx, ry, rz;
            var nx, ny, nz;
            var cx, cy, cz;
            var coeff, u, v, w;
            var p0x, p0y, p0z;
            var p1x, p1y, p1z;
            var p2x, p2y, p2z;
            var s0x, s0y, s0z;
            var s1x, s1y, s1z;
            var nl, nDotV, D, disToPlane;
            var Q1Q2, Q1Q1, Q2Q2, RQ1, RQ2;
            var subGeom = subMesh.subGeometry;
            var indexData = subGeom.indexData;
            var vertexData = subGeom.vertexPositionData;
            var uvData = subGeom.UVData;
            var collisionTriangleIndex = -1;
            var vertexStride = subGeom.vertexPositionStride;
            var vertexOffset = 0;
            var uvStride = subGeom.UVStride;
            var numIndices = indexData.length;
            //遍历每个三角形 检测碰撞
            for (var index = 0; index < numIndices; index += 3) {
                //三角形三个顶点索引
                i0 = vertexOffset + indexData[index] * vertexStride;
                i1 = vertexOffset + indexData[number(index + 1)] * vertexStride;
                i2 = vertexOffset + indexData[number(index + 2)] * vertexStride;
                //三角形三个顶点数据
                p0x = vertexData[i0];
                p0y = vertexData[number(i0 + 1)];
                p0z = vertexData[number(i0 + 2)];
                p1x = vertexData[i1];
                p1y = vertexData[number(i1 + 1)];
                p1z = vertexData[number(i1 + 2)];
                p2x = vertexData[i2];
                p2y = vertexData[number(i2 + 1)];
                p2z = vertexData[number(i2 + 2)];
                //计算出三角面的法线
                s0x = p1x - p0x; // s0 = p1 - p0
                s0y = p1y - p0y;
                s0z = p1z - p0z;
                s1x = p2x - p0x; // s1 = p2 - p0
                s1y = p2y - p0y;
                s1z = p2z - p0z;
                nx = s0y * s1z - s0z * s1y; // n = s0 x s1
                ny = s0z * s1x - s0x * s1z;
                nz = s0x * s1y - s0y * s1x;
                nl = 1 / Math.sqrt(nx * nx + ny * ny + nz * nz); // normalize n
                nx *= nl;
                ny *= nl;
                nz *= nl;
                //初始化射线数据
                var rayPosition = ray3D.position;
                var rayDirection = ray3D.direction;
                //计算射线与法线的点积，不等于零表示射线所在直线与三角面相交
                nDotV = nx * rayDirection.x + ny * +rayDirection.y + nz * rayDirection.z; // rayDirection . normal
                //判断射线是否与三角面相交
                if ((!bothSides && nDotV < 0.0) || (bothSides && nDotV != 0.0)) {
                    //计算平面方程D值，参考Plane3D
                    D = -(nx * p0x + ny * p0y + nz * p0z);
                    //射线点到平面的距离
                    disToPlane = -(nx * rayPosition.x + ny * rayPosition.y + nz * rayPosition.z + D);
                    t = disToPlane / nDotV;
                    //得到交点
                    cx = rayPosition.x + t * rayDirection.x;
                    cy = rayPosition.y + t * rayDirection.y;
                    cz = rayPosition.z + t * rayDirection.z;
                    //判断交点是否在三角形内( using barycentric coordinates )
                    Q1Q2 = s0x * s1x + s0y * s1y + s0z * s1z;
                    Q1Q1 = s0x * s0x + s0y * s0y + s0z * s0z;
                    Q2Q2 = s1x * s1x + s1y * s1y + s1z * s1z;
                    rx = cx - p0x;
                    ry = cy - p0y;
                    rz = cz - p0z;
                    RQ1 = rx * s0x + ry * s0y + rz * s0z;
                    RQ2 = rx * s1x + ry * s1y + rz * s1z;
                    coeff = 1 / (Q1Q1 * Q2Q2 - Q1Q2 * Q1Q2);
                    v = coeff * (Q2Q2 * RQ1 - Q1Q2 * RQ2);
                    w = coeff * (-Q1Q2 * RQ1 + Q1Q1 * RQ2);
                    if (v < 0)
                        continue;
                    if (w < 0)
                        continue;
                    u = 1 - v - w;
                    //u v w都大于0表示点在三角形内 射线的坐标t大于0表示射线朝向三角面
                    if (!(u < 0) && t > 0 && t < shortestCollisionDistance) {
                        shortestCollisionDistance = t;
                        collisionTriangleIndex = index / 3;
                        pickingCollisionVO.rayEntryDistance = t;
                        pickingCollisionVO.localPosition = new Vector3D(cx, cy, cz);
                        pickingCollisionVO.localNormal = new Vector3D(nx, ny, nz);
                        pickingCollisionVO.uv = getCollisionUV(indexData, uvData, index, v, w, u, 0, uvStride);
                        pickingCollisionVO.index = index;
                        //是否继续寻找最优解
                        if (!this._findClosestCollision)
                            return true;
                    }
                }
            }
            if (collisionTriangleIndex >= 0)
                return true;
            return false;
        };
        return AS3PickingCollider;
    }(feng3d.PickingColliderBase));
    feng3d.AS3PickingCollider = AS3PickingCollider;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 基于PixelBender计算与实体的相交
     */
    var PBPickingCollider = (function (_super) {
        __extends(PBPickingCollider, _super);
        /**
         * 创建一个 PBPickingCollider
         * @param findClosestCollision 是否查找最短距离碰撞
         */
        function PBPickingCollider(findClosestCollision) {
            if (findClosestCollision === void 0) { findClosestCollision = false; }
            this._findClosestCollision = findClosestCollision;
            //初始化出入缓存
            this._kernelOutputBuffer = new number[]();
            //初始化渲染器
            this._rayTriangleKernel = new Shader(new this.RayTriangleKernelClass());
        }
        PBPickingCollider.prototype.setLocalRay = function (ray3D) {
            _super.prototype.setLocalRay.call(this, ray3D);
            //上传射线信息到渲染器
            this._rayTriangleKernel.data.rayStartPoint.value = [ray3D.position.x, ray3D.position.y, ray3D.position.z];
            this._rayTriangleKernel.data.rayDirection.value = [ray3D.direction.x, ray3D.direction.y, ray3D.direction.z];
        };
        PBPickingCollider.prototype.testSubMeshCollision = function (subMesh, pickingCollisionVO, shortestCollisionDistance, bothSides) {
            if (bothSides === void 0) { bothSides = true; }
            var subGeom = subMesh.subGeometry;
            var cx, cy, cz;
            var u, v, w;
            var indexData = subGeom.indexData;
            var vertexData = subGeom.vertexPositionData;
            var uvData = subGeom.UVData;
            var numericIndexData = number[](indexData);
            var indexBufferDims = this.evaluateArrayAsGrid(numericIndexData);
            //更新几何体数据到渲染器
            if (!this._lastSubMeshUploaded || this._lastSubMeshUploaded !== subMesh) {
                //上传顶点数据到pb
                var duplicateVertexData = vertexData.concat();
                var vertexBufferDims = this.evaluateArrayAsGrid(duplicateVertexData);
                this._rayTriangleKernel.data.vertexBuffer.width = vertexBufferDims.x;
                this._rayTriangleKernel.data.vertexBuffer.height = vertexBufferDims.y;
                this._rayTriangleKernel.data.vertexBufferWidth.value = [vertexBufferDims.x];
                this._rayTriangleKernel.data.vertexBuffer.input = duplicateVertexData;
                this._rayTriangleKernel.data.bothSides.value = [bothSides ? 1.0 : 0.0];
                //上传索引数据到pb
                this._rayTriangleKernel.data.indexBuffer.width = indexBufferDims.x;
                this._rayTriangleKernel.data.indexBuffer.height = indexBufferDims.y;
                this._rayTriangleKernel.data.indexBuffer.input = numericIndexData;
            }
            this._lastSubMeshUploaded = subMesh;
            //运行渲染器(计算器)
            var shaderJob = new ShaderJob(this._rayTriangleKernel, this._kernelOutputBuffer, indexBufferDims.x, indexBufferDims.y);
            shaderJob.start(true);
            //从输出数据中查找最优相交
            var i;
            var t;
            var collisionTriangleIndex = -1;
            var len = this._kernelOutputBuffer.length;
            for (i = 0; i < len; i += 3) {
                t = this._kernelOutputBuffer[i];
                if (t > 0 && t < shortestCollisionDistance) {
                    shortestCollisionDistance = t;
                    collisionTriangleIndex = i;
                    if (!this._findClosestCollision)
                        break;
                }
            }
            //检测冲突，收集数据
            if (collisionTriangleIndex >= 0) {
                pickingCollisionVO.rayEntryDistance = shortestCollisionDistance;
                pickingCollisionVO.localPosition = ray3D.getPoint(shortestCollisionDistance);
                pickingCollisionVO.localNormal = getCollisionNormal(indexData, vertexData, collisionTriangleIndex, pickingCollisionVO.localNormal);
                v = this._kernelOutputBuffer[collisionTriangleIndex + 1]; // barycentric coord 1
                w = this._kernelOutputBuffer[collisionTriangleIndex + 2]; // barycentric coord 2
                u = 1.0 - v - w;
                pickingCollisionVO.uv = getCollisionUV(indexData, uvData, collisionTriangleIndex, v, w, u, 0, 2, pickingCollisionVO.uv);
                pickingCollisionVO.index = collisionTriangleIndex * 3;
                return true;
            }
            return false;
        };
        /**
         * 评估格子
         * @param array
         * @return
         */
        PBPickingCollider.prototype.evaluateArrayAsGrid = function (array) {
            var count = array.length / 3;
            var w = Math.floor(Math.sqrt(count));
            var h = w;
            var i;
            while (w * h < count) {
                for (i = 0; i < w; ++i)
                    array.push(0.0, 0.0, 0.0);
                h++;
            }
            return new Point(w, h);
        };
        return PBPickingCollider;
    }(feng3d.PickingColliderBase));
    feng3d.PBPickingCollider = PBPickingCollider;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 定义检测相交的工具类
     * @author feng 2014-4-30
     */
    var PickingColliderType = (function () {
        function PickingColliderType() {
        }
        /**
         * Default null collider that forces picker to only use entity bounds for hit calculations on an Entity
         */
        PickingColliderType.BOUNDS_ONLY = null;
        /**
         * 基于PixelBender计算与实体的相交
         */
        PickingColliderType.PB_BEST_HIT = new feng3d.PBPickingCollider(true);
        /**
         * 使用纯AS3计算与实体相交
         */
        PickingColliderType.AS3_BEST_HIT = new feng3d.AS3PickingCollider(true);
        return PickingColliderType;
    }());
    feng3d.PickingColliderType = PickingColliderType;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 采集的碰撞数据
     * @author feng 2014-4-29
     */
    var PickingCollisionVO = (function () {
        /**
         * 创建射线拾取碰撞数据
         * @param entity
         */
        function PickingCollisionVO(entity) {
            /**
             * 本地坐标系射线
             */
            this.localRay = new feng3d.Ray3D();
            /**
             * 场景中碰撞射线
             */
            this.ray3D = new feng3d.Ray3D();
            this.firstEntity = entity;
        }
        Object.defineProperty(PickingCollisionVO.prototype, "scenePosition", {
            /**
             * 实体上碰撞世界坐标
             */
            get: function () {
                return feng3d.Matrix3DUtils.transformVector(firstEntity.sceneTransform, localPosition);
            },
            enumerable: true,
            configurable: true
        });
        return PickingCollisionVO;
    }());
    feng3d.PickingCollisionVO = PickingCollisionVO;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 光线投射采集
     * @author feng 2014-4-29
     */
    var RaycastPicker = (function () {
        /**
         *
         * @param findClosestCollision 是否需要寻找最接近的
         */
        function RaycastPicker(findClosestCollision) {
            this._findClosestCollision = findClosestCollision;
        }
        /**
         * 获取射线穿过的实体
         * @param ray3D 射线
         * @param entitys 实体列表
         * @return
         */
        RaycastPicker.prototype.getViewCollision = function (ray3D, entitys) {
            this._entities = new feng3d.Entity[]();
            if (entitys.length == 0)
                return null;
            for (each(); ; )
                var entity;
             in entitys;
            {
                if (entity.isIntersectingRay(ray3D))
                    this._entities.push(entity);
            }
            if (this._entities.length == 0)
                return null;
            return this.getPickingCollisionVO();
        };
        /**
         *获取射线穿过的实体
         */
        RaycastPicker.prototype.getPickingCollisionVO = function () {
            // Sort entities from closest to furthest.
            this._entities = this._entities.sort(this.sortOnNearT);
            // ---------------------------------------------------------------------
            // Evaluate triangle collisions when needed.
            // Replaces collision data provided by bounds collider with more precise data.
            // ---------------------------------------------------------------------
            var shortestCollisionDistance = number.MAX_VALUE;
            var bestCollisionVO;
            var pickingCollisionVO;
            var entity;
            var i;
            for (i = 0; i < this._entities.length; ++i) {
                entity = this._entities[i];
                pickingCollisionVO = entity._pickingCollisionVO;
                if (entity.pickingCollider) {
                    // If a collision exists, update the collision data and stop all checks.
                    if ((bestCollisionVO == null || pickingCollisionVO.rayEntryDistance < bestCollisionVO.rayEntryDistance) && entity.collidesBefore(shortestCollisionDistance, this._findClosestCollision)) {
                        shortestCollisionDistance = pickingCollisionVO.rayEntryDistance;
                        bestCollisionVO = pickingCollisionVO;
                        if (!this._findClosestCollision) {
                            this.updateLocalPosition(pickingCollisionVO);
                            return pickingCollisionVO;
                        }
                    }
                }
                else if (bestCollisionVO == null || pickingCollisionVO.rayEntryDistance < bestCollisionVO.rayEntryDistance) {
                    // Note: a bounds collision with a ray origin inside its bounds is ONLY ever used
                    // to enable the detection of a corresponsding triangle collision.
                    // Therefore, bounds collisions with a ray origin inside its bounds can be ignored
                    // if it has been established that there is NO triangle collider to test
                    if (!pickingCollisionVO.rayOriginIsInsideBounds) {
                        this.updateLocalPosition(pickingCollisionVO);
                        return pickingCollisionVO;
                    }
                }
            }
            return bestCollisionVO;
        };
        /**
         * 按与射线原点距离排序
         */
        RaycastPicker.prototype.sortOnNearT = function (entity1, entity2) {
            return entity1.pickingCollisionVO.rayEntryDistance > entity2.pickingCollisionVO.rayEntryDistance ? 1 : -1;
        };
        /**
         * 更新碰撞本地坐标
         * @param pickingCollisionVO
         */
        RaycastPicker.prototype.updateLocalPosition = function (pickingCollisionVO) {
            pickingCollisionVO.localPosition = pickingCollisionVO.localRay.getPoint(pickingCollisionVO.rayEntryDistance);
        };
        return RaycastPicker;
    }());
    feng3d.RaycastPicker = RaycastPicker;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    [feng3d.Event(name = "enterFrame", type = "flash.events.Event")][feng3d.Event(name = "exitFrame", type = "flash.events.Event")];
    /**
     * 3D舞台代理
     */
    var Stage3DProxy = (function (_super) {
        __extends(Stage3DProxy, _super);
        /**
         * 创建一个3D舞台代理
         * @param stage3DIndex		被代理3D舞台编号
         * @param stage3D			被代理的3D舞台
         * @param stage3DManager	3D舞台管理类
         * @param forceSoftware		是否强制软件渲染
         * @param profile
         */
        function Stage3DProxy(stage3DIndex, stage3D, stage3DManager, forceSoftware, profile) {
            if (forceSoftware === void 0) { forceSoftware = false; }
            if (profile === void 0) { profile = "baseline"; }
            this._frameEventDriver = new Shape();
            this._stage3DIndex = -1;
            this._backBufferEnableDepthAndStencil = true;
            /**
             * 添加事件侦听
             * @param type							事件的类型
             * @param listener						处理事件的侦听器函数
             * @param useCapture					确定侦听器是运行于捕获阶段还是运行于目标和冒泡阶段
             * @param priority						事件侦听器的优先级。优先级由一个带符号的 32 位整数指定。数字越大，优先级越高。优先级为 n 的所有侦听器会在优先级为 n -1 的侦听器之前得到处理。如果两个或更多个侦听器共享相同的优先级，则按照它们的添加顺序进行处理。默认优先级为 0。
             * @param useWeakReference				确定对侦听器的引用是强引用，还是弱引用。强引用（默认值）可防止您的侦听器被当作垃圾回收。弱引用则没有此作用。
             */
            this.override = function addEventListener(type, listener, useCapture, priority, useWeakReference) {
                if (useCapture === void 0) { useCapture = false; }
                if (priority === void 0) { priority = 0; }
                if (useWeakReference === void 0) { useWeakReference = false; }
                _super.addEventListener.call(this, type, listener, useCapture, priority, useWeakReference);
                if ((type == feng3d.Event.ENTER_FRAME || type == feng3d.Event.EXIT_FRAME) && !this._frameEventDriver.hasEventListener(feng3d.Event.ENTER_FRAME))
                    this._frameEventDriver.addEventListener(feng3d.Event.ENTER_FRAME, this.onEnterFrame, useCapture, priority, useWeakReference);
            };
            /**
             * 移除事件侦听
             * @param type				事件的类型
             * @param listener			要删除的侦听器函数
             * @param useCapture		指出是为捕获阶段还是为目标和冒泡阶段注册了侦听器。如果为捕获阶段以及目标和冒泡阶段注册了侦听器，则需要对 removeEventListener() 进行两次调用才能将这两个侦听器删除，一次调用将 useCapture() 设置为 true，另一次调用将 useCapture() 设置为 false。
             */
            this.override = function removeEventListener(type, listener, useCapture) {
                if (useCapture === void 0) { useCapture = false; }
                _super.removeEventListener.call(this, type, listener, useCapture);
                // Remove the main rendering listener if no EnterFrame listeners remain
                if (!this.hasEventListener(feng3d.Event.ENTER_FRAME) && !this.hasEventListener(feng3d.Event.EXIT_FRAME) && this._frameEventDriver.hasEventListener(feng3d.Event.ENTER_FRAME))
                    this._frameEventDriver.removeEventListener(feng3d.Event.ENTER_FRAME, this.onEnterFrame, useCapture);
            };
            this._stage3DIndex = stage3DIndex;
            this._stage3D = stage3D;
            this._stage3D.x = 0;
            this._stage3D.y = 0;
            this._stage3D.visible = true;
            this._stage3DManager = stage3DManager;
            this._viewPort = new Rectangle();
            this._stage3D.addEventListener(feng3d.Event.CONTEXT3D_CREATE, this.onContext3DUpdate, false, 1000, false);
            this.requestContext(forceSoftware, profile);
        }
        Object.defineProperty(Stage3DProxy.prototype, "color", {
            /**
             * The background color of the Stage3D.
             */
            get: function () {
                return _color;
            },
            set: function (color) {
                _color = color;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 通知视窗发生变化
         */
        Stage3DProxy.prototype.notifyViewportUpdated = function () {
            if (this._viewportDirty)
                return;
            this._viewportDirty = true;
            if (!this.hasEventListener(feng3d.Stage3DEvent.VIEWPORT_UPDATED))
                return;
            this._viewportUpdated = new feng3d.Stage3DEvent(feng3d.Stage3DEvent.VIEWPORT_UPDATED);
            this.dispatchEvent(this._viewportUpdated);
        };
        /**
         * 通知进入帧事件
         */
        Stage3DProxy.prototype.notifyEnterFrame = function () {
            if (!this.hasEventListener(feng3d.Event.ENTER_FRAME))
                return;
            if (!this._enterFrame)
                this._enterFrame = new feng3d.Event(feng3d.Event.ENTER_FRAME);
            this.dispatchEvent(this._enterFrame);
        };
        /**
         * 通知退出帧事件
         */
        Stage3DProxy.prototype.notifyExitFrame = function () {
            if (!this.hasEventListener(feng3d.Event.EXIT_FRAME))
                return;
            if (!this._exitFrame)
                this._exitFrame = new feng3d.Event(feng3d.Event.EXIT_FRAME);
            this.dispatchEvent(this._exitFrame);
        };
        /**
         * 释放3D舞台代理，同时释放3D舞台中的3D环境
         */
        Stage3DProxy.prototype.dispose = function () {
            this._stage3DManager.removeStage3DProxy(this);
            this._stage3D.removeEventListener(feng3d.Event.CONTEXT3D_CREATE, this.onContext3DUpdate);
            this.freeContext3D();
            this._stage3D = null;
            this._stage3DManager = null;
            this._stage3DIndex = -1;
        };
        /**
         * 设置渲染缓冲区的视口尺寸和其他属性
         * @param backBufferWidth		缓冲区的宽度，以像素为单位。
         * @param backBufferHeight		缓冲区的高度，以像素为单位。
         * @param antiAlias				一个整数值，指定所请求的消除锯齿品质。该值与消除锯齿时使用的子实例的数量相关联。使用更多子实例要求执行更多的计算，尽管相对性能影响取决于特定的渲染硬件。消除锯齿的类型和是否执行消除锯齿操作取决于设备和渲染模式。软件渲染上下文完全不支持消除锯齿。
         */
        Stage3DProxy.prototype.configureBackBuffer = function (backBufferWidth, backBufferHeight, antiAlias) {
            if (backBufferWidth < 50)
                backBufferWidth = 50;
            if (backBufferHeight < 50)
                backBufferHeight = 50;
            var oldWidth = this._backBufferWidth;
            var oldHeight = this._backBufferHeight;
            this._backBufferWidth = this._viewPort.width = backBufferWidth;
            this._backBufferHeight = this._viewPort.height = backBufferHeight;
            if (oldWidth != this._backBufferWidth || oldHeight != this._backBufferHeight)
                this.notifyViewportUpdated();
            this._antiAlias = antiAlias;
            if (this._context3D)
                this._context3D.configureBackBuffer(backBufferWidth, backBufferHeight, antiAlias, this._backBufferEnableDepthAndStencil);
        };
        /**
         * 清除与重置缓冲区
         */
        Stage3DProxy.prototype.clear = function () {
            if (!this._context3D)
                return;
            if (this._backBufferDirty) {
                this.configureBackBuffer(this._backBufferWidth, this._backBufferHeight, this._antiAlias);
                this._backBufferDirty = false;
            }
            this._context3D.clear(//
            ((this._color >> 16) & 0xff) / 255.0, //
            ((this._color >> 8) & 0xff) / 255.0, //
            (this._color & 0xff) / 255.0, //
            ((this._color >> 24) & 0xff) / 255.0);
            this._bufferClear = true;
        };
        /**
         * 显示渲染缓冲
         */
        Stage3DProxy.prototype.present = function () {
            if (!this._context3D)
                return;
            this._context3D.present();
        };
        Object.defineProperty(Stage3DProxy.prototype, "scissorRect", {
            /**
             * 裁剪矩形
             */
            get: function () {
                return _scissorRect;
            },
            set: function (value) {
                _scissorRect = value;
                _context3D.setScissorRectangle(_scissorRect);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Stage3DProxy.prototype, "stage3DIndex", {
            /**
             * 3D舞台编号
             */
            get: function () {
                return _stage3DIndex;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Stage3DProxy.prototype, "stage3D", {
            /**
             * 3D舞台
             */
            get: function () {
                return _stage3D;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Stage3DProxy.prototype, "context3D", {
            /**
             * 3D环境
             */
            get: function () {
                return _context3D;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Stage3DProxy.prototype, "driverInfo", {
            /**
             * 驱动信息
             */
            get: function () {
                return _context3D ? _context3D.driverInfo : null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Stage3DProxy.prototype, "usesSoftwareRendering", {
            /**
             * 是否在软件模式渲染
             */
            get: function () {
                return _usesSoftwareRendering;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Stage3DProxy.prototype, "x", {
            /**
             * 3D舞台X坐标
             */
            get: function () {
                return _stage3D.x;
            },
            set: function (value) {
                if (_viewPort.x == value)
                    return;
                _stage3D.x = _viewPort.x = value;
                notifyViewportUpdated();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Stage3DProxy.prototype, "y", {
            /**
             * 3D舞台Y坐标
             */
            get: function () {
                return _stage3D.y;
            },
            set: function (value) {
                if (_viewPort.y == value)
                    return;
                _stage3D.y = _viewPort.y = value;
                notifyViewportUpdated();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Stage3DProxy.prototype, "width", {
            /**
             * 3D舞台宽度
             */
            get: function () {
                return _backBufferWidth;
            },
            set: function (width) {
                if (_viewPort.width == width)
                    return;
                if (width < 50)
                    width = 50;
                _backBufferWidth = _viewPort.width = width;
                _backBufferDirty = true;
                notifyViewportUpdated();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Stage3DProxy.prototype, "height", {
            /**
             * 3D舞台高度
             */
            get: function () {
                return _backBufferHeight;
            },
            set: function (height) {
                if (_viewPort.height == height)
                    return;
                if (height < 50)
                    height = 50;
                _backBufferHeight = _viewPort.height = height;
                _backBufferDirty = true;
                notifyViewportUpdated();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Stage3DProxy.prototype, "antiAlias", {
            /**
             * 抗锯齿值
             */
            get: function () {
                return _antiAlias;
            },
            set: function (antiAlias) {
                _antiAlias = antiAlias;
                _backBufferDirty = true;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Stage3DProxy.prototype, "viewPort", {
            /**
             * 视窗矩形
             */
            get: function () {
                _viewportDirty = false;
                return _viewPort;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Stage3DProxy.prototype, "visible", {
            /**
             * 是否可见
             */
            get: function () {
                return _stage3D.visible;
            },
            set: function (value) {
                _stage3D.visible = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Stage3DProxy.prototype, "bufferClear", {
            /**
             * 缓冲区清理状态
             */
            get: function () {
                return _bufferClear;
            },
            set: function (newBufferClear) {
                _bufferClear = newBufferClear;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 释放3D环境
         */
        Stage3DProxy.prototype.freeContext3D = function () {
            if (this._context3D) {
                this._context3D.dispose();
                this.dispatchEvent(new feng3d.Stage3DEvent(feng3d.Stage3DEvent.CONTEXT3D_DISPOSED));
            }
            this._context3D = null;
        };
        /**
         * 处理3D环境变化事件
         */
        Stage3DProxy.prototype.onContext3DUpdate = function (event) {
            if (this._stage3D.context3D) {
                var hadContext = (this._context3D != null);
                this._context3D = this._stage3D.context3D;
                this._context3D.enableErrorChecking = feng3d.Debug.agalDebug;
                this._usesSoftwareRendering = (this._context3D.driverInfo.indexOf('Software') == 0);
                // Only configure back buffer if this.width and this.height have been set,
                // which they may not have been if View3D.render() has yet to be
                // invoked for the first time.
                if (this._backBufferWidth && this._backBufferHeight)
                    this._context3D.configureBackBuffer(this._backBufferWidth, this._backBufferHeight, this._antiAlias, this._backBufferEnableDepthAndStencil);
                // Dispatch the appropriate event depending on whether context was
                // created for the first time or recreated after a device loss.
                this.dispatchEvent(new feng3d.Stage3DEvent(hadContext ? feng3d.Stage3DEvent.CONTEXT3D_RECREATED : feng3d.Stage3DEvent.CONTEXT3D_CREATED));
            }
            else
                throw new Error("Rendering context lost!");
        };
        /**
         * 请求3D环境
         */
        Stage3DProxy.prototype.requestContext = function (forceSoftware, profile) {
            if (forceSoftware === void 0) { forceSoftware = false; }
            if (profile === void 0) { profile = Context3DProfile.STANDARD; }
            // If forcing software, we can be certain that the
            // returned Context3D will be running software mode.
            // If not, we can't be sure and should stick to the
            // old value (will likely be same if re-requesting.)
            this._usesSoftwareRendering || ;
            forceSoftware;
            this._profile = profile;
            // ugly stuff for backward compatibility
            var renderMode = forceSoftware ? Context3DRenderMode.SOFTWARE : Context3DRenderMode.AUTO;
            if (profile == "baseline")
                this._stage3D.requestContext3D(renderMode);
            else {
                try {
                    this._stage3D.requestContext3D(renderMode, profile);
                }
                catch (error) {
                    throw "An error occurred creating a context using the given profile. Profiles are not supported for the SDK this was compiled with.";
                }
            }
            this._contextRequested = true;
        };
        /**
         * 处理进入帧事件
         */
        Stage3DProxy.prototype.onEnterFrame = function (event) {
            if (!this._context3D)
                return;
            this.clear();
            this.notifyEnterFrame();
            this.present();
            this.notifyExitFrame();
        };
        /**
         *	判断3D环境是否可用
         */
        Stage3DProxy.prototype.recoverFromDisposal = function () {
            if (!this._context3D)
                return false;
            if (this._context3D.driverInfo == "Disposed") {
                this._context3D = null;
                this.dispatchEvent(new feng3d.Stage3DEvent(feng3d.Stage3DEvent.CONTEXT3D_DISPOSED));
                return false;
            }
            return true;
        };
        return Stage3DProxy;
    }(feng3d.EventDispatcher));
    feng3d.Stage3DProxy = Stage3DProxy;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    _proxy;
    dynamic;
    var Register = (function (_super) {
        __extends(Register, _super);
        /**
         * 创建一个寄存器
         * @param regId			寄存器id
         */
        function Register(regId) {
            this._index = -1;
            /**
             * 获取寄存器分量
             * @param name 分量名称
             * @return
             */
            this.override = flash_proxy;
            this._regId = regId;
            this.init();
        }
        Object.defineProperty(Register.prototype, "valueString", {
            get: function () {
                if (_regType != feng3d.RegisterType.OP && _regType != feng3d.RegisterType.OC)
                    return _regType + _index;
                return _regType;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Register.prototype, "nameString", {
            get: function () {
                return regId;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Register.prototype, "index", {
            /**
             * 寄存器编号
             */
            get: function () {
                return _index;
            },
            set: function (value) {
                _index = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Register.prototype, "regId", {
            /** 寄存器id */
            get: function () {
                return _regId;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Register.prototype, "regType", {
            get: function () {
                return _regType;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 初始化
         */
        Register.prototype.init = function () {
            var bufferType = feng3d.Context3DBufferTypeManager.getBufferType(this._regId);
            this._regType = bufferType.registerType;
            this._index = -1;
        };
        /**
         * @inheritDoc
         */
        Register.prototype.toString = function () {
            if (Register.TO_STRING == Register.NAME)
                return this.nameString;
            return this.valueString;
        };
        /**
         * 寄存器分量
         * @param component 分量编号
         * @return 寄存器分量
         */
        Register.prototype.c = function (component) {
            return new feng3d.RegisterComponent(this, COMPONENTS[component]);
        };
        /**
         * 输出寄存器名称
         */
        Register.NAME = "name";
        /**
         * 输出寄存器值
         */
        Register.VALUE = "value";
        /**
         * 寄存器输出方式
         */
        Register.TO_STRING = NAME;
        /**
         * 寄存器中元素数组
         */
        Register.COMPONENTS = ["x", "y", "z", "w"];
        return Register;
    }(Proxy));
     *
        {
            var: components, string: string,
            if: function (components, length) { },
            throw: new Error("无效寄存器分量: " + this + "." + components),
            if: function (components, length) { },
            throw: new Error("无效寄存器分量: " + this + "." + components),
            for: function () { }, var: i, number: number, i: function () { } }++;
    {
        if (!feng3d.RegisterComponent.valid(components.substr(i, 1)))
            throw new Error("无效寄存器分量: " + this + "." + components);
    }
    if (components.length == 1) {
        return new feng3d.RegisterComponent(this, components.toLowerCase());
    }
    return new feng3d.RegisterComponentSelection(this, components.toLowerCase());
})(feng3d || (feng3d = {}));
/**
 * @inheritDoc
 */
override;
flash_proxy;
 *
    {
        return: null
    };
get;
desc();
string;
{
    var str = regId + ":";
    if (index != -1) {
        str += valueString;
    }
    if (description && description.length > 0)
        return str += "[" + description + "]";
    return str;
}
get;
regLen();
number;
{
    return 1;
}
clear();
{
    this.index = -1;
}
var feng3d;
(function (feng3d) {
    /**
     * 寄存器数组
     * @author feng 2014-11-4
     */
    var RegisterArray = (function (_super) {
        __extends(RegisterArray, _super);
        /**
         * 创建一个寄存器数组
         * @param regId		寄存器id
         */
        function RegisterArray(regId) {
            this._regs = new Register[]();
            this._regs.length = 1;
            _super.call(this, regId);
        }
        Object.defineProperty(RegisterArray.prototype, "first", {
            /**
             * 第一个寄存器
             */
            get: function () {
                return getReg(0);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RegisterArray.prototype, "last", {
            /**
             * 最后一个寄存器
             */
            get: function () {
                return getReg(_regs.length - 1);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 获取寄存器链表中的元素
         * @param $index 链表中的位置
         * @return 寄存器
         */
        RegisterArray.prototype.getReg = function ($index) {
            if (this._regs.length < $index + 1) {
                this._regs.length = $index + 1;
            }
            if (!this._regs[$index]) {
                var reg = new feng3d.RegisterArrayItem(this, $index);
                this._regs[$index] = reg;
            }
            return this._regs[$index];
        };
        /**
         * 获取寄存器数组中的寄存器
         * @param args 索引信息
         * @return
         */
        RegisterArray.prototype.getReg1 = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var index = 0;
            var complexArgs = [];
            for (var i = 0; i < args.length; i++) {
                if (args[i])
                    is;
                number;
                {
                    index += args[i];
                }
            }
        };
        return RegisterArray;
    }(Register));
    feng3d.RegisterArray = RegisterArray;
    {
        complexArgs.push(args[i]);
    }
})(feng3d || (feng3d = {}));
if (complexArgs.length == 0)
    return this.getReg(index);
return new RegisterArrayComplexItem(this, complexArgs, index);
get;
regLen();
number;
{
    return _regs.length;
}
set;
regLen(value, number);
{
    _regs.length = value;
}
clear();
{
    this.regLen = 1;
    _super.clear.call(this);
}
var feng3d;
(function (feng3d) {
    /**
     * 寄存器矩阵
     * @author feng 2014-11-4
     */
    var RegisterMatrix = (function (_super) {
        __extends(RegisterMatrix, _super);
        /**
         *
         * @param regId
         */
        function RegisterMatrix(regId) {
            _super.call(this, regId);
            this.regLen = 4;
        }
        /**
         * @inheritDoc
         */
        RegisterMatrix.prototype.clear = function () {
            this.regLen = 4;
            this.index = -1;
        };
        return RegisterMatrix;
    }(feng3d.RegisterArray));
    feng3d.RegisterMatrix = RegisterMatrix;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 寄存器数组元素
     * @author feng 2014-11-3
     */
    var RegisterArrayItem = (function (_super) {
        __extends(RegisterArrayItem, _super);
        /**
         * 创建一个寄存器数组元素
         * @param registerArray			所属寄存器数组
         * @param arrayIndex			所在寄存器数组中的索引
         */
        function RegisterArrayItem(registerArray, arrayIndex) {
            _super.call(this, registerArray.regId);
            this._registerArray = registerArray;
            this._arrayIndex = arrayIndex;
        }
        RegisterArrayItem.prototype.toString = function () {
            if (Register.TO_STRING == Register.NAME)
                return this.regId + "[" + this._arrayIndex + "]";
            if (_regType != feng3d.RegisterType.OP && _regType != feng3d.RegisterType.OC)
                return this.regType + (this._arrayIndex + this._registerArray.index);
            return _regType;
        };
        return RegisterArrayItem;
    }(Register));
    feng3d.RegisterArrayItem = RegisterArrayItem;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 寄存器数组复杂元素
     * @author feng 2014-11-3
     */
    var RegisterArrayComplexItem = (function (_super) {
        __extends(RegisterArrayComplexItem, _super);
        /**
         * 创建一个寄存器数组复杂元素
         * @param registerArray			所属寄存器数组
         * @param complexArgs			复杂参数（用来计算所在寄存器数组中的索引值）
         * @param arrayIndex			起始索引值
         */
        function RegisterArrayComplexItem(registerArray, complexArgs, startIndex) {
            this._complexArgs = complexArgs;
            _super.call(this, registerArray, startIndex);
        }
        Object.defineProperty(RegisterArrayComplexItem.prototype, "complexArgs", {
            /**
             * 复杂参数（用来计算所在寄存器数组中的索引值）
             */
            get: function () {
                return _complexArgs;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        RegisterArrayComplexItem.prototype.toString = function () {
            var _numStr = this._complexArgs.join("+");
            if (Register.TO_STRING == Register.NAME)
                return this.regId + "[" + _numStr + "+" + _arrayIndex + "]";
            if (_regType != feng3d.RegisterType.OP && _regType != feng3d.RegisterType.OC)
                return this.regType + "[" + _numStr + "+" + (_arrayIndex + _registerArray.index) + "]";
            return _regType;
        };
        return RegisterArrayComplexItem;
    }(feng3d.RegisterArrayItem));
    feng3d.RegisterArrayComplexItem = RegisterArrayComplexItem;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 寄存器池
     * @author feng 2014-6-9
     */
    var RegisterPool = (function () {
        /**
         * 创建寄存器池
         * @param regType 寄存器类型
         * @param regCount 寄存器总数
         */
        function RegisterPool(regType, regCount) {
            this._regType = regType;
            this._regCount = regCount;
            this.init();
        }
        Object.defineProperty(RegisterPool.prototype, "regCount", {
            /**
             * 寄存器总数
             */
            get: function () {
                return _regCount;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RegisterPool.prototype, "regType", {
            /**
             * 寄存器类型
             */
            get: function () {
                return _regType;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 初始化
         */
        RegisterPool.prototype.init = function () {
            this.usedRegisters = [];
        };
        /**
         * 获取寄存器
         * @param num 寄存器个数
         */
        RegisterPool.prototype.requestFreeRegisters = function (num) {
            var index = this.find(num);
            if (index == -1)
                throw new Error(this._regType + "寄存器不够用!");
            var reg = new feng3d.RegisterValue();
            reg.regType = this._regType;
            reg.index = index;
            reg.length = num;
            for (var i = 0; i < num; i++) {
                this.usedRegisters[index + i] = true;
            }
            return reg;
        };
        /**
         * 移除使用寄存器
         * @param register 寄存器
         */
        RegisterPool.prototype.removeUsage = function (register) {
            //只允许临时寄存器移除寄存器
            if (feng3d.RegisterType.isTemp(register.regType)) {
                for (var i = 0; i < register.regLen; i++) {
                    this.usedRegisters[register.index + i] = false;
                }
            }
        };
        /**
         * 销毁
         */
        RegisterPool.prototype.dispose = function () {
            this.usedRegisters = null;
        };
        /**
         * 重置
         */
        RegisterPool.prototype.reset = function () {
            this.usedRegisters = [];
        };
        /**
         * 寻找连续可用寄存器编号
         * @param num 个数
         * @return 如果找到返回非负值，未找到返回-1
         */
        RegisterPool.prototype.find = function (num) {
            if (num === void 0) { num = 1; }
            var cNum = 0;
            for (var i = 0; i < this._regCount; i++) {
                if (!this.usedRegisters[i])
                    cNum++;
                else
                    cNum = 0;
                if (cNum == num)
                    return i - cNum + 1;
            }
            return -1;
        };
        return RegisterPool;
    }());
    feng3d.RegisterPool = RegisterPool;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 寄存器类型
     * @author feng 2014-6-9
     */
    var RegisterType = (function () {
        function RegisterType() {
        }
        /**
         * 是否常量
         * @param regType		寄存器类型
         */
        RegisterType.isConst = function (regType) {
            return regType == VC || regType == FC;
        };
        /**
         * 是否临时变量
         * @param regType		寄存器类型
         */
        RegisterType.isTemp = function (regType) {
            return regType == VT || regType == FT;
        };
        /**
         * 是否只读
         * @param regType		寄存器类型
         * @return
         */
        RegisterType.isReadOnly = function (regType) {
            switch (regType) {
                case VA:
                    return true;
                case VC:
                    return true;
                case VT:
                    return false;
                case OP:
                    return false;
                case V:
                    return false;
                case FS:
                    return true;
                case FC:
                    return true;
                case FT:
                    return false;
                case OC:
                    return false;
            }
            throw new Error("错误寄存器类型");
        };
        /**
         * 是否可以在顶点寄存器中出现
         * @param regType		寄存器类型
         * @return
         */
        RegisterType.inVertex = function (regType) {
            switch (regType) {
                case VA:
                    return true;
                case VC:
                    return true;
                case VT:
                    return true;
                case OP:
                    return true;
                case V:
                    return true;
                case FS:
                    return false;
                case FC:
                    return false;
                case FT:
                    return false;
                case OC:
                    return false;
            }
            throw new Error("错误寄存器类型");
        };
        /**
         * 是否可以在片段寄存器中出现
         * @param regType		寄存器类型
         * @return
         */
        RegisterType.inFragment = function (regType) {
            switch (regType) {
                case VA:
                    return false;
                case VC:
                    return false;
                case VT:
                    return false;
                case OP:
                    return false;
                case V:
                    return true;
                case FS:
                    return true;
                case FC:
                    return true;
                case FT:
                    return true;
                case OC:
                    return true;
            }
            throw new Error("错误寄存器类型");
        };
        /**
         * 是否为输入数据寄存器
         * @param regType		寄存器类型
         * @return
         */
        RegisterType.isInputDataRegister = function (regType) {
            switch (regType) {
                case VA:
                    return true;
                case VC:
                    return true;
                case VT:
                    return false;
                case OP:
                    return false;
                case V:
                    return false;
                case FS:
                    return true;
                case FC:
                    return true;
                case FT:
                    return false;
                case OC:
                    return false;
            }
            throw new Error("错误寄存器类型");
        };
        /** 顶点属性寄存器 */
        RegisterType.VA = "va";
        /** 顶点程序常量寄存器 */
        RegisterType.VC = "vc";
        /** 顶点临时寄存器 */
        RegisterType.VT = "vt";
        /** 顶点程序输出寄存器 */
        RegisterType.OP = "op";
        /**变量寄存器 */
        RegisterType.V = "v";
        /** 片段程序的纹理寄存器 */
        RegisterType.FS = "fs";
        /** 片段程序常量寄存器 */
        RegisterType.FC = "fc";
        /** 片段程序临时寄存器 */
        RegisterType.FT = "ft";
        /** 片段程序输出寄存器 */
        RegisterType.OC = "oc";
        return RegisterType;
    }());
    feng3d.RegisterType = RegisterType;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 寄存器值
     * @author feng 2015-7-30
     */
    var RegisterValue = (function () {
        function RegisterValue() {
            /**
             * 寄存器长度
             */
            this.length = 1;
        }
        /**
         * 输出为字符串
         */
        RegisterValue.prototype.toString = function () {
            if (this.regType == feng3d.RegisterType.OP || this.regType == feng3d.RegisterType.OC)
                return this.regType;
            return this.regType + this.index;
        };
        return RegisterValue;
    }());
    feng3d.RegisterValue = RegisterValue;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 渲染寄存器缓存
     * @author feng 2014-6-5
     */
    var ShaderRegisterCache = (function () {
        /**
         * 创建渲染寄存器缓存
         */
        function ShaderRegisterCache() {
            if (_instance)
                throw new Error("ShaderRegisterCache 单例");
            _instance = this;
            this.init();
        }
        /**
         * 初始化
         */
        ShaderRegisterCache.prototype.init = function () {
            this._dataRegisterDic = {};
            this.registerPoolDic = {};
            this.usedDataRegisterNum = 0;
            for (var i = 0; i < this.registerConfig.length; i++) {
                this.registerPoolDic[this.registerConfig[i][0]] = new feng3d.RegisterPool(this.registerConfig[i][0], this.registerConfig[i][1]);
            }
            _dirty = false;
        };
        /**
         * 重置
         */
        ShaderRegisterCache.prototype.reset = function () {
            this._dataRegisterDic = {};
            this.usedDataRegisterNum = 0;
            for (each(); ; )
                var registerPool;
             in this.registerPoolDic;
            {
                registerPool.reset();
            }
            _dirty = false;
        };
        /**
         * 回收不需要再使用的临时寄存器
         * @param register 不需要再使用的临时寄存器
         */
        ShaderRegisterCache.prototype.removeTempUsage = function (dataTypeId) {
            var register = FagalRegisterCenter.dataRegisterDic[dataTypeId];
            if (!register)
                return;
            var _fragmentTempCache = this.registerPoolDic[register.regType];
            _fragmentTempCache.removeUsage(register);
        };
        /**
         * 申请数据寄存器
         * @param dataType 数据类型
         * @param numRegister 寄存器的个数(默认1个)
         * @return 数据寄存器
         */
        ShaderRegisterCache.prototype.requestRegister = function (dataTypeId) {
            if (this._dataRegisterDic[dataTypeId])
                return;
            var register = FagalRegisterCenter.dataRegisterDic[dataTypeId];
            var registerPool = this.registerPoolDic[register.regType];
            var registerValue = registerPool.requestFreeRegisters(register.regLen);
            registerValue.dataTypeId = register.regId;
            register.index = registerValue.index;
            this._dataRegisterDic[dataTypeId] = registerValue;
            this.usedDataRegisterNum++;
        };
        /**
         * 是否存在 dataType 类型寄存器
         * @param dataType 数据类型
         * @return
         */
        ShaderRegisterCache.prototype.hasReg = function (dataType) {
            return this._dataRegisterDic[dataType] != null;
        };
        /**
         * 注销
         */
        ShaderRegisterCache.prototype.dispose = function () {
            for (each(); ; )
                var registerPool;
             in this.registerPoolDic;
            {
                registerPool.dispose();
            }
            this._dataRegisterDic = null;
            this.registerPoolDic = null;
        };
        Object.defineProperty(ShaderRegisterCache, "instance", {
            /**
             * 实例
             */
            get: function () {
                _instance || new ShaderRegisterCache();
                if (_dirty)
                    _instance.reset();
                return _instance;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 使缓存失效
         */
        ShaderRegisterCache.invalid = function () {
            _dirty = true;
        };
        Object.defineProperty(ShaderRegisterCache.prototype, "dataRegisterDic", {
            /**
             * 数据寄存器缓存
             */
            get: function () {
                return _dataRegisterDic;
            },
            enumerable: true,
            configurable: true
        });
        /** 脏标记 */
        ShaderRegisterCache._dirty = true;
        //		/** 寄存器配置 */
        //		private registerConfig:Array = //
        //			[[RegisterType.VA, 8], //
        //			[RegisterType.VC, 128], //
        //			[RegisterType.VT, 8], //
        //			[RegisterType.V, 8], //
        //			[RegisterType.FS, 8], //
        //			[RegisterType.FC, 28], //
        //			[RegisterType.FT, 8], //
        //			[RegisterType.OP, 1], //
        //			[RegisterType.OC, 1], //
        //			];
        /**
         * AGAL2寄存器配置
         */
        ShaderRegisterCache.registerConfig = [[feng3d.RegisterType.VA, 8],
            [feng3d.RegisterType.VC, 250],
            [feng3d.RegisterType.VT, 26],
            [feng3d.RegisterType.V, 10],
            [feng3d.RegisterType.FS, 8],
            [feng3d.RegisterType.FC, 64],
            [feng3d.RegisterType.FT, 16],
            [feng3d.RegisterType.OP, 1],
            [feng3d.RegisterType.OC, 1],
        ];
        return ShaderRegisterCache;
    }());
    feng3d.ShaderRegisterCache = ShaderRegisterCache;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 渲染器抽象基类
     * @author feng 2015-3-1
     */
    var RendererBase = (function () {
        /**
         * 创建一个渲染创新基类
         * @param renderToTexture		释放渲染到纹理
         */
        function RendererBase(renderToTexture) {
            if (renderToTexture === void 0) { renderToTexture = false; }
            //背景颜色
            this._backgroundR = 0;
            this._backgroundG = 0;
            this._backgroundB = 0;
            this._backgroundColor = 0;
            this._backgroundAlpha = 1;
            this._textureRatioX = 1;
            this._textureRatioY = 1;
            this._shareContext = false;
            this._renderableSorter = new feng3d.RenderableMergeSort();
        }
        /**
         * 创建一个实体收集器
         */
        RendererBase.prototype.createEntityCollector = function () {
            return new feng3d.EntityCollector();
        };
        Object.defineProperty(RendererBase.prototype, "viewWidth", {
            /**
             * 窗口宽度
             */
            get: function () {
                return _viewWidth;
            },
            set: function (value) {
                _viewWidth = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RendererBase.prototype, "viewHeight", {
            /**
             * 窗口高度
             */
            get: function () {
                return _viewHeight;
            },
            set: function (value) {
                _viewHeight = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RendererBase.prototype, "backgroundAlpha", {
            /**
             * 背景颜色透明度部分
             */
            get: function () {
                return _backgroundAlpha;
            },
            set: function (value) {
                _backgroundAlpha = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RendererBase.prototype, "backgroundColor", {
            /**
             * 背景颜色
             */
            get: function () {
                return _backgroundColor;
            },
            set: function (value) {
                _backgroundR = ((value >> 16) & 0xff) / 0xff;
                _backgroundG = ((value >> 8) & 0xff) / 0xff;
                _backgroundB = (value & 0xff) / 0xff;
                _backgroundColor = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RendererBase.prototype, "shareContext", {
            /**
             * Defers control of Context3D clear() and present() calls to Stage3DProxy, enabling multiple Stage3D frameworks
             * to share the same Context3D object.
             *
             * @private
             */
            get: function () {
                return _shareContext;
            },
            set: function (value) {
                _shareContext = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 释放
         */
        RendererBase.prototype.dispose = function () {
        };
        /**
         * 渲染潜在可见几何体到缓冲区或纹理
         * @param stage3DProxy			3D舞台代理
         * @param entityCollector 		实体收集器
         * @param target 				目标纹理，默认为null表示渲染到缓冲区
         */
        RendererBase.prototype.render = function (stage3DProxy, entityCollector, target) {
            if (target === void 0) { target = null; }
            var _context = stage3DProxy.context3D;
            if (!stage3DProxy || !_context)
                return;
            //执行渲染
            this.executeRender(stage3DProxy, entityCollector, target);
            //清除3D环境缓存
            for (var i = 0; i < 8; ++i) {
                _context.setVertexBufferAt(i, null);
                _context.setTextureAt(i, null);
            }
        };
        /**
         * 执行渲染
         * @param stage3DProxy			3D舞台代理
         * @param entityCollector		实体收集器
         * @param target				渲染目标
         */
        RendererBase.prototype.executeRender = function (stage3DProxy, entityCollector, target) {
            if (target === void 0) { target = null; }
            var _context = stage3DProxy.context3D;
            if (this._renderableSorter)
                this._renderableSorter.sort(entityCollector);
            this._renderIndex = 0;
            //重置3D环境背景颜色
            if ((target || !this._shareContext))
                _context.clear(this._backgroundR, this._backgroundG, this._backgroundB, this._backgroundAlpha, 1, 0);
            _context.setDepthTest(false, Context3DCompareMode.ALWAYS);
            //绘制
            this.draw(stage3DProxy, entityCollector, target);
        };
        /**
         * 绘制
         * @param stage3DProxy			3D舞台代理
         * @param entityCollector		实体收集器
         * @param target				渲染目标
         */
        RendererBase.prototype.draw = function (stage3DProxy, entityCollector, target) {
            throw new feng3d.AbstractMethodError();
        };
        return RendererBase;
    }());
    feng3d.RendererBase = RendererBase;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 默认渲染器，使用根据材质渲染场景图
     * @author feng 2015-3-5
     */
    var DefaultRenderer = (function (_super) {
        __extends(DefaultRenderer, _super);
        /**
         * 创建一个默认渲染器
         */
        function DefaultRenderer() {
            _super.call(this);
            /**
             * @inheritDoc
             */
            this.override = function executeRender(stage3DProxy, entityCollector, target) {
                if (target === void 0) { target = null; }
                if (!usePlanarShadow) {
                    this.updateLights(stage3DProxy, entityCollector);
                }
                _super.executeRender.call(this, stage3DProxy, entityCollector, target);
                if (usePlanarShadow) {
                    this._planarShadowRenderer.render(stage3DProxy, entityCollector, target);
                }
            };
            this._depthRenderer = new feng3d.DepthRenderer();
            this._planarShadowRenderer = new feng3d.PlanarShadowRenderer();
        }
        /**
         * @inheritDoc
         */
        DefaultRenderer.prototype.draw = function (stage3DProxy, entityCollector, target) {
            var _context = stage3DProxy.context3D;
            _context.setBlendFactors(Context3DBlendFactor.ONE, Context3DBlendFactor.ZERO);
            if (entityCollector.skyBox) {
                if (this._activeMaterial)
                    this._activeMaterial.deactivate();
                this._activeMaterial = null;
                _context.setDepthTest(false, Context3DCompareMode.ALWAYS);
                this.drawSkyBox(stage3DProxy, entityCollector);
            }
            _context.setDepthTest(true, Context3DCompareMode.LESS_EQUAL);
            this.drawRenderables(stage3DProxy, entityCollector.opaqueRenderableHead, entityCollector);
            this.drawRenderables(stage3DProxy, entityCollector.blendedRenderableHead, entityCollector);
            _context.setDepthTest(false, Context3DCompareMode.LESS_EQUAL);
            if (this._activeMaterial)
                this._activeMaterial.deactivate();
            this._activeMaterial = null;
        };
        /**
         * Draw the skybox if present.
         * @param entityCollector The EntityCollector containing all potentially visible information.
         */
        /**
         * 绘制天空盒
         * @param stage3DProxy				3D舞台代理
         * @param entityCollector			实体收集器
         *
         */
        DefaultRenderer.prototype.drawSkyBox = function (stage3DProxy, entityCollector) {
            var renderable = entityCollector.skyBox.subMeshes[0].renderableBase;
            var camera = entityCollector.camera;
            var material = renderable.material;
            material.updateMaterial();
            var pass = material.getPass(0);
            //初始化渲染参数
            pass.shaderParams.initParams();
            //激活渲染通道
            pass.activate(camera);
            pass.render(renderable, stage3DProxy, camera, _renderIndex++);
            pass.deactivate();
        };
        /**
         * 绘制可渲染列表
         * @param renderables 			可渲染列表
         * @param entityCollector 		实体收集器，包含所有潜在显示实体信息
         */
        DefaultRenderer.prototype.drawRenderables = function (stage3DProxy, item, entityCollector) {
            var numPasses;
            var j;
            var camera = entityCollector.camera;
            var item2;
            while (item) {
                this._activeMaterial = item.renderable.material;
                this._activeMaterial.updateMaterial();
                numPasses = this._activeMaterial.numPasses;
                j = 0;
                do {
                    item2 = item;
                    var pass = this._activeMaterial.getPass(j);
                    //初始化渲染参数
                    pass.shaderParams.initParams();
                    //激活渲染通道
                    pass.activate(camera);
                    do {
                        pass.render(item2.renderable, stage3DProxy, camera, _renderIndex++);
                        item2 = item2.next;
                    } while (item2 && item2.renderable.material == this._activeMaterial);
                    this._activeMaterial.deactivatePass(j);
                } while (++j < numPasses);
                item = item2;
            }
        };
        /**
         * 更新灯光
         * @param stage3DProxy				3D场景代理
         * @param entityCollector			实体集合
         */
        DefaultRenderer.prototype.updateLights = function (stage3DProxy, entityCollector) {
            var dirLights = entityCollector.directionalLights;
            var len, i;
            var light;
            var shadowMapper;
            len = dirLights.length;
            for (i = 0; i < len; ++i) {
                light = dirLights[i];
                shadowMapper = light.shadowMapper;
                if (light.castsShadows && (shadowMapper.autoUpdateShadows || shadowMapper._shadowsInvalid))
                    shadowMapper.renderDepthMap(stage3DProxy, entityCollector, this._depthRenderer);
            }
        };
        DefaultRenderer.SCREEN_PASSES = 2;
        DefaultRenderer.ALL_PASSES = 3;
        return DefaultRenderer;
    }(feng3d.RendererBase));
    feng3d.DefaultRenderer = DefaultRenderer;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 深度渲染器
     * @author feng 2015-5-28
     */
    var DepthRenderer = (function (_super) {
        __extends(DepthRenderer, _super);
        /**
         * 创建一个深度渲染器
         */
        function DepthRenderer() {
            _super.call(this);
            _backgroundR = 1;
            _backgroundG = 1;
            _backgroundB = 1;
        }
        /**
         * @inheritDoc
         */
        DepthRenderer.prototype.draw = function (stage3DProxy, entityCollector, target) {
            var _context = stage3DProxy.context3D;
            _context.setBlendFactors(Context3DBlendFactor.ONE, Context3DBlendFactor.ZERO);
            _context.setDepthTest(true, Context3DCompareMode.LESS);
            this.drawRenderables(stage3DProxy, entityCollector.opaqueRenderableHead, entityCollector, target);
            this._activeMaterial = null;
        };
        /**
         * 绘制渲染列表
         * @param stage3DProxy			3D场景代理
         * @param item					渲染对象列表单元
         * @param entityCollector		实体集合
         * @param target				渲染目标
         */
        DepthRenderer.prototype.drawRenderables = function (stage3DProxy, item, entityCollector, target) {
            var camera = entityCollector.camera;
            var item2;
            while (item) {
                this._activeMaterial = item.renderable.material;
                var depthPass = this._activeMaterial.depthPass;
                //初始化渲染参数
                depthPass.shaderParams.initParams();
                //激活渲染通道
                depthPass.activate(camera, target);
                item2 = item;
                do {
                    depthPass.render(item2.renderable, stage3DProxy, camera, _renderIndex++);
                    item2 = item2.next;
                } while (item2 && item2.renderable.material == this._activeMaterial);
                depthPass.deactivate();
                item = item2;
            }
        };
        return DepthRenderer;
    }(feng3d.RendererBase));
    feng3d.DepthRenderer = DepthRenderer;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 平面阴影渲染器
     * @author feng 2015-8-23
     */
    var PlanarShadowRenderer = (function (_super) {
        __extends(PlanarShadowRenderer, _super);
        /**
         * 创建一个深度渲染器
         */
        function PlanarShadowRenderer() {
            _super.call(this);
        }
        /**
         * @inheritDoc
         */
        PlanarShadowRenderer.prototype.executeRender = function (stage3DProxy, entityCollector, target) {
            if (target === void 0) { target = null; }
            var _context = stage3DProxy.context3D;
            if (_renderableSorter)
                _renderableSorter.sort(entityCollector);
            _context.setDepthTest(false, Context3DCompareMode.ALWAYS);
            //绘制
            this.draw(stage3DProxy, entityCollector, target);
        };
        /**
         * @inheritDoc
         */
        PlanarShadowRenderer.prototype.draw = function (stage3DProxy, entityCollector, target) {
            var _context = stage3DProxy.context3D;
            _context.setBlendFactors(Context3DBlendFactor.ONE, Context3DBlendFactor.ZERO);
            _context.setDepthTest(true, Context3DCompareMode.LESS);
            this.drawRenderables(stage3DProxy, entityCollector.opaqueRenderableHead, entityCollector, target);
            this._activeMaterial = null;
        };
        /**
         * 绘制渲染列表
         * @param stage3DProxy			3D场景代理
         * @param item					渲染对象列表单元
         * @param entityCollector		实体集合
         * @param target				渲染目标
         */
        PlanarShadowRenderer.prototype.drawRenderables = function (stage3DProxy, item, entityCollector, target) {
            var camera = entityCollector.camera;
            var item2;
            while (item) {
                this._activeMaterial = item.renderable.material;
                var planarShadowPass = this._activeMaterial.planarShadowPass;
                //初始化渲染参数
                planarShadowPass.shaderParams.initParams();
                //激活渲染通道
                planarShadowPass.activate(camera, target);
                item2 = item;
                do {
                    if (item2.renderable.castsShadows) {
                        planarShadowPass.render(item2.renderable, stage3DProxy, camera, _renderIndex++);
                    }
                    item2 = item2.next;
                } while (item2 && item2.renderable.material == this._activeMaterial);
                planarShadowPass.deactivate();
                item = item2;
            }
        };
        return PlanarShadowRenderer;
    }(feng3d.RendererBase));
    feng3d.PlanarShadowRenderer = PlanarShadowRenderer;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 可渲染合并排序
     * <p>为了提升渲染性能，排序EntityCollector中潜在显示对象。</p>
     * <p>排序方式优先使用材质，其次是离摄像机的距离。不透明对象从前往后移，当对象需要混合的从后往前移，确保能够正确渲染。</p>
     * @author feng 2015-3-9
     */
    var RenderableMergeSort = (function () {
        /**
         * 创建一个可渲染合并排序对象
         */
        function RenderableMergeSort() {
        }
        /**
         * @inheritDoc
         */
        RenderableMergeSort.prototype.sort = function (collector) {
            collector.opaqueRenderableHead = this.mergeSortByMaterial(collector.opaqueRenderableHead);
            collector.blendedRenderableHead = this.mergeSortByDepth(collector.blendedRenderableHead);
        };
        /**
         * 合并按深度排序
         * @param head			可渲染链表（头元素）
         * @return				排好序的可渲染链表（头元素）
         */
        RenderableMergeSort.prototype.mergeSortByDepth = function (head) {
            var headB;
            var fast, slow;
            if (!head || !head.next)
                return head;
            // split in two sublists
            slow = head;
            fast = head.next;
            while (fast) {
                fast = fast.next;
                if (fast) {
                    slow = slow.next;
                    fast = fast.next;
                }
            }
            headB = slow.next;
            slow.next = null;
            // recurse
            head = this.mergeSortByDepth(head);
            headB = this.mergeSortByDepth(headB);
            // merge sublists while respecting order
            var result;
            var curr;
            var l;
            if (!head)
                return headB;
            if (!headB)
                return head;
            while (head && headB && head != null && headB != null) {
                if (head.zIndex < headB.zIndex) {
                    l = head;
                    head = head.next;
                }
                else {
                    l = headB;
                    headB = headB.next;
                }
                if (!result)
                    result = l;
                else
                    curr.next = l;
                curr = l;
            }
            if (head)
                curr.next = head;
            else if (headB)
                curr.next = headB;
            return result;
        };
        /**
         * 合并按材质排序
         * @param head			可渲染链表（头元素）
         * @return				排好序的可渲染链表（头元素）
         */
        RenderableMergeSort.prototype.mergeSortByMaterial = function (head) {
            var headB;
            var fast, slow;
            if (!head || !head.next)
                return head;
            // split in two sublists
            slow = head;
            fast = head.next;
            while (fast) {
                fast = fast.next;
                if (fast) {
                    slow = slow.next;
                    fast = fast.next;
                }
            }
            headB = slow.next;
            slow.next = null;
            // recurse
            head = this.mergeSortByMaterial(head);
            headB = this.mergeSortByMaterial(headB);
            // merge sublists while respecting order
            var result;
            var curr;
            var l;
            var cmp;
            if (!head)
                return headB;
            if (!headB)
                return head;
            while (head && headB && head != null && headB != null) {
                // first this.sort per render order id (reduces program3D switches),
                // then on material id (reduces setting props),
                // then on zIndex (reduces overdraw)
                var aid = head.renderOrderId;
                var bid = headB.renderOrderId;
                if (aid == bid) {
                    var ma = head.materialId;
                    var mb = headB.materialId;
                    if (ma == mb) {
                        if (head.zIndex < headB.zIndex)
                            cmp = 1;
                        else
                            cmp = -1;
                    }
                    else if (ma > mb)
                        cmp = 1;
                    else
                        cmp = -1;
                }
                else if (aid > bid)
                    cmp = 1;
                else
                    cmp = -1;
                if (cmp < 0) {
                    l = head;
                    head = head.next;
                }
                else {
                    l = headB;
                    headB = headB.next;
                }
                if (!result) {
                    result = l;
                    curr = l;
                }
                else {
                    curr.next = l;
                    curr = l;
                }
            }
            if (head)
                curr.next = head;
            else if (headB)
                curr.next = headB;
            return result;
        };
        return RenderableMergeSort;
    }());
    feng3d.RenderableMergeSort = RenderableMergeSort;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 分区横越者
     * @author feng 2015-3-1
     */
    var PartitionTraverser = (function () {
        /**
         * 构建一个分区横越者
         */
        function PartitionTraverser() {
        }
        /**
         * 进入节点
         * <p>正在穿过节点，或者正在与该节点进行检测</p>
         * @param node 		被进入的节点
         * @return			true：需要进一步检测子节点
         */
        PartitionTraverser.prototype.enterNode = function (node) {
            node = node;
            return true;
        };
        /**
         * 应用天空盒
         * @param skyBox		天空盒
         */
        PartitionTraverser.prototype.applySkyBox = function (skyBox) {
            throw new feng3d.AbstractMethodError();
        };
        /**
         * 应用渲染对象
         * @param renderable		被横越者通过的可渲染对象
         */
        PartitionTraverser.prototype.applyRenderable = function (renderable) {
            throw new feng3d.AbstractMethodError();
        };
        /**
         * 应用方向光源
         * @param light		被横越者通过的方向光源
         */
        PartitionTraverser.prototype.applyDirectionalLight = function (light) {
            throw new feng3d.AbstractMethodError();
        };
        /**
         * 应用点光源
         * @param light		被横越者通过的点光源
         */
        PartitionTraverser.prototype.applyPointLight = function (light) {
            throw new feng3d.AbstractMethodError();
        };
        return PartitionTraverser;
    }());
    feng3d.PartitionTraverser = PartitionTraverser;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 实体收集器
     * <p>为场景分区收集所有场景图中被认为潜在显示对象</p>
     *
     * @see me.feng3d.core.partition.Partition3D
     * @see me.feng3d.entities.Entity
     *
     * @author feng 2015-3-1
     */
    var EntityCollector = (function (_super) {
        __extends(EntityCollector, _super);
        /**
         * 创建一个实体收集器
         */
        function EntityCollector() {
            this.init();
        }
        /**
         * 初始化
         */
        EntityCollector.prototype.init = function () {
            this._lights = new feng3d.LightBase[]();
            this._directionalLights = new feng3d.DirectionalLight[]();
            this._pointLights = new feng3d.PointLight[]();
            this._renderableListItemPool = new feng3d.RenderableListItemPool();
            this._entityListItemPool = new feng3d.EntityListItemPool();
        };
        /**
         * 清除
         */
        EntityCollector.prototype.clear = function () {
            if (this._camera) {
                this._entryPoint = this._camera.scenePosition;
                this._cameraForward = feng3d.Matrix3DUtils.getForward(this._camera.transform3D.transform, this._cameraForward);
            }
            this._cullPlanes = this._customCullPlanes ? this._customCullPlanes : (this._camera ? this._camera.frustumPlanes : null);
            this._numCullPlanes = this._cullPlanes ? this._cullPlanes.length : 0;
            this._numTriangles = this._numMouseEnableds = 0;
            this._blendedRenderableHead = null;
            this._opaqueRenderableHead = null;
            this._renderableListItemPool.freeAll();
            this._entityListItemPool.freeAll();
            this._skyBox = null;
            if (this._numLights > 0)
                this._lights.length = this._numLights = 0;
            if (this._numDirectionalLights > 0)
                this._directionalLights.length = this._numDirectionalLights = 0;
            if (this._numPointLights > 0)
                this._pointLights.length = this._numPointLights = 0;
        };
        Object.defineProperty(EntityCollector.prototype, "camera", {
            /**
             * 提供可见视锥体的摄像机
             */
            get: function () {
                return _camera;
            },
            set: function (value) {
                _camera = value;
                _entryPoint = _camera.scenePosition;
                _cameraForward = feng3d.Matrix3DUtils.getForward(_camera.transform3D.transform, _cameraForward);
                _cullPlanes = _camera.frustumPlanes;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EntityCollector.prototype, "cullPlanes", {
            /**
             * 视椎面
             */
            get: function () {
                return _customCullPlanes;
            },
            set: function (value) {
                _customCullPlanes = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EntityCollector.prototype, "skyBox", {
            /**
             * 天空盒对象
             */
            get: function () {
                return _skyBox;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EntityCollector.prototype, "opaqueRenderableHead", {
            /**
             * 不透明渲染对象链表头
             */
            get: function () {
                return _opaqueRenderableHead;
            },
            set: function (value) {
                _opaqueRenderableHead = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EntityCollector.prototype, "blendedRenderableHead", {
            /**
             * 透明渲染对象链表头
             */
            get: function () {
                return _blendedRenderableHead;
            },
            set: function (value) {
                _blendedRenderableHead = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 添加渲染对象到潜在显示对象中
         * @param renderable	可渲染对象
         */
        EntityCollector.prototype.applyRenderable = function (renderable) {
            var material;
            var entity = renderable.sourceEntity;
            if (renderable.mouseEnabled)
                ++this._numMouseEnableds;
            this._numTriangles += renderable.numTriangles;
            material = renderable.material;
            if (material) {
                var item = this._renderableListItemPool.getItem();
                item.renderable = renderable;
                item.materialId = material._uniqueId;
                item.renderOrderId = material._renderOrderId;
                var entityScenePos = entity.scenePosition;
                var dx = this._entryPoint.x - entityScenePos.x;
                var dy = this._entryPoint.y - entityScenePos.y;
                var dz = this._entryPoint.z - entityScenePos.z;
                // project onto this.camera's z-axis
                item.zIndex = dx * this._cameraForward.x + dy * this._cameraForward.y + dz * this._cameraForward.z + entity.zOffset;
                item.renderSceneTransform = renderable.sourceEntity.getRenderSceneTransform(this.camera);
                if (material.requiresBlending) {
                    item.next = this._blendedRenderableHead;
                    this._blendedRenderableHead = item;
                }
                else {
                    item.next = this._opaqueRenderableHead;
                    this._opaqueRenderableHead = item;
                }
            }
        };
        /**
         * 判断节点是否出现在视锥体中
         * @param node 用于测试的节点
         */
        EntityCollector.prototype.enterNode = function (node) {
            var enter = _collectionMark != node._collectionMark && node.isInFrustum(this._cullPlanes, this._numCullPlanes);
            node._collectionMark = _collectionMark;
            return enter;
        };
        /**
         * @inheritDoc
         */
        EntityCollector.prototype.applySkyBox = function (skyBox) {
            this._skyBox = skyBox;
        };
        /**
         * @inheritDoc
         */
        EntityCollector.prototype.applyDirectionalLight = function (light) {
            this._lights[this._numLights++] = light;
            this._directionalLights[this._numDirectionalLights++] = light;
        };
        /**
         * @inheritDoc
         */
        EntityCollector.prototype.applyPointLight = function (light) {
            this._lights[this._numLights++] = light;
            this._pointLights[this._numPointLights++] = light;
        };
        Object.defineProperty(EntityCollector.prototype, "directionalLights", {
            /**
             * 方向光列表
             */
            get: function () {
                return _directionalLights;
            },
            enumerable: true,
            configurable: true
        });
        return EntityCollector;
    }(feng3d.PartitionTraverser));
    feng3d.EntityCollector = EntityCollector;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 阴影投射者集合
     * @author feng 2015-5-29
     */
    var ShadowCasterCollector = (function (_super) {
        __extends(ShadowCasterCollector, _super);
        /**
         * 创建阴影投射者集合
         */
        function ShadowCasterCollector() {
            _super.call(this);
        }
        /**
         * 应用可渲染对象
         * @param renderable		可渲染对象
         */
        ShadowCasterCollector.prototype.applyRenderable = function (renderable) {
            var material = renderable.material;
            var entity = renderable.sourceEntity;
            //收集可投射阴影的可渲染对象
            if (renderable.castsShadows && material) {
                var item = _renderableListItemPool.getItem();
                item.renderable = renderable;
                item.next = _opaqueRenderableHead;
                var entityScenePos = entity.scenePosition;
                var dx = this._entryPoint.x - entityScenePos.x;
                var dy = this._entryPoint.y - entityScenePos.y;
                var dz = this._entryPoint.z - entityScenePos.z;
                item.zIndex = dx * _cameraForward.x + dy * _cameraForward.y + dz * _cameraForward.z;
                item.renderSceneTransform = renderable.sourceEntity.getRenderSceneTransform(_camera);
                _opaqueRenderableHead = item;
            }
        };
        return ShadowCasterCollector;
    }(feng3d.EntityCollector));
    feng3d.ShadowCasterCollector = ShadowCasterCollector;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * <p>Stats monitor for Away3D or general use in any project. The widget was designed to
     * display all the necessary data in ways that are easily readable, while maintaining a
     * tiny size.</p>
     *
     * <p>The following data is displayed by the widget, either graphically, through
     * text, or both.</p>
     * <ul>
     *   <li>Current frame rate in FPS (white in graph/bar)</li>
     *   <li>SWF frame rate (Stage.frameRate)</li>
     *   <li>Average FPS (blue in graph/bar)</li>
     *   <li>Min/Max FPS (only on frame rate bar in minimized mode)</li>
     *   <li>Current RAM usage (pink in graph)</li>
     *   <li>Maximum RAM usage</li>
     *   <li>number of polygons in scene</li>
     *   <li>number of polygons last rendered (yellow in graph)</li>
     * </ul>
     *
     * <p>There are two display modes; standard and minimized, which are alternated by clicking
     * the button in the upper right corner, at runtime. The widget can also be configured to
     * start in minimized mode by setting the relevant constructor parameter.</p>
     *
     * <p>All data can be reset at any time, by clicking the lower part of the widget (where
     * the RAM and POLY counters are located. The average FPS can be reset separately by
     * clicking it's ²displayed value. Furthermore, the stage frame rate can be increased or
     * decreased by clicking the upper and lower parts of the graph, respectively. Clicking close
     * to the center will increment in small values, and further away will increase the steps.
     * The graph itself is only visible in standard (as opposed to minimized) display mode.</p>
     *
     * <p>The average FPS is calculated using one of two methods, configurable via constructor
     * parameters. By setting the meanDataLength to a non-zero value, the number of recorded
     * frame rate values on which the average is based can be configured. This has a tiny
     * impact on CPU usage, which is the reason why the default number is zero, denoting that
     * the average is calculated from a running sum since the widget was last reset.</p>
     */
    var AwayStats = (function (_super) {
        __extends(AwayStats, _super);
        /**
         * <p>Create an Away3D stats widget. The widget can be added to the stage
         * and positioned like any other display object. Once on the stage, you
         * can drag the widget to re-position it at runtime.</p>
         *
         * <p>If you pass a View3D instance, the widget will be able to display
         * the total number of faces in your scene, and the amount of faces that
         * were rendered during the last render() call. Views can also be registered
         * after construction using the registerView() method. Omit the view
         * constructor parameter to disable this feature altogether.</p>
         *
         * @param view A reference to your Away3D view. This is required if you
         * want the stats widget to display polycounts.
         *
         * @param minimized Defines whether the widget should start up in minimized
         * mode. By default, it is shown in full-size mode on launch.
         *
         * @param transparent Defines whether to omit the background plate and print
         * statistics directly on top of the underlying stage.
         *
         * @param meanDataLength The number of frames on which to base the average
         * frame rate calculation. The default value of zero indicates that all
         * frames since the last reset will be used.
         *
         * @param enableClickToReset Enables interaction allowing you to reset all
         * counters by clicking the bottom bar of the widget. When activated, you
         * can also click the average frame rate trace-out to reset just that one
         * value.
         *
         * @param enableModifyFramerate When enabled, allows you to click the upper
         * and lower parts of the graph area to increase and decrease SWF frame rate
         * respectively.
         */
        function AwayStats(view3d, minimized, transparent, meanDataLength, enableClickToReset, enableModifyFrameRate) {
            if (view3d === void 0) { view3d = null; }
            if (minimized === void 0) { minimized = false; }
            if (transparent === void 0) { transparent = false; }
            if (meanDataLength === void 0) { meanDataLength = 0; }
            if (enableClickToReset === void 0) { enableClickToReset = true; }
            if (enableModifyFrameRate === void 0) { enableModifyFrameRate = true; }
            _super.call(this);
            this._minimized = minimized;
            this._transparent = transparent;
            this._enable_reset = enableClickToReset;
            this._enable_mod_fr = enableModifyFrameRate;
            this._mean_data_length = meanDataLength;
            this._views = new feng3d.View3D[]();
            if (view3d)
                this._views.push(view3d);
            // Store instance for singleton access. Singleton status
            // is not enforced, since the widget will work anyway.
            if (_INSTANCE)
                trace('Creating several statistics windows in one project. Is this intentional?');
            _INSTANCE = this;
            this._fps = 0;
            this._num_frames = 0;
            this._avg_fps = 0;
            this._ram = 0;
            this._max_ram = 0;
            this._tfaces = 0;
            this._rfaces = 0;
            this._init();
        }
        Object.defineProperty(AwayStats.prototype, "max_ram", {
            get: function () {
                return _max_ram;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AwayStats.prototype, "ram", {
            get: function () {
                return _ram;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AwayStats.prototype, "avg_fps", {
            get: function () {
                return _avg_fps;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AwayStats.prototype, "max_fps", {
            get: function () {
                return _max_fps;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AwayStats.prototype, "fps", {
            get: function () {
                return _fps;
            },
            enumerable: true,
            configurable: true
        });
        AwayStats.prototype._init = function () {
            this._initMisc();
            this._initTopBar();
            this._initBottomBar();
            this._initDiagrams();
            this._initInteraction();
            this.reset();
            this._redrawWindow();
            this.addEventListener(feng3d.Event.ADDED_TO_STAGE, this._onAddedToStage);
            this.addEventListener(feng3d.Event.REMOVED_FROM_STAGE, this._onRemovedFromStage);
        };
        Object.defineProperty(AwayStats, "instance", {
            /**
             * Holds a reference to the stats widget (or if several have been created
             * during session, the one that was last instantiated.) Allows you to set
             * properties and register views from anywhere in your code.
             */
            get: function () {
                return _INSTANCE ? _INSTANCE : _INSTANCE = new AwayStats();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Add a view to the list of those that are taken into account when
         * calculating on-screen and total poly counts. Use this method when the
         * stats widget is not instantiated in the same place as where you create
         * your view, or when using several views, or when views are created and
         * destroyed dynamically at runtime.
         */
        AwayStats.prototype.registerView = function (view3d) {
            if (view3d && this._views.indexOf(view3d) < 0)
                this._views.push(view3d);
        };
        /**
         * Remove a view from the list of those that are taken into account when
         * calculating on-screen and total poly counts. If the supplied view is
         * the only one known to the stats widget, calling this will leave the
         * list empty, disabling poly count statistics altogether.
         */
        AwayStats.prototype.unregisterView = function (view3d) {
            if (view3d) {
                var idx = this._views.indexOf(view3d);
                if (idx >= 0)
                    this._views.splice(idx, 1);
            }
        };
        AwayStats.prototype._initMisc = function () {
            this._timer = new Timer(200, 0);
            this._timer.addEventListener('timer', this._onTimer);
            this._label_format = new TextFormat('_sans', 9, 0xffffff, true);
            this._data_format = new TextFormat('_sans', 9, 0xffffff, false);
            if (this._mean_data_length > 0) {
                var i;
                this._mean_data = [];
                for (i = 0; i < this._mean_data_length; i++)
                    this._mean_data[i] = 0.0;
            }
        };
        /**
         * @private
         * Draw logo and create title textfield.
         */
        AwayStats.prototype._initTopBar = function () {
            var logo;
            var markers;
            //var logo_tf : TextField;
            var fps_label_tf;
            var afps_label_tf;
            this._top_bar = new Sprite;
            this._top_bar.graphics.beginFill(0, 0);
            this._top_bar.graphics.drawRect(0, 0, _WIDTH, 20);
            this.addChild(this._top_bar);
            logo = new Shape;
            logo.x = 9;
            logo.y = 7.5;
            logo.scaleX = 0.6;
            logo.scaleY = 0.6;
            logo.graphics.beginFill(0xffffff, 1);
            // Left
            logo.graphics.moveTo(-0.5, -7);
            logo.graphics.curveTo(-0.5, -7.7, -1, -7);
            logo.graphics.lineTo(-9, 5);
            logo.graphics.curveTo(-9.3, 5.5, -8, 5);
            logo.graphics.curveTo(-1, 1, -0.5, -7);
            // Right
            logo.graphics.moveTo(0.5, -7);
            logo.graphics.curveTo(0.5, -7.7, 1, -7);
            logo.graphics.lineTo(9, 5);
            logo.graphics.curveTo(9.3, 5.5, 8, 5);
            logo.graphics.curveTo(1, 1, 0.5, -7);
            // Bottom
            logo.graphics.moveTo(-8, 7);
            logo.graphics.curveTo(-8.3, 6.7, -7.5, 6.3);
            logo.graphics.curveTo(0, 2, 7.5, 6.3);
            logo.graphics.curveTo(8.3, 6.7, 8, 7);
            logo.graphics.lineTo(-8, 7);
            this._top_bar.addChild(logo);
            // Color markers 
            markers = new Shape;
            markers.graphics.beginFill(0xffffff);
            markers.graphics.drawRect(20, 7, 4, 4);
            markers.graphics.beginFill(0x3388dd);
            markers.graphics.drawRect(77, 7, 4, 4);
            this._top_bar.addChild(markers);
            // CURRENT FPS
            fps_label_tf = new TextField();
            fps_label_tf.defaultTextFormat = this._label_format;
            fps_label_tf.autoSize = TextFieldAutoSize.LEFT;
            fps_label_tf.text = 'FR:';
            fps_label_tf.x = 24;
            fps_label_tf.y = 2;
            fps_label_tf.selectable = false;
            this._top_bar.addChild(fps_label_tf);
            this._fps_tf = new TextField;
            this._fps_tf.defaultTextFormat = this._data_format;
            this._fps_tf.autoSize = TextFieldAutoSize.LEFT;
            this._fps_tf.x = fps_label_tf.x + 16;
            this._fps_tf.y = fps_label_tf.y;
            this._fps_tf.selectable = false;
            this._top_bar.addChild(this._fps_tf);
            // AVG FPS
            afps_label_tf = new TextField;
            afps_label_tf.defaultTextFormat = this._label_format;
            afps_label_tf.autoSize = TextFieldAutoSize.LEFT;
            afps_label_tf.text = 'A:';
            afps_label_tf.x = 81;
            afps_label_tf.y = 2;
            afps_label_tf.selectable = false;
            this._top_bar.addChild(afps_label_tf);
            this._afps_tf = new TextField;
            this._afps_tf.defaultTextFormat = this._data_format;
            this._afps_tf.autoSize = TextFieldAutoSize.LEFT;
            this._afps_tf.x = afps_label_tf.x + 12;
            this._afps_tf.y = afps_label_tf.y;
            this._afps_tf.selectable = false;
            this._top_bar.addChild(this._afps_tf);
            // Minimize / maximize button
            this._min_max_btn = new Sprite;
            this._min_max_btn.x = _WIDTH - 8;
            this._min_max_btn.y = 7;
            this._min_max_btn.graphics.beginFill(0, 0);
            this._min_max_btn.graphics.lineStyle(1, 0xefefef, 1, true);
            this._min_max_btn.graphics.drawRect(-4, -4, 8, 8);
            this._min_max_btn.graphics.moveTo(-3, 2);
            this._min_max_btn.graphics.lineTo(3, 2);
            this._min_max_btn.buttonMode = true;
            this._min_max_btn.addEventListener(MouseEvent.CLICK, this._onMinMaxBtnClick);
            this._top_bar.addChild(this._min_max_btn);
        };
        AwayStats.prototype._initBottomBar = function () {
            var markers;
            var ram_label_tf;
            var poly_label_tf;
            var swhw_label_tf;
            this._btm_bar = new Sprite();
            this._btm_bar.graphics.beginFill(0, 0.2);
            this._btm_bar.graphics.drawRect(0, 0, _WIDTH, _BOTTOM_BAR_HEIGHT);
            this.addChild(this._btm_bar);
            // Hit area for bottom bar (to avoid having textfields
            // affect interaction badly.)
            this._btm_bar_hit = new Sprite;
            this._btm_bar_hit.graphics.beginFill(0xffcc00, 0);
            this._btm_bar_hit.graphics.drawRect(0, 1, _WIDTH, _BOTTOM_BAR_HEIGHT - 1);
            this.addChild(this._btm_bar_hit);
            // Color markers
            markers = new Shape;
            markers.graphics.beginFill(_MEM_COL);
            markers.graphics.drawRect(5, 4, 4, 4);
            markers.graphics.beginFill(_POLY_COL);
            markers.graphics.drawRect(5, 14, 4, 4);
            this._btm_bar.addChild(markers);
            // CURRENT RAM
            ram_label_tf = new TextField;
            ram_label_tf.defaultTextFormat = this._label_format;
            ram_label_tf.autoSize = TextFieldAutoSize.LEFT;
            ram_label_tf.text = 'RAM:';
            ram_label_tf.x = 10;
            ram_label_tf.y = _UPPER_Y;
            ram_label_tf.selectable = false;
            ram_label_tf.mouseEnabled = false;
            this._btm_bar.addChild(ram_label_tf);
            this._ram_tf = new TextField;
            this._ram_tf.defaultTextFormat = this._data_format;
            this._ram_tf.autoSize = TextFieldAutoSize.LEFT;
            this._ram_tf.x = ram_label_tf.x + 31;
            this._ram_tf.y = ram_label_tf.y;
            this._ram_tf.selectable = false;
            this._ram_tf.mouseEnabled = false;
            this._btm_bar.addChild(this._ram_tf);
            // POLY COUNT
            poly_label_tf = new TextField;
            poly_label_tf.defaultTextFormat = this._label_format;
            poly_label_tf.autoSize = TextFieldAutoSize.LEFT;
            poly_label_tf.text = 'POLY:';
            poly_label_tf.x = 10;
            poly_label_tf.y = _MID_Y;
            poly_label_tf.selectable = false;
            poly_label_tf.mouseEnabled = false;
            this._btm_bar.addChild(poly_label_tf);
            this._poly_tf = new TextField;
            this._poly_tf.defaultTextFormat = this._data_format;
            this._poly_tf.autoSize = TextFieldAutoSize.LEFT;
            this._poly_tf.x = poly_label_tf.x + 31;
            this._poly_tf.y = poly_label_tf.y;
            this._poly_tf.selectable = false;
            this._poly_tf.mouseEnabled = false;
            this._btm_bar.addChild(this._poly_tf);
            // SOFTWARE RENDERER WARNING
            swhw_label_tf = new TextField;
            swhw_label_tf.defaultTextFormat = this._label_format;
            swhw_label_tf.autoSize = TextFieldAutoSize.LEFT;
            swhw_label_tf.text = 'DRIV:';
            swhw_label_tf.x = 10;
            swhw_label_tf.y = _LOWER_Y;
            swhw_label_tf.selectable = false;
            swhw_label_tf.mouseEnabled = false;
            this._btm_bar.addChild(swhw_label_tf);
            this._swhw_tf = new TextField;
            this._swhw_tf.defaultTextFormat = this._data_format;
            this._swhw_tf.autoSize = TextFieldAutoSize.LEFT;
            this._swhw_tf.x = swhw_label_tf.x + 31;
            this._swhw_tf.y = swhw_label_tf.y;
            this._swhw_tf.selectable = false;
            this._swhw_tf.mouseEnabled = false;
            this._btm_bar.addChild(this._swhw_tf);
        };
        AwayStats.prototype._initDiagrams = function () {
            this._dia_bmp = new BitmapData(_WIDTH, _DIAG_HEIGHT, true, 0);
            this._diagram = new Sprite;
            this._diagram.graphics.beginBitmapFill(this._dia_bmp);
            this._diagram.graphics.drawRect(0, 0, this._dia_bmp.width, this._dia_bmp.height);
            this._diagram.graphics.endFill();
            this._diagram.y = 17;
            this.addChild(this._diagram);
            this._diagram.graphics.lineStyle(1, 0xffffff, 0.03);
            this._diagram.graphics.moveTo(0, 0);
            this._diagram.graphics.lineTo(_WIDTH, 0);
            this._diagram.graphics.moveTo(0, Math.floor(this._dia_bmp.height / 2));
            this._diagram.graphics.lineTo(_WIDTH, Math.floor(this._dia_bmp.height / 2));
            // FRAME RATE BAR
            this._fps_bar = new Shape;
            this._fps_bar.graphics.beginFill(0xffffff);
            this._fps_bar.graphics.drawRect(0, 0, _WIDTH, 4);
            this._fps_bar.x = 0;
            this._fps_bar.y = 16;
            this.addChild(this._fps_bar);
            // AVERAGE FPS
            this._afps_bar = new Shape;
            this._afps_bar.graphics.lineStyle(1, 0x3388dd, 1, false, LineScaleMode.NORMAL, CapsStyle.SQUARE);
            this._afps_bar.graphics.lineTo(0, 4);
            this._afps_bar.y = this._fps_bar.y;
            this.addChild(this._afps_bar);
            // MINIMUM FPS
            this._lfps_bar = new Shape;
            this._lfps_bar.graphics.lineStyle(1, 0xff0000, 1, false, LineScaleMode.NORMAL, CapsStyle.SQUARE);
            this._lfps_bar.graphics.lineTo(0, 4);
            this._lfps_bar.y = this._fps_bar.y;
            this.addChild(this._lfps_bar);
            // MAXIMUM FPS
            this._hfps_bar = new Shape;
            this._hfps_bar.graphics.lineStyle(1, 0x00ff00, 1, false, LineScaleMode.NORMAL, CapsStyle.SQUARE);
            this._hfps_bar.graphics.lineTo(0, 4);
            this._hfps_bar.y = this._fps_bar.y;
            this.addChild(this._hfps_bar);
            this._mem_points = [];
            this._mem_graph = new Shape;
            this._mem_graph.y = this._diagram.y + this._diagram.height;
            this.addChildAt(this._mem_graph, 0);
        };
        AwayStats.prototype._initInteraction = function () {
            // Mouse down to drag on the title
            this._top_bar.addEventListener(MouseEvent.MOUSE_DOWN, this._onTopBarMouseDown);
            // Reset functionality
            if (this._enable_reset) {
                this._btm_bar.mouseEnabled = false;
                this._btm_bar_hit.addEventListener(MouseEvent.CLICK, this._onCountersClick_reset);
                this._afps_tf.addEventListener(MouseEvent.MOUSE_UP, this._onAverageFpsClick_reset, false, 1);
            }
            // Framerate increase/decrease by clicking on the diagram
            if (this._enable_mod_fr)
                this._diagram.addEventListener(MouseEvent.CLICK, this._onDiagramClick);
        };
        AwayStats.prototype._redrawWindow = function () {
            var plate_height;
            plate_height = this._minimized ? _MIN_HEIGHT : _MAX_HEIGHT;
            // Main plate
            if (!this._transparent) {
                this.graphics.clear();
                this.graphics.beginFill(0, 0.6);
                this.graphics.drawRect(0, 0, _WIDTH, plate_height);
            }
            // Minimize/maximize button
            this._min_max_btn.rotation = this._minimized ? 180 : 0;
            // Position counters
            this._btm_bar.y = plate_height - _BOTTOM_BAR_HEIGHT;
            this._btm_bar_hit.y = this._btm_bar.y;
            // Hide/show diagram for minimized/maximized view respectively
            this._diagram.visible = !this._minimized;
            this._mem_graph.visible = !this._minimized;
            this._fps_bar.visible = this._minimized;
            this._afps_bar.visible = this._minimized;
            this._lfps_bar.visible = this._minimized;
            this._hfps_bar.visible = this._minimized;
            // Redraw memory graph
            if (!this._minimized)
                this._redrawMemGraph();
        };
        AwayStats.prototype._redrawStats = function () {
            var dia_y;
            // Redraw counters
            this._fps_tf.text = this._fps.toString().concat('/', number(this.stage.frameRate));
            this._afps_tf.text = Math.round(this._avg_fps).toString();
            this._ram_tf.text = this._getRamString(this._ram).concat(' / ', this._getRamString(this._max_ram));
            // Move entire diagram
            this._dia_bmp.scroll(1, 0);
            // Only redraw polycount if there is a  view available
            // or they won't have been calculated properly
            if (this._views.length > 0) {
                //				this._poly_tf.text = this._rfaces.toString().concat(' / ', this._tfaces); // TODO: Total faces not yet available in 4.x
                this._poly_tf.text = this._rfaces + "";
                // Plot rendered faces
                dia_y = this._dia_bmp.height - Math.floor(this._rfaces / this._tfaces * this._dia_bmp.height);
                this._dia_bmp.setPixel32(1, dia_y, _POLY_COL + 0xff000000);
            }
            else
                this._poly_tf.text = 'n/a (no view)';
            // Show software (SW) or hardware (HW)
            if (!this._showing_driv_info) {
                if (this._views && this._views.length && this._views[0].stage3DProxy && this._views[0].stage3DProxy.context3D) {
                    var di = this._views[0].stage3DProxy.context3D.driverInfo;
                    this._swhw_tf.text = di.substr(0, di.indexOf(' '));
                    this._showing_driv_info = true;
                }
                else
                    this._swhw_tf.text = 'n/a (no view)';
            }
            // Plot current framerate
            dia_y = this._dia_bmp.height - Math.floor(this._fps / this.stage.frameRate * this._dia_bmp.height);
            this._dia_bmp.setPixel32(1, dia_y, 0xffffffff);
            // Plot average framerate
            dia_y = this._dia_bmp.height - Math.floor(this._avg_fps / this.stage.frameRate * this._dia_bmp.height);
            this._dia_bmp.setPixel32(1, dia_y, 0xff33bbff);
            // Redraw diagrams
            if (this._minimized) {
                this._fps_bar.scaleX = Math.min(1, this._fps / this.stage.frameRate);
                this._afps_bar.x = Math.min(1, this._avg_fps / this.stage.frameRate) * _WIDTH;
                this._lfps_bar.x = Math.min(1, this._min_fps / this.stage.frameRate) * _WIDTH;
                this._hfps_bar.x = Math.min(1, this._max_fps / this.stage.frameRate) * _WIDTH;
            }
            else if (this._updates % 5 == 0)
                this._redrawMemGraph();
            // Move along regardless of whether the graph
            // was updated this time around
            this._mem_graph.x = this._updates % 5;
            this._updates++;
        };
        AwayStats.prototype._redrawMemGraph = function () {
            var i;
            var g;
            var max_val = 0;
            // Redraw memory graph (only every 5th update)
            this._mem_graph.scaleY = 1;
            g = this._mem_graph.graphics;
            g.clear();
            g.lineStyle(.5, _MEM_COL, 1, true, LineScaleMode.NONE);
            g.moveTo(5 * (this._mem_points.length - 1), -this._mem_points[this._mem_points.length - 1]);
            for (i = this._mem_points.length - 1; i >= 0; --i) {
                if (this._mem_points[i + 1] == 0 || this._mem_points[i] == 0) {
                    g.moveTo(i * 5, -this._mem_points[i]);
                    continue;
                }
                g.lineTo(i * 5, -this._mem_points[i]);
                if (this._mem_points[i] > max_val)
                    max_val = this._mem_points[i];
            }
            this._mem_graph.scaleY = this._dia_bmp.height / max_val;
        };
        AwayStats.prototype._getRamString = function (ram) {
            var ram_unit = 'B';
            if (ram > 1048576) {
                ram /= 1048576;
                ram_unit = 'M';
            }
            else if (ram > 1024) {
                ram /= 1024;
                ram_unit = 'K';
            }
            return ram.toFixed(1) + ram_unit;
        };
        AwayStats.prototype.reset = function () {
            var i;
            // Reset all values
            this._updates = 0;
            this._num_frames = 0;
            this._min_fps = number.MAX_VALUE;
            this._max_fps = 0;
            this._avg_fps = 0;
            this._fps_sum = 0;
            this._max_ram = 0;
            // Reset RAM usage log
            for (i = 0; i < _WIDTH / 5; i++)
                this._mem_points[i] = 0;
            // Reset FPS log if any
            if (this._mean_data) {
                for (i = 0; i < this._mean_data.length; i++)
                    this._mean_data[i] = 0.0;
            }
            // Clear diagram this.graphics
            this._mem_graph.graphics.clear();
            this._dia_bmp.fillRect(this._dia_bmp.rect, 0);
        };
        AwayStats.prototype._endDrag = function () {
            if (this.x < -_WIDTH)
                this.x = -(_WIDTH - 20);
            else if (this.x > this.stage.stageWidth)
                this.x = this.stage.stageWidth - 20;
            if (this.y < 0)
                this.y = 0;
            else if (this.y > this.stage.stageHeight)
                this.y = this.stage.stageHeight - 15;
            // Round this.x/this.y position to make sure it's on
            // whole pixels to avoid weird anti-aliasing
            this.x = Math.round(this.x);
            this.y = Math.round(this.y);
            this._dragging = false;
            this.stage.removeEventListener(feng3d.Event.MOUSE_LEAVE, this._onMouseUpOrLeave);
            this.stage.removeEventListener(MouseEvent.MOUSE_UP, this._onMouseUpOrLeave);
            this.stage.removeEventListener(MouseEvent.MOUSE_MOVE, this._onMouseMove);
        };
        AwayStats.prototype._onAddedToStage = function (ev) {
            this._timer.start();
            this.addEventListener(feng3d.Event.ENTER_FRAME, this._onEnterFrame);
        };
        AwayStats.prototype._onRemovedFromStage = function (ev) {
            this._timer.stop();
            this.removeEventListener(feng3d.Event.ENTER_FRAME, this._onTimer);
        };
        AwayStats.prototype._onTimer = function (ev) {
            // Store current and max RAM
            this._ram = System.totalMemory;
            if (this._ram > this._max_ram)
                this._max_ram = this._ram;
            // Remove first, add last
            if (this._updates % 5 == 0) {
                this._mem_points.unshift(this._ram / 1024);
                this._mem_points.pop();
            }
            this._tfaces = this._rfaces = 0;
            // Update polycount if views are available
            if (this._views.length > 0) {
                var i;
                // Sum up poly counts across all registered views
                for (i = 0; i < this._views.length; i++) {
                    this._rfaces += this._views[i].renderedFacesCount;
                }
            }
            this._redrawStats();
        };
        AwayStats.prototype._onEnterFrame = function (ev) {
            var time = getTimer() - this._last_frame_timestamp;
            // Calculate current FPS
            this._fps = Math.floor(1000 / time);
            this._fps_sum += this._fps;
            // Update min/max this.fps
            if (this._fps > this._max_fps)
                this._max_fps = this._fps;
            else if (this._fps != 0 && this._fps < this._min_fps)
                this._min_fps = this._fps;
            // If using a limited length log of frames
            // for the average, push the latest recorded
            // framerate onto fifo, shift one off and
            // subtract it from the running sum, to keep
            // the sum reflecting the log entries.
            if (this._mean_data) {
                this._mean_data.push(this._fps);
                this._fps_sum -= number(this._mean_data.shift());
                // Average = sum of all log entries over
                // number of log entries.
                this._avg_fps = this._fps_sum / this._mean_data_length;
            }
            else {
                // Regular average calculation, i.e. using
                // a running sum since last this.reset
                this._num_frames++;
                this._avg_fps = this._fps_sum / this._num_frames;
            }
            this._last_frame_timestamp = getTimer();
        };
        AwayStats.prototype._onDiagramClick = function (ev) {
            this.stage.frameRate -= Math.floor((this._diagram.mouseY - this._dia_bmp.height / 2) / 5);
        };
        /**
         * @private
         * Reset just the average FPS counter.
         */
        AwayStats.prototype._onAverageFpsClick_reset = function (ev) {
            if (!this._dragging) {
                var i;
                this._num_frames = 0;
                this._fps_sum = 0;
                if (this._mean_data) {
                    for (i = 0; i < this._mean_data.length; i++)
                        this._mean_data[i] = 0.0;
                }
            }
        };
        AwayStats.prototype._onCountersClick_reset = function (ev) {
            this.reset();
        };
        AwayStats.prototype._onMinMaxBtnClick = function (ev) {
            this._minimized = !this._minimized;
            this._redrawWindow();
        };
        AwayStats.prototype._onTopBarMouseDown = function (ev) {
            this._drag_dx = this.mouseX;
            this._drag_dy = this.mouseY;
            this.stage.addEventListener(MouseEvent.MOUSE_MOVE, this._onMouseMove);
            this.stage.addEventListener(MouseEvent.MOUSE_UP, this._onMouseUpOrLeave);
            this.stage.addEventListener(feng3d.Event.MOUSE_LEAVE, this._onMouseUpOrLeave);
        };
        AwayStats.prototype._onMouseMove = function (ev) {
            this._dragging = true;
            this.x = this.stage.mouseX - this._drag_dx;
            this.y = this.stage.mouseY - this._drag_dy;
        };
        AwayStats.prototype._onMouseUpOrLeave = function (ev) {
            this._endDrag();
        };
        AwayStats._WIDTH = 125;
        AwayStats._MAX_HEIGHT = 85;
        AwayStats._MIN_HEIGHT = 51;
        AwayStats._UPPER_Y = -1;
        AwayStats._MID_Y = 9;
        AwayStats._LOWER_Y = 19;
        AwayStats._DIAG_HEIGHT = _MAX_HEIGHT - 50;
        AwayStats._BOTTOM_BAR_HEIGHT = 31;
        AwayStats._POLY_COL = 0xffcc00;
        AwayStats._MEM_COL = 0xff00cc;
        return AwayStats;
    }(Sprite));
    feng3d.AwayStats = AwayStats;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 3d环境缓存调试工具类
     * @author feng 2014-9-9
     */
    var Context3DBufferDebug = (function () {
        /**
         * 创建3d环境缓存调试工具类
         */
        function Context3DBufferDebug() {
        }
        /**
         * 调试Context3DCache
         * @param context3DCache			3D环境缓冲
         * @return							调试信息
         */
        Context3DBufferDebug.debug = function (context3DCache) {
            var debugInfos = [];
            var debugInfoItem;
            debugInfoItem = debugInfo(context3DCache.programBuffer);
            debugInfos.push(debugInfoItem);
            for (each(); ; )
                var context3DDataBuffer;
             in context3DCache.otherBufferDic;
            {
                debugInfoItem = debugInfo(context3DDataBuffer);
                debugInfos.push(debugInfoItem);
            }
            for (each(); ; )
                var registerBuffer;
             in context3DCache.runRegBufferList;
            {
                debugInfoItem = debugInfo(registerBuffer);
                debugInfoItem.shaderRegister = registerBuffer.firstRegister.toString();
                debugInfos.push(debugInfoItem);
            }
            debugInfoItem = debugInfo(context3DCache.indexBuffer);
            debugInfos.push(debugInfoItem);
            return debugInfos;
        };
        /**
         * 调试Context3DCache
         * @param context3DBuffer			3D环境缓冲
         * @return							调试信息
         */
        Context3DBufferDebug.function = debugInfo(context3DBuffer, feng3d.Context3DBuffer);
        return Context3DBufferDebug;
    }());
    feng3d.Context3DBufferDebug = Context3DBufferDebug;
    {
        var debugInfoItem = { className: getQualifiedClassName(context3DBuffer), constructorParams: [context3DBuffer.dataTypeId, null] };
        var cla = feng3d.ClassUtils.getClass(context3DBuffer);
        switch (cla) {
            case feng3d.ProgramBuffer:
                var programBuffer = context3DBuffer;
                debugInfoItem.updateParams = [programBuffer.vertexCode, programBuffer.fragmentCode];
                break;
            case feng3d.BlendFactorsBuffer:
                var blendFactorsBuffer = context3DBuffer;
                debugInfoItem.updateParams = [blendFactorsBuffer.sourceFactor, blendFactorsBuffer.destinationFactor];
                break;
            case feng3d.CullingBuffer:
                var cullingBuffer = context3DBuffer;
                debugInfoItem.updateParams = [cullingBuffer.triangleFaceToCull];
                break;
            case feng3d.DepthTestBuffer:
                var depthTestBuffer = context3DBuffer;
                debugInfoItem.updateParams = [depthTestBuffer.depthMask, depthTestBuffer.passCompareMode];
                break;
            case feng3d.FCMatrixBuffer:
                var fcMatrixBuffer = context3DBuffer;
                debugInfoItem.updateParams = [fcMatrixBuffer.matrix, fcMatrixBuffer.transposedMatrix];
                break;
            case feng3d.FCVectorBuffer:
                var fcVectorBuffer = context3DBuffer;
                debugInfoItem.updateParams = [fcVectorBuffer.data, fcVectorBuffer.numRegisters];
                break;
            case feng3d.FSBuffer:
                var fsBuffer = context3DBuffer;
                debugInfoItem.updateParams = [fsBuffer.texture];
                break;
            case feng3d.IndexBuffer:
                var indexBuffer = context3DBuffer;
                debugInfoItem.updateParams = [indexBuffer.data, indexBuffer.numIndices, indexBuffer.count, indexBuffer.firstIndex, indexBuffer.numTriangles];
                break;
            case feng3d.VABuffer:
                var vaBuffer = context3DBuffer;
                debugInfoItem.updateParams = [vaBuffer.dataBuffer.data, vaBuffer.dataBuffer.numVertices, vaBuffer.dataBuffer.data32PerVertex];
                break;
            case feng3d.VCMatrixBuffer:
                var vcMatrixBuffer = context3DBuffer;
                debugInfoItem.updateParams = [vcMatrixBuffer.matrix, vcMatrixBuffer.transposedMatrix];
                break;
            case feng3d.VCVectorBuffer:
                var vcVectorBuffer = context3DBuffer;
                debugInfoItem.updateParams = [vcVectorBuffer.data, vcVectorBuffer.numRegisters];
                break;
            default:
                throw new Error("无法处理类型：" + cla);
                break;
        }
        //编码参数
        feng3d.ClassUtils.encodeParams(debugInfoItem.updateParams);
        return debugInfoItem;
    }
    getContext3DCache(obj, Object);
    feng3d.Context3DCache;
    {
        var context3DCache = new feng3d.Context3DCache();
        var arr = obj;
        for (var i = 0; i < arr.length; i++) {
            var item = arr[i];
            var cla = feng3d.ClassUtils.getClass(item.className);
            var buff = feng3d.ClassUtils.structureInstance(cla, item.constructorParams);
            feng3d.ClassUtils.decodeParams(item.updateParams);
            feng3d.ClassUtils.call(buff, "update", item.updateParams);
            context3DCache.addDataBuffer(buff);
            if (buff)
                is;
            feng3d.RegisterBuffer;
            {
                var regBuff = buff;
                var regStr = item.shaderRegister;
                var myPattern = /([a-z]+)(\d+)/;
                var result = myPattern.exec(regStr);
                //-------------------
                regBuff.firstRegister = result[2];
                if (context3DCache.runRegBufferList == null) {
                    context3DCache.runRegBufferList = [];
                }
                context3DCache.runRegBufferList.push(buff);
            }
        }
        return context3DCache;
    }
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 调试配置
     * @author feng 2014-4-13
     */
    var Debug = (function () {
        function Debug() {
        }
        /**
         * 是否开启AGAL调试
         */
        Debug.agalDebug = true;
        return Debug;
    }());
    feng3d.Debug = Debug;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     *
     * @author feng 2015-12-30
     */
    var SegmentUtils = (function () {
        function SegmentUtils() {
            this.LIMIT = 3 * 0xFFFF;
        }
        SegmentUtils.getSegmentSubGeometrys = function (_segments) {
            var segmentUtils = new SegmentUtils();
            var _segmentSubGeometry = segmentUtils.getSegmentSubGeometry(_segments);
            return _segmentSubGeometry;
        };
        SegmentUtils.prototype.getSegmentSubGeometry = function (_segments) {
            this._segmentSubGeometry = new feng3d.SegmentSubGeometry();
            this._indices = new number[]();
            this._pointData0 = new number[]();
            this._pointData1 = new number[]();
            this._thicknessData = new number[]();
            this._colorData = new number[]();
            for (var i = 0; i < _segments.length; i++) {
                this.computeSegment(_segments[i], i);
            }
            //一条线段由4个顶点组成
            this._segmentSubGeometry.numVertices = _segments.length * 4;
            this._segmentSubGeometry.updateIndexData(this._indices);
            this._segmentSubGeometry.updatePointData0(this._pointData0);
            this._segmentSubGeometry.updatePointData1(this._pointData1);
            this._segmentSubGeometry.updateThicknessData(this._thicknessData);
            this._segmentSubGeometry.updateColorData(this._colorData);
            return this._segmentSubGeometry;
        };
        /**
         * 计算线段数据
         * @param segment 			线段数据
         * @param segmentIndex 		线段编号
         */
        SegmentUtils.prototype.computeSegment = function (segment, segmentIndex) {
            //to do: add support for curve segment
            var start = segment.start;
            var end = segment.end;
            var startX = start.x, startY = start.y, startZ = start.z;
            var endX = end.x, endY = end.y, endZ = end.z;
            var startR = segment.startR, startG = segment.startG, startB = segment.startB;
            var endR = segment.endR, endG = segment.endG, endB = segment.endB;
            var point0Index = segmentIndex * 4 * this._segmentSubGeometry.pointData0Stride;
            var point1Index = segmentIndex * 4 * this._segmentSubGeometry.pointData1Stride;
            var thicknessIndex = segmentIndex * 4 * this._segmentSubGeometry.thicknessDataStride;
            var colorIndex = segmentIndex * 4 * this._segmentSubGeometry.colorDataStride;
            var t = segment.thickness;
            //生成线段顶点数据
            this._pointData0[point0Index++] = startX;
            this._pointData0[point0Index++] = startY;
            this._pointData0[point0Index++] = startZ;
            this._pointData1[point1Index++] = endX;
            this._pointData1[point1Index++] = endY;
            this._pointData1[point1Index++] = endZ;
            this._thicknessData[thicknessIndex++] = t;
            this._colorData[colorIndex++] = startR;
            this._colorData[colorIndex++] = startG;
            this._colorData[colorIndex++] = startB;
            this._colorData[colorIndex++] = 1;
            this._pointData0[point0Index++] = endX;
            this._pointData0[point0Index++] = endY;
            this._pointData0[point0Index++] = endZ;
            this._pointData1[point1Index++] = startX;
            this._pointData1[point1Index++] = startY;
            this._pointData1[point1Index++] = startZ;
            this._thicknessData[thicknessIndex++] = -t;
            this._colorData[colorIndex++] = endR;
            this._colorData[colorIndex++] = endG;
            this._colorData[colorIndex++] = endB;
            this._colorData[colorIndex++] = 1;
            this._pointData0[point0Index++] = startX;
            this._pointData0[point0Index++] = startY;
            this._pointData0[point0Index++] = startZ;
            this._pointData1[point1Index++] = endX;
            this._pointData1[point1Index++] = endY;
            this._pointData1[point1Index++] = endZ;
            this._thicknessData[thicknessIndex++] = -t;
            this._colorData[colorIndex++] = startR;
            this._colorData[colorIndex++] = startG;
            this._colorData[colorIndex++] = startB;
            this._colorData[colorIndex++] = 1;
            this._pointData0[point0Index++] = endX;
            this._pointData0[point0Index++] = endY;
            this._pointData0[point0Index++] = endZ;
            this._pointData1[point1Index++] = startX;
            this._pointData1[point1Index++] = startY;
            this._pointData1[point1Index++] = startZ;
            this._thicknessData[thicknessIndex++] = t;
            this._colorData[colorIndex++] = endR;
            this._colorData[colorIndex++] = endG;
            this._colorData[colorIndex++] = endB;
            this._colorData[colorIndex++] = 1;
            //生成顶点索引数据
            var indexIndex = segmentIndex * 4;
            this._indices.push(indexIndex, indexIndex + 1, indexIndex + 2, indexIndex + 3, indexIndex + 2, indexIndex + 1);
        };
        return SegmentUtils;
    }());
    feng3d.SegmentUtils = SegmentUtils;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var AnimationSetError = (function (_super) {
        __extends(AnimationSetError, _super);
        function AnimationSetError(message) {
            _super.call(this, message);
        }
        return AnimationSetError;
    }(Error));
    feng3d.AnimationSetError = AnimationSetError;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 3D舞台事件
     * @author feng 2015-3-5
     */
    var Stage3DEvent = (function (_super) {
        __extends(Stage3DEvent, _super);
        /**
         * 构建一个3D舞台事件
         * @param type			事件的类型，可以作为 Event.type 访问。
         * @param bubbles		确定 Event 对象是否参与事件流的冒泡阶段。默认值为 false。
         */
        function Stage3DEvent(type, bubbles) {
            if (bubbles === void 0) { bubbles = false; }
            _super.call(this, type, bubbles);
        }
        /** 3D环境被创建事件 */
        Stage3DEvent.CONTEXT3D_CREATED = "Context3DCreated";
        /** 3D环境被摧毁事件 */
        Stage3DEvent.CONTEXT3D_DISPOSED = "Context3DDisposed";
        /** 3D环境被重新创建事件 */
        Stage3DEvent.CONTEXT3D_RECREATED = "Context3DRecreated";
        /** 视窗有发生变化 */
        Stage3DEvent.VIEWPORT_UPDATED = "ViewportUpdated";
        return Stage3DEvent;
    }(feng3d.Event));
    feng3d.Stage3DEvent = Stage3DEvent;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     *
     * @author feng 2015-9-25
     */
    constructor();
    {
        var _ =  * , FagalRE, instance, space;
        _.add(_.finalColor_ft_4.w, _.finalColor_ft_4.w, _.commonsData_fc_vector.z); //
        _.div(_.finalColor_ft_4.xyz, _.finalColor_ft_4, _.finalColor_ft_4.w); //
        _.sub(_.finalColor_ft_4.w, _.finalColor_ft_4.w, _.commonsData_fc_vector.z); //
        _.sat(_.finalColor_ft_4.xyz, _.finalColor_ft_4);
    }
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 环境光片段渲染程序
     * @author feng 2014-11-7
     */
    constructor();
    {
        var _ =  * , FagalRE, instance, space;
        var shaderParams = FagalRE.instance.context3DCache.shaderParams;
        var commonShaderParams = shaderParams.getOrCreateComponentByClass(feng3d.CommonShaderParams);
        if (commonShaderParams.useAmbientTexture > 0) {
            var mAmbient_ft = _.getFreeTemp("环境颜色值临时变量");
            _.tex(mAmbient_ft, _.uv_v, _.ambientTexture_fs);
            // apparently, still needs to un-premultiply :s
            _.div(mAmbient_ft.xyz, mAmbient_ft.xyz, mAmbient_ft.w);
            _.mov(_.finalColor_ft_4, mAmbient_ft);
        }
        else {
            _.mov(_.finalColor_ft_4, _.ambientColor_fc_vector);
        }
    }
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * blinn-phong half vector model
     * @author feng 2015-9-24
     */
    constructor(singleSpecularColorReg, Register, lightDirReg, Register);
    {
        var _ =  * , FagalRE, instance, space;
        //入射光与视线方向的和 = 光照场景方向 add 标准视线方向
        _.add(singleSpecularColorReg, lightDirReg, _.viewDir_ft_4);
        //标准化入射光与视线的和
        _.nrm(singleSpecularColorReg.xyz, singleSpecularColorReg);
        //镜面反射光强度 = 法线 dp3 入射光与视线方向的和
        _.dp3(singleSpecularColorReg.w, _.normal_ft_4, singleSpecularColorReg);
        //镜面反射光强度 锁定在0-1之间
        _.sat(singleSpecularColorReg.w, singleSpecularColorReg.w);
    }
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    _DiffuseColor;
    _DiffuseTexure;
    /**
     * 发布漫反射光
     * @author feng 2014-11-7
     */
    constructor();
    {
        var shaderParams = FagalRE.instance.context3DCache.shaderParams;
        var commonShaderParams = shaderParams.getOrCreateComponentByClass(feng3d.CommonShaderParams);
        var lightShaderParams = shaderParams.getOrCreateComponentByClass(feng3d.LightShaderParams);
        var shadowShaderParams = shaderParams.getOrCreateComponentByClass(feng3d.ShadowShaderParams);
        var _ =  * , FagalRE, instance, space;
        //把阴影使用到漫反射光上
        if (lightShaderParams.numLights > 0 && shadowShaderParams.needsShadowRegister > 0) {
            _.mul(_.totalDiffuseLightColor_ft_4.xyz, _.totalDiffuseLightColor_ft_4, _.shadowValue_ft_4.w);
        }
        //获取漫反射灯光
        if (commonShaderParams.hasDiffuseTexture > 0) {
            F_DiffuseTexure();
        }
        else {
            F_DiffuseColor();
        }
        if (lightShaderParams.numLights == 0) {
            _.mov(_.finalColor_ft_4, _.mDiff_ft);
            return;
        }
        //控制在0到1之间
        _.sat(_.totalDiffuseLightColor_ft_4, _.totalDiffuseLightColor_ft_4);
        if (commonShaderParams.useAmbientTexture > 0) {
            _.mul(_.mDiff_ft.xyz, _.mDiff_ft, _.totalDiffuseLightColor_ft_4); //
            _.mul(_.totalDiffuseLightColor_ft_4.xyz, _.finalColor_ft_4, _.totalDiffuseLightColor_ft_4); //
            _.sub(_.finalColor_ft_4.xyz, _.finalColor_ft_4, _.totalDiffuseLightColor_ft_4); //
            _.add(_.finalColor_ft_4.xyz, _.mDiff_ft, _.finalColor_ft_4);
        }
        else {
            //漫反射 + 环境光 因子
            _.add(_.finalColor_ft_4.xyz, _.totalDiffuseLightColor_ft_4, _.finalColor_ft_4);
            //混合漫反射光
            _.mul(_.finalColor_ft_4.xyz, _.mDiff_ft, _.finalColor_ft_4);
            //保存w值不变
            _.mov(_.finalColor_ft_4.w, _.mDiff_ft.w);
        }
    }
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 方向光渲染函数
     * @author feng 2014-11-7
     */
    constructor();
    {
        var _ =  * , FagalRE, instance, space;
        var shaderParams = FagalRE.instance.context3DCache.shaderParams;
        var commonShaderParams = shaderParams.getOrCreateComponentByClass(feng3d.CommonShaderParams);
        var lightShaderParams = shaderParams.getOrCreateComponentByClass(feng3d.LightShaderParams);
        var numDirectionalLights = lightShaderParams.numDirectionalLights;
        //遍历处理每个方向光
        for (var i = 0; i < numDirectionalLights; ++i) {
            //灯光方向寄存器
            var lightDirReg = _.dirLightSceneDir_fc_vector.getReg(i);
            //漫反射颜色寄存器
            var diffuseColorReg = _.dirLightDiffuse_fc_vector.getReg(i);
            //镜面反射颜色寄存器
            var specularColorReg = _.dirLightSpecular_fc_vector.getReg(i);
            //处理每个光的漫反射
            if (commonShaderParams.usingDiffuseMethod > 0) {
                getDiffCodePerLight(lightDirReg, diffuseColorReg);
            }
            //处理每个光的镜面反射
            if (lightShaderParams.usingSpecularMethod > 0) {
                getSpecCodePerLight(lightDirReg, specularColorReg);
            }
        }
    }
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * phong model
     * @author feng 2015-9-24
     */
    constructor(singleSpecularColorReg, Register, lightDirReg, Register);
    {
        var _ =  * , FagalRE, instance, space;
        // phong model
        _.dp3(singleSpecularColorReg.w, lightDirReg, _.normal_ft_4); // sca1 = light.normal
        //find the reflected light vector R
        _.add(singleSpecularColorReg.w, singleSpecularColorReg.w, singleSpecularColorReg.w); // sca1 = sca1*2
        _.mul(singleSpecularColorReg.xyz, _.normal_ft_4, singleSpecularColorReg.w); // vec1 = normal*sca1
        _.sub(singleSpecularColorReg.xyz, singleSpecularColorReg, lightDirReg); // vec1 = vec1 - light (light vector is negative)
        //smooth the edge as incidence angle approaches 90
        _.add(singleSpecularColorReg.w, singleSpecularColorReg.w, _.commonsData_fc_vector.w); // sca1 = sca1 + smoothtep;
        _.sat(singleSpecularColorReg.w, singleSpecularColorReg.w); // sca1 range 0 - 1
        _.mul(singleSpecularColorReg.xyz, singleSpecularColorReg, singleSpecularColorReg.w); // vec1 = vec1*sca1
        //find the dot product between R and V
        _.dp3(singleSpecularColorReg.w, singleSpecularColorReg, _.viewDir_ft_4); // sca1 = vec1.view
        _.sat(singleSpecularColorReg.w, singleSpecularColorReg.w);
    }
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 点光源渲染
     * @author feng 2014-11-8
     */
    constructor();
    {
        var _ =  * , FagalRE, instance, space;
        var shaderParams = FagalRE.instance.context3DCache.shaderParams;
        var commonShaderParams = shaderParams.getOrCreateComponentByClass(feng3d.CommonShaderParams);
        var lightShaderParams = shaderParams.getOrCreateComponentByClass(feng3d.LightShaderParams);
        var numPointLights = lightShaderParams.numPointLights;
        //
        //光线方向
        var pointLightDirReg;
        //点光源漫反射颜色寄存器
        var pointLightdiffuseColorReg;
        //点光源镜面反射颜色寄存器
        var pointLightSpecularColorReg;
        //点光源世界坐标寄存器
        var pointLightPosReg;
        pointLightDirReg = _.getFreeTemp("光照方向");
        //遍历点光源
        for (var i = 0; i < numPointLights; ++i) {
            pointLightPosReg = _.pointLightScenePos_fc_vector.getReg(i);
            pointLightdiffuseColorReg = _.pointLightDiffuse_fc_vector.getReg(i);
            pointLightSpecularColorReg = _.pointLightSpecular_fc_vector.getReg(i);
            _.comment("计算光照方向与光强");
            // 计算光衰减 （根据物体表面离光源的距离来计算光强）
            //物体表面到光源距离
            _.sub(pointLightDirReg, pointLightPosReg, _.globalPos_v);
            // attenuate
            _.dp3(pointLightDirReg.w, pointLightDirReg, pointLightDirReg);
            // w = d - radis
            _.sub(pointLightDirReg.w, pointLightDirReg.w, pointLightdiffuseColorReg.w);
            // w = (d - radius)/(max-min) 
            _.mul(pointLightDirReg.w, pointLightDirReg.w, pointLightSpecularColorReg.w);
            // w = clamp(w, 0, 1)
            _.sat(pointLightDirReg.w, pointLightDirReg.w);
            // w = 1-w (w为光强)
            _.sub(pointLightDirReg.w, pointLightPosReg.w, pointLightDirReg.w);
            // normalize
            _.nrm(pointLightDirReg.xyz, pointLightDirReg); //
            //计算漫反射
            if (commonShaderParams.usingDiffuseMethod) {
                getDiffCodePerLight(pointLightDirReg, pointLightdiffuseColorReg);
            }
            //计算镜面反射
            if (lightShaderParams.usingSpecularMethod) {
                getSpecCodePerLight(pointLightDirReg, pointLightSpecularColorReg);
            }
        }
    }
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 结算镜面反射光
     * @author feng 2014-11-7
     */
    constructor();
    {
        var _ =  * , FagalRE, instance, space;
        var shaderParams = FagalRE.instance.context3DCache.shaderParams;
        var lightShaderParams = shaderParams.getOrCreateComponentByClass(feng3d.LightShaderParams);
        var shadowShaderParams = shaderParams.getOrCreateComponentByClass(feng3d.ShadowShaderParams);
        //把阴影值使用到镜面反射上
        if (shadowShaderParams.needsShadowRegister) {
            _.mul(_.totalSpecularLightColor_ft_4.xyz, _.totalSpecularLightColor_ft_4, _.shadowValue_ft_4.w);
        }
        if (lightShaderParams.hasSpecularTexture > 0) {
            _.mul(_.totalSpecularLightColor_ft_4.xyz, _.totalSpecularLightColor_ft_4, _.specularTexData_ft_4.x);
        }
        //混合镜面反射光 = 镜面反射光颜色 mul 材质镜面反射颜色
        _.mul(_.totalSpecularLightColor_ft_4.xyz, _.totalSpecularLightColor_ft_4, _.specularData_fc_vector);
        //添加到最终颜色中
        _.add(_.finalColor_ft_4.xyz, _.finalColor_ft_4, _.totalSpecularLightColor_ft_4);
    }
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     *
     * @author feng 2015-9-24
     */
    var SpecularModelType = (function () {
        function SpecularModelType() {
        }
        SpecularModelType.BLINN_PHONG = "blinn-phong half vector model";
        SpecularModelType.PHONG = "phong model";
        return SpecularModelType;
    }());
    feng3d.SpecularModelType = SpecularModelType;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 处理
     * @author feng 2015-4-24
     */
    constructor(lightDirReg, Register, diffuseColorReg, Register);
    {
        var _ =  * , FagalRE, instance, space;
        var shaderParams = FagalRE.instance.context3DCache.shaderParams;
        var lightShaderParams = shaderParams.getOrCreateComponentByClass(feng3d.LightShaderParams);
        var diffuseColorFtReg;
        if (lightShaderParams.isFirstDiffLight) {
            diffuseColorFtReg = _.totalDiffuseLightColor_ft_4;
        }
        else {
            diffuseColorFtReg = _.getFreeTemp("单个漫反射光寄存器");
        }
        //计算灯光方向与法线夹角
        _.dp3(diffuseColorFtReg.x, lightDirReg, _.normal_ft_4);
        //过滤负数
        _.max(diffuseColorFtReg.w, diffuseColorFtReg.x, _.commonsData_fc_vector.y);
        //灯光衰减
        if (lightShaderParams.useLightFallOff)
            _.mul(diffuseColorFtReg.w, diffuseColorFtReg.w, lightDirReg.w);
        if (shaderParams.diffuseModulateMethod != null) {
            shaderParams.diffuseModulateMethod(diffuseColorFtReg);
        }
        _.comment("漫反射光颜色 = 灯光漫反射颜色 mul 漫反射光强度");
        _.mul(diffuseColorFtReg, diffuseColorFtReg.w, diffuseColorReg);
        //叠加灯光
        if (!lightShaderParams.isFirstDiffLight) {
            _.add(_.totalDiffuseLightColor_ft_4.xyz, _.totalDiffuseLightColor_ft_4, diffuseColorFtReg);
        }
        lightShaderParams.isFirstDiffLight = false;
    }
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 计算单个镜面反射光
     * @author feng 2015-4-24
     */
    constructor(lightDirReg, Register, specularColorReg, Register);
    {
        var _ =  * , FagalRE, instance, space;
        var shaderParams = FagalRE.instance.context3DCache.shaderParams;
        var lightShaderParams = shaderParams.getOrCreateComponentByClass(feng3d.LightShaderParams);
        //镜面反射光原理
        //法线 = 入射光方向 - 反射光方向------------1
        //物理光学已知：当视线方向与反射光方向相反时，反射光达到最亮。反射光强度和（反射光方向与-视线方向 的 夹角余弦值）相关
        //反射光方向与-视线 的 夹角 ---(代入1)--> (入射光方向 - 法线) 与 -视线 的 夹角 ----> 入射光方向+视线 与 法线的夹角
        //反射光方向与-视线方向 的 夹角余弦值 == 入射光方向+视线 与 法线 的 夹角余弦值  == 反射光强度
        var singleSpecularColorReg;
        if (lightShaderParams.isFirstSpecLight) {
            singleSpecularColorReg = _.totalSpecularLightColor_ft_4;
        }
        else {
            singleSpecularColorReg = _.getFreeTemp("单个镜面反射光寄存器");
        }
        //灯光模型
        if (shaderParams.specularModelType == feng3d.SpecularModelType.PHONG) {
            F_Phong(singleSpecularColorReg, lightDirReg);
        }
        else {
            F_Blinn_Phong(singleSpecularColorReg, lightDirReg);
        }
        if (lightShaderParams.hasSpecularTexture > 0) {
            //使用光照图调整高光
            //光泽纹理数据片段临时寄存器
            _.mul(_.specularTexData_ft_4.w, _.specularTexData_ft_4.y, _.specularData_fc_vector.w);
            _.pow(singleSpecularColorReg.w, singleSpecularColorReg.w, _.specularTexData_ft_4.w);
        }
        else {
            //镜面反射光强度 = 镜面反射光强度 pow 光泽度
            _.pow(singleSpecularColorReg.w, singleSpecularColorReg.w, _.specularData_fc_vector.w);
        }
        if (lightShaderParams.useLightFallOff) {
            //镜面反射光强度 = 镜面反射强度  nul (入射光强度？)
            _.mul(singleSpecularColorReg.w, singleSpecularColorReg.w, lightDirReg.w);
        }
        if (shaderParams.modulateMethod != null) {
            shaderParams.modulateMethod(singleSpecularColorReg);
        }
        _.comment("镜面反射光颜色 = 灯光镜面反射颜色 mul 镜面反射光强度");
        _.mul(singleSpecularColorReg.xyz, specularColorReg, singleSpecularColorReg.w);
        //叠加镜面反射光
        if (!lightShaderParams.isFirstSpecLight) {
            //总镜面反射光 = 总镜面反射光 + 单个镜面反射光
            _.add(_.totalSpecularLightColor_ft_4.xyz, _.totalSpecularLightColor_ft_4, singleSpecularColorReg);
        }
        lightShaderParams.isFirstSpecLight = false;
    }
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     *
     * @author feng 2015-9-24
     */
    constructor(target, Register);
    {
        var _ =  * , FagalRE, instance, space;
        var shaderParams = FagalRE.instance.context3DCache.shaderParams;
        var _dataReg = _.fresnelSpecularData_fc_vector;
        var _incidentLight = shaderParams.incidentLight;
        _.dp3(target.y, _.viewDir_ft_4.xyz, _incidentLight ? target.xyz : _.normal_ft_4.xyz); // dot(V, H)
        _.sub(target.y, _dataReg.z, target.y); // base = 1-dot(V, H)
        _.pow(target.x, target.y, _dataReg.y); // exp = pow(base, 5)
        _.sub(target.y, _dataReg.z, target.y); // 1 - exp
        _.mul(target.y, _dataReg.x, target.y); // f0*(1 - exp)
        _.add(target.y, target.x, target.y); // exp + f0*(1 - exp)
        _.mul(target.w, target.w, target.y);
    }
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     *
     * @author feng 2015-1-21
     */
    constructor();
    {
        var _ =  * , FagalRE, instance, space;
        //			if (hasColorMulNode)
        _.mul(_.finalColor_ft_4, _.finalColor_ft_4, _.particleColorMultiplier_v);
        //			if (hasColorAddNode)
        _.add(_.finalColor_ft_4, _.finalColor_ft_4, _.particleColorOffset_v);
    }
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 粒子片段渲染程序
     * @author feng 2015-1-21
     */
    constructor();
    {
        var shaderParams = FagalRE.instance.context3DCache.shaderParams;
        var particleShaderParams = shaderParams.getOrCreateComponentByClass(feng3d.ParticleShaderParams);
        /** 粒子渲染参数 */
        if (particleShaderParams.ParticleColorGlobal) {
            F_ParticleColorCombination();
        }
    }
})(feng3d || (feng3d = {}));
var feng3dMap;
(function (feng3dMap) {
    /**
     * 编译阴影映射片段程序
     * @author feng 2015-6-23
     */
    constructor();
    {
        var _ =  * , FagalRE, instance, space;
        var shaderParams = FagalRE.instance.context3DCache.shaderParams;
        var shadowShaderParams = shaderParams.getOrCreateComponentByClass(ShadowShaderParams);
        F_ShadowMapSample();
        _.add(_.shadowValue_ft_4.w, _.shadowValue_ft_4.w, _.shadowCommondata1_fc_vector.y); //添加(1-阴影透明度)
        _.sat(_.shadowValue_ft_4.w, _.shadowValue_ft_4.w); //使阴影值在(0,1)区间内
        var temp = _.getFreeTemp();
        if (shadowShaderParams.useNearShadowMap > 0) {
            //根据阴影离摄像机的距离计算阴影的透明度
            _.abs(temp, _.positionProjected_v.w); //获取顶点深度正值
            _.sub(temp, temp, _.secondary_fc_vector.x); //深度-最近可观察阴影距离
            _.mul(temp, temp, _.secondary_fc_vector.y); //计算衰减值
            _.sat(temp, temp); //
            _.sub(temp, _.secondary_fc_vector.w, temp); //ft5.x（阴影透明度）=1-衰减值
            _.sub(_.shadowValue_ft_4.w, _.secondary_fc_vector.w, _.shadowValue_ft_4.w); //ft0.w==1时为阴影
            _.mul(_.shadowValue_ft_4.w, _.shadowValue_ft_4.w, temp); //阴影乘以透明度
            _.sub(_.shadowValue_ft_4.w, _.secondary_fc_vector.w, _.shadowValue_ft_4.w); //ft0.w==0时为阴影
        }
    }
})(feng3dMap || (feng3dMap = {}));
var feng3dMap;
(function (feng3dMap) {
    /**
     * 阴影图采样比较计算阴影值
     * @author feng 2015-7-17
     */
    constructor();
    {
        var _ =  * , FagalRE, instance, space;
        var depthCol = _.getFreeTemp("深度值临时寄存器");
        var uvReg = _.getFreeTemp("深度图uv临时寄存器");
        _.mov(uvReg, _.depthMapCoord_v); //计算阴影
        _.tex(depthCol, _.depthMapCoord_v, _.depthMap_fs); //读取阴影图值
        _.dp4(depthCol.z, depthCol, _.shadowCommondata0_fc_vector);
        _.slt(uvReg.z, _.depthMapCoord_v.z, depthCol.z); //比较深度 // 0 if in shadow
        _.add(uvReg.x, _.depthMapCoord_v.x, _.shadowCommondata2_fc_vector.z); //取(1,0)位置的深度值
        _.tex(depthCol, uvReg, _.depthMap_fs); //读取阴影图值
        _.dp4(depthCol.z, depthCol, _.shadowCommondata0_fc_vector);
        _.slt(uvReg.w, _.depthMapCoord_v.z, depthCol.z); //与(1,0)深度做比较 // 0 if in shadow
        _.mul(depthCol.x, _.depthMapCoord_v.x, _.shadowCommondata2_fc_vector.y); //计算顶点在阴影图的像素x位置
        _.frc(depthCol.x, depthCol.x); //取出分数部分  0<分数部分<1
        _.blend(_.shadowValue_ft_4.w, uvReg.z, uvReg.w, depthCol.x); //混合(0,0)与(1,0)的深度结果
        //与(0,1)深度做比较
        _.mov(uvReg.x, _.depthMapCoord_v.x);
        _.add(uvReg.y, _.depthMapCoord_v.y, _.shadowCommondata2_fc_vector.z); // (0, 1)
        _.tex(depthCol, uvReg, _.depthMap_fs);
        _.dp4(depthCol.z, depthCol, _.shadowCommondata0_fc_vector);
        _.slt(uvReg.z, _.depthMapCoord_v.z, depthCol.z); // 0 if in shadow
        //与(1,1)深度做比较
        _.add(uvReg.x, _.depthMapCoord_v.x, _.shadowCommondata2_fc_vector.z); // (1, 1)
        _.tex(depthCol, uvReg, _.depthMap_fs);
        _.dp4(depthCol.z, depthCol, _.shadowCommondata0_fc_vector);
        _.slt(uvReg.w, _.depthMapCoord_v.z, depthCol.z); // 0 if in shadow
        //根据X方向分数部分来混合(0,1)与(1,1)的深度结果  x1-x0
        _.mul(depthCol.x, _.depthMapCoord_v.x, _.shadowCommondata2_fc_vector.y);
        _.frc(depthCol.x, depthCol.x);
        _.blend(uvReg.w, uvReg.z, uvReg.w, depthCol.x);
        //再次根据Y方向分数部分来混合两次X方向混合的结果
        _.mul(depthCol.x, _.depthMapCoord_v.y, _.shadowCommondata2_fc_vector.y);
        _.frc(depthCol.x, depthCol.x);
        _.blend(_.shadowValue_ft_4.w, _.shadowValue_ft_4.w, uvReg.w, depthCol.x);
    }
})(feng3dMap || (feng3dMap = {}));
var feng3d;
(function (feng3d) {
    /**
     * 漫反射材质颜色
     * @author feng 2014-11-6
     */
    constructor();
    {
        var _ =  * , FagalRE, instance, space;
        //漫射输入静态数据 
        _.mov(_.mDiff_ft, _.diffuseInput_fc_vector);
    }
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 漫反射纹理取样
     * @author feng 2014-11-6
     */
    constructor();
    {
        var _ =  * , FagalRE, instance, space;
        var shaderParams = FagalRE.instance.context3DCache.shaderParams;
        var commonShaderParams = shaderParams.getOrCreateComponentByClass(feng3d.CommonShaderParams);
        _.tex(_.mDiff_ft, _.uv_v, _.texture_fs);
        if (commonShaderParams.alphaThreshold > 0) {
            var cutOffReg = _.alphaThreshold_fc_vector;
            _.sub(_.mDiff_ft.w, _.mDiff_ft.w, cutOffReg.x);
            _.kil(_.mDiff_ft.w);
            _.add(_.mDiff_ft.w, _.mDiff_ft.w, cutOffReg.x);
        }
    }
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     *
     * @author feng 2015-9-5
     */
    constructor();
    {
        var _ =  * , FagalRE, instance, space;
        var shaderParams = FagalRE.instance.context3DCache.shaderParams;
        var envShaderParams = shaderParams.getOrCreateComponentByClass(feng3d.EnvShaderParams);
        var dataRegister = _.envMapData_fc_vector;
        var temp = _.getFreeTemp("");
        var cubeMapReg = _.envMapcubeTexture_fs;
        var temp2 = _.getFreeTemp("");
        var targetReg = _.finalColor_ft_4;
        // r = I - 2(I.N)*N
        _.dp3(temp.w, _.viewDir_ft_4.xyz, _.normal_ft_4.xyz);
        _.add(temp.w, temp.w, temp.w);
        _.mul(temp.xyz, _.normal_ft_4.xyz, temp.w);
        _.sub(temp.xyz, temp.xyz, _.viewDir_ft_4.xyz);
        //有些没看懂..................................
        _.tex(temp, temp, cubeMapReg);
        _.sub(temp2.w, temp.w, _.commonsData_fc_vector.x); // -.5
        _.kil(temp2.w); // used for real time reflection mapping - if alpha is not 1 (mock texture) kil output
        _.sub(temp, temp, targetReg);
        if (envShaderParams.useEnvMapMask) {
            _.tex(temp2, _.uv_v, _.envMapMaskTexture_fs);
            _.mul(temp, temp2, temp);
        }
        _.mul(temp, temp, dataRegister.x);
        _.add(targetReg, targetReg, temp);
    }
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 最终颜色输出函数
     * @author feng 2014-11-7
     */
    constructor();
    {
        var _ =  * , FagalRE, instance, space;
        _.mov(_._oc, _.finalColor_ft_4);
    }
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 雾片段着色器
     * @author feng 2015-8-27
     */
    constructor();
    {
        var _ =  * , FagalRE, instance, space;
        var temp2 = _.getFreeTemp("");
        var temp = _.getFreeTemp("");
        //计算雾因子
        //fogRatio = max(0,min(1,(positionZ-minZ)/(maxZ-minZ)))
        _.sub(temp2.w, _.positionProjected_v.z, _.fogCommonData_fc_vector.x); //deltaZ=positionZ-minZ
        _.mul(temp2.w, temp2.w, _.fogCommonData_fc_vector.y); //fogRatio = deltaZ/(maxZ-minZ)
        _.sat(temp2.w, temp2.w); //fogRatio = max(0,fogRatio))
        //使用雾因子把雾颜色混合到最终颜色中
        //col = (fogColor - col) * fogRatio + col = fogRatio * fogColor + (1 - fogRatio) * col
        _.sub(temp, _.fogColor_fc_vector, _.finalColor_ft_4); // (fogColor- col)
        _.mul(temp, temp, temp2.w); // (fogColor- col)*fogRatio
        _.add(_.finalColor_ft_4, _.finalColor_ft_4, temp); // fogRatio*(fogColor- col) + col
    }
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 法线取样函数
     * @author feng 2014-10-23
     */
    constructor();
    {
        var _ =  * , FagalRE, instance, space;
        //获取纹理数据
        _.tex(_.normalTexData_ft_4, _.uv_v, _.normalTexture_fs);
        //使法线纹理数据 【0,1】->【-0.5,0.5】
        _.sub(_.normalTexData_ft_4.xyz, _.normalTexData_ft_4.xyz, _.commonsData_fc_vector.xxx);
        //标准化法线纹理数据
        _.nrm(_.normalTexData_ft_4.xyz, _.normalTexData_ft_4.xyz);
    }
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 光泽图取样函数
     * @author feng 2014-10-23
     */
    constructor();
    {
        var _ =  * , FagalRE, instance, space;
        //获取纹理数据
        _.tex(_.specularTexData_ft_4, _.uv_v, _.specularTexture_fs);
    }
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 编译切线法线贴图片段程序
     * @author feng 2014-11-7
     */
    constructor();
    {
        var _ =  * , FagalRE, instance, space;
        //此处必须三个寄存器申请为寄存器数组来确保三个临时寄存器连续与同时销毁
        var normalMxt3 = _.getFreeTemps("动画后顶点法线空间寄存器向量，(切线，双切线，法线)", 3);
        var t = normalMxt3.getReg(0);
        var b = normalMxt3.getReg(1);
        var n = normalMxt3.getReg(2);
        //标准化切线
        _.nrm(t.xyz, _.tangent_v);
        //保存w不变
        _.mov(t.w, _.tangent_v.w);
        //标准化双切线
        _.nrm(b.xyz, _.bitangent_v);
        //标准化法线
        _.nrm(n.xyz, _.normal_v);
        F_NormalSample();
        //标准化法线纹理数据
        _.m33(_.normal_ft_4.xyz, _.normalTexData_ft_4, t);
        //保存w不变
        _.mov(_.normal_ft_4.w, _.normal_v.w);
    }
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 编译切线片段程序(无法线图)
     * @author feng 2014-11-7
     */
    constructor();
    {
        var _ =  * , FagalRE, instance, space;
        //标准化法线
        _.nrm(_.normal_ft_4.xyz, _.normal_v);
        //保存w不变
        _.mov(_.normal_ft_4.w, _.normal_v.w);
    }
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 地形渲染函数
     * @author feng 2014-11-6
     */
    constructor();
    {
        var _ =  * , FagalRE, instance, space;
        var shaderParams = FagalRE.instance.context3DCache.shaderParams;
        var terrainShaderParams = shaderParams.getOrCreateComponentByClass(feng3d.TerrainShaderParams);
        var numSplattingLayers = terrainShaderParams.splatNum;
        //缩放后的uv坐标、uv计算后的颜色值
        var uvTemp = _.getFreeTemp("缩放后的uv坐标");
        //混合比例（4个分量表示4个纹理所占比重）
        var blendTemp = _.getFreeTemp("混合比例");
        _.mul(uvTemp, _.uv_v, _.tile_fc_vector.c(0)); // 缩放uv （表示将重复x*x遍） x=scaleRegister.c(0)
        _.tex(_.finalColor_ft_4, uvTemp, _.texture_fs); // 使用默认贴图 得到默认颜色值
        _.tex(blendTemp, _.uv_v, _.blendingtexture_fs); // 计算混合纹理
        for (var i = 0; i < numSplattingLayers; ++i) {
            _.mul(uvTemp, _.uv_v, _.tile_fc_vector.c(i + 1)); //  缩放uv （表示将重复x*x遍） x=scaleRegister.c(i + 1)
            _.tex(uvTemp, uvTemp, _.terrainTextures_fs_array.getReg(i)); // 使用地面纹理 得到该纹理颜色值
            _.sub(uvTemp, uvTemp, _.finalColor_ft_4); // uvtemp = uvtemp - targetreg; --------------1
            _.mul(uvTemp, uvTemp, blendTemp.c(i)); // uvtemp = uvtemp * blendtemp; ----------2  (0 <= blendtemp <= 1)
            _.add(_.finalColor_ft_4, _.finalColor_ft_4, uvTemp); // 添加到默认颜色值上  targetreg = targetreg + uvtemp; ------------3
        }
    }
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 视线片段渲染函数
     * @author feng 2014-11-7
     */
    constructor();
    {
        var _ =  * , FagalRE, instance, space;
        //标准化视线
        _.nrm(_.viewDir_ft_4.xyz, _.viewDir_v);
        //保持w不变
        _.mov(_.viewDir_ft_4.w, _.viewDir_v.w);
    }
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * Fagal函数
     * @author feng 2014-10-23
     */
    var FagalMethod = (function () {
        /**
         * 构建一个Fagal函数
         */
        function FagalMethod() {
            feng3d.AbstractClassError.check(this);
        }
        Object.defineProperty(FagalMethod.prototype, "shaderParams", {
            /**
             * 渲染参数
             */
            get: function () {
                return FagalRE.instance.context3DCache.shaderParams;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FagalMethod.prototype, "shaderType", {
            /**
             * 着色器类型
             */
            get: function () {
                return _shaderType;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 运行函数，产生agal代码，最核心部分
         */
        FagalMethod.prototype.runFunc = function () {
            throw new feng3d.AbstractMethodError();
        };
        return FagalMethod;
    }());
    feng3d.FagalMethod = FagalMethod;
})(feng3d || (feng3d = {}));
var feng3dMap;
(function (feng3dMap) {
    /**
     * 深度图片段主程序
     * @author feng 2015-5-30
     */
    var F_Main_DepthMap = (function (_super) {
        __extends(F_Main_DepthMap, _super);
        /**
         * 创建深度图片段主程序
         */
        function F_Main_DepthMap() {
            _shaderType = Context3DProgramType.FRAGMENT;
        }
        /**
         * @inheritDoc
         */
        F_Main_DepthMap.prototype.runFunc = function () {
            var _ =  * , FagalRE, instance, space;
            var positionReg = _.getFreeTemp("坐标"); //ft2
            //深度的（乘以1,255,255*255,255*255*255后）不同值
            var depthValueReg = _.getFreeTemp("深度值");
            var ft1 = _.getFreeTemp("");
            //计算深度值depth属于（0,1）,该范围外的将会被frc处理为0或1
            _.div(positionReg, _.positionProjected_v, _.positionProjected_v.w);
            //深度值保存为颜色值
            _.mul(depthValueReg, _.depthCommonData0_fc_vector, positionReg.z);
            //和上行代码配合，保存了深度的1/255/255/255的精度的值
            _.frc(depthValueReg, depthValueReg);
            //计算多余的值
            _.mul(ft1, depthValueReg.yzww, _.depthCommonData1_fc_vector);
            //真正的深度值 = 减去多余的(1/255)值  （精度在1/255/255/255）
            _.sub(_.depthMap_oc, depthValueReg, ft1);
            /*
    片段着色器计算貌似有些高深。。,
    其目的是使用rgba高精度方式保存深度值，并且可以从rgba中获取深度值。
    此处应把深度看为255进制数据，rgba分别保存4个位(1，1/255，1/255/255,1/255/255/255)的值。
    此处使用rgba分别保存（1，1/255,1/255/255,1/255/255/255）这4个不同精度的值
    depth = r*1 + g/255 + b/255/255 + a/255/255/255 + x；此处有depth,r,g,b,a属于(0,1)范围;地处x<1/255/255/255,x可忽略不计
    
    正常计算rgba的方法
    r=frc(depth)-frc(depth*255)/255;
    g=frc(depth*255)-frc(depth*255*255)/255;
    b=frc(depth*255*255)-frc(depth*255*255)/255;
    a=frc(depth*255*255*255)-frc(depth*255*255*255*255)/255;
    由于无法生成depth*255*255*255*255的值，精度就定在1/255/255/255，精度只会在1/255/255/255出有损失
    因此 a= frc(depth*255*255*255)
    
    
    通过渲染程序推倒
    mul ft0, fc0, ft2.z 		=> depth*(1,255,255*255,255*255*255)=(depth,depth*255,depth*255*255,depth*255*255*255)
    frc ft0, ft0				=> (frc(depth),frc(depth*255),frc(depth*255*255),frc(depth*255*255*255))
    mul ft1, ft0.yzww, fc1		=>	(frc(depth*255)/255,frc(depth*255*255)/255,frc(depth*255*255*255)/255,0)
    sub oc, ft0, ft1			=>	(frc(depth)-frc(depth*255)/255,frc(depth*255)-frc(depth*255*255)/255,frc(depth*255*255)-frc(depth*255*255*255)/255,frc(depth*255*255*255))
    =>	(r,g,b,a)
    */
        };
        return F_Main_DepthMap;
    }(FagalMethod));
    feng3dMap.F_Main_DepthMap = F_Main_DepthMap;
})(feng3dMap || (feng3dMap = {}));
var feng3dMap;
(function (feng3dMap) {
    /**
     * 深度图片段主程序
     * @author feng 2015-5-30
     */
    var F_Main_PlanarShadow = (function (_super) {
        __extends(F_Main_PlanarShadow, _super);
        /**
         * 创建深度图片段主程序
         */
        function F_Main_PlanarShadow() {
            _shaderType = Context3DProgramType.FRAGMENT;
        }
        /**
         * @inheritDoc
         */
        F_Main_PlanarShadow.prototype.runFunc = function () {
            var _ =  * , FagalRE, instance, space;
            _.mov(_._oc, _.shadowColorCommonsData_fc_vector);
        };
        return F_Main_PlanarShadow;
    }(FagalMethod));
    feng3dMap.F_Main_PlanarShadow = F_Main_PlanarShadow;
})(feng3dMap || (feng3dMap = {}));
var feng3d;
(function (feng3d) {
    _AlphaPremultiplied;
    _Ambient;
    _DirectionalLight;
    _PointLight;
    _SpecularPostLighting;
    _Particles;
    _ShadowMap;
    /**
     * 片段渲染程序主入口
     * @author feng 2014-10-30
     */
    var F_Main = (function (_super) {
        __extends(F_Main, _super);
        /**
         * 创建片段渲染程序主入口
         */
        function F_Main() {
            _shaderType = Context3DProgramType.FRAGMENT;
        }
        /**
         * @inheritDoc
         */
        F_Main.prototype.runFunc = function () {
            this.shaderParams.preRunParams();
            var commonShaderParams = this.shaderParams.getOrCreateComponentByClass(feng3d.CommonShaderParams);
            var lightShaderParams = this.shaderParams.getOrCreateComponentByClass(feng3d.LightShaderParams);
            var shadowShaderParams = this.shaderParams.getOrCreateComponentByClass(feng3d.ShadowShaderParams);
            var fogShaderParams = this.shaderParams.getOrCreateComponentByClass(feng3d.FogShaderParams);
            var envShaderParams = this.shaderParams.getOrCreateComponentByClass(feng3d.EnvShaderParams);
            //计算法线
            if (lightShaderParams.needsNormals > 0) {
                if (lightShaderParams.hasNormalTexture) {
                    F_TangentNormalMap();
                }
                else {
                    F_TangentNormalNoMap();
                }
            }
            //光泽图采样
            if (lightShaderParams.hasSpecularTexture > 0) {
                F_SpecularSample();
            }
            //计算视线
            if (lightShaderParams.needsViewDir > 0) {
                F_ViewDir();
            }
            //处理方向灯光
            if (lightShaderParams.numDirectionalLights > 0) {
                F_DirectionalLight();
            }
            //处理点灯光
            if (lightShaderParams.numPointLights > 0) {
                F_PointLight();
            }
            //计算环境光
            if (lightShaderParams.numLights > 0) {
                F_Ambient();
            }
            //渲染阴影
            if (shadowShaderParams.usingShadowMapMethod > 0) {
                F_ShadowMap();
            }
            //计算漫反射
            if (commonShaderParams.usingDiffuseMethod) {
                lightShaderParams.diffuseMethod();
            }
            if (this.shaderParams.alphaPremultiplied) {
                F_AlphaPremultiplied();
            }
            if (lightShaderParams.numLights > 0 && lightShaderParams.usingSpecularMethod > 0) {
                F_SpecularPostLighting();
            }
            //调用粒子相关片段渲染程序
            F_Particles();
            if (envShaderParams.useEnvMapMethod > 0) {
                F_EnvMapMethod();
            }
            if (fogShaderParams.useFog > 0) {
                F_Fog();
            }
            F_FinalOut();
        };
        return F_Main;
    }(feng3d.FagalMethod));
    feng3d.F_Main = F_Main;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 线段片段渲染程序
     * @author feng 2014-10-28
     */
    var F_Segment = (function (_super) {
        __extends(F_Segment, _super);
        function F_Segment() {
            _shaderType = Context3DProgramType.FRAGMENT;
        }
        F_Segment.prototype.runFunc = function () {
            var _ =  * , FagalRE, instance, space;
            _.comment("传递顶点颜色数据" + _.color_v + "到片段寄存器" + _._oc);
            _.mov(_._oc, _.color_v);
        };
        return F_Segment;
    }(feng3d.FagalMethod));
    feng3d.F_Segment = F_Segment;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 天空盒片段渲染程序
     * @author feng 2014-11-4
     */
    var F_SkyBox = (function (_super) {
        __extends(F_SkyBox, _super);
        function F_SkyBox() {
            _shaderType = Context3DProgramType.FRAGMENT;
        }
        F_SkyBox.prototype.runFunc = function () {
            var _ =  * , FagalRE, instance, space;
            //获取纹理数据
            _.tex(_._oc, _.uv_v, _.skyboxTexture_fs);
        };
        return F_SkyBox;
    }(feng3d.FagalMethod));
    feng3d.F_SkyBox = F_SkyBox;
})(feng3d || (feng3d = {}));
var feng3dMap;
(function (feng3dMap) {
    _BaseAnimation;
    _SkeletonAnimationCPU;
    _SkeletonAnimationGPU;
    _VertexAnimationCPU;
    _VertexAnimationGPU;
    _Particles;
    /**
     * 深度图顶点主程序
     * @author feng 2015-5-30
     */
    var V_Main_DepthMap = (function (_super) {
        __extends(V_Main_DepthMap, _super);
        /**
         * 构建 深度图顶点主程序
         */
        function V_Main_DepthMap() {
            _shaderType = Context3DProgramType.VERTEX;
        }
        /**
         * @inheritDoc
         */
        V_Main_DepthMap.prototype.runFunc = function () {
            var _ =  * , FagalRE, instance, space;
            this.buildAnimationAGAL();
            //普通动画
            //			_.mov(_.animatedPosition_vt_4, _.position_va_3);
            var outPosition = _.getFreeTemp("投影后的坐标");
            //计算投影
            _.m44(outPosition, _.animatedPosition_vt_4, _.projection_vc_matrix);
            //输出顶点坐标数据			
            _.mov(_._op, outPosition);
            //把顶点投影坐标输出到片段着色器
            _.mov(_.positionProjected_v, outPosition);
        };
        /**
         * 生成动画代码
         */
        V_Main_DepthMap.prototype.buildAnimationAGAL = function () {
            var animationShaderParams = this.shaderParams.getOrCreateComponentByClass(AnimationShaderParams);
            switch (animationShaderParams.animationType) {
                case AnimationType.NONE:
                    V_BaseAnimation();
                    break;
                case AnimationType.VERTEX_CPU:
                    V_VertexAnimationCPU();
                    break;
                case AnimationType.VERTEX_GPU:
                    V_VertexAnimationGPU();
                    break;
                case AnimationType.SKELETON_CPU:
                    V_SkeletonAnimationCPU();
                    break;
                case AnimationType.SKELETON_GPU:
                    V_SkeletonAnimationGPU();
                    break;
                case AnimationType.PARTICLE:
                    V_Particles();
                    break;
                default:
                    throw new Error(AnimationType.PARTICLE + "类型动画缺少FAGAL代码");
                    break;
            }
        };
        return V_Main_DepthMap;
    }(FagalMethod));
    feng3dMap.V_Main_DepthMap = V_Main_DepthMap;
})(feng3dMap || (feng3dMap = {}));
var feng3dMap;
(function (feng3dMap) {
    _BaseAnimation;
    _SkeletonAnimationCPU;
    _SkeletonAnimationGPU;
    _VertexAnimationCPU;
    _VertexAnimationGPU;
    _Particles;
    /**
     * 平面阴影顶点主程序
     * @author feng 2015-5-30
     */
    var V_Main_PlanarShadow = (function (_super) {
        __extends(V_Main_PlanarShadow, _super);
        /**
         * 构建 深度图顶点主程序
         */
        function V_Main_PlanarShadow() {
            _shaderType = Context3DProgramType.VERTEX;
        }
        /**
         * @inheritDoc
         */
        V_Main_PlanarShadow.prototype.runFunc = function () {
            var _ =  * , FagalRE, instance, space;
            this.buildAnimationAGAL();
            var outPosition = _.getFreeTemp("投影后的坐标");
            //计算投影
            _.m44(outPosition, _.animatedPosition_vt_4, _.projection_vc_matrix);
            //输出顶点坐标数据			
            _.mov(_._op, outPosition);
            //把顶点投影坐标输出到片段着色器
            _.mov(_.positionProjected_v, outPosition);
        };
        /**
         * 生成动画代码
         */
        V_Main_PlanarShadow.prototype.buildAnimationAGAL = function () {
            var animationShaderParams = this.shaderParams.getOrCreateComponentByClass(AnimationShaderParams);
            switch (animationShaderParams.animationType) {
                case AnimationType.NONE:
                    V_BaseAnimation();
                    break;
                case AnimationType.VERTEX_CPU:
                    V_VertexAnimationCPU();
                    break;
                case AnimationType.VERTEX_GPU:
                    V_VertexAnimationGPU();
                    break;
                case AnimationType.SKELETON_CPU:
                    V_SkeletonAnimationCPU();
                    break;
                case AnimationType.SKELETON_GPU:
                    V_SkeletonAnimationGPU();
                    break;
                case AnimationType.PARTICLE:
                    V_Particles();
                    break;
                default:
                    throw new Error(AnimationType.PARTICLE + "类型动画缺少FAGAL代码");
                    break;
            }
        };
        return V_Main_PlanarShadow;
    }(FagalMethod));
    feng3dMap.V_Main_PlanarShadow = V_Main_PlanarShadow;
})(feng3dMap || (feng3dMap = {}));
var feng3d;
(function (feng3d) {
    _SkeletonAnimationCPU;
    _SkeletonAnimationGPU;
    _SpriteSheetAnimation;
    _UVAnimation;
    _VertexAnimationCPU;
    _VertexAnimationGPU;
    _Particles;
    _ShadowMap;
    /**
     * 顶点渲染程序主入口
     * @author feng 2014-10-30
     */
    var V_Main = (function (_super) {
        __extends(V_Main, _super);
        /**
         * 创建顶点渲染程序主入口
         *
         */
        function V_Main() {
            _shaderType = Context3DProgramType.VERTEX;
        }
        /**
         * @inheritDoc
         */
        V_Main.prototype.runFunc = function () {
            var _ =  * , FagalRE, instance, space;
            var commonShaderParams = this.shaderParams.getOrCreateComponentByClass(feng3d.CommonShaderParams);
            var animationShaderParams = this.shaderParams.getOrCreateComponentByClass(feng3d.AnimationShaderParams);
            var lightShaderParams = this.shaderParams.getOrCreateComponentByClass(feng3d.LightShaderParams);
            var shadowShaderParams = this.shaderParams.getOrCreateComponentByClass(feng3d.ShadowShaderParams);
            this.buildPositionAnimationAGAL();
            //计算世界顶点坐标
            if (lightShaderParams.needWorldPosition)
                V_WorldPosition();
            //输出世界坐标到片段寄存器
            if (lightShaderParams.usesGlobalPosFragment)
                V_WorldPositionOut();
            //计算投影坐标
            V_BaseOut();
            //输出数据到片段寄存器
            if (commonShaderParams.needsUV > 0) {
                //
                if (animationShaderParams.useUVAnimation > 0) {
                    V_UVAnimation(_.uv_va_2, _.uv_v);
                }
                else if (animationShaderParams.useSpriteSheetAnimation > 0) {
                    V_SpriteSheetAnimation(_.uv_va_2, _.uv_v);
                }
                else {
                    _.mov(_.uv_v, _.uv_va_2);
                }
            }
            //处理法线相关数据
            if (lightShaderParams.needsNormals > 0) {
                if (lightShaderParams.hasNormalTexture) {
                    V_TangentNormalMap();
                }
                else {
                    V_TangentNormalNoMap();
                }
            }
            //计算视线方向
            if (lightShaderParams.needsViewDir > 0) {
                V_ViewDir();
            }
            //计算阴影相关数据
            if (shadowShaderParams.usingShadowMapMethod > 0) {
                V_ShadowMap();
            }
        };
        /**
         * 生成动画代码
         */
        V_Main.prototype.buildPositionAnimationAGAL = function () {
            var animationShaderParams = this.shaderParams.getOrCreateComponentByClass(feng3d.AnimationShaderParams);
            switch (animationShaderParams.animationType) {
                case feng3d.AnimationType.NONE:
                    V_BaseAnimation();
                    break;
                case feng3d.AnimationType.VERTEX_CPU:
                    V_VertexAnimationCPU();
                    break;
                case feng3d.AnimationType.VERTEX_GPU:
                    V_VertexAnimationGPU();
                    break;
                case feng3d.AnimationType.SKELETON_CPU:
                    V_SkeletonAnimationCPU();
                    break;
                case feng3d.AnimationType.SKELETON_GPU:
                    V_SkeletonAnimationGPU();
                    break;
                case feng3d.AnimationType.PARTICLE:
                    V_Particles();
                    break;
                default:
                    throw new Error(feng3d.AnimationType.PARTICLE + "类型动画缺少FAGAL代码");
                    break;
            }
        };
        return V_Main;
    }(feng3d.FagalMethod));
    feng3d.V_Main = V_Main;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 线段顶点渲染程序
     * @author feng 2014-10-28
     */
    var V_Segment = (function (_super) {
        __extends(V_Segment, _super);
        function V_Segment() {
            _shaderType = Context3DProgramType.VERTEX;
        }
        V_Segment.prototype.runFunc = function () {
            var _ =  * , FagalRE, instance, space;
            var cStartPosReg = _.getFreeTemp("摄像机空间起点坐标");
            var cEndPosReg = _.getFreeTemp("摄像机空间终点坐标");
            var lenghtReg = _.getFreeTemp("线段长度");
            var temp3 = _.getFreeTemp("");
            var temp4 = _.getFreeTemp("");
            var temp5 = _.getFreeTemp("");
            _.comment("计算相机坐标系起点位置、终点位置、线段距离");
            _.m44(cStartPosReg, _.segmentStart_va_3, _.segmentM2cMatrix_vc_matrix);
            _.m44(cEndPosReg, _.segmentEnd_va_3, _.segmentM2cMatrix_vc_matrix);
            _.sub(lenghtReg, cEndPosReg, cStartPosReg);
            // test if behind camera near plane
            // if 0 - Q0.z < Camera.near then the point needs to be clipped
            //"neg "+temp5+".x, "+temp0+".z				\n" + // 0 - Q0.z
            _.slt(temp5.x, cStartPosReg.z, _.segmentConstants_vc_vector.z); // behind = ( 0 - Q0.z < -Camera.near ) ? 1 : 0
            _.sub(temp5.y, _.segmentOne_vc_vector.x, temp5.x); // !behind = 1 - behind
            // p = point on the plane (0,0,-near)
            // n = plane normal (0,0,-1)
            // D = Q1 - Q0
            // t = ( dot( n, ( p - Q0 ) ) / ( dot( n, d )
            // solve for t where line crosses Camera.near
            _.add(temp4.x, cStartPosReg.z, _.segmentConstants_vc_vector.z); // Q0.z + ( -Camera.near )
            _.sub(temp4.y, cStartPosReg.z, cEndPosReg.z); // Q0.z - Q1.z
            // fix divide by zero for horizontal lines
            _.seq(temp4.z, temp4.y, _.segmentFront_vc_vector.x); // offset = (Q0.z - Q1.z)==0 ? 1 : 0
            _.add(temp4.y, temp4.y, temp4.z); // ( Q0.z - Q1.z ) + offset
            _.div(temp4.z, temp4.x, temp4.y); // t = ( Q0.z - near ) / ( Q0.z - Q1.z )
            _.mul(temp4.xyz, temp4.zzz, lenghtReg.xyz); // t(L)
            _.add(temp3.xyz, cStartPosReg.xyz, temp4.xyz); // Qclipped = Q0 + t(L)
            _.mov(temp3.w, _.segmentOne_vc_vector.x); // Qclipped.w = 1
            // If necessary, replace Q0 with new Qclipped
            _.mul(cStartPosReg, cStartPosReg, temp5.yyyy); // !behind * Q0
            _.mul(temp3, temp3, temp5.xxxx); // behind * Qclipped
            _.add(cStartPosReg, cStartPosReg, temp3); // newQ0 = Q0 + Qclipped
            // calculate side vector for line
            _.sub(lenghtReg, cEndPosReg, cStartPosReg); // L = Q1 - Q0
            _.nrm(lenghtReg.xyz, lenghtReg.xyz); // normalize( L )
            _.nrm(temp5.xyz, cStartPosReg.xyz); // D = normalize( Q1 )
            _.mov(temp5.w, _.segmentOne_vc_vector.x); // D.w = 1
            _.crs(temp3.xyz, lenghtReg, temp5); // S = L x D
            _.nrm(temp3.xyz, temp3.xyz); // normalize( S )
            // face the side vector properly for the given point
            _.mul(temp3.xyz, temp3.xyz, _.segmentThickness_va_1.xxx); // S *= weight
            _.mov(temp3.w, _.segmentOne_vc_vector.x); // S.w = 1
            // calculate the amount required to move at the point's distance to correspond to the line's pixel width
            // scale the side vector by that amount
            _.dp3(temp4.x, cStartPosReg, _.segmentFront_vc_vector); // distance = dot( view )
            _.mul(temp4.x, temp4.x, _.segmentConstants_vc_vector.x); // distance *= vpsod
            _.mul(temp3.xyz, temp3.xyz, temp4.xxx); // S.xyz *= pixelScaleFactor
            // add scaled side vector to Q0 and transform to clip space
            _.add(cStartPosReg.xyz, cStartPosReg.xyz, temp3.xyz); // Q0 + S
            _.m44(_._op, cStartPosReg, _.segmentC2pMatrix_vc_matrix); // transform Q0 to clip space
            // interpolate color
            _.mov(_.color_v, _.segmentColor_va_4);
        };
        return V_Segment;
    }(feng3d.FagalMethod));
    feng3d.V_Segment = V_Segment;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 天空盒顶点渲染程序
     * @author feng 2014-11-4
     */
    var V_SkyBox = (function (_super) {
        __extends(V_SkyBox, _super);
        function V_SkyBox() {
            _shaderType = Context3DProgramType.VERTEX;
        }
        V_SkyBox.prototype.runFunc = function () {
            var _ =  * , FagalRE, instance, space;
            var vt0 = _.getFreeTemp("缩放后的顶点坐标");
            _.comment("缩放到天空盒应有的大小");
            _.mul(vt0, _.position_va_3, _.scaleSkybox_vc_vector);
            _.comment("把天空盒中心放到摄像机位置");
            _.add(vt0, vt0, _.camerapos_vc_vector);
            _.comment("投影天空盒坐标");
            _.m44(_._op, vt0, _.projection_vc_matrix);
            _.comment("占坑用的，猜的");
            _.mov(_.uv_v, _.position_va_3);
        };
        return V_SkyBox;
    }(feng3d.FagalMethod));
    feng3d.V_SkyBox = V_SkyBox;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 骨骼动画渲染程序(CPU)
     * @author feng 2014-11-3
     */
    constructor();
    {
        var _ =  * , FagalRE, instance, space;
        _.mov(_.animatedPosition_vt_4, _.animated_va_3);
    }
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 骨骼动画渲染程序(GPU)
     * @author feng 2014-11-3
     */
    constructor();
    Register;
    {
        var _ =  * , FagalRE, instance, space;
        var shaderParams = FagalRE.instance.context3DCache.shaderParams;
        var animationShaderParams = shaderParams.getOrCreateComponentByClass(feng3d.AnimationShaderParams);
        //
        var vt1 = _.getFreeTemp();
        var vt2 = _.getFreeTemp();
        _.globalmatrices_vc_vector.regLen = animationShaderParams.numJoints * 3;
        _.comment("计算该顶点坐标通关该关节得到的x值-----------1");
        _.dp4(vt1.x, _.position_va_3, _.globalmatrices_vc_vector.getReg1(_.jointindex_va_x.x));
        _.comment("计算该顶点坐标通关该关节得到的y值-----------2");
        _.dp4(vt1.y, _.position_va_3, _.globalmatrices_vc_vector.getReg1(_.jointindex_va_x.x, 1));
        _.comment("计算该顶点坐标通关该关节得到的z值-----------3");
        _.dp4(vt1.z, _.position_va_3, _.globalmatrices_vc_vector.getReg1(_.jointindex_va_x.x, 2));
        _.comment("w值不变-----------------4");
        _.mov(vt1.w, _.position_va_3.w);
        _.comment("通过权重计算该关节对顶点的影响值---------------5");
        _.mul(vt1, vt1, _.jointweights_va_x.x);
        _.comment("vt2保存了计算后的顶点坐标，第一个关节影响值使用mov赋值，后面的关节将会使用add来累加-----------------6(1到6将会对每个与该顶点相关的关节调用，该实例中只有一个关节，所以少了个for循环)");
        _.mov(vt2, vt1);
        _.comment("赋值给顶点坐标寄存器，提供给后面投影使用");
        _.mov(_.animatedPosition_vt_4, vt2);
        return _.animatedPosition_vt_4;
    }
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * Sprite动画顶点渲染程序
     * @author feng 2015-9-5
     */
    constructor(UVSource, Register, UVTarget, Register);
    {
        var _ =  * , FagalRE, instance, space;
        var tempUV = _.getFreeTemp();
        var constantRegID = _.spriteSheetVectorFrame_vc_vector;
        //计算平移缩放
        _.mov(tempUV, UVSource);
        _.mul(tempUV.xy, tempUV.xy, constantRegID.zw);
        _.add(tempUV.xy, tempUV.xy, constantRegID.xy);
        _.mov(UVTarget, tempUV);
    }
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * UV动画顶点渲染程序
     * @author feng 2015-9-5
     */
    constructor(UVSource, Register, UVTarget, Register);
    {
        var _ =  * , FagalRE, instance, space;
        var tempUV = _.getFreeTemp();
        var tempUV2 = _.getFreeTemp("用点乘代替m44运算的临时寄存器");
        var uvTranslateReg = _.uvAnimatorTranslate_vc_vector;
        var uvTransformReg = _.uvAnimatorMatrix2d_vc_vector;
        _.mov(tempUV, UVSource);
        _.sub(tempUV.xy, tempUV.xy, uvTranslateReg.zw);
        //使用矩阵对UV操作（使用点乘代替矩阵运算）	_.m44(tempUV, tempUV, uvTransformReg);
        _.dp3(tempUV2.x, tempUV, uvTransformReg.getReg1(0));
        _.dp3(tempUV2.y, tempUV, uvTransformReg.getReg1(1));
        _.mov(tempUV.xy, tempUV2.xy);
        //计算平移缩放
        _.add(tempUV.xy, tempUV.xy, uvTranslateReg.xy);
        _.add(tempUV.xy, tempUV.xy, uvTranslateReg.zw);
        _.mov(UVTarget, tempUV);
    }
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 顶点动画渲染程序(CPU)
     * @author feng 2014-11-3
     */
    constructor();
    {
        var _ =  * , FagalRE, instance, space;
        _.mov(_.animatedPosition_vt_4, _.position_va_3);
    }
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 顶点动画渲染程序(GPU)
     * @author feng 2014-11-3
     */
    constructor();
    {
        var _ =  * , FagalRE, instance, space;
        //		
        var tempVts0 = _.getFreeTemp();
        var tempVts1 = _.getFreeTemp();
        //			_.comment("计算第0个顶点混合值");
        _.mul(tempVts0, _.position0_va_3, _.weights_vc_vector.x);
        //			_.comment("计算第1个顶点混合值");
        _.mul(tempVts1, _.position1_va_3, _.weights_vc_vector.y);
        //			_.comment("混合两个顶点");
        _.add(_.animatedPosition_vt_4, tempVts0, tempVts1);
    }
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 粒子广告牌节点顶点渲染程序
     * @param particleBillboardMtx			广告牌旋转矩阵(3个长度向量形式)
     * @param animatedPosition				动画后的顶点坐标数据
     * @author feng 2014-12-26
     */
    constructor(particleBillboardMtx, Register, animatedPosition, Register);
    {
        var _ =  * , FagalRE, instance, space;
        //使用广告牌 朝向摄像机
        _.m33(animatedPosition.xyz, animatedPosition.xyz, particleBillboardMtx); //计算旋转
    }
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 粒子颜色变化结算顶点渲染程序
     * @param colorMulTarget			粒子颜色乘数因子，用于乘以纹理上的颜色值
     * @param colorAddTarget			粒子颜色偏移值，在片段渲染的最终颜色值上偏移
     * @param colorMulVary				粒子颜色乘数因子，用于乘以纹理上的颜色值
     * @param colorAddVary				粒子颜色偏移值，在片段渲染的最终颜色值上偏移
     * @author feng 2015-1-20
     */
    constructor(colorMulTarget, Register, colorAddTarget, Register, colorMulVary, Register, colorAddVary, Register);
    {
        var _ =  * , FagalRE, instance, space;
        //			if (hasColorMulNode)
        _.mov(colorMulVary, colorMulTarget);
        //			if (hasColorAddNode)
        _.mov(colorAddVary, colorAddTarget);
    }
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 粒子颜色节点顶点渲染程序
     * @author feng 2015-1-20
     */
    constructor(startMultiplierValue, Register, deltaMultiplierValue, Register, startOffsetValue, Register, deltaOffsetValue, Register, inCycleTimeTemp, Register, colorMulTarget, Register, colorAddTarget, Register);
    {
        var _ =  * , FagalRE, instance, space;
        var temp = _.getFreeTemp();
        //			if (animationRegisterCache.needFragmentAnimation) {
        //				var temp:ShaderRegisterElement = animationRegisterCache.getFreeVertexVectorTemp();
        //				if (_usesCycle) {
        //					var cycleConst:ShaderRegisterElement = animationRegisterCache.getFreeVertexConstant();
        //					animationRegisterCache.setRegisterIndex(this, CYCLE_INDEX, cycleConst.index);
        //					
        //					animationRegisterCache.addVertexTempUsages(temp, 1);
        //					var sin:ShaderRegisterElement = animationRegisterCache.getFreeVertexSingleTemp();
        //					animationRegisterCache.removeVertexTempUsage(temp);
        //					
        //					code += "mul " + sin + "," + animationRegisterCache.vertexTime + "," + cycleConst + ".x\n";
        //					
        //					if (_usesPhase)
        //						code += "add " + sin + "," + sin + "," + cycleConst + ".y\n";
        //					
        //					code += "sin " + sin + "," + sin + "\n";
        //				}
        //				if (_usesMultiplier) {
        //					var startMultiplierValue:ShaderRegisterElement = (_mode == ParticlePropertiesMode.GLOBAL)? animationRegisterCache.getFreeVertexConstant() : animationRegisterCache.getFreeVertexAttribute();
        //					var deltaMultiplierValue:ShaderRegisterElement = (_mode == ParticlePropertiesMode.GLOBAL)? animationRegisterCache.getFreeVertexConstant() : animationRegisterCache.getFreeVertexAttribute();
        //					
        //					animationRegisterCache.setRegisterIndex(this, START_MULTIPLIER_INDEX, startMultiplierValue.index);
        //					animationRegisterCache.setRegisterIndex(this, DELTA_MULTIPLIER_INDEX, deltaMultiplierValue.index);
        _.mul(temp, deltaMultiplierValue, inCycleTimeTemp.y);
        _.add(temp, temp, startMultiplierValue);
        _.mul(colorMulTarget, temp, colorMulTarget);
        //				}
        //				if (_usesOffset) {
        //					var startOffsetValue:ShaderRegisterElement = (_mode == ParticlePropertiesMode.LOCAL_STATIC)? animationRegisterCache.getFreeVertexAttribute() : animationRegisterCache.getFreeVertexConstant();
        //					var deltaOffsetValue:ShaderRegisterElement = (_mode == ParticlePropertiesMode.LOCAL_STATIC)? animationRegisterCache.getFreeVertexAttribute() : animationRegisterCache.getFreeVertexConstant();
        //					
        //					animationRegisterCache.setRegisterIndex(this, START_OFFSET_INDEX, startOffsetValue.index);
        //					animationRegisterCache.setRegisterIndex(this, DELTA_OFFSET_INDEX, deltaOffsetValue.index);
        _.mul(temp, deltaOffsetValue, inCycleTimeTemp.y);
        _.add(temp, temp, startOffsetValue);
        _.add(colorAddTarget, temp, colorAddTarget);
    }
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 粒子结算偏移坐标渲染程序
     * @param animatedPosition			动画后的顶点坐标数据
     * @param positionTemp				偏移坐标临时寄存器
     * @author feng 2014-12-26
     */
    constructor(animatedPosition, Register, positionTemp, Register);
    {
        var _ =  * , FagalRE, instance, space;
        //得到最终坐标
        _.add(animatedPosition.xyz, animatedPosition.xyz, positionTemp.xyz);
    }
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 粒子缩放节点顶点渲染程序
     * @param scaleRegister				粒子缩放常数数据
     * @param inCycleTimeTemp			粒子周期内时间临时寄存器
     * @param animatedPosition			动画后的顶点坐标数据
     * @author feng 2014-12-26
     */
    constructor(scaleRegister, Register, inCycleTimeTemp, Register, animatedPosition, Register);
    {
        var _ =  * , FagalRE, instance, space;
        var temp = _.getFreeTemp();
        //			if (_usesCycle) {
        //				code += "mul " + temp + "," + animationRegisterCache.vertexTime + "," + scaleRegister + ".z\n";
        //				
        //				if (_usesPhase)
        //					code += "add " + temp + "," + temp + "," + scaleRegister + ".w\n";
        //				
        //				code += "sin " + temp + "," + temp + "\n";
        //			}
        _.mul(temp, scaleRegister.y, inCycleTimeTemp.y); //计算  随时间增量  = 差值 * 本周期比例
        _.add(temp, scaleRegister.x, temp); //缩放值 = 最小值 + 随时间增量
        _.mul(animatedPosition.xyz, animatedPosition.xyz, temp); //缩放应用到顶点坐标上
    }
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 粒子速度节点顶点渲染程序
     * @param particleVelocity			粒子速度数据
     * @param positionTemp				偏移坐标临时寄存器
     * @param inCycleTimeTemp			粒子周期内时间临时寄存器
     * @author feng 2014-12-26
     */
    constructor(particleVelocity, Register, positionTemp, Register, inCycleTimeTemp, Register);
    {
        var _ =  * , FagalRE, instance, space;
        var vt3 = _.getFreeTemp();
        //计算速度
        _.mul(vt3, inCycleTimeTemp.x, particleVelocity); //时间*速度
        _.add(positionTemp.xyz, vt3, positionTemp.xyz); //计算偏移量
    }
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 粒子速度节点顶点渲染程序
     * @param particleVelocity			粒子速度数据
     * @param positionTemp				偏移坐标临时寄存器
     * @param inCycleTimeTemp			粒子周期内时间临时寄存器
     * @author feng 2014-12-26
     */
    constructor(particleVelocity, Register, positionTemp, Register, inCycleTimeTemp, Register);
    {
        var _ =  * , FagalRE, instance, space;
        var vt3 = _.getFreeTemp();
        //计算速度
        _.mul(vt3, inCycleTimeTemp.x, particleVelocity); //时间*速度
        _.add(positionTemp.xyz, vt3, positionTemp.xyz); //计算偏移量
    }
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 粒子顶点渲染程序
     * @author feng 2014-11-14
     */
    constructor();
    {
        var _ =  * , FagalRE, instance, space;
        var shaderParams = FagalRE.instance.context3DCache.shaderParams;
        var particleShaderParams = shaderParams.getOrCreateComponentByClass(feng3d.ParticleShaderParams);
        //初始化
        if (particleShaderParams.changePosition > 0) {
            V_ParticlesInit(_.particlePositionTemp_vt_4, _.animatedPosition_vt_4, _.position_va_3, _.particleCommon_vc_vector);
        }
        //粒子颜色初始化
        if (particleShaderParams.changeColor > 0) {
            V_ParticlesInitColor(_.particleCommon_vc_vector, _.particleColorMultiplier_vt_4, _.particleColorOffset_vt_4);
        }
        //计算时间
        if (particleShaderParams.ParticleTimeLocalStatic) {
            V_ParticlesTime(_.particleCommon_vc_vector, _.animatedPosition_vt_4, _.particleTime_va_4, _.particleTime_vc_vector, _.inCycleTime_vt_4);
        }
        //粒子速度节点顶点渲染程序
        if (particleShaderParams.ParticleVelocityGlobal) {
            V_ParticleVelocityGlobal(_.particleVelocity_vc_vector, _.particlePositionTemp_vt_4, _.inCycleTime_vt_4);
        }
        //计算速度
        if (particleShaderParams.ParticleVelocityLocalStatic) {
            V_ParticleVelocity(_.particleVelocity_va_3, _.particlePositionTemp_vt_4, _.inCycleTime_vt_4);
        }
        //粒子缩放节点顶点渲染程序
        if (particleShaderParams.ParticleScaleGlobal) {
            V_ParticleScaleGlobal(_.particleScale_vc_vector, _.inCycleTime_vt_4, _.animatedPosition_vt_4);
        }
        //使用广告牌 朝向摄像机
        if (particleShaderParams.ParticleBillboardGlobal) {
            V_ParticleBillboard(_.particleBillboard_vc_matrix, _.animatedPosition_vt_4);
        }
        //粒子颜色节点顶点渲染程序
        if (particleShaderParams.changeColor > 0) {
            V_ParticleColorGlobal(_.particleStartColorMultiplier_vc_vector, _.particleDeltaColorMultiplier_vc_vector, _.particleStartColorOffset_vc_vector, _.particleDeltaColorOffset_vc_vector, _.inCycleTime_vt_4, _.particleColorMultiplier_vt_4, _.particleColorOffset_vt_4);
        }
        //结算坐标偏移
        if (particleShaderParams.changePosition > 0) {
            V_ParticlePositionEnd(_.animatedPosition_vt_4, _.particlePositionTemp_vt_4);
        }
        //结算颜色
        if (particleShaderParams.ParticleColorGlobal) {
            V_ParticleColorEnd(_.particleColorMultiplier_vt_4, _.particleColorOffset_vt_4, _.particleColorMultiplier_v, _.particleColorOffset_v);
        }
    }
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 粒子初始化顶点渲染程序
     * @param positionTemp			偏移坐标临时寄存器
     * @param animatedPosition		动画后的顶点坐标数据
     * @param positionReg			顶点坐标数据
     * @param particleCommon		粒子常数数据[0,1,2,0]
     * @author feng 2014-12-26
     */
    constructor(positionTemp, Register, animatedPosition, Register, positionReg, Register, particleCommon, Register);
    {
        var _ =  * , FagalRE, instance, space;
        _.comment("初始化粒子");
        _.mov(animatedPosition, positionReg); //坐标赋值
        _.mov(positionTemp.xyz, particleCommon.x); //初始化偏移位置0
    }
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 粒子颜色初始化
     * @param particleCommon		粒子常数数据[0,1,2,0]
     * @param colorMulTarget		粒子颜色乘数因子，用于乘以纹理上的颜色值
     * @param colorAddTarget		粒子颜色偏移值，在片段渲染的最终颜色值上偏移
     * @author feng 2015-1-20
     */
    constructor(particleCommon, Register, colorMulTarget, Register, colorAddTarget, Register);
    {
        var _ =  * , FagalRE, instance, space;
        //初始化  粒子颜色乘数因子 为(1,1,1,1)
        _.mov(colorMulTarget, particleCommon.y);
        //初始化 粒子颜色偏移值 为(0,0,0,0)
        _.mov(colorAddTarget, particleCommon.x);
    }
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 粒子时间节点顶点渲染程序
     * @author feng 2014-12-26
     */
    constructor(particleCommon, Register, animatedPosition, Register, particleTimeVA, Register, particleTimeVC, Register, inCycleTimeTemp, Register);
    {
        var _ =  * , FagalRE, instance, space;
        var vt3 = _.getFreeTemp();
        //计算时间
        _.sub(inCycleTimeTemp.x, particleTimeVC, particleTimeVA.x); //生存了的时间  = 粒子特效时间 - 粒子出生时间
        _.sge(vt3.x, inCycleTimeTemp.x, particleCommon.x); //粒子是否出生  = 生存了的时间 [inCycleTimeTemp.x] > 0[particleCommon.x] ? 1 : 0
        _.mul(animatedPosition.xyz, animatedPosition.xyz, vt3.x); //粒子顶点坐标 = 粒子顶点坐标 * 粒子是否出生
        //处理循环
        _.mul(vt3.x, inCycleTimeTemp.x, particleTimeVA.w); //粒子生存的周期数 = 生存了的时间 * 周期倒数
        _.frc(vt3.x, vt3.x); //本周期比例 = 粒子生存的周期数取小数部分
        _.mul(inCycleTimeTemp.x, vt3.x, particleTimeVA.y); //周期内时间 = 本周期比例 * 周期 
        //计算周期数(vt2.y)
        _.mul(inCycleTimeTemp.y, inCycleTimeTemp.x, particleTimeVA.w); //本周期比例 = 周期内时间 * 周期倒数
    }
})(feng3d || (feng3d = {}));
var feng3dMap;
(function (feng3dMap) {
    /**
     * 编译阴影映射顶点程序
     * @author feng 2015-6-23
     */
    constructor();
    {
        var shaderParams = FagalRE.instance.context3DCache.shaderParams;
        var shadowShaderParams = shaderParams.getOrCreateComponentByClass(ShadowShaderParams);
        shadowShaderParams.usePoint > 0 ? V_ShadowMapPoint() : V_ShadowMapPlanar();
    }
})(feng3dMap || (feng3dMap = {}));
var feng3dMap;
(function (feng3dMap) {
    /**
     * 方向光阴影映射
     * @author feng 2015-7-17
     */
    constructor();
    {
        var _ =  * , FagalRE, instance, space;
        var temp = _.getFreeTemp();
        //计算顶点深度值
        _.m44(temp, _.globalPosition_vt_4, _.depthMap_vc_matrix);
        //计算顶点深度值(x,y计算深度图中的uv，z计算深度)
        _.div(temp, temp, temp.w);
        //x,y计算深度图中的uv
        _.mul(temp.xy, temp.xy, _.shadowCommondata0_vc_vector.xy);
        //计算深度图坐标
        _.add(_.depthMapCoord_v, temp, _.shadowCommondata0_vc_vector.xxwz);
    }
})(feng3dMap || (feng3dMap = {}));
var feng3dMap;
(function (feng3dMap) {
    /**
     * 点光源阴影映射
     * @author feng 2015-7-17
     */
    constructor();
    {
    }
})(feng3dMap || (feng3dMap = {}));
var feng3d;
(function (feng3d) {
    /**
     * 基础动画顶点渲染函数(无动画)
     * @author feng 2014-11-3
     */
    constructor();
    {
        var _ =  * , FagalRE, instance, space;
        _.mov(_.animatedPosition_vt_4, _.position_va_3);
    }
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 基本顶点投影渲染
     * @author feng 2014-10-30
     */
    constructor();
    {
        var _ =  * , FagalRE, instance, space;
        var shaderParams = FagalRE.instance.context3DCache.shaderParams;
        var shadowShaderParams = shaderParams.getOrCreateComponentByClass(feng3d.ShadowShaderParams);
        //阴影渲染需要 投影后的顶点坐标
        if (shadowShaderParams.needsProjection > 0) {
            var vt5 = _.getFreeTemp("投影后顶点坐标");
            _.m44(vt5, _.animatedPosition_vt_4, _.projection_vc_matrix);
            //保存投影坐标数据
            _.mov(_.positionProjected_v, vt5);
            _.mov(_._op, vt5);
        }
        else {
            _.m44(_._op, _.animatedPosition_vt_4, _.projection_vc_matrix);
        }
    }
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 编译切线顶点程序
     * @author feng 2014-11-7
     */
    constructor();
    {
        var _ =  * , FagalRE, instance, space;
        var animatedNormal = _.getFreeTemp("动画后顶点法线临时寄存器");
        var animatedTangent = _.getFreeTemp("动画后顶点切线临时寄存器");
        var bitanTemp = _.getFreeTemp("动画后顶点双切线临时寄存器");
        //赋值法线数据
        _.mov(animatedNormal, _.normal_va_3);
        //赋值切线数据
        _.mov(animatedTangent, _.tangent_va_3);
        //计算顶点世界法线 vc8：模型转世界矩阵
        _.m33(animatedNormal.xyz, animatedNormal, _.normalSceneTransform_vc_matrix);
        //标准化顶点世界法线
        _.nrm(animatedNormal.xyz, animatedNormal);
        //计算顶点世界切线
        _.m33(animatedTangent.xyz, animatedTangent, _.normalSceneTransform_vc_matrix);
        //标准化顶点世界切线
        _.nrm(animatedTangent.xyz, animatedTangent);
        //计算切线x
        _.mov(_.tangent_v.x, animatedTangent.x);
        //计算切线z
        _.mov(_.tangent_v.z, animatedNormal.x);
        //计算切线w
        _.mov(_.tangent_v.w, _.normal_va_3.w);
        //计算双切线x
        _.mov(_.bitangent_v.x, animatedTangent.y);
        //计算双切线z
        _.mov(_.bitangent_v.z, animatedNormal.y);
        //计算双切线w
        _.mov(_.bitangent_v.w, _.normal_va_3.w);
        //计算法线x
        _.mov(_.normal_v.x, animatedTangent.z);
        //计算法线z
        _.mov(_.normal_v.z, animatedNormal.z);
        //计算法线w
        _.mov(_.normal_v.w, _.normal_va_3.w);
        //计算双切线
        _.crs(bitanTemp.xyz, animatedNormal, animatedTangent);
        //计算切线y
        _.mov(_.tangent_v.y, bitanTemp.x);
        //计算双切线y
        _.mov(_.bitangent_v.y, bitanTemp.y);
        //计算法线y
        _.mov(_.normal_v.y, bitanTemp.z);
    }
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 编译切线顶点程序(无法线图)
     * @author feng 2014-11-7
     */
    constructor();
    {
        var _ =  * , FagalRE, instance, space;
        _.comment("转换法线到全局");
        _.m33(_.normal_v.xyz, _.normal_va_3, _.normalSceneTransform_vc_matrix);
        //保存w不变
        _.mov(_.normal_v.w, _.normal_va_3.w);
    }
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 视线顶点渲染函数
     * @author feng 2014-11-7
     */
    constructor();
    {
        var _ =  * , FagalRE, instance, space;
        _.comment("计算视线方向");
        _.sub(_.viewDir_v, _.cameraPosition_vc_vector, _.globalPosition_vt_4);
    }
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 顶点世界坐标渲染函数
     * @author feng 2014-11-7
     */
    constructor();
    {
        var _ =  * , FagalRE, instance, space;
        _.comment("场景坐标转换");
        _.m44(_.globalPosition_vt_4, _.animatedPosition_vt_4, _.sceneTransform_vc_matrix);
    }
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 世界坐标输出函数
     * @author feng 2014-11-7
     */
    constructor();
    {
        var _ =  * , FagalRE, instance, space;
        _.mov(_.globalPos_v, _.globalPosition_vt_4);
    }
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * Fagal标记
     * @author feng 2014-10-22
     */
    var FagalToken = (function () {
        function FagalToken() {
        }
        /** AGAL换行符 */
        FagalToken.BREAK = "\n";
        /** 单行注释符 */
        FagalToken.COMMENT = "//";
        return FagalToken;
    }());
    feng3d.FagalToken = FagalToken;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    regType();
    string;
    regId();
    string;
    desc();
    string;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    regLen();
    number;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 寄存器单元
     * @author feng 2014-10-22
     */
    var RegisterComponent = (function () {
        /**
         * 创建一个寄存器单元
         * @param register 寄存器类型
         * @param prop 单元名称
         */
        function RegisterComponent(register, prop) {
            this._prop = prop;
            this._register = register;
            this._regType = register.regType;
            this._regId = register.regId;
            if (!this.valid(prop))
                throw new Error("无效寄存器分量: " + this._register);
        }
        Object.defineProperty(RegisterComponent.prototype, "regId", {
            /** 寄存器id */
            get: function () {
                return _regId;
            },
            /**
             * @private
             */
            set: function (value) {
                _regId = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RegisterComponent.prototype, "regType", {
            /**
             * @inheritDoc
             */
            get: function () {
                return _regType;
            },
            enumerable: true,
            configurable: true
        });
        RegisterComponent.prototype.toString = function () {
            return this._register + "." + this._prop;
        };
        /**
         * 判断是否有效
         * @param prop
         * @return			true：有效，false：无效
         */
        RegisterComponent.valid = function (prop) {
            switch (prop) {
                case "x":
                case "y":
                case "z":
                case "w":
                case "r":
                case "g":
                case "b":
                case "a":
                    return true;
            }
            return false;
        };
        Object.defineProperty(RegisterComponent.prototype, "desc", {
            /**
             * @inheritDoc
             */
            get: function () {
                return toString();
            },
            enumerable: true,
            configurable: true
        });
        return RegisterComponent;
    }());
    feng3d.RegisterComponent = RegisterComponent;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 寄存器单元组合
     * @author feng 2014-10-22
     */
    var RegisterComponentSelection = (function () {
        /**
         * 创建一个寄存器单元组合
         * @param register 		寄存器类型
         * @param prop 			组合名称
         */
        function RegisterComponentSelection(register, prop) {
            this._register = register;
            this._prop = prop;
            this._regType = register.regType;
            this._regId = register.regId;
            // Validate components
            if (prop.length > 4)
                throw new Error("无效寄存器分量: " + this._register);
            for (var i = 0; i < prop.length; i++) {
                if (!feng3d.RegisterComponent.valid(prop.substr(i, 1)))
                    throw new Error("无效寄存器分量: " + this._register);
            }
        }
        Object.defineProperty(RegisterComponentSelection.prototype, "regId", {
            /** 寄存器id */
            get: function () {
                return _regId;
            },
            /**
             * @private
             */
            set: function (value) {
                _regId = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RegisterComponentSelection.prototype, "regType", {
            /**
             * @inheritDoc
             */
            get: function () {
                return _regType;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        RegisterComponentSelection.prototype.toString = function () {
            return this._register + ((this._prop.length > 0) ? ("." + this._prop) : "");
        };
        Object.defineProperty(RegisterComponentSelection.prototype, "desc", {
            /**
             * @inheritDoc
             */
            get: function () {
                return toString();
            },
            enumerable: true,
            configurable: true
        });
        return RegisterComponentSelection;
    }());
    feng3d.RegisterComponentSelection = RegisterComponentSelection;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 纹理类型
     * @author feng 2014-10-23
     */
    var TextureType = (function () {
        function TextureType() {
        }
        /**  Images in this texture all are 2-dimensional. They have width and height, but no depth. */
        TextureType.TYPE_2D = "2d";
        /**  Images in this texture all are 3-dimensional. They have width, height, and depth. */
        TextureType.TYPE_3D = "3d";
        /**  There are exactly 6 distinct sets of 2D images, all of the same size. They act as 6 faces of a cube. */
        TextureType.TYPE_CUBE = "cube";
        return TextureType;
    }());
    feng3d.TextureType = TextureType;
})(feng3d || (feng3d = {}));
var feng3dRE;
(function (feng3dRE) {
    _proxy;
    dynamic;
    var FagalIdCenter = (function (_super) {
        __extends(FagalIdCenter, _super);
        /**
         * 创建Fagal编号中心
         */
        function FagalIdCenter() {
            /**
             * @inheritDoc
             */
            this.override = AS3;
            if (_instance)
                throw new Error("该类为单例");
            _instance = this;
        }
        return FagalIdCenter;
    }(Proxy));
    null;
    boolean;
    {
        var attr = V;
        return feng3dRE.FagalRE.idDic[attr] != null;
    }
    /**
     * @inheritDoc
     */
    override;
    flash_proxy;
     *
        {
            var: attr, string: string,
            return: attr
        };
    get;
    instance();
    FagalIdCenter;
    {
        return _instance || new FagalIdCenter();
    }
})(feng3dRE || (feng3dRE = {}));
var feng3dRE;
(function (feng3dRE) {
    /**
     * fagal函数单元
     * @author feng 2015-8-8
     */
    var FagalItem = (function () {
        /**
         * 创建一个fagal函数单元
         * @param funcName			函数名称
         * @param parameters		参数
         */
        function FagalItem(funcName, parameters) {
            this.funcName = funcName;
            this.parameters = parameters;
        }
        /**
         * 获取参数中出现的寄存器id以及次数
         * @param parameters			拥有寄存器的参数
         * @return						寄存器id字典(key:regID,value:count)
         */
        FagalItem.prototype.getRegCountDic = function () {
            var dic = {};
            //针对使用到的寄存器计数
            if (this.funcName == "comment") {
                return dic;
            }
            var list = this.getIFieldList();
            for (each(); ; )
                var reg;
             in list;
            {
                dic[reg.regId] = number(dic[reg.regId]) + 1;
            }
            return dic;
        };
        /**
         * 获取寄存器列表
         */
        FagalItem.prototype.getIFieldList = function () {
            var list = new IField[]();
            for (each(); ; )
                var reg;
             in this.parameters;
            {
                var registerArrayComplexItem = reg;
                if (registerArrayComplexItem != null) {
                    for (each(); ; )
                        var complexArg;
                     in registerArrayComplexItem.complexArgs;
                    {
                        list.push(complexArg);
                    }
                }
                //记录寄存器使用次数
                if (reg != null) {
                    list.push(reg);
                }
            }
            return list;
        };
        return FagalItem;
    }());
    feng3dRE.FagalItem = FagalItem;
})(feng3dRE || (feng3dRE = {}));
var feng3dRE;
(function (feng3dRE) {
    /**
     * Fagal函数运行环境(FagalMethodRuntimeEnvironment)
     * @author feng 2014-10-24
     */
    var FagalRE = (function () {
        function FagalRE() {
            /**
             * 数据id字典
             */
            this.internal = static;
        }
        return FagalRE;
    }());
    feng3dRE.FagalRE = FagalRE;
    var idDic = {};
    addBufferID(configs, Array);
    {
        for (var i = 0; i < configs.length; i++) {
            idDic[configs[i][0]] = configs[i];
        }
    }
    /**
     * 创建一个Fagal函数运行环境
     */
    constructor();
    {
        if (_instance)
            throw new Error("该类为单例");
        _instance = this;
    }
    get;
    space();
    FagalRESpace;
    {
        return _space || ;
        new FagalRESpace();
    }
    get;
    context3DCache();
    Context3DCache;
    {
        return _context3DCache;
    }
    set;
    context3DCache(value, Context3DCache);
    {
        _context3DCache = value;
    }
    runShader(vertexShader,  * , fragmentShader,  * );
    feng3dRE.FagalShaderResult;
    {
        return instance.runShader(vertexShader, fragmentShader);
    }
    get;
    registerCenter();
    FagalRegisterCenter;
    {
        return FagalRegisterCenter.instance;
    }
    runShader(vertexShader,  * , fragmentShader,  * );
    feng3dRE.FagalShaderResult;
    {
        //清理缓存
        FagalRegisterCenter.clear();
        ShaderRegisterCache.invalid();
        var shaderResult = new feng3dRE.FagalShaderResult();
        //运行顶点渲染函数
        shaderResult.vertexCallLog = this.run(vertexShader);
        //运行片段渲染函数
        shaderResult.fragmentCallLog = this.run(fragmentShader);
        shaderResult.print();
        return shaderResult;
    }
    run(agalMethod,  * );
    feng3dRE.FagalItem[];
    {
        //Fagal函数类实例
        var agalMethodInstance = ClassUtils.getInstance(agalMethod);
        //着色器类型
        this._shaderType = agalMethodInstance.shaderType;
        //运行Fagal函数
        var callLog = this.space.run(agalMethodInstance.runFunc);
        return callLog;
    }
    get;
    shaderType();
    string;
    {
        return _shaderType;
    }
    get;
    instance();
    FagalRE;
    {
        return _instance || new FagalRE();
    }
})(feng3dRE || (feng3dRE = {}));
var feng3dRE;
(function (feng3dRE) {
    _proxy;
    dynamic;
    var FagalRESpace = (function (_super) {
        __extends(FagalRESpace, _super);
        /**
         * 创建Fagal运行环境空间
         */
        function FagalRESpace() {
            _super.call(this);
            /**
             * @inheritDoc
             */
            this.override = flash_proxy;
        }
        Object.defineProperty(FagalRESpace.prototype, "math", {
            /**
             * Fagal数学运算
             */
            get: function () {
                return _math || ;
                new FagalMath();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FagalRESpace.prototype, "registerCenter", {
            /**
             * Fagal寄存器中心
             */
            get: function () {
                return FagalRegisterCenter.instance;
            },
            enumerable: true,
            configurable: true
        });
        return FagalRESpace;
    }(Proxy));
     *
        {
            var: attr, string: string,
            if: function (FagalRESpace, prototype) {
                if (prototype === void 0) { prototype = [attr] != null; }
                return FagalRESpace.prototype[attr];
            },
            if: function (registerCenter, hasOwnProperty) {
                if (hasOwnProperty === void 0) { hasOwnProperty = (attr); }
                var value =  * , FagalRESpace, prototype = (_a = registerCenter[attr], attr = _a[0], _a);
                return value;
                var _a;
            },
            throw: new ReferenceError("在 " + getQualifiedClassName(this) + " 上找不到属性 " + attr + "，且没有默认值")
        };
    /**
     * @inheritDoc
     */
    override;
    flash_proxy;
     *
        {
            var: funcName, string: string,
            var: func, Function: Function,
            assert: function (func) {
                if (func === void 0) { func =  != null; }
            }, "在Fagal中尝试调用": +getQualifiedClassName(math) + "." + funcName + "中不存在的函数",
            callLog: .push(new feng3dRE.FagalItem(funcName, parameters))
        };
    run(fagalMethod, Function);
    feng3dRE.FagalItem[];
    {
        this.callLog = new feng3dRE.FagalItem[]();
        fagalMethod();
        return this.callLog;
    }
    getFreeTemp(description, string = "");
    Register;
    {
        var register = FagalRegisterCenter.getFreeTemp(description);
        return register;
    }
    getFreeTemps(description, string = "", num, number = 1);
    RegisterArray;
    {
        var register = FagalRegisterCenter.getFreeTemps(description, num);
        return register;
    }
})(feng3dRE || (feng3dRE = {}));
var feng3dRE;
(function (feng3dRE) {
    _proxy;
    dynamic;
    var FagalRegisterCenter = (function (_super) {
        __extends(FagalRegisterCenter, _super);
        /**
         * 构建Fagal寄存器中心
         */
        function FagalRegisterCenter() {
            /**
             * @inheritDoc
             */
            this.override = AS3;
            if (_instance)
                throw new Error("该类为单例");
            _instance = this;
        }
        Object.defineProperty(FagalRegisterCenter, "dataRegisterDic", {
            /**
             * 数据寄存器缓存
             */
            get: function () {
                return _dataRegisterDic || ;
                { }
                ;
            },
            enumerable: true,
            configurable: true
        });
        return FagalRegisterCenter;
    }(Proxy));
    null;
    boolean;
    {
        var attr = V;
        return feng3dRE.FagalRE.idDic[attr] != null;
    }
    /**
     * @inheritDoc
     */
    override;
    flash_proxy;
     *
        {
            var: attr, string: string,
            var: idData, Array: Array,
            //获取寄存器
            var: register, Register: Register,
            register: .description = idData[1],
            return: register
        };
    createRegister(dataTypeId, string);
    Register;
    {
        if (dataRegisterDic[dataTypeId])
            return dataRegisterDic[dataTypeId];
        var bufferType = Context3DBufferTypeManager.getBufferType(dataTypeId);
        var register;
        if (bufferType.dataType == RgisterDataType.MATRIX) {
            //获取寄存器矩阵
            register = new RegisterMatrix(dataTypeId);
        }
        else if (bufferType.dataType == RgisterDataType.ARRAY) {
            register = new RegisterArray(dataTypeId);
        }
        else if (bufferType.dataType == RgisterDataType.VECTOR) {
            //获取寄存器数组
            register = new RegisterArray(dataTypeId);
        }
        else {
            register = new Register(dataTypeId);
        }
        dataRegisterDic[dataTypeId] = register;
        return register;
    }
    getFreeTemp(description, string = "");
    Register;
    {
        var tempTypeId;
        if (feng3dRE.FagalRE.instance.shaderType == Context3DProgramType.VERTEX) {
            tempTypeId = "temp" + (tempIndex++) + "_vt_4";
        }
        else if (feng3dRE.FagalRE.instance.shaderType == Context3DProgramType.FRAGMENT) {
            tempTypeId = "temp" + (tempIndex++) + "_ft_4";
        }
        var register = createRegister(tempTypeId);
        register.description = description;
        return register;
    }
    getFreeTemps(description, string = "", num, number = 1);
    Register;
    {
        var tempTypeId;
        if (feng3dRE.FagalRE.instance.shaderType == Context3DProgramType.VERTEX) {
            if (num > 1) {
                tempTypeId = "temp" + (tempIndex++) + "_vt_" + RgisterDataType.ARRAY;
            }
            else {
                tempTypeId = "temp" + (tempIndex++) + "_vt_4";
            }
        }
        else if (feng3dRE.FagalRE.instance.shaderType == Context3DProgramType.FRAGMENT) {
            if (num > 1) {
                tempTypeId = "temp" + (tempIndex++) + "_ft_" + RgisterDataType.ARRAY;
            }
            else {
                tempTypeId = "temp" + (tempIndex++) + "_ft_4";
            }
        }
        var register = createRegister(tempTypeId);
        register.description = description;
        return register;
    }
    clear();
    {
        for (each(); ; )
            var register;
         in dataRegisterDic;
        {
            register.clear();
        }
    }
    get;
    instance();
    FagalRegisterCenter;
    {
        return _instance || new FagalRegisterCenter();
    }
})(feng3dRE || (feng3dRE = {}));
var feng3dRE;
(function (feng3dRE) {
    /**
     * Fagal渲染结果
     * @author feng 2015-8-8
     */
    var FagalShaderResult = (function () {
        /**
         * 创建一个Fagal渲染结果
         */
        function FagalShaderResult() {
            this.agalCode = "";
        }
        /**
         * 打印输出结果
         */
        FagalShaderResult.prototype.print = function () {
            this.vertexFCode = this.doCallLog(this.vertexCallLog, Register.NAME);
            this.fragmentFCode = this.doCallLog(this.fragmentCallLog, Register.NAME);
            this.requestRegisterValue();
            this.vertexCode = this.doCallLog(this.vertexCallLog, Register.VALUE);
            this.fragmentCode = this.doCallLog(this.fragmentCallLog, Register.VALUE);
            logger("------------Compiling Register info------------------");
            for (each(); ; )
                var register;
             in this.regDic;
            {
                logger(register.desc);
            }
            logger("Compiling FAGAL Code:");
            logger("--------------------");
            logger(this.vertexFCode);
            logger("--------------------");
            logger(this.fragmentFCode);
            logger("Compiling AGAL Code:");
            logger("--------------------");
            logger(this.vertexCode);
            logger("--------------------");
            logger(this.fragmentCode);
            logger("------------Compiling info end------------------");
        };
        /**
         * 根据寄存器引用计数进行申请与释放寄存器
         * 处理寄存器值(va0,vc0....)
         */
        FagalShaderResult.prototype.requestRegisterValue = function () {
            //使用寄存器计数字典
            var useRegDic = {};
            var callLog = this.vertexCallLog.concat(this.fragmentCallLog);
            var i;
            var regCountDic;
            var regId;
            var fagalItem;
            for (i = 0; i < callLog.length; i++) {
                fagalItem = callLog[i];
                regCountDic = fagalItem.getRegCountDic();
                for (regId in regCountDic) {
                    //记录寄存器使用次数
                    useRegDic[regId] = number(useRegDic[regId]) + number(regCountDic[regId]);
                }
            }
            for (i = 0; i < callLog.length; i++) {
                regCountDic = callLog[i].getRegCountDic();
                //申请寄存器
                for (regId in regCountDic) {
                    //申请寄存器 此处并不会重复申请，内部有判断过滤
                    this.regCache.requestRegister(regId);
                }
                //注：申请寄存器与释放临时寄存器需要分开处理，如此可避免同一个agal函数中有两个不同的数据使用相同的寄存器
                //计算使用计数，释放计数为0的临时寄存器
                for (regId in regCountDic) {
                    //记录寄存器使用次数
                    useRegDic[regId] = number(useRegDic[regId]) - number(regCountDic[regId]);
                    //移除临时寄存器
                    if (useRegDic[regId] == 0) {
                        this.regCache.removeTempUsage(regId);
                    }
                }
            }
            this.regDic = {};
            var register;
            Register.TO_STRING = Register.NAME;
            for (regId in useRegDic) {
                assert(useRegDic[regId] == 0, "不应该存在寄存器使用次数为负数的情况");
                register = FagalRegisterCenter.dataRegisterDic[regId];
                this.regDic[register.regId] = register;
            }
        };
        /**
         * 执行Fagal函数记录
         */
        FagalShaderResult.prototype.doCallLog = function (callLog, type) {
            Register.TO_STRING = type;
            this.fagalCodeList = [];
            this.math.addEventListener(FagalMathEvent.FAGALMATHEVENT_APPEND, this.onFagalCodeAppend);
            var funcName;
            var parameters;
            for (var i = 0; i < callLog.length; i++) {
                funcName = callLog[i].funcName;
                parameters = callLog[i].parameters;
                var func = this.math[funcName];
                func.apply(null, parameters);
            }
            this.math.removeEventListener(FagalMathEvent.FAGALMATHEVENT_APPEND, this.onFagalCodeAppend);
            var fagalCode = this.fagalCodeList.join(FagalToken.BREAK);
            return fagalCode;
        };
        Object.defineProperty(FagalShaderResult.prototype, "regCache", {
            /**
             * 寄存器缓存
             */
            get: function () {
                return ShaderRegisterCache.instance;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FagalShaderResult.prototype, "math", {
            /**
             * Fagal数学运算
             */
            get: function () {
                if (_math == null) {
                    _math = new FagalMath();
                }
                return _math;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 处理Fagal数学函数事件
         */
        FagalShaderResult.prototype.onFagalCodeAppend = function (event) {
            this.fagalCodeList.push(event.code);
        };
        return FagalShaderResult;
    }());
    feng3dRE.FagalShaderResult = FagalShaderResult;
})(feng3dRE || (feng3dRE = {}));
var feng3d;
(function (feng3d) {
    var AssetType = (function () {
        function AssetType() {
        }
        /** 实体 */
        AssetType.ENTITY = 'entity';
        /** 天空盒 */
        AssetType.SKYBOX = 'skybox';
        /** 摄像机 */
        AssetType.CAMERA = 'camera';
        /** 线条 */
        AssetType.SEGMENT_SET = 'segmentSet';
        /** 网格 */
        AssetType.MESH = 'mesh';
        /** 几何体 */
        AssetType.GEOMETRY = 'geometry';
        /** 骨骼 */
        AssetType.SKELETON = 'skeleton';
        /** 骨骼姿势 */
        AssetType.SKELETON_POSE = 'skeletonPose';
        /** 容器 */
        AssetType.CONTAINER = 'container';
        /** 纹理 */
        AssetType.TEXTURE = 'texture';
        AssetType.TEXTURE_PROJECTOR = 'textureProjector';
        /** 材质 */
        AssetType.MATERIAL = 'material';
        AssetType.ANIMATION_SET = 'animationSet';
        /** 动画状态 */
        AssetType.ANIMATION_STATE = 'animationState';
        /** 动画节点 */
        AssetType.ANIMATION_NODE = 'animationNode';
        /** 动画 */
        AssetType.ANIMATOR = 'animator';
        AssetType.STATE_TRANSITION = 'stateTransition';
        /** 灯光 */
        AssetType.LIGHT = 'light';
        /** 灯光采集器 */
        AssetType.LIGHT_PICKER = 'lightPicker';
        /** 阴影投射方法 */
        AssetType.SHADOW_MAP_METHOD = 'shadowMapMethod';
        AssetType.EFFECTS_METHOD = 'effectsMethod';
        return AssetType;
    }());
    feng3d.AssetType = AssetType;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    namedAsset();
    feng3d.NamedAsset;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 拥有名字的对象
     * @author feng 2014-5-7
     */
    var NamedAsset = (function () {
        /**
         * 创建一个拥有名字的对象
         */
        function NamedAsset(asset, assetType) {
            _super.call(this);
            this._asset = asset;
            this._assetType = assetType;
        }
        Object.defineProperty(NamedAsset.prototype, "name", {
            /**
             * 名称
             */
            get: function () {
                if (!_name) {
                    var defaultName = feng3d.ClassUtils.getDefaultName(this);
                    _name = defaultName + number(nameDic[defaultName]);
                    nameDic[defaultName] = number(nameDic[defaultName]) + 1;
                }
                return _name;
            },
            set: function (value) {
                //			if (_name)
                //				throw new Error(getQualifiedClassName(this) + " -- 对象已经有名称，无法更改");
                _name = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NamedAsset.prototype, "assetType", {
            /**
             * @inheritDoc
             */
            get: function () {
                return _assetType;
            },
            enumerable: true,
            configurable: true
        });
        NamedAsset.nameDic = {};
        return NamedAsset;
    }());
    feng3d.NamedAsset = NamedAsset;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 阴影映射基类
     * @author feng 2015-5-28
     */
    var ShadowMapperBase = (function () {
        /**
         * 创建阴影映射
         */
        function ShadowMapperBase() {
            this._depthMapSize = 2048;
            this._autoUpdateShadows = true;
            this._casterCollector = this.createCasterCollector();
        }
        /**
         * 创建阴影投射者集合
         */
        ShadowMapperBase.prototype.createCasterCollector = function () {
            return new feng3d.ShadowCasterCollector();
        };
        Object.defineProperty(ShadowMapperBase.prototype, "light", {
            /**
             * 灯光
             */
            get: function () {
                return _light;
            },
            set: function (value) {
                _light = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ShadowMapperBase.prototype, "depthMap", {
            /**
             * 深度图
             */
            get: function () {
                return _depthMap || ;
                createDepthTexture();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ShadowMapperBase.prototype, "autoUpdateShadows", {
            /**
             * 是否自动更新阴影
             */
            get: function () {
                return _autoUpdateShadows;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 渲染深度图
         * @param stage3DProxy			3D场景代理
         * @param entityCollector		实体集合
         * @param renderer				渲染器
         */
        ShadowMapperBase.prototype.renderDepthMap = function (stage3DProxy, entityCollector, renderer) {
            this._shadowsInvalid = false;
            this.updateDepthProjection(entityCollector.camera);
            this._depthMap || ;
            this.createDepthTexture();
            this.drawDepthMap(this._depthMap, stage3DProxy, entityCollector.scene, renderer);
        };
        /**
         * 创建深度纹理
         */
        ShadowMapperBase.prototype.createDepthTexture = function () {
            return new feng3d.RenderTexture(this._depthMapSize, this._depthMapSize);
        };
        /**
         * 更新深度投影矩阵
         * @param viewCamera		摄像机
         */
        ShadowMapperBase.prototype.updateDepthProjection = function (viewCamera) {
            throw new feng3d.AbstractMethodError();
        };
        /**
         * 绘制深度图
         * @param depthMap				深度图纹理
         * @param stage3DProxy			3D舞台代理
         * @param scene					场景
         * @param renderer				渲染器
         */
        ShadowMapperBase.prototype.drawDepthMap = function (depthMap, stage3DProxy, scene, renderer) {
            throw new feng3d.AbstractMethodError();
        };
        Object.defineProperty(ShadowMapperBase.prototype, "depthMapSize", {
            /**
             * 深度图尺寸
             */
            get: function () {
                return _depthMapSize;
            },
            set: function (value) {
                if (value == _depthMapSize)
                    return;
                _depthMapSize = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 销毁
         */
        ShadowMapperBase.prototype.dispose = function () {
        };
        return ShadowMapperBase;
    }());
    feng3d.ShadowMapperBase = ShadowMapperBase;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 方向光阴影映射
     * @author feng 2015-5-28
     */
    var DirectionalShadowMapper = (function (_super) {
        __extends(DirectionalShadowMapper, _super);
        /**
         * 创建方向光阴影映射
         */
        function DirectionalShadowMapper() {
            _super.call(this);
            this._lightOffset = 10000;
            this._snap = 64;
            this._cullPlanes = new feng3d.Plane3D[]();
            this._overallDepthLens = new feng3d.FreeMatrixLens();
            this._overallDepthCamera = new feng3d.Camera3D(this._overallDepthLens);
            this._localFrustum = new number[](8 * 3);
            this._matrix = new Matrix3D();
        }
        Object.defineProperty(DirectionalShadowMapper.prototype, "depthProjection", {
            /**
             * 深度投影矩阵
             * <p>世界坐标转换为深度图空间</p>
             */
            get: function () {
                return _overallDepthCamera.viewProjection;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DirectionalShadowMapper.prototype, "depth", {
            /**
             * 投影深度
             * Depth projection matrix that projects from scene space to depth map.
             */
            get: function () {
                return _maxZ - _minZ;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        DirectionalShadowMapper.prototype.drawDepthMap = function (target, stage3DProxy, scene, renderer) {
            _casterCollector.camera = this._overallDepthCamera;
            _casterCollector.cullPlanes = this._cullPlanes;
            _casterCollector.clear();
            scene.traversePartitions(_casterCollector);
            renderer.render(stage3DProxy, _casterCollector, target);
        };
        DirectionalShadowMapper.prototype.updateCullPlanes = function (viewCamera) {
            var lightFrustumPlanes = this._overallDepthCamera.frustumPlanes;
            var viewFrustumPlanes = viewCamera.frustumPlanes;
            this._cullPlanes.length = 4;
            this._cullPlanes[0] = lightFrustumPlanes[0];
            this._cullPlanes[1] = lightFrustumPlanes[1];
            this._cullPlanes[2] = lightFrustumPlanes[2];
            this._cullPlanes[3] = lightFrustumPlanes[3];
            var dir = feng3d.DirectionalLight(_light).sceneDirection;
            var dirX = dir.x;
            var dirY = dir.y;
            var dirZ = dir.z;
            var j = 4;
            for (var i = 0; i < 6; ++i) {
                var plane = viewFrustumPlanes[i];
                if (plane.a * dirX + plane.b * dirY + plane.c * dirZ < 0)
                    this._cullPlanes[j++] = plane;
            }
        };
        DirectionalShadowMapper.prototype.updateDepthProjection = function (viewCamera) {
            this.updateProjectionFromFrustumCorners(viewCamera, viewCamera.lens.frustumCorners, this._matrix);
            this._overallDepthLens.matrix = this._matrix;
            this.updateCullPlanes(viewCamera);
        };
        /**
         * 更新投影矩阵
         * @param viewCamera		摄像机
         * @param corners
         * @param matrix
         */
        DirectionalShadowMapper.prototype.updateProjectionFromFrustumCorners = function (viewCamera, corners, matrix) {
            var raw = feng3d.Matrix3DUtils.RAW_DATA_CONTAINER;
            var dir;
            var x, y, z;
            var minX, minY;
            var maxX, maxY;
            var i;
            dir = feng3d.DirectionalLight(_light).sceneDirection;
            this._overallDepthCamera.transform3D.transform = _light.sceneTransform;
            x = number((viewCamera.transform3D.x - dir.x * this._lightOffset) / this._snap) * this._snap;
            y = number((viewCamera.transform3D.y - dir.y * this._lightOffset) / this._snap) * this._snap;
            z = number((viewCamera.transform3D.z - dir.z * this._lightOffset) / this._snap) * this._snap;
            this._overallDepthCamera.transform3D.x = x;
            this._overallDepthCamera.transform3D.y = y;
            this._overallDepthCamera.transform3D.z = z;
            this._matrix.copyFrom(this._overallDepthCamera.inverseSceneTransform);
            this._matrix.prepend(viewCamera.sceneTransform);
            this._matrix.transformVectors(corners, this._localFrustum);
            minX = maxX = this._localFrustum[0];
            minY = maxY = this._localFrustum[1];
            this._maxZ = this._localFrustum[2];
            i = 3;
            while (i < 24) {
                x = this._localFrustum[i];
                y = this._localFrustum[number(i + 1)];
                z = this._localFrustum[number(i + 2)];
                if (x < minX)
                    minX = x;
                if (x > maxX)
                    maxX = x;
                if (y < minY)
                    minY = y;
                if (y > maxY)
                    maxY = y;
                if (z > this._maxZ)
                    this._maxZ = z;
                i += 3;
            }
            this._minZ = 1;
            var w = maxX - minX;
            var h = maxY - minY;
            var d = 1 / (this._maxZ - this._minZ);
            if (minX < 0)
                minX -= this._snap; // because number() rounds up for < 0
            if (minY < 0)
                minY -= this._snap;
            minX = number(minX / this._snap) * this._snap;
            minY = number(minY / this._snap) * this._snap;
            var snap2 = 2 * this._snap;
            w = number(w / snap2 + 2) * snap2;
            h = number(h / snap2 + 2) * snap2;
            maxX = minX + w;
            maxY = minY + h;
            w = 1 / w;
            h = 1 / h;
            raw[0] = 2 * w;
            raw[5] = 2 * h;
            raw[10] = d;
            raw[12] = -(maxX + minX) * w;
            raw[13] = -(maxY + minY) * h;
            raw[14] = -this._minZ * d;
            raw[15] = 1;
            raw[1] = raw[2] = raw[3] = raw[4] = raw[6] = raw[7] = raw[8] = raw[9] = raw[11] = 0;
            matrix.copyRawDataFrom(raw);
        };
        return DirectionalShadowMapper;
    }(feng3d.ShadowMapperBase));
    feng3d.DirectionalShadowMapper = DirectionalShadowMapper;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 近方向光阴影映射
     * @author feng 2015-5-28
     */
    var NearDirectionalShadowMapper = (function (_super) {
        __extends(NearDirectionalShadowMapper, _super);
        /**
         * 创建近方向光阴影映射
         * @param coverageRatio		覆盖比例
         */
        function NearDirectionalShadowMapper(coverageRatio) {
            if (coverageRatio === void 0) { coverageRatio = .5; }
            _super.call(this);
            this.coverageRatio = coverageRatio;
        }
        Object.defineProperty(NearDirectionalShadowMapper.prototype, "coverageRatio", {
            /**
             * 阴影的覆盖视椎体的比例
             * <p>0表示视椎体内看不到阴影，0.5表示从近平面到与远平面之间可以看到阴影，1表示视椎体内都可以看到阴影。</p>
             * <p><b>注：看到阴影的前提是有阴影产生</b></p>
             */
            get: function () {
                return _coverageRatio;
            },
            set: function (value) {
                if (value > 1)
                    value = 1;
                else if (value < 0)
                    value = 0;
                _coverageRatio = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        NearDirectionalShadowMapper.prototype.updateDepthProjection = function (viewCamera) {
            var corners = viewCamera.lens.frustumCorners;
            for (var i = 0; i < 12; ++i) {
                var v = corners[i];
                _localFrustum[i] = v;
                _localFrustum[number(i + 12)] = v + (corners[number(i + 12)] - v) * this._coverageRatio;
            }
            updateProjectionFromFrustumCorners(viewCamera, _localFrustum, _matrix);
            _overallDepthLens.matrix = _matrix;
        };
        return NearDirectionalShadowMapper;
    }(feng3d.DirectionalShadowMapper));
    feng3d.NearDirectionalShadowMapper = NearDirectionalShadowMapper;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 3d直线
     * @author feng 2013-6-13
     */
    var Line3D = (function () {
        /**
         * 根据直线某点与方向创建直线
         * @param position 直线上某点
         * @param direction 直线的方向
         */
        function Line3D(position, direction) {
            if (position === void 0) { position = null; }
            if (direction === void 0) { direction = null; }
            this.position = position ? position : new Vector3D();
            this.direction = direction ? direction : new Vector3D(0, 0, 1);
        }
        /**
         * 根据直线上两点初始化直线
         * @param p0 Vector3D
         * @param p1 Vector3D
         */
        Line3D.prototype.fromPoints = function (p0, p1) {
            this.position = p0;
            this.direction = p1.subtract(p0);
        };
        /**
         * 根据直线某点与方向初始化直线
         * @param position 直线上某点
         * @param direction 直线的方向
         */
        Line3D.prototype.fromPosAndDir = function (position, direction) {
            this.position = position;
            this.direction = direction;
        };
        /**
         * 获取直线上的一个点
         * @param length 与原点距离
         */
        Line3D.prototype.getPoint = function (length) {
            if (length === void 0) { length = 0; }
            var lengthDir = this.direction.clone();
            lengthDir.scaleBy(length);
            var newPoint = this.position.add(lengthDir);
            return newPoint;
        };
        return Line3D;
    }());
    feng3d.Line3D = Line3D;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 3D射线
     * @author feng 2013-6-13
     */
    var Ray3D = (function (_super) {
        __extends(Ray3D, _super);
        function Ray3D(position, direction) {
            if (position === void 0) { position = null; }
            if (direction === void 0) { direction = null; }
            _super.call(this, position, direction);
        }
        return Ray3D;
    }(feng3d.Line3D));
    feng3d.Ray3D = Ray3D;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 数学常量类
     */
    var MathConsts = (function () {
        function MathConsts() {
        }
        /**
         * 弧度转角度因子
         */
        MathConsts.RADIANS_TO_DEGREES = 180 / Math.PI;
        /**
         * 角度转弧度因子
         */
        MathConsts.DEGREES_TO_RADIANS = Math.PI / 180;
        return MathConsts;
    }());
    feng3d.MathConsts = MathConsts;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
        * ;
    /**
     * 矩阵工具类
     * Matrix3DUtils provides additional Matrix3D math functions.
     */
    var Matrix3DUtils = (function () {
        function Matrix3DUtils() {
        }
        /**
         * Fills the 3d matrix object with values representing the transformation made by the given quaternion.
         *
         * @param    quarternion    The quarterion object to convert.
         */
        Matrix3DUtils.quaternion2matrix = function (quarternion, m) {
            if (m === void 0) { m = null; }
            var x = quarternion.x;
            var y = quarternion.y;
            var z = quarternion.z;
            var w = quarternion.w;
            var xx = x * x;
            var xy = x * y;
            var xz = x * z;
            var xw = x * w;
            var yy = y * y;
            var yz = y * z;
            var yw = y * w;
            var zz = z * z;
            var zw = z * w;
            var raw = RAW_DATA_CONTAINER;
            raw[0] = 1 - 2 * (yy + zz);
            raw[1] = 2 * (xy + zw);
            raw[2] = 2 * (xz - yw);
            raw[4] = 2 * (xy - zw);
            raw[5] = 1 - 2 * (xx + zz);
            raw[6] = 2 * (yz + xw);
            raw[8] = 2 * (xz + yw);
            raw[9] = 2 * (yz - xw);
            raw[10] = 1 - 2 * (xx + yy);
            raw[3] = raw[7] = raw[11] = raw[12] = raw[13] = raw[14] = 0;
            raw[15] = 1;
            if (m) {
                m.copyRawDataFrom(raw);
                return m;
            }
            else
                return new Matrix3D(raw);
        };
        /**
         *
         * Returns a normalised <code>Vector3D</code> object representing the forward vector of the given matrix.
         * @param    m        The Matrix3D object to use to get the forward vector
         * @param    v        [optional] A vector holder to prevent make new Vector3D instance if already exists. Default is null.
         * @return            The forward vector
         */
        Matrix3DUtils.getForward = function (m, v) {
            if (v === void 0) { v = null; }
            if (!v)
                v = new Vector3D();
            m.copyColumnTo(2, v);
            v.normalize();
            return v;
        };
        /**
         * Returns a normalised <code>Vector3D</code> object representing the up vector of the given matrix.
         * @param    m        The Matrix3D object to use to get the up vector
         * @param    v        [optional] A vector holder to prevent make new Vector3D instance if already exists. Default is null.
         * @return            The up vector
         */
        Matrix3DUtils.getUp = function (m, v) {
            if (v === void 0) { v = null; }
            if (!v)
                v = new Vector3D();
            m.copyColumnTo(1, v);
            v.normalize();
            return v;
        };
        /**
         * Returns a normalised <code>Vector3D</code> object representing the right vector of the given matrix.
         * @param    m        The Matrix3D object to use to get the right vector
         * @param    v        [optional] A vector holder to prevent make new Vector3D instance if already exists. Default is null.
         * @return            The right vector
         */
        Matrix3DUtils.getRight = function (m, v) {
            if (v === void 0) { v = null; }
            if (!v)
                v = new Vector3D();
            m.copyColumnTo(0, v);
            v.normalize();
            return v;
        };
        /**
         * Returns a boolean value representing whether there is any significant difference between the two given 3d matrices.
         */
        Matrix3DUtils.compare = function (m1, m2) {
            var r1 = Matrix3DUtils.RAW_DATA_CONTAINER;
            var r2 = m2.rawData;
            m1.copyRawDataTo(r1);
            for (var i = 0; i < 16; ++i) {
                if (r1[i] != r2[i])
                    return false;
            }
            return true;
        };
        Matrix3DUtils.lookAt = function (matrix, pos, dir, up) {
            var dirN;
            var upN;
            var lftN;
            var raw = RAW_DATA_CONTAINER;
            lftN = dir.crossProduct(up);
            lftN.normalize();
            upN = lftN.crossProduct(dir);
            upN.normalize();
            dirN = dir.clone();
            dirN.normalize();
            raw[0] = lftN.x;
            raw[1] = upN.x;
            raw[2] = -dirN.x;
            raw[3] = 0.0;
            raw[4] = lftN.y;
            raw[5] = upN.y;
            raw[6] = -dirN.y;
            raw[7] = 0.0;
            raw[8] = lftN.z;
            raw[9] = upN.z;
            raw[10] = -dirN.z;
            raw[11] = 0.0;
            raw[12] = -lftN.dotProduct(pos);
            raw[13] = -upN.dotProduct(pos);
            raw[14] = dirN.dotProduct(pos);
            raw[15] = 1.0;
            matrix.copyRawDataFrom(raw);
        };
        Matrix3DUtils.reflection = function (plane, target) {
            if (target === void 0) { target = null; }
            target || ;
            new Matrix3D();
            var a = plane.a, b = plane.b, c = plane.c, d = plane.d;
            var rawData = Matrix3DUtils.RAW_DATA_CONTAINER;
            var ab2 = -2 * a * b;
            var ac2 = -2 * a * c;
            var bc2 = -2 * b * c;
            // reflection matrix
            rawData[0] = 1 - 2 * a * a;
            rawData[4] = ab2;
            rawData[8] = ac2;
            rawData[12] = -2 * a * d;
            rawData[1] = ab2;
            rawData[5] = 1 - 2 * b * b;
            rawData[9] = bc2;
            rawData[13] = -2 * b * d;
            rawData[2] = ac2;
            rawData[6] = bc2;
            rawData[10] = 1 - 2 * c * c;
            rawData[14] = -2 * c * d;
            rawData[3] = 0;
            rawData[7] = 0;
            rawData[11] = 0;
            rawData[15] = 1;
            target.copyRawDataFrom(rawData);
            return target;
        };
        Matrix3DUtils.decompose = function (sourceMatrix, orientationStyle) {
            if (orientationStyle === void 0) { orientationStyle = "eulerAngles"; }
            var raw = RAW_DATA_CONTAINER;
            sourceMatrix.copyRawDataTo(raw);
            var a = raw[0];
            var e = raw[1];
            var i = raw[2];
            var b = raw[4];
            var f = raw[5];
            var j = raw[6];
            var c = raw[8];
            var g = raw[9];
            var k = raw[10];
            var x = raw[12];
            var y = raw[13];
            var z = raw[14];
            var tx = Math.sqrt(a * a + e * e + i * i);
            var ty = Math.sqrt(b * b + f * f + j * j);
            var tz = Math.sqrt(c * c + g * g + k * k);
            var tw = 0;
            var scaleX = tx;
            var scaleY = ty;
            var scaleZ = tz;
            if (a * (f * k - j * g) - e * (b * k - j * c) + i * (b * g - f * c) < 0) {
                scaleZ = -scaleZ;
            }
            a = a / scaleX;
            e = e / scaleX;
            i = i / scaleX;
            b = b / scaleY;
            f = f / scaleY;
            j = j / scaleY;
            c = c / scaleZ;
            g = g / scaleZ;
            k = k / scaleZ;
            //from away3d-ts
            if (orientationStyle == Orientation3D.EULER_ANGLES) {
                tx = Math.atan2(j, k);
                ty = Math.atan2(-i, Math.sqrt(a * a + e * e));
                var s1 = Math.sin(tx);
                var c1 = Math.cos(tx);
                tz = Math.atan2(s1 * c - c1 * b, c1 * f - s1 * g);
            }
            else if (orientationStyle == Orientation3D.AXIS_ANGLE) {
                tw = Math.acos((a + f + k - 1) / 2);
                var len = Math.sqrt((j - g) * (j - g) + (c - i) * (c - i) + (e - b) * (e - b));
                tx = (j - g) / len;
                ty = (c - i) / len;
                tz = (e - b) / len;
            }
            else {
                var tr = a + f + k;
                if (tr > 0) {
                    tw = Math.sqrt(1 + tr) / 2;
                    tx = (j - g) / (4 * tw);
                    ty = (c - i) / (4 * tw);
                    tz = (e - b) / (4 * tw);
                }
                else if ((a > f) && (a > k)) {
                    tx = Math.sqrt(1 + a - f - k) / 2;
                    tw = (j - g) / (4 * tx);
                    ty = (e + b) / (4 * tx);
                    tz = (c + i) / (4 * tx);
                }
                else if (f > k) {
                    ty = Math.sqrt(1 + f - a - k) / 2;
                    tx = (e + b) / (4 * ty);
                    tw = (c - i) / (4 * ty);
                    tz = (j + g) / (4 * ty);
                }
                else {
                    tz = Math.sqrt(1 + k - a - f) / 2;
                    tx = (c + i) / (4 * tz);
                    ty = (j + g) / (4 * tz);
                    tw = (e - b) / (4 * tz);
                }
            }
            var v = CALCULATION_DECOMPOSE;
            v[0].x = x;
            v[0].y = y;
            v[0].z = z;
            v[1].x = tx;
            v[1].y = ty;
            v[1].z = tz;
            v[1].w = tw;
            v[2].x = scaleX;
            v[2].y = scaleY;
            v[2].z = scaleZ;
            return v;
        };
        Matrix3DUtils.transformVector = function (matrix, vector, result) {
            if (result === void 0) { result = null; }
            if (!result)
                result = new Vector3D();
            var raw = Matrix3DUtils.RAW_DATA_CONTAINER;
            matrix.copyRawDataTo(raw);
            var a = raw[0];
            var e = raw[1];
            var i = raw[2];
            var m = raw[3];
            var b = raw[4];
            var f = raw[5];
            var j = raw[6];
            var n = raw[7];
            var c = raw[8];
            var g = raw[9];
            var k = raw[10];
            var o = raw[11];
            var d = raw[12];
            var h = raw[13];
            var l = raw[14];
            var p = raw[15];
            var x = vector.x;
            var y = vector.y;
            var z = vector.z;
            result.x = a * x + b * y + c * z + d;
            result.y = e * x + f * y + g * z + h;
            result.z = i * x + j * y + k * z + l;
            result.w = m * x + n * y + o * z + p;
            return result;
        };
        Matrix3DUtils.deltaTransformVector = function (matrix, vector, result) {
            if (result === void 0) { result = null; }
            if (!result)
                result = new Vector3D();
            var raw = Matrix3DUtils.RAW_DATA_CONTAINER;
            matrix.copyRawDataTo(raw);
            var a = raw[0];
            var e = raw[1];
            var i = raw[2];
            var m = raw[3];
            var b = raw[4];
            var f = raw[5];
            var j = raw[6];
            var n = raw[7];
            var c = raw[8];
            var g = raw[9];
            var k = raw[10];
            var o = raw[11];
            var x = vector.x;
            var y = vector.y;
            var z = vector.z;
            result.x = a * x + b * y + c * z;
            result.y = e * x + f * y + g * z;
            result.z = i * x + j * y + k * z;
            result.w = m * x + n * y + o * z;
            return result;
        };
        Matrix3DUtils.getTranslation = function (transform, result) {
            if (result === void 0) { result = null; }
            if (!result)
                result = new Vector3D();
            transform.copyColumnTo(3, result);
            return result;
        };
        Matrix3DUtils.deltaTransformVectors = function (matrix, vin, vout) {
            var raw = Matrix3DUtils.RAW_DATA_CONTAINER;
            matrix.copyRawDataTo(raw);
            var a = raw[0];
            var e = raw[1];
            var i = raw[2];
            var m = raw[3];
            var b = raw[4];
            var f = raw[5];
            var j = raw[6];
            var n = raw[7];
            var c = raw[8];
            var g = raw[9];
            var k = raw[10];
            var o = raw[11];
            var outIndex = 0;
            var length = vin.length;
            for (var index = 0; index < length; index += 3) {
                var x = vin[index];
                var y = vin[index + 1];
                var z = vin[index + 2];
                vout[outIndex++] = a * x + b * y + c * z;
                vout[outIndex++] = e * x + f * y + g * z;
                vout[outIndex++] = i * x + j * y + k * z;
            }
        };
        /**
         * 更新本地射线
         * @param inverseSceneTransform 逆场景变换矩阵
         * @param ray3D 场景射线
         * @param localRay 本地射线
         */
        Matrix3DUtils.updateLocalRay = function (inverseSceneTransform, ray3D, localRay) {
            Matrix3DUtils.transformVector(inverseSceneTransform, ray3D.position, localRay.position);
            Matrix3DUtils.deltaTransformVector(inverseSceneTransform, ray3D.direction, localRay.direction);
        };
        /**
         * A reference to a Vector to be used as a temporary raw data container, to prevent object creation.
         */
        Matrix3DUtils.RAW_DATA_CONTAINER = new number[](16);
        Matrix3DUtils.CALCULATION_MATRIX = new Matrix3D();
        Matrix3DUtils.CALCULATION_VECTOR3D = new Vector3D();
        Matrix3DUtils.CALCULATION_DECOMPOSE = Vector3D[]([new Vector3D(), new Vector3D(), new Vector3D()]);
        return Matrix3DUtils;
    }());
    feng3d.Matrix3DUtils = Matrix3DUtils;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 3d面
     */
    var Plane3D = (function () {
        /**
         * 创建一个平面
         * @param a		A系数
         * @param b		B系数
         * @param c		C系数
         * @param d		D系数
         */
        function Plane3D(a, b, c, d) {
            if (a === void 0) { a = 0; }
            if (b === void 0) { b = 0; }
            if (c === void 0) { c = 0; }
            if (d === void 0) { d = 0; }
            this.a = a;
            this.b = b;
            this.c = c;
            this.d = d;
            if (a == 0 && b == 0)
                this._alignment = ALIGN_XY_AXIS;
            else if (b == 0 && c == 0)
                this._alignment = ALIGN_YZ_AXIS;
            else if (a == 0 && c == 0)
                this._alignment = ALIGN_XZ_AXIS;
            else
                this._alignment = ALIGN_ANY;
        }
        /**
         * 通过3顶点定义一个平面
         * @param p0		点0
         * @param p1		点1
         * @param p2		点2
         */
        Plane3D.prototype.fromPoints = function (p0, p1, p2) {
            //计算向量1
            var d1x = p1.x - p0.x;
            var d1y = p1.y - p0.y;
            var d1z = p1.z - p0.z;
            //计算向量2
            var d2x = p2.x - p0.x;
            var d2y = p2.y - p0.y;
            var d2z = p2.z - p0.z;
            //叉乘计算法线
            this.a = d1y * d2z - d1z * d2y;
            this.b = d1z * d2x - d1x * d2z;
            this.c = d1x * d2y - d1y * d2x;
            //平面上点与法线点乘计算D值
            this.d = this.a * p0.x + this.b * p0.y + this.c * p0.z;
            //法线平行z轴
            if (this.a == 0 && this.b == 0)
                this._alignment = ALIGN_XY_AXIS;
            else if (this.b == 0 && this.c == 0)
                this._alignment = ALIGN_YZ_AXIS;
            else if (this.a == 0 && this.c == 0)
                this._alignment = ALIGN_XZ_AXIS;
            else
                this._alignment = ALIGN_ANY;
        };
        /**
         * 根据法线与点定义平面
         * @param normal		平面法线
         * @param point			平面上任意一点
         */
        Plane3D.prototype.fromNormalAndPoint = function (normal, point) {
            this.a = normal.x;
            this.b = normal.y;
            this.c = normal.z;
            this.d = this.a * point.x + this.b * point.y + this.c * point.z;
            if (this.a == 0 && this.b == 0)
                this._alignment = ALIGN_XY_AXIS;
            else if (this.b == 0 && this.c == 0)
                this._alignment = ALIGN_YZ_AXIS;
            else if (this.a == 0 && this.c == 0)
                this._alignment = ALIGN_XZ_AXIS;
            else
                this._alignment = ALIGN_ANY;
        };
        /**
         * 标准化平面
         * @return		标准化后的平面
         */
        Plane3D.prototype.normalize = function () {
            var len = 1 / Math.sqrt(this.a * this.a + this.b * this.b + this.c * this.c);
            this.a *= len;
            this.b *= len;
            this.c *= len;
            this.d *= len;
            return this;
        };
        /**
         * 计算点与平面的距离
         * @param p		点
         * @returns		距离
         */
        Plane3D.prototype.distance = function (p) {
            if (this._alignment == ALIGN_YZ_AXIS)
                return this.a * p.x - this.d;
            else if (this._alignment == ALIGN_XZ_AXIS)
                return this.b * p.y - this.d;
            else if (this._alignment == ALIGN_XY_AXIS)
                return this.c * p.z - this.d;
            else
                return this.a * p.x + this.b * p.y + this.c * p.z - this.d;
        };
        /**
         * 顶点分类
         * <p>把顶点分为后面、前面、相交三类</p>
         * @param p			顶点
         * @return			顶点类型 PlaneClassification.BACK,PlaneClassification.FRONT,PlaneClassification.INTERSECT
         * @see				me.feng3d.core.math.PlaneClassification
         */
        Plane3D.prototype.classifyPoint = function (p, epsilon) {
            if (epsilon === void 0) { epsilon = 0.01; }
            // check NaN
            if (this.d != this.d)
                return feng3d.PlaneClassification.FRONT;
            var len;
            if (this._alignment == ALIGN_YZ_AXIS)
                len = this.a * p.x - this.d;
            else if (this._alignment == ALIGN_XZ_AXIS)
                len = this.b * p.y - this.d;
            else if (this._alignment == ALIGN_XY_AXIS)
                len = this.c * p.z - this.d;
            else
                len = this.a * p.x + this.b * p.y + this.c * p.z - this.d;
            if (len < -epsilon)
                return feng3d.PlaneClassification.BACK;
            else if (len > epsilon)
                return feng3d.PlaneClassification.FRONT;
            else
                return feng3d.PlaneClassification.INTERSECT;
        }
        feng3d.classifyPoint = classifyPoint;;
        /**
         * 输出字符串
         */
        Plane3D.prototype.toString = function () {
            return "Plane3D [this.a:" + this.a + ", this.b:" + this.b + ", this.c:" + this.c + ", this.d:" + this.d + "]";
        };
        /**
         * 普通平面
         * <p>不与对称轴平行或垂直</p>
         */
        Plane3D.ALIGN_ANY = 0;
        /**
         * XY方向平面
         * <p>法线与Z轴平行</p>
         */
        Plane3D.ALIGN_XY_AXIS = 1;
        /**
         * YZ方向平面
         * <p>法线与X轴平行</p>
         */
        Plane3D.ALIGN_YZ_AXIS = 2;
        /**
         * XZ方向平面
         * <p>法线与Y轴平行</p>
         */
        Plane3D.ALIGN_XZ_AXIS = 3;
        return Plane3D;
    }());
    feng3d.Plane3D = Plane3D;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 点与面的相对位置
     * @author feng
     */
    var PlaneClassification = (function () {
        function PlaneClassification() {
        }
        /**
         * 在平面后面
         * <p>等价于平面内</p>
         * @see #IN
         */
        PlaneClassification.BACK = 0;
        /**
         * 在平面前面
         * <p>等价于平面外</p>
         * @see #OUT
         */
        PlaneClassification.FRONT = 1;
        /**
         * 在平面内
         * <p>等价于在平面后</p>
         * @see #BACK
         */
        PlaneClassification.IN = 0;
        /**
         * 在平面外
         * <p>等价于平面前面</p>
         * @see #FRONT
         */
        PlaneClassification.OUT = 1;
        /**
         * 与平面相交
         */
        PlaneClassification.INTERSECT = 2;
        return PlaneClassification;
    }());
    feng3d.PlaneClassification = PlaneClassification;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    final;
    var Quaternion = (function () {
        /**
         * Creates a new Quaternion object.
         * @param x The x value of the quaternion.
         * @param y The y value of the quaternion.
         * @param z The z value of the quaternion.
         * @param w The w value of the quaternion.
         */
        function Quaternion(x, y, z, w) {
            if (x === void 0) { x = 0; }
            if (y === void 0) { y = 0; }
            if (z === void 0) { z = 0; }
            if (w === void 0) { w = 1; }
            /**
             * The x value of the quaternion.
             */
            this.x = 0;
            /**
             * The y value of the quaternion.
             */
            this.y = 0;
            /**
             * The z value of the quaternion.
             */
            this.z = 0;
            /**
             * The w value of the quaternion.
             */
            this.w = 1;
            this.x = x;
            this.y = y;
            this.z = z;
            this.w = w;
        }
        Object.defineProperty(Quaternion.prototype, "magnitude", {
            /**
             * Returns the magnitude of the quaternion object.
             */
            get: function () {
                return Math.sqrt(w * w + x * x + y * y + z * z);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Fills the quaternion object with the result from a multiplication of two quaternion objects.
         *
         * @param    qa    The first quaternion in the multiplication.
         * @param    qb    The second quaternion in the multiplication.
         */
        Quaternion.prototype.multiply = function (qa, qb) {
            var w1 = qa.w, x1 = qa.x, y1 = qa.y, z1 = qa.z;
            var w2 = qb.w, x2 = qb.x, y2 = qb.y, z2 = qb.z;
            this.w = w1 * w2 - x1 * x2 - y1 * y2 - z1 * z2;
            this.x = w1 * x2 + x1 * w2 + y1 * z2 - z1 * y2;
            this.y = w1 * y2 - x1 * z2 + y1 * w2 + z1 * x2;
            this.z = w1 * z2 + x1 * y2 - y1 * x2 + z1 * w2;
        };
        Quaternion.prototype.multiplyVector = function (vector, target) {
            if (target === void 0) { target = null; }
            target || ;
            new Quaternion();
            var x2 = vector.x;
            var y2 = vector.y;
            var z2 = vector.z;
            target.w = -this.x * x2 - this.y * y2 - this.z * z2;
            target.x = this.w * x2 + this.y * z2 - this.z * y2;
            target.y = this.w * y2 - this.x * z2 + this.z * x2;
            target.z = this.w * z2 + this.x * y2 - this.y * x2;
            return target;
        };
        /**
         * Fills the quaternion object with values representing the given rotation around a vector.
         *
         * @param    axis    The axis around which to rotate
         * @param    angle    The angle in radians of the rotation.
         */
        Quaternion.prototype.fromAxisAngle = function (axis, angle) {
            var sin_a = Math.sin(angle / 2);
            var cos_a = Math.cos(angle / 2);
            this.x = axis.x * sin_a;
            this.y = axis.y * sin_a;
            this.z = axis.z * sin_a;
            this.w = cos_a;
            this.normalize();
        };
        /**
         * Spherically interpolates between two quaternions, providing an interpolation between rotations with constant angle change rate.
         * @param qa The first quaternion to interpolate.
         * @param qb The second quaternion to interpolate.
         * @param t The interpolation weight, a value between 0 and 1.
         */
        Quaternion.prototype.slerp = function (qa, qb, t) {
            var w1 = qa.w, x1 = qa.x, y1 = qa.y, z1 = qa.z;
            var w2 = qb.w, x2 = qb.x, y2 = qb.y, z2 = qb.z;
            var dot = w1 * w2 + x1 * x2 + y1 * y2 + z1 * z2;
            // shortest direction
            if (dot < 0) {
                dot = -dot;
                w2 = -w2;
                x2 = -x2;
                y2 = -y2;
                z2 = -z2;
            }
            if (dot < 0.95) {
                // interpolate angle linearly
                var angle = Math.acos(dot);
                var s = 1 / Math.sin(angle);
                var s1 = Math.sin(angle * (1 - t)) * s;
                var s2 = Math.sin(angle * t) * s;
                this.w = w1 * s1 + w2 * s2;
                this.x = x1 * s1 + x2 * s2;
                this.y = y1 * s1 + y2 * s2;
                this.z = z1 * s1 + z2 * s2;
            }
            else {
                // nearly identical angle, interpolate linearly
                this.w = w1 + t * (w2 - w1);
                this.x = x1 + t * (x2 - x1);
                this.y = y1 + t * (y2 - y1);
                this.z = z1 + t * (z2 - z1);
                var len = 1.0 / Math.sqrt(this.w * this.w + this.x * this.x + this.y * this.y + this.z * this.z);
                this.w *= len;
                this.x *= len;
                this.y *= len;
                this.z *= len;
            }
        };
        /**
         * 线性求插值
         * @param qa 第一个四元素
         * @param qb 第二个四元素
         * @param t 权重
         */
        Quaternion.prototype.lerp = function (qa, qb, t) {
            var w1 = qa.w, x1 = qa.x, y1 = qa.y, z1 = qa.z;
            var w2 = qb.w, x2 = qb.x, y2 = qb.y, z2 = qb.z;
            var len;
            // shortest direction
            if (w1 * w2 + x1 * x2 + y1 * y2 + z1 * z2 < 0) {
                w2 = -w2;
                x2 = -x2;
                y2 = -y2;
                z2 = -z2;
            }
            this.w = w1 + t * (w2 - w1);
            this.x = x1 + t * (x2 - x1);
            this.y = y1 + t * (y2 - y1);
            this.z = z1 + t * (z2 - z1);
            len = 1.0 / Math.sqrt(this.w * this.w + this.x * this.x + this.y * this.y + this.z * this.z);
            this.w *= len;
            this.x *= len;
            this.y *= len;
            this.z *= len;
        };
        /**
         * Fills the quaternion object with values representing the given euler rotation.
         *
         * @param    ax        The angle in radians of the rotation around the ax axis.
         * @param    ay        The angle in radians of the rotation around the ay axis.
         * @param    az        The angle in radians of the rotation around the az axis.
         */
        Quaternion.prototype.fromEulerAngles = function (ax, ay, az) {
            var halfX = ax * .5, halfY = ay * .5, halfZ = az * .5;
            var cosX = Math.cos(halfX), sinX = Math.sin(halfX);
            var cosY = Math.cos(halfY), sinY = Math.sin(halfY);
            var cosZ = Math.cos(halfZ), sinZ = Math.sin(halfZ);
            this.w = cosX * cosY * cosZ + sinX * sinY * sinZ;
            this.x = sinX * cosY * cosZ - cosX * sinY * sinZ;
            this.y = cosX * sinY * cosZ + sinX * cosY * sinZ;
            this.z = cosX * cosY * sinZ - sinX * sinY * cosZ;
        };
        /**
         * Fills a target Vector3D object with the Euler angles that form the rotation represented by this quaternion.
         * @param target An optional Vector3D object to contain the Euler angles. If not provided, a new object is created.
         * @return The Vector3D containing the Euler angles.
         */
        Quaternion.prototype.toEulerAngles = function (target) {
            if (target === void 0) { target = null; }
            target || ;
            new Vector3D();
            target.x = Math.atan2(2 * (this.w * this.x + this.y * this.z), 1 - 2 * (this.x * this.x + this.y * this.y));
            target.y = Math.asin(2 * (this.w * this.y - this.z * this.x));
            target.z = Math.atan2(2 * (this.w * this.z + this.x * this.y), 1 - 2 * (this.y * this.y + this.z * this.z));
            return target;
        };
        /**
         * Normalises the quaternion object.
         */
        Quaternion.prototype.normalize = function (val) {
            if (val === void 0) { val = 1; }
            var mag = val / Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
            this.x *= mag;
            this.y *= mag;
            this.z *= mag;
            this.w *= mag;
        };
        /**
         * Used to trace the values of a quaternion.
         *
         * @return A string representation of the quaternion object.
         */
        Quaternion.prototype.toString = function () {
            return "{this.x:" + this.x + " this.y:" + this.y + " this.z:" + this.z + " this.w:" + this.w + "}";
        };
        /**
         * Converts the quaternion to a Matrix3D object representing an equivalent rotation.
         * @param target An optional Matrix3D container to store the transformation in. If not provided, a new object is created.
         * @return A Matrix3D object representing an equivalent rotation.
         */
        Quaternion.prototype.toMatrix3D = function (target) {
            if (target === void 0) { target = null; }
            var rawData = feng3d.Matrix3DUtils.RAW_DATA_CONTAINER;
            var xy2 = 2.0 * this.x * this.y, xz2 = 2.0 * this.x * this.z, xw2 = 2.0 * this.x * this.w;
            var yz2 = 2.0 * this.y * this.z, yw2 = 2.0 * this.y * this.w, zw2 = 2.0 * this.z * this.w;
            var xx = this.x * this.x, yy = this.y * this.y, zz = this.z * this.z, ww = this.w * this.w;
            rawData[0] = xx - yy - zz + ww;
            rawData[4] = xy2 - zw2;
            rawData[8] = xz2 + yw2;
            rawData[12] = 0;
            rawData[1] = xy2 + zw2;
            rawData[5] = -xx + yy - zz + ww;
            rawData[9] = yz2 - xw2;
            rawData[13] = 0;
            rawData[2] = xz2 - yw2;
            rawData[6] = yz2 + xw2;
            rawData[10] = -xx - yy + zz + ww;
            rawData[14] = 0;
            rawData[3] = 0.0;
            rawData[7] = 0.0;
            rawData[11] = 0;
            rawData[15] = 1;
            if (!target)
                return new Matrix3D(rawData);
            target.copyRawDataFrom(rawData);
            return target;
        };
        /**
         * Extracts a quaternion rotation matrix out of a given Matrix3D object.
         * @param matrix The Matrix3D out of which the rotation will be extracted.
         */
        Quaternion.prototype.fromMatrix = function (matrix) {
            var v = matrix.decompose(Orientation3D.QUATERNION)[1];
            this.x = v.x;
            this.y = v.y;
            this.z = v.z;
            this.w = v.w;
        };
        /**
         * Converts the quaternion to a Vector.&lt;number&gt; matrix representation of a rotation equivalent to this quaternion.
         * @param target The Vector.&lt;number&gt; to contain the raw matrix data.
         * @param exclude4thRow If true, the last row will be omitted, and a 4x3 matrix will be generated instead of a 4x4.
         */
        Quaternion.prototype.toRawData = function (target, exclude4thRow) {
            if (exclude4thRow === void 0) { exclude4thRow = false; }
            var xy2 = 2.0 * this.x * this.y, xz2 = 2.0 * this.x * this.z, xw2 = 2.0 * this.x * this.w;
            var yz2 = 2.0 * this.y * this.z, yw2 = 2.0 * this.y * this.w, zw2 = 2.0 * this.z * this.w;
            var xx = this.x * this.x, yy = this.y * this.y, zz = this.z * this.z, ww = this.w * this.w;
            target[0] = xx - yy - zz + ww;
            target[1] = xy2 - zw2;
            target[2] = xz2 + yw2;
            target[4] = xy2 + zw2;
            target[5] = -xx + yy - zz + ww;
            target[6] = yz2 - xw2;
            target[8] = xz2 - yw2;
            target[9] = yz2 + xw2;
            target[10] = -xx - yy + zz + ww;
            target[3] = target[7] = target[11] = 0;
            if (!exclude4thRow) {
                target[12] = target[13] = target[14] = 0;
                target[15] = 1;
            }
        };
        /**
         * Clones the quaternion.
         * @return An exact duplicate of the current Quaternion.
         */
        Quaternion.prototype.clone = function () {
            return new Quaternion(this.x, this.y, this.z, this.w);
        };
        /**
         * Rotates a point.
         * @param vector The Vector3D object to be rotated.
         * @param target An optional Vector3D object that will contain the rotated coordinates. If not provided, a new object will be created.
         * @return A Vector3D object containing the rotated point.
         */
        Quaternion.prototype.rotatePoint = function (vector, target) {
            if (target === void 0) { target = null; }
            var x1, y1, z1, w1;
            var x2 = vector.x, y2 = vector.y, z2 = vector.z;
            target || ;
            new Vector3D();
            // p*q'
            w1 = -this.x * x2 - this.y * y2 - this.z * z2;
            x1 = this.w * x2 + this.y * z2 - this.z * y2;
            y1 = this.w * y2 - this.x * z2 + this.z * x2;
            z1 = this.w * z2 + this.x * y2 - this.y * x2;
            target.x = -w1 * this.x + x1 * this.w - y1 * this.z + z1 * this.y;
            target.y = -w1 * this.y + x1 * this.z + y1 * this.w - z1 * this.x;
            target.z = -w1 * this.z - x1 * this.y + y1 * this.x + z1 * this.w;
            return target;
        };
        /**
         * Copies the data from a quaternion into this instance.
         * @param q The quaternion to copy from.
         */
        Quaternion.prototype.copyFrom = function (q) {
            this.x = q.x;
            this.y = q.y;
            this.z = q.z;
            this.w = q.w;
        };
        return Quaternion;
    }());
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 三角形
     * @author feng 2014-5-4
     */
    var Triangle3D = (function () {
        function Triangle3D(p0, p1, p2) {
            this.p0 = p0;
            this.p1 = p1;
            this.p2 = p2;
        }
        /**
         * 测试是否与直线相交
         * @param line3D 直线
         * @return 是否相交
         */
        Triangle3D.prototype.testLineCollision = function (line3D) {
            return false;
        };
        Object.defineProperty(Triangle3D.prototype, "p0", {
            /**
             * 第1个点
             */
            get: function () {
                return _p0;
            },
            set: function (value) {
                _p0 = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Triangle3D.prototype, "p1", {
            /**
             * 第2个点
             */
            get: function () {
                return _p1;
            },
            set: function (value) {
                _p1 = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Triangle3D.prototype, "p2", {
            /**
             * 第3个点
             */
            get: function () {
                return _p2;
            },
            set: function (value) {
                _p2 = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Triangle3D.prototype, "normal", {
            /**
             * 法线
             */
            get: function () {
                if (_normal == null)
                    updateNomal();
                return _normal;
            },
            enumerable: true,
            configurable: true
        });
        Triangle3D.prototype.updateNomal = function () {
            this._normal = this.p1.subtract(this.p0).crossProduct(this.p2.subtract(this.p0));
        };
        return Triangle3D;
    }());
    feng3d.Triangle3D = Triangle3D;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 解析工具类
     */
    var ParserUtil = (function () {
        function ParserUtil() {
        }
        /**
         * 把数据转换为二进制
         * @param data 数据
         * @return
         *
         */
        ParserUtil.toByteArray = function (data) {
            if (data === void 0) { data =  * ; }
            if (data)
                is;
            Class;
            data = new data();
            if (data)
                is;
            ByteArray;
            return data;
        };
        return ParserUtil;
    }());
    feng3d.ParserUtil = ParserUtil;
    return null;
})(feng3d || (feng3d = {}));
toString(data,  * , length, number = 0);
string;
{
    var ba;
    length || ;
    number.MAX_VALUE;
    if (data)
        is;
    string;
    return string(data).substr(0, length);
    ba = toByteArray(data);
    if (ba) {
        ba.position = 0;
        return ba.readUTFBytes(Math.min(ba.bytesAvailable, length));
    }
    return null;
}
var feng3d;
(function (feng3d) {
    /**
     * 解析数据的格式
     */
    var ParserDataFormat = (function () {
        function ParserDataFormat() {
        }
        /**
         * 二进制文件
         */
        ParserDataFormat.BINARY = "binary";
        /**
         * 明文
         */
        ParserDataFormat.PLAIN_TEXT = "plainText";
        return ParserDataFormat;
    }());
    feng3d.ParserDataFormat = ParserDataFormat;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 资源依赖(包含需要加载与处理的资源)
     * @author feng 2014-5-19
     */
    var ResourceDependency = (function () {
        /**
         * 创建资源依赖
         * @param id 编号
         * @param req url请求
         * @param data 数据
         * @param parentParser 被依赖的解析者
         * @param retrieveAsRawData
         * @param suppressAssetEvents
         */
        function ResourceDependency(id, req, data, parentParser, retrieveAsRawData, suppressAssetEvents) {
            if (data === void 0) { data =  * ; }
            if (retrieveAsRawData === void 0) { retrieveAsRawData = false; }
            if (suppressAssetEvents === void 0) { suppressAssetEvents = false; }
            this._data =  * ;
            this._id = id;
            this._req = req;
            this._parentParser = parentParser;
            this._data = data;
            this._retrieveAsRawData = retrieveAsRawData;
            this._suppressAssetEvents = suppressAssetEvents;
            this._assets = new IAsset[]();
            this._dependencies = new ResourceDependency[]();
        }
        Object.defineProperty(ResourceDependency.prototype, "id", {
            get: function () {
                return _id;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ResourceDependency.prototype, "assets", {
            get: function () {
                return _assets;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ResourceDependency.prototype, "dependencies", {
            get: function () {
                return _dependencies;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ResourceDependency.prototype, "request", {
            get: function () {
                return _req;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ResourceDependency.prototype, "retrieveAsRawData", {
            get: function () {
                return _retrieveAsRawData;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ResourceDependency.prototype, "suppresAssetEvents", {
            get: function () {
                return _suppressAssetEvents;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ResourceDependency.prototype, "data", {
            get: function () { },
            enumerable: true,
            configurable: true
        });
        ResourceDependency.prototype. = function () {
            return _data;
        };
        ResourceDependency.prototype.setData = function (data) {
            if (data === void 0) { data =  * ; }
            this._data = data;
        };
        Object.defineProperty(ResourceDependency.prototype, "parentParser", {
            /**
             * 被依赖的解析者
             */
            get: function () {
                return _parentParser;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 解决依赖
         */
        ResourceDependency.prototype.resolve = function () {
            if (this._parentParser)
                this._parentParser.resolveDependency(this);
        };
        /**
         * 解决失败
         */
        ResourceDependency.prototype.resolveFailure = function () {
            if (this._parentParser)
                this._parentParser.resolveDependencyFailure(this);
        };
        /**
         * 解决资源的名称
         */
        ResourceDependency.prototype.resolveName = function (asset) {
            if (this._parentParser)
                return this._parentParser.resolveDependencyName(this, asset);
            return asset.namedAsset.name;
        };
        return ResourceDependency;
    }());
    feng3d.ResourceDependency = ResourceDependency;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 单条线段数据
     * @author feng 2014-4-9
     */
    var Segment = (function () {
        /**
         * 创建一条线段数据
         * @param start 起点坐标
         * @param end 终点坐标
         * @param colorStart 起点颜色
         * @param colorEnd 终点颜色
         * @param thickness 线段厚度
         */
        function Segment(start, end, colorStart, colorEnd, thickness) {
            if (colorStart === void 0) { colorStart = 0x333333; }
            if (colorEnd === void 0) { colorEnd = 0x333333; }
            if (thickness === void 0) { thickness = 1; }
            this._thickness = thickness * .5;
            this._start = start;
            this._end = end;
            this.startColor = colorStart;
            this.endColor = colorEnd;
        }
        /**
         * 更新线段信息
         * @param start 起点坐标
         * @param end 终点坐标
         * @param colorStart 起点颜色
         * @param colorEnd 终点颜色
         * @param thickness 线段厚度
         */
        Segment.prototype.updateSegment = function (start, end, colorStart, colorEnd, thickness) {
            if (colorStart === void 0) { colorStart = 0x333333; }
            if (colorEnd === void 0) { colorEnd = 0x333333; }
            if (thickness === void 0) { thickness = 1; }
            this._start = start;
            this._end = end;
            if (this._startColor != colorStart)
                this.startColor = colorStart;
            if (this._endColor != colorEnd)
                this.endColor = colorEnd;
            this._thickness = thickness * .5;
        };
        Object.defineProperty(Segment.prototype, "start", {
            /**
             * 起点坐标
             */
            get: function () {
                return _start;
            },
            set: function (value) {
                _start = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Segment.prototype, "end", {
            /**
             * 终点坐标
             */
            get: function () {
                return _end;
            },
            set: function (value) {
                _end = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Segment.prototype, "thickness", {
            /**
             * 线段厚度
             */
            get: function () {
                return _thickness * 2;
            },
            set: function (value) {
                _thickness = value * .5;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Segment.prototype, "startColor", {
            /**
             * 起点颜色
             */
            get: function () {
                return _startColor;
            },
            set: function (color) {
                _startR = ((color >> 16) & 0xff) / 255;
                _startG = ((color >> 8) & 0xff) / 255;
                _startB = (color & 0xff) / 255;
                _startColor = color;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Segment.prototype, "endColor", {
            /**
             * 终点颜色
             */
            get: function () {
                return _endColor;
            },
            set: function (color) {
                _endR = ((color >> 16) & 0xff) / 255;
                _endG = ((color >> 8) & 0xff) / 255;
                _endB = (color & 0xff) / 255;
                _endColor = color;
            },
            enumerable: true,
            configurable: true
        });
        Segment.prototype.dispose = function () {
            this._start = null;
            this._end = null;
        };
        Object.defineProperty(Segment.prototype, "startR", {
            get: function () {
                return _startR;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Segment.prototype, "startG", {
            get: function () {
                return _startG;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Segment.prototype, "startB", {
            get: function () {
                return _startB;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Segment.prototype, "endR", {
            get: function () {
                return _endR;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Segment.prototype, "endG", {
            get: function () {
                return _endG;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Segment.prototype, "endB", {
            get: function () {
                return _endB;
            },
            enumerable: true,
            configurable: true
        });
        return Segment;
    }());
    feng3d.Segment = Segment;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * A Line Segment primitive.
     */
    var LineSegment = (function (_super) {
        __extends(LineSegment, _super);
        /**
         * Create a line segment
         * @param v0 Start position of the line segment
         * @param v1 Ending position of the line segment
         * @param color0 Starting color of the line segment
         * @param color1 Ending colour of the line segment
         * @param thickness Thickness of the line
         */
        function LineSegment(v0, v1, color0, color1, thickness) {
            if (color0 === void 0) { color0 = 0x333333; }
            if (color1 === void 0) { color1 = 0x333333; }
            if (thickness === void 0) { thickness = 1; }
            _super.call(this, v0, v1, color0, color1, thickness);
            this.TYPE = "line";
        }
        return LineSegment;
    }(feng3d.Segment));
    feng3d.LineSegment = LineSegment;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 测试基类
     * @author feng 2014-4-9
     */
    var TestBase = (function (_super) {
        __extends(TestBase, _super);
        function TestBase() {
            this.rootPaths = [
                "http://127.0.0.1:9080/",
                "http://images.feng3d.me/feng3dDemo/assets/",
            ];
            //资源根路径
            this.rootPath = "http://127.0.0.1:9080/";
            this.initModules();
            this.tryConnect();
        }
        TestBase.prototype.initModules = function () {
            feng3d.Task.init();
            feng3d.Load.init();
        };
        TestBase.prototype.tryConnect = function () {
            var tryRootPath = new feng3d.TryConnectURL();
            tryRootPath.addEventListener(feng3d.TaskEvent.COMPLETED, this.tryRootPathComplete);
            tryRootPath.tryConnect(this.rootPaths);
        };
        TestBase.prototype.tryRootPathComplete = function (event) {
            var tryConnectURL = event.currentTarget;
            if (tryConnectURL.connectedUrls.length == 0) {
                trace("没有可连接的资源路径！");
            }
            else {
                trace("以下为可连接的资源路径：");
                trace(tryConnectURL.connectedUrls);
                this.rootPath = tryConnectURL.connectedUrls[0];
                this.loadTextures();
            }
        };
        /**
         * 加载纹理资源
         */
        TestBase.prototype.loadTextures = function () {
            this.resourceDic = {};
            //加载资源
            var loadObj = new feng3d.LoadModuleEventData();
            loadObj.urls = [];
            for (var i = 0; this.resourceList != null && i < this.resourceList.length; i++) {
                if (this.resourceList[i])
                    is;
                string;
                {
                    loadObj.urls.push(this.rootPath + this.resourceList[i]);
                }
            }
        };
        return TestBase;
    }(Sprite));
    feng3d.TestBase = TestBase;
    {
        this.resourceList[i].url = this.rootPath + this.resourceList[i].url;
        loadObj.urls.push(this.resourceList[i]);
    }
})(feng3d || (feng3d = {}));
loadObj.addEventListener(LoadUrlEvent.LOAD_SINGLE_COMPLETE, this.singleGeometryComplete);
loadObj.addEventListener(LoadUrlEvent.LOAD_COMPLETE, this.allItemsLoaded);
GlobalDispatcher.instance.dispatchEvent(new LoadModuleEvent(LoadModuleEvent.LOAD_RESOURCE, loadObj));
singleGeometryComplete(evnet, LoadUrlEvent);
{
    var path = evnet.loadTaskItem.url;
    path = path.substr(this.rootPath.length);
    this.resourceDic[path] = evnet.loadTaskItem.loadingItem.content;
}
allItemsLoaded(event, LoadUrlEvent);
{
    //配置3d缓存编号
    FagalRE.addBufferID(Context3DBufferIDConfig.bufferIdConfigs);
    this["init"]();
}
var feng3d;
(function (feng3d) {
    /**
     * 粒子几何体帮助类
     */
    var ParticleGeometryHelper = (function () {
        function ParticleGeometryHelper() {
        }
        /**
         * 创建一个粒子几何体
         * @param geometries 单个粒子几何体列表
         * @param transforms
         * @return 粒子几何体
         */
        ParticleGeometryHelper.generateGeometry = function (geometries) {
            var particleGeometry = new feng3d.ParticleGeometry();
            /** 粒子数量 */
            var numParticles = particleGeometry.numParticles = geometries.length;
            /** 粒子数据 */
            var particles = particleGeometry.particles = new feng3d.ParticleData[](numParticles, true);
            /** 当前粒子子几何体 */
            var particleSubGeometry = createParticleSubGeometry();
            particleGeometry.addSubGeometry(particleSubGeometry);
            //单个粒子几何体
            var sourceGeometry;
            /** 单个粒子子几何体列表 */
            var sourceSubGeometries;
            /** 单个粒子的子几何体 */
            var sourceSubGeometry;
            /** 单个粒子子几何体数 */
            var numSubGeometries;
            /** 单个粒子子几何体索引 */
            var srcIndex = 0;
            /** 粒子索引 */
            var i;
            //遍历粒子
            for (i = 0; i < numParticles; i++) {
                sourceGeometry = geometries[i];
                if (sourceGeometry.numVertices > MAX_VERTEX)
                    throw new Error("不支持顶点数大于" + MAX_VERTEX + "的粒子");
                sourceSubGeometries = geometries[i].subGeometries;
                numSubGeometries = sourceSubGeometries.length;
                //判断 当前单个粒子子网格 是否会使当前粒子子几何体顶点数量超出最大值 ,如果超出就创建一个新的粒子子几何体
                if (sourceGeometry.numVertices + particleSubGeometry.numVertices > MAX_VERTEX) {
                    particleSubGeometry = createParticleSubGeometry();
                    particleGeometry.addSubGeometry(particleSubGeometry);
                }
                //收集粒子数据
                var particleData = new feng3d.ParticleData();
                particleData.numVertices = sourceGeometry.numVertices;
                particleData.startVertexIndex = particleSubGeometry.numVertices;
                particleData.subGeometry = particleSubGeometry;
                particles[i] = particleData;
                //遍历单个粒子的子几何体
                for (srcIndex = 0; srcIndex < numSubGeometries; srcIndex++) {
                    //设置当前单个粒子子网格
                    sourceSubGeometry = sourceSubGeometries[srcIndex];
                    //添加 单个粒子的子几何体 到  当前粒子子几何体
                    feng3d.GeomUtil.addSubGeometry(sourceSubGeometry, particleSubGeometry);
                }
            }
            return particleGeometry;
        };
        ParticleGeometryHelper.createParticleSubGeometry = function () {
            /** 当前粒子子几何体 */
            var particleSubGeometry = new feng3d.SubGeometry();
            particleSubGeometry.updateIndexData(new number[]());
            return particleSubGeometry;
        };
        /** stage3d单次渲染支持的最大顶点数 */
        ParticleGeometryHelper.MAX_VERTEX = 65535;
        return ParticleGeometryHelper;
    }());
    feng3d.ParticleGeometryHelper = ParticleGeometryHelper;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * sprite动画剪辑节帮助程序
     * @author feng 2015-9-18
     */
    var SpriteSheetHelper = (function () {
        function SpriteSheetHelper() {
        }
        return SpriteSheetHelper;
    }());
    feng3d.SpriteSheetHelper = SpriteSheetHelper;
    /**
     * 创建sprite动画剪辑节帮助程序实例
     */
    function SpriteSheetHelper() {
    }
    generateFromMovieClip(sourceMC, MovieClip, cols, number, rows, number, width, number, height, number, transparent, boolean = false, backgroundColor, number = 0);
    feng3d.Texture2DBase[];
    {
        var spriteSheets = new feng3d.Texture2DBase[]();
        var framesCount = sourceMC.totalFrames;
        var i = framesCount;
        var w = width;
        var h = height;
        if (!feng3d.TextureUtils.isPowerOfTwo(w))
            w = feng3d.TextureUtils.getBestPowerOf2(w);
        if (!feng3d.TextureUtils.isPowerOfTwo(h))
            h = feng3d.TextureUtils.getBestPowerOf2(h);
        var spriteSheet;
        var destCellW = Math.round(h / cols);
        var destCellH = Math.round(w / rows);
        //var cellRect:Rectangle = new Rectangle(0, 0, destCellW, destCellH);
        var mcFrameW = sourceMC.width;
        var mcFrameH = sourceMC.height;
        var sclw = destCellW / mcFrameW;
        var sclh = destCellH / mcFrameH;
        var t = new Matrix();
        t.scale(sclw, sclh);
        var tmpCache = new BitmapData(mcFrameW * sclw, mcFrameH * sclh, transparent, transparent ? 0x00FFFFFF : backgroundColor);
        var u, v;
        var cellsPerMap = cols * rows;
        var maps = framesCount / cellsPerMap;
        if (maps < framesCount / cellsPerMap)
            maps++;
        var pastePoint = new Point();
        var frameNum = 0;
        var bitmapTexture;
        while (maps--) {
            u = v = 0;
            spriteSheet = new BitmapData(w, h, transparent, transparent ? 0x00FFFFFF : backgroundColor);
            for (i = 0; i < cellsPerMap; i++) {
                frameNum++;
                if (frameNum <= framesCount) {
                    pastePoint.x = Math.round(destCellW * u);
                    pastePoint.y = Math.round(destCellH * v);
                    sourceMC.gotoAndStop(frameNum);
                    tmpCache.draw(sourceMC, t, null, "normal", tmpCache.rect, true);
                    spriteSheet.copyPixels(tmpCache, tmpCache.rect, pastePoint);
                    if (transparent)
                        tmpCache.fillRect(tmpCache.rect, 0x00FFFFFF);
                    u++;
                    if (u == cols) {
                        u = 0;
                        v++;
                    }
                }
                else
                    break;
            }
            bitmapTexture = new feng3d.BitmapTexture(spriteSheet);
            spriteSheets.push(bitmapTexture);
        }
        tmpCache.dispose();
        return spriteSheets;
    }
    generateSpriteSheetClipNode(animID, string, cols, number, rows, number, mapCount, number = 1, from, number = 0, to, number = 0);
    SpriteSheetClipNode;
    {
        var spriteSheetClipNode = new SpriteSheetClipNode();
        spriteSheetClipNode.name = animID;
        var u, v;
        var framesCount = cols * rows;
        if (mapCount < 1)
            mapCount = 1;
        if (to == 0 || to < from || to > framesCount * mapCount)
            to = cols * rows * mapCount;
        if (from > to)
            throw new Error("Param 'from' must be lower than the 'to' param.");
        var scaleV = 1 / rows;
        var scaleU = 1 / cols;
        var frame;
        var i, j;
        var animFrames = 0;
        for (i = 0; i < mapCount; ++i) {
            u = v = 0;
            for (j = 0; j < framesCount; ++j) {
                if (animFrames >= from && animFrames < to) {
                    frame = new SpriteSheetAnimationFrame();
                    frame.offsetU = scaleU * u;
                    frame.offsetV = scaleV * v;
                    frame.scaleU = scaleU;
                    frame.scaleV = scaleV;
                    frame.mapID = i;
                    spriteSheetClipNode.addFrame(frame, 16);
                }
                if (animFrames == to)
                    return spriteSheetClipNode;
                animFrames++;
                u++;
                if (u == cols) {
                    u = 0;
                    v++;
                }
            }
        }
        return spriteSheetClipNode;
    }
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * Helper Class to retrieve objects bounds <code>Bounds</code>
     */
    var Bounds = (function () {
        function Bounds() {
        }
        /**
         * Calculate the bounds of a Mesh object
         * @param mesh        Mesh. The Mesh to get the bounds from.
         * Use the getters of this class to retrieve the results
         */
        Bounds.getMeshBounds = function (mesh) {
            getObjectContainerBounds(mesh);
        };
        /**
         * Calculate the bounds of an ObjectContainer3D object
         * @param container        ObjectContainer3D. The ObjectContainer3D to get the bounds from.
         * Use the getters of this class to retrieve the results
         */
        Bounds.getObjectContainerBounds = function (container, worldBased) {
            if (worldBased === void 0) { worldBased = true; }
            reset();
            parseObjectContainerBounds(container);
            if (isInfinite(_minX) || isInfinite(_minY) || isInfinite(_minZ) || isInfinite(_maxX) || isInfinite(_maxY) || isInfinite(_maxZ)) {
                return;
            }
            // Transform min/max values to the scene if required
            if (worldBased) {
                var b = number[]([Infinity, Infinity, Infinity, -Infinity, -Infinity, -Infinity]);
                var c = getBoundsCorners(_minX, _minY, _minZ, _maxX, _maxY, _maxZ);
                transformContainer(b, c, container.sceneTransform);
                _minX = b[0];
                _minY = b[1];
                _minZ = b[2];
                _maxX = b[3];
                _maxY = b[4];
                _maxZ = b[5];
            }
        };
        /**
         * Calculate the bounds from a vector of number representing the vertices. &lt;x,y,z,x,y,z.....&gt;
         * @param vertices        Vector.&lt;number&gt;. The vertices to get the bounds from.
         * Use the getters of this class to retrieve the results
         */
        Bounds.getVerticesVectorBounds = function (vertices) {
            reset();
            var l = vertices.length;
            if (l % 3 != 0)
                return;
            var x;
            var y;
            var z;
            for (var i = 0; i < l; i += 3) {
                x = vertices[i];
                y = vertices[i + 1];
                z = vertices[i + 2];
                if (x < _minX)
                    _minX = x;
                if (x > _maxX)
                    _maxX = x;
                if (y < _minY)
                    _minY = y;
                if (y > _maxY)
                    _maxY = y;
                if (z < _minZ)
                    _minZ = z;
                if (z > _maxZ)
                    _maxZ = z;
            }
        };
        /**
         * @param outCenter        Vector3D. Optional Vector3D, if provided the same Vector3D is returned with the bounds center.
         * @return the center of the bound
         */
        Bounds.getCenter = function (outCenter) {
            if (outCenter === void 0) { outCenter = null; }
            var center = outCenter || new Vector3D();
            center.x = _minX + (_maxX - _minX) * .5;
            center.y = _minY + (_maxY - _minY) * .5;
            center.z = _minZ + (_maxZ - _minZ) * .5;
            return center;
        };
        Object.defineProperty(Bounds, "minX", {
            /**
             * @return the smalest x value
             */
            get: function () {
                return _minX;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Bounds, "minY", {
            /**
             * @return the smalest y value
             */
            get: function () {
                return _minY;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Bounds, "minZ", {
            /**
             * @return the smalest z value
             */
            get: function () {
                return _minZ;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Bounds, "maxX", {
            /**
             * @return the biggest x value
             */
            get: function () {
                return _maxX;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Bounds, "maxY", {
            /**
             * @return the biggest y value
             */
            get: function () {
                return _maxY;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Bounds, "maxZ", {
            /**
             * @return the biggest z value
             */
            get: function () {
                return _maxZ;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Bounds, "width", {
            /**
             * @return the width value from the bounds
             */
            get: function () {
                return _maxX - _minX;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Bounds, "height", {
            /**
             * @return the height value from the bounds
             */
            get: function () {
                return _maxY - _minY;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Bounds, "depth", {
            /**
             * @return the depth value from the bounds
             */
            get: function () {
                return _maxZ - _minZ;
            },
            enumerable: true,
            configurable: true
        });
        Bounds._defaultPosition = new Vector3D(0.0, 0.0, 0.0);
        Bounds.function = reset();
        return Bounds;
    }());
    feng3d.Bounds = Bounds;
    {
        _containers = {};
        _minX = _minY = _minZ = Infinity;
        _maxX = _maxY = _maxZ = -Infinity;
        _defaultPosition.x = 0.0;
        _defaultPosition.y = 0.0;
        _defaultPosition.z = 0.0;
    }
    function parseObjectContainerBounds(obj, parentTransform) {
        if (parentTransform === void 0) { parentTransform = null; }
        if (!obj.visible)
            return;
        var containerBounds = _containers[obj] || , number = []([Infinity, Infinity, Infinity, -Infinity, -Infinity, -Infinity]);
        var child;
        var isEntity = obj;
        var containerTransform = new Matrix3D();
        if (isEntity && parentTransform) {
            parseObjectBounds(obj, parentTransform);
            containerTransform = obj.transform3D.transform.clone();
            if (parentTransform)
                containerTransform.append(parentTransform);
        }
        else if (isEntity && !parentTransform) {
            var mat = obj.transform3D.transform.clone();
            mat.invert();
            parseObjectBounds(obj, mat);
        }
        for (var i = 0; i < obj.numChildren; ++i) {
            child = obj.getChildAt(i);
            parseObjectContainerBounds(child, containerTransform);
        }
        var parentBounds = _containers[obj.parent];
        if (!isEntity && parentTransform)
            parseObjectBounds(obj, parentTransform, true);
        if (parentBounds) {
            parentBounds[0] = Math.min(parentBounds[0], containerBounds[0]);
            parentBounds[1] = Math.min(parentBounds[1], containerBounds[1]);
            parentBounds[2] = Math.min(parentBounds[2], containerBounds[2]);
            parentBounds[3] = Math.max(parentBounds[3], containerBounds[3]);
            parentBounds[4] = Math.max(parentBounds[4], containerBounds[4]);
            parentBounds[5] = Math.max(parentBounds[5], containerBounds[5]);
        }
        else {
            _minX = containerBounds[0];
            _minY = containerBounds[1];
            _minZ = containerBounds[2];
            _maxX = containerBounds[3];
            _maxY = containerBounds[4];
            _maxZ = containerBounds[5];
        }
    }
    function isInfinite(value) {
        return value == number.POSITIVE_INFINITY || value == number.NEGATIVE_INFINITY;
    }
    function parseObjectBounds(oC, parentTransform, resetBounds) {
        if (parentTransform === void 0) { parentTransform = null; }
        if (resetBounds === void 0) { resetBounds = false; }
        if (oC)
            is;
        feng3d.LightBase;
        return;
        var e = oC;
        var corners;
        var mat = oC.transform3D.transform.clone();
        var cB = _containers[oC];
        if (e) {
            if (isInfinite(e.minX) || isInfinite(e.minY) || isInfinite(e.minZ) || isInfinite(e.maxX) || isInfinite(e.maxY) || isInfinite(e.maxZ)) {
                return;
            }
            corners = getBoundsCorners(e.minX, e.minY, e.minZ, e.maxX, e.maxY, e.maxZ);
            if (parentTransform)
                mat.append(parentTransform);
        }
        else {
            corners = getBoundsCorners(cB[0], cB[1], cB[2], cB[3], cB[4], cB[5]);
            if (parentTransform)
                mat.prepend(parentTransform);
        }
        if (resetBounds) {
            cB[0] = cB[1] = cB[2] = Infinity;
            cB[3] = cB[4] = cB[5] = -Infinity;
        }
        transformContainer(cB, corners, mat);
    }
    function getBoundsCorners(minX, minY, minZ, maxX, maxY, maxZ) {
        return number[]([minX, minY, minZ, minX, minY, maxZ, minX, maxY, minZ, minX, maxY, maxZ, maxX, minY, minZ, maxX, minY, maxZ, maxX, maxY, minZ, maxX, maxY, maxZ]);
    }
    function transformContainer(bounds, corners, matrix) {
        matrix.transformVectors(corners, corners);
        var x;
        var y;
        var z;
        var pCtr = 0;
        while (pCtr < corners.length) {
            x = corners[pCtr++];
            y = corners[pCtr++];
            z = corners[pCtr++];
            if (x < bounds[0])
                bounds[0] = x;
            if (x > bounds[3])
                bounds[3] = x;
            if (y < bounds[1])
                bounds[1] = y;
            if (y > bounds[4])
                bounds[4] = y;
            if (z < bounds[2])
                bounds[2] = z;
            if (z > bounds[5])
                bounds[5] = z;
        }
    }
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 资源处理
     * @author feng 2014-3-24
     */
    var Cast = (function () {
        function Cast() {
        }
        /**
         * 获取类定义
         * @param name		类描述字符串
         * @return			类定义
         */
        Cast.tryClass = function (name) {
            if (_notClasses[name])
                return name;
            var result = _classes[name];
            if (result != null)
                return result;
            try {
                result = getDefinitionByName(name);
                _classes[name] = result;
                return result;
            }
            catch (error) {
            }
            _notClasses[name] = true;
            return name;
        };
        /**
         * 转换位图数据
         * @param data		位图数据
         * @return 			位图数据
         */
        Cast.bitmapData = function (data) {
            if (data === void 0) { data =  * ; }
            if (data == null)
                return null;
            if (data)
                is;
            string;
            data = tryClass(data);
            if (data)
                is;
            Class;
            {
                try {
                    data = new data;
                }
                catch (bitmapError) {
                    data = new data(0, 0);
                }
            }
            if (data)
                is;
            BitmapData;
            return data;
            if (data)
                is;
            Bitmap;
            {
                if (data.hasOwnProperty("bitmapData"))
                    return data.bitmapData;
            }
            if (data)
                is;
            DisplayObject;
            {
                var ds = data;
                var bmd = new BitmapData(ds.width, ds.height, true, 0x00FFFFFF);
                var mat = ds.transform.matrix.clone();
                mat.tx = 0;
                mat.ty = 0;
                bmd.draw(ds, mat, ds.transform.colorTransform, ds.blendMode, bmd.rect, true);
                return bmd;
            }
            throw new Error("Can't cast to BitmapData: " + data);
        };
        /**
         * 转换位图纹理
         * @param data		位图数据
         * @return 			位图纹理
         */
        Cast.bitmapTexture = function (data) {
            if (data === void 0) { data =  * ; }
            if (data == null)
                return null;
            if (data)
                is;
            string;
            data = tryClass(data);
            if (data)
                is;
            Class;
            {
                try {
                    data = new data;
                }
                catch (materialError) {
                    data = new data(0, 0);
                }
            }
            if (data)
                is;
            Texture;
            return data;
            try {
                var bmd = Cast.bitmapData(data);
                return new feng3d.BitmapTexture(bmd);
            }
            catch (error) {
            }
            throw new Error("Can't cast to BitmapTexture: " + data);
        };
        Cast._notClasses = {};
        Cast._classes = {};
        return Cast;
    }());
    feng3d.Cast = Cast;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     *
     * @author feng 2015-4-28
     */
    var ColliderUtils = (function () {
        function ColliderUtils() {
        }
        /**
         * 射线与三角形碰撞
         * @param rayPosition		射线顶点
         * @param rayDirection		射线方向
         * @param p0				三角形顶点0
         * @param p1				三角形顶点1
         * @param p2				三角形顶点2
         * @return					交点
         */
        ColliderUtils.rayTriangleCollision = function (rayPosition, rayDirection, p0, p1, p2) {
            var t;
            var rx, ry, rz;
            var nx, ny, nz;
            var cx, cy, cz;
            var coeff, u, v, w;
            var p0x, p0y, p0z;
            var p1x, p1y, p1z;
            var p2x, p2y, p2z;
            var s0x, s0y, s0z;
            var s1x, s1y, s1z;
            var nl, nDotV, D, disToPlane;
            var Q1Q2, Q1Q1, Q2Q2, RQ1, RQ2;
            //三角形三个顶点数据
            p0x = p0.x;
            p0y = p0.y;
            p0z = p0.z;
            p1x = p1.x;
            p1y = p1.y;
            p1z = p1.z;
            p2x = p2.x;
            p2y = p2.y;
            p2z = p2.z;
            //计算出三角面的法线
            s0x = p1x - p0x; // s0 = p1 - p0
            s0y = p1y - p0y;
            s0z = p1z - p0z;
            s1x = p2x - p0x; // s1 = p2 - p0
            s1y = p2y - p0y;
            s1z = p2z - p0z;
            nx = s0y * s1z - s0z * s1y; // n = s0 x s1
            ny = s0z * s1x - s0x * s1z;
            nz = s0x * s1y - s0y * s1x;
            nl = 1 / Math.sqrt(nx * nx + ny * ny + nz * nz); // normalize n
            nx *= nl;
            ny *= nl;
            nz *= nl;
            //计算射线与法线的点积，小于零表示射线所在直线与三角面相交
            nDotV = nx * rayDirection.x + ny * +rayDirection.y + nz * rayDirection.z; // rayDirection . normal
            //判断射线所在直线是否与三角面相交
            if (nDotV != 0.0) {
                //计算平面方程D值，参考Plane3D
                D = -(nx * p0x + ny * p0y + nz * p0z);
                //射线点到平面的距离
                disToPlane = -(nx * rayPosition.x + ny * rayPosition.y + nz * rayPosition.z + D);
                t = disToPlane / nDotV;
                //得到交点
                cx = rayPosition.x + t * rayDirection.x;
                cy = rayPosition.y + t * rayDirection.y;
                cz = rayPosition.z + t * rayDirection.z;
                //判断交点是否在三角形内( using barycentric coordinates )
                Q1Q2 = s0x * s1x + s0y * s1y + s0z * s1z;
                Q1Q1 = s0x * s0x + s0y * s0y + s0z * s0z;
                Q2Q2 = s1x * s1x + s1y * s1y + s1z * s1z;
                rx = cx - p0x;
                ry = cy - p0y;
                rz = cz - p0z;
                RQ1 = rx * s0x + ry * s0y + rz * s0z;
                RQ2 = rx * s1x + ry * s1y + rz * s1z;
                coeff = 1 / (Q1Q1 * Q2Q2 - Q1Q2 * Q1Q2);
                v = coeff * (Q2Q2 * RQ1 - Q1Q2 * RQ2);
                w = coeff * (-Q1Q2 * RQ1 + Q1Q1 * RQ2);
                if (v < 0)
                    return null;
                if (w < 0)
                    return null;
                u = 1 - v - w;
                //u v w都大于0表示点在三角形内 射线的坐标t大于0表示射线朝向三角面
                if (u >= 0 && t > 0) {
                    return new Vector3D(cx, cy, cz);
                }
            }
            return null;
        };
        return ColliderUtils;
    }());
    feng3d.ColliderUtils = ColliderUtils;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var DefaultMaterialManager = (function () {
        function DefaultMaterialManager() {
        }
        DefaultMaterialManager.getDefaultMaterial = function () {
            if (!_defaultTexture)
                createDefaultTexture();
            if (!_defaultMaterial)
                createDefaultMaterial();
            return _defaultMaterial;
        };
        DefaultMaterialManager.getDefaultTexture = function () {
            if (!_defaultTexture)
                createDefaultTexture();
            return _defaultTexture;
        };
        DefaultMaterialManager.function = createDefaultTexture(color, number = 0XFFFFFF);
        return DefaultMaterialManager;
    }());
    feng3d.DefaultMaterialManager = DefaultMaterialManager;
    {
        _defaultTextureBitmapData = new BitmapData(8, 8, false, 0x0);
        //create chekerboard
        var i, j;
        for (i = 0; i < 8; i++) {
            for (j = 0; j < 8; j++) {
                if ((j & 1) ^ (i & 1))
                    _defaultTextureBitmapData.setPixel(i, j, 0XFFFFFF);
            }
        }
        _defaultTexture = new feng3d.BitmapTexture(_defaultTextureBitmapData);
    }
    function createDefaultMaterial() {
        _defaultMaterial = new feng3d.TextureMaterial(_defaultTexture);
        _defaultMaterial.mipmap = false;
        _defaultMaterial.smooth = false;
    }
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     *
     * @author feng 2014-5-19
     */
    var GeomUtil = (function () {
        function GeomUtil() {
        }
        /**
         * 根据数据数组创建子网格
         * @param verts
         * @param indices
         * @param uvs
         * @param normals
         * @param tangents
         * @param weights
         * @param jointIndices
         * @param triangleOffset
         * @return
         */
        GeomUtil.fromVectors = function (verts, indices, uvs, weights, jointIndices, triangleOffset) {
            if (triangleOffset === void 0) { triangleOffset = 0; }
            LIMIT_VERTS: number = 3 * 0xffff;
            LIMIT_INDICES: number = 15 * 0xffff;
            var subs = new feng3d.SubGeometry[]();
            if (uvs && !uvs.length)
                uvs = null;
            if (weights && !weights.length)
                weights = null;
            if (jointIndices && !jointIndices.length)
                jointIndices = null;
            if ((indices.length >= LIMIT_INDICES) || (verts.length >= LIMIT_VERTS)) {
                var i, len, outIndex, j;
                var splitVerts = new number[]();
                var splitIndices = new number[]();
                var splitUvs = (uvs != null) ? new number[]() : null;
                var splitWeights = (weights != null) ? new number[]() : null;
                var splitJointIndices = (jointIndices != null) ? new number[]() : null;
                var mappings = new number[](verts.length / 3, true);
                i = mappings.length;
                while (i-- > 0)
                    mappings[i] = -1;
                var originalIndex;
                var splitIndex;
                var o0, o1, o2, s0, s1, s2, su, ou, sv, ov;
                // Loop over all triangles
                outIndex = 0;
                len = indices.length;
                for (i = 0; i < len; i += 3) {
                    splitIndex = splitVerts.length + 6;
                    if (((outIndex + 2) >= LIMIT_INDICES) || (splitIndex >= LIMIT_VERTS)) {
                        subs.push(constructSubGeometry(splitVerts, splitIndices, splitUvs, splitWeights, splitJointIndices, triangleOffset));
                        splitVerts = new number[]();
                        splitIndices = new number[]();
                        splitUvs = (uvs != null) ? new number[]() : null;
                        splitWeights = (weights != null) ? new number[]() : null;
                        splitJointIndices = (jointIndices != null) ? new number[]() : null;
                        splitIndex = 0;
                        j = mappings.length;
                        while (j-- > 0)
                            mappings[j] = -1;
                        outIndex = 0;
                    }
                    // Loop over all vertices in triangle
                    for (j = 0; j < 3; j++) {
                        originalIndex = indices[i + j];
                        if (mappings[originalIndex] >= 0)
                            splitIndex = mappings[originalIndex];
                        else {
                            o0 = originalIndex * 3 + 0;
                            o1 = originalIndex * 3 + 1;
                            o2 = originalIndex * 3 + 2;
                            // This vertex does not yet exist in the split list and
                            // needs to be copied from the long list.
                            splitIndex = splitVerts.length / 3;
                            s0 = splitIndex * 3 + 0;
                            s1 = splitIndex * 3 + 1;
                            s2 = splitIndex * 3 + 2;
                            splitVerts[s0] = verts[o0];
                            splitVerts[s1] = verts[o1];
                            splitVerts[s2] = verts[o2];
                            if (uvs) {
                                su = splitIndex * 2 + 0;
                                sv = splitIndex * 2 + 1;
                                ou = originalIndex * 2 + 0;
                                ov = originalIndex * 2 + 1;
                                splitUvs[su] = uvs[ou];
                                splitUvs[sv] = uvs[ov];
                            }
                            if (weights) {
                                splitWeights[s0] = weights[o0];
                                splitWeights[s1] = weights[o1];
                                splitWeights[s2] = weights[o2];
                            }
                            if (jointIndices) {
                                splitJointIndices[s0] = jointIndices[o0];
                                splitJointIndices[s1] = jointIndices[o1];
                                splitJointIndices[s2] = jointIndices[o2];
                            }
                            mappings[originalIndex] = splitIndex;
                        }
                        // Store new index, which may have come from the mapping look-up,
                        // or from copying a new set of vertex data from the original vector
                        splitIndices[outIndex + j] = splitIndex;
                    }
                    outIndex += 3;
                }
                if (splitVerts.length > 0) {
                    // More was added in the last iteration of the loop.
                    subs.push(constructSubGeometry(splitVerts, splitIndices, splitUvs, splitWeights, splitJointIndices, triangleOffset));
                }
            }
            else
                subs.push(constructSubGeometry(verts, indices, uvs, weights, jointIndices, triangleOffset));
            return subs;
        };
        GeomUtil.constructSubGeometry = function (verts, indices, uvs, weights, jointIndices, triangleOffset) {
            var sub = new feng3d.SubGeometry();
            if (weights && jointIndices) {
                // If there were weights and joint indices defined, this
                // is a skinned mesh and needs to be built from skinned
                // sub-geometries.
                var skinnedSubGeometry = new feng3d.SkinnedSubGeometry(weights.length / (verts.length / 3));
                sub.addComponent(skinnedSubGeometry);
                skinnedSubGeometry.updateJointWeightsData(weights);
                skinnedSubGeometry.updateJointIndexData(jointIndices);
            }
            else
                sub = new feng3d.SubGeometry();
            sub.numVertices = verts.length / 3;
            sub.updateIndexData(indices);
            sub.fromVectors(verts, uvs);
            sub.getOrCreateComponentByClass(feng3d.AutoDeriveVertexNormals);
            sub.getOrCreateComponentByClass(feng3d.AutoDeriveVertexTangents);
            return sub;
        };
        /**
         * 拷贝子网格数据
         * @param source 源子网格
         * @param target 目标子网格
         */
        GeomUtil.copyDataSubGeom = function (source, target) {
            target.numVertices = source.numVertices;
            target.updateVertexPositionData(source.vertexPositionData.concat());
            target.updateUVData(source.UVData.concat());
            target.updateIndexData(source.indices.concat());
        };
        /**
         * source添加到target中
         * @param source 源自几何体
         * @param target 目标子几何体
         * @return true：添加成功；false：添加失败，应该是顶点个数超出最大值65535
         */
        GeomUtil.addSubGeometry = function (source, target) {
            if (source.numVertices + target.numVertices > MAX_VERTEX)
                return false;
            //顶点属性编号列表
            var vaIdList = source.vaIdList;
            var vaId;
            /** 顶点数据字典 */
            var sourceVertexDataDic = {};
            var targetVertexDataDic = {};
            for (each(vaId in vaIdList); {
                sourceVertexDataDic: (_a = source.getVAData(vaId), vaId = _a[0], _a),
                assert: function (sourceVertexDataDic) { },
                targetVertexDataDic: (_b = target.getVAData(vaId), vaId = _b[0], _b),
                assert: function (targetVertexDataDic) { }
            }; 
            //添加索引数据
            )
                //添加索引数据
                var indices = feng3d.VectorUtils.add1(source.indices, target.indices, target.numVertices);
            target.updateIndexData(indices);
            //更改顶点数量
            target.numVertices = source.numVertices + target.numVertices;
            var vertexData;
            //添加顶点数据
            for (each(vaId in vaIdList); {
                //
                vertexData: vertexData,
                target: .setVAData(vaId, vertexData)
            }; )
                return true;
            var _a, _b;
        };
        /** stage3d单次渲染支持的最大顶点数 */
        GeomUtil.MAX_VERTEX = 65535;
        return GeomUtil;
    }());
    feng3d.GeomUtil = GeomUtil;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 纹理材质工厂
     * @author feng 2014-7-7
     */
    var MaterialUtils = (function () {
        function MaterialUtils() {
        }
        /**
         * 创建纹理材质
         * @param url		贴图路径
         * @return			纹理材质
         */
        MaterialUtils.createTextureMaterial = function (url) {
            feng3d.Load.init();
            var textureMaterial = new feng3d.TextureMaterial(feng3d.DefaultMaterialManager.getDefaultTexture());
            var loadObj = new feng3d.LoadModuleEventData();
            loadObj.urls = [url];
            loadObj.addEventListener(feng3d.LoadUrlEvent.LOAD_SINGLE_COMPLETE, onLoadSingleComplete);
            loadObj.data = { textureMaterial: textureMaterial };
            dispatcher.dispatchEvent(new feng3d.LoadModuleEvent(feng3d.LoadModuleEvent.LOAD_RESOURCE, loadObj));
            return textureMaterial;
        };
        MaterialUtils.dispatcher = feng3d.GlobalDispatcher.instance;
        MaterialUtils.function = onLoadSingleComplete(event, feng3d.LoadUrlEvent);
        return MaterialUtils;
    }());
    feng3d.MaterialUtils = MaterialUtils;
    {
        var loadData = event.target;
        var textureMaterial = loadData.data.textureMaterial;
        var bitmap = event.loadTaskItem.loadingItem.content;
        textureMaterial.texture = feng3d.Cast.bitmapTexture(bitmap);
    }
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * MipmapGenerator is a helper class that uploads BitmapData to a Texture including mipmap levels.
     */
    var MipmapGenerator = (function () {
        function MipmapGenerator() {
            this.w =  >>= 1;
            this.h =  >>= 1;
            this.width = w > 1 ? w : 1;
            this.height = h > 1 ? h : 1;
        }
        /**
         * Uploads a BitmapData with mip maps to a target Texture object.
         * @param source The source BitmapData to upload.
         * @param target The target Texture to upload to.
         * @param mipmap An optional mip map holder to avoids creating new instances for fe animated materials.
         * @param alpha Indicate whether or not the uploaded bitmapData is transparent.
         */
        MipmapGenerator.generateMipMaps = function (source, target, mipmap, alpha, side) {
            if (mipmap === void 0) { mipmap = null; }
            if (alpha === void 0) { alpha = false; }
            if (side === void 0) { side = -1; }
            var w = source.width, h = source.height;
            var i;
            var regen = mipmap != null;
            mipmap || ;
            new BitmapData(w, h, alpha);
            _rect.width = w;
            _rect.height = h;
            while (w >= 1 || h >= 1) {
                if (alpha)
                    mipmap.fillRect(_rect, 0);
                _matrix.a = _rect.width / source.width;
                _matrix.d = _rect.height / source.height;
                mipmap.draw(source, _matrix, null, null, null, true);
                if (target)
                    is;
                Texture;
                Texture(target).uploadFromBitmapData(mipmap, i++);
            }
        };
        MipmapGenerator.prototype.CubeTexture = ;
        MipmapGenerator._matrix = new Matrix();
        MipmapGenerator._rect = new Rectangle();
        return MipmapGenerator;
    }());
    feng3d.MipmapGenerator = MipmapGenerator;
    if (!regen)
        mipmap.dispose();
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     *
     * @author feng 2014-12-18
     */
    var SubGeomUtil = (function () {
        function SubGeomUtil() {
        }
        /**
         * 更新面法线数据
         * @param _faceNormals
         * @param vertices
         * @param _faceWeights
         * @param _indices
         * @param _useFaceWeights
         * @return
         */
        SubGeomUtil.updateFaceNormals = function (_faceNormals, vertices, _indices) {
            var i, j, k;
            var index;
            var len = _indices.length;
            var x1, x2, x3;
            var y1, y2, y3;
            var z1, z2, z3;
            var dx1, dy1, dz1;
            var dx2, dy2, dz2;
            var cx, cy, cz;
            var d;
            var posStride = 3;
            var posOffset = 0;
            _faceNormals || ;
            new number[](len, true);
            while (i < len) {
                index = posOffset + _indices[i++] * posStride;
                x1 = vertices[index];
                y1 = vertices[index + 1];
                z1 = vertices[index + 2];
                index = posOffset + _indices[i++] * posStride;
                x2 = vertices[index];
                y2 = vertices[index + 1];
                z2 = vertices[index + 2];
                index = posOffset + _indices[i++] * posStride;
                x3 = vertices[index];
                y3 = vertices[index + 1];
                z3 = vertices[index + 2];
                dx1 = x3 - x1;
                dy1 = y3 - y1;
                dz1 = z3 - z1;
                dx2 = x2 - x1;
                dy2 = y2 - y1;
                dz2 = z2 - z1;
                cx = dz1 * dy2 - dy1 * dz2;
                cy = dx1 * dz2 - dz1 * dx2;
                cz = dy1 * dx2 - dx1 * dy2;
                d = Math.sqrt(cx * cx + cy * cy + cz * cz);
                // length of cross product = 2*triangle area
                d = 1 / d;
                _faceNormals[j++] = cx * d;
                _faceNormals[j++] = cy * d;
                _faceNormals[j++] = cz * d;
            }
            return _faceNormals;
        };
        /**
         * 更新面切线数据
         * @param _faceTangents
         * @param vertices
         * @param uvs
         * @param _indices
         * @return
         *
         */
        SubGeomUtil.updateFaceTangents = function (_faceTangents, vertices, uvs, _indices) {
            var i;
            var index1, index2, index3;
            var len = _indices.length;
            var ui, vi;
            var v0;
            var dv1, dv2;
            var denom;
            var x0, y0, z0;
            var dx1, dy1, dz1;
            var dx2, dy2, dz2;
            var cx, cy, cz;
            var posStride = 3;
            var texStride = 2;
            _faceTangents || ;
            new number[](_indices.length, true);
            while (i < len) {
                index1 = _indices[i];
                index2 = _indices[i + 1];
                index3 = _indices[i + 2];
                ui = index1 * texStride + 1;
                v0 = uvs[ui];
                ui = index2 * texStride + 1;
                dv1 = uvs[ui] - v0;
                ui = index3 * texStride + 1;
                dv2 = uvs[ui] - v0;
                vi = index1 * posStride;
                x0 = vertices[vi];
                y0 = vertices[number(vi + 1)];
                z0 = vertices[number(vi + 2)];
                vi = index2 * posStride;
                dx1 = vertices[number(vi)] - x0;
                dy1 = vertices[number(vi + 1)] - y0;
                dz1 = vertices[number(vi + 2)] - z0;
                vi = index3 * posStride;
                dx2 = vertices[number(vi)] - x0;
                dy2 = vertices[number(vi + 1)] - y0;
                dz2 = vertices[number(vi + 2)] - z0;
                cx = dv2 * dx1 - dv1 * dx2;
                cy = dv2 * dy1 - dv1 * dy2;
                cz = dv2 * dz1 - dv1 * dz2;
                denom = 1 / Math.sqrt(cx * cx + cy * cy + cz * cz);
                _faceTangents[i++] = denom * cx;
                _faceTangents[i++] = denom * cy;
                _faceTangents[i++] = denom * cz;
            }
            return _faceTangents;
        };
        /**
         * 计算顶点法线数据
         * @param target
         * @param _faceNormals
         * @param _faceWeights
         * @param _indices
         * @param numVertices
         * @param _useFaceWeights
         * @return
         */
        SubGeomUtil.updateVertexNormals = function (target, _faceNormals, _indices, numVertices) {
            var v1;
            var f1 = 0, f2 = 1, f3 = 2;
            var lenV = numVertices * 3;
            var normalStride = 3;
            target || ;
            new number[](lenV, true);
            v1 = 0;
            while (v1 < lenV) {
                target[v1] = 0.0;
                target[v1 + 1] = 0.0;
                target[v1 + 2] = 0.0;
                v1 += normalStride;
            }
            var i, k;
            var lenI = _indices.length;
            var index;
            while (i < lenI) {
                index = _indices[i++] * normalStride;
                target[index++] += _faceNormals[f1];
                target[index++] += _faceNormals[f2];
                target[index] += _faceNormals[f3];
                index = _indices[i++] * normalStride;
                target[index++] += _faceNormals[f1];
                target[index++] += _faceNormals[f2];
                target[index] += _faceNormals[f3];
                index = _indices[i++] * normalStride;
                target[index++] += _faceNormals[f1];
                target[index++] += _faceNormals[f2];
                target[index] += _faceNormals[f3];
                f1 += 3;
                f2 += 3;
                f3 += 3;
            }
            v1 = 0;
            while (v1 < lenV) {
                var vx = target[v1];
                var vy = target[v1 + 1];
                var vz = target[v1 + 2];
                var d = 1.0 / Math.sqrt(vx * vx + vy * vy + vz * vz);
                target[v1] = vx * d;
                target[v1 + 1] = vy * d;
                target[v1 + 2] = vz * d;
                v1 += normalStride;
            }
            return target;
        };
        /**
         * 计算切线数据
         * @param target
         * @param _faceTangents
         * @param _faceWeights
         * @param _indices
         * @param numVertices
         * @param _useFaceWeights
         * @return
         */
        SubGeomUtil.updateVertexTangents = function (target, _faceTangents, _indices, numVertices) {
            var i;
            var lenV = numVertices * 3;
            var tangentStride = 3;
            target || ;
            new number[](lenV, true);
            i = 0;
            while (i < lenV) {
                target[i] = 0.0;
                target[i + 1] = 0.0;
                target[i + 2] = 0.0;
                i += tangentStride;
            }
            var k;
            var lenI = _indices.length;
            var index;
            var f1 = 0, f2 = 1, f3 = 2;
            i = 0;
            while (i < lenI) {
                index = _indices[i++] * tangentStride;
                target[index++] += _faceTangents[f1];
                target[index++] += _faceTangents[f2];
                target[index] += _faceTangents[f3];
                index = _indices[i++] * tangentStride;
                target[index++] += _faceTangents[f1];
                target[index++] += _faceTangents[f2];
                target[index] += _faceTangents[f3];
                index = _indices[i++] * tangentStride;
                target[index++] += _faceTangents[f1];
                target[index++] += _faceTangents[f2];
                target[index] += _faceTangents[f3];
                f1 += 3;
                f2 += 3;
                f3 += 3;
            }
            i = 0;
            while (i < lenV) {
                var vx = target[i];
                var vy = target[i + 1];
                var vz = target[i + 2];
                var d = 1.0 / Math.sqrt(vx * vx + vy * vy + vz * vz);
                target[i] = vx * d;
                target[i + 1] = vy * d;
                target[i + 2] = vz * d;
                i += tangentStride;
            }
            return target;
        };
        return SubGeomUtil;
    }());
    feng3d.SubGeomUtil = SubGeomUtil;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 纹理工具类
     * @author feng 2015-7-7
     */
    var TextureUtils = (function () {
        function TextureUtils() {
        }
        /**
         * 判断是否为有效位图
         * @param bitmapData		位图
         * @return
         */
        TextureUtils.isBitmapDataValid = function (bitmapData) {
            if (bitmapData == null)
                return true;
            return isDimensionValid(bitmapData.width) && isDimensionValid(bitmapData.height);
        };
        /**
         * 尺寸是否有效
         * @param d		尺寸
         * @return
         */
        TextureUtils.isDimensionValid = function (d) {
            return d >= 1 && d <= MAX_SIZE && isPowerOfTwo(d);
        };
        /**
         * 是否为2的指数次方
         * @param value			被检查的值
         * @return
         */
        TextureUtils.isPowerOfTwo = function (value) {
            return value ? ((value & -value) == value) : false;
        };
        /**
         * 转换为最佳2的指数次方值
         * @param value			尺寸
         * @return
         */
        TextureUtils.getBestPowerOf2 = function (value) {
            var p = 1;
            while (p < value)
                p <<= 1;
            if (p > MAX_SIZE)
                p = MAX_SIZE;
            return p;
        };
        /**
         * 获取纹理取样参数
         * @param useMipmapping 		是否使用贴图分层细化
         * @param useSmoothTextures 	是否使用平滑纹理
         * @param repeatTextures 		是否重复纹理
         * @param texture 				取样纹理
         * @param forceWrap 			强制重复纹理参数
         * @return
         */
        TextureUtils.getFlags = function (useMipmapping, useSmoothTextures, repeatTextures, texture, forceWrap) {
            if (forceWrap === void 0) { forceWrap = null; }
            var flags = [texture.type];
            var enableMipMaps = useMipmapping && texture.hasMipMaps;
            if (useSmoothTextures) {
                flags.push(Context3DTextureFilter.LINEAR);
                if (enableMipMaps)
                    flags.push(Context3DMipFilter.MIPLINEAR);
            }
            else {
                flags.push(Context3DTextureFilter.NEAREST);
                if (enableMipMaps)
                    flags.push(Context3DMipFilter.MIPNEAREST);
            }
            if (forceWrap) {
                flags.push(forceWrap);
            }
            else {
                if (!(texture))
                    is;
                feng3d.BitmapCubeTexture;
                {
                    if (repeatTextures) {
                        flags.push(Context3DWrapMode.REPEAT);
                    }
                    else {
                        flags.push(Context3DWrapMode.CLAMP);
                    }
                }
            }
            return flags;
        };
        /**
         * 支持的最大纹理尺寸
         */
        TextureUtils.MAX_SIZE = 4096;
        return TextureUtils;
    }());
    feng3d.TextureUtils = TextureUtils;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 向量工具类
     * @author feng 2014-12-10
     */
    var VectorUtils = (function () {
        function VectorUtils() {
        }
        /**
         * 把source添加到target中
         * @param source 源向量
         * @param target 目标向量
         */
        VectorUtils.add = function (source, target) {
            var sourceLen = target.length;
            var targetLen = source.length;
            var sourceFixed = target.fixed;
            target.fixed = false;
            target.length = target.length + source.length;
            target.fixed = sourceFixed;
            for (var i = 0; i < targetLen; i++) {
                target[sourceLen + i] = source[i];
            }
            return target;
        };
        /**
         * 拷贝数组
         * @param source		源数组
         * @param target		目标数组
         * @param offset		在源数组中的偏移量
         */
        VectorUtils.copy = function (source, target, offset) {
            source.forEach(function (item, index) {
                var args = [];
                for (var _i = 2; _i < arguments.length; _i++) {
                    args[_i - 2] = arguments[_i];
                }
                target[offset + index] = item;
            });
        };
        /**
         * 把source添加到target中
         * @param source 源向量
         * @param target 目标向量
         */
        VectorUtils.add1 = function (source, target, addNum) {
            var sourceLen = target.length;
            var targetLen = source.length;
            var sourceFixed = target.fixed;
            target.fixed = false;
            target.length = target.length + source.length;
            target.fixed = sourceFixed;
            for (var i = 0; i < targetLen; i++) {
                target[sourceLen + i] = source[i] + addNum;
            }
            return target;
        };
        return VectorUtils;
    }());
    feng3d.VectorUtils = VectorUtils;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * Fagal
     * @author feng 2015-4-27
     */
    var Fagal = (function () {
        function Fagal() {
        }
        /**
         * 网站
         */
        Fagal.WEBSITE_URL = "http://www.feng3d.me";
        /**
         * Fagal版本号
         */
        Fagal.REVISION = "2015.4.27";
        return Fagal;
    }());
    feng3d.Fagal = Fagal;
})(feng3d || (feng3d = {}));
//# sourceMappingURL=feng3d.js.map