var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var feng3d;
(function (feng3d) {
    /**
     * feng3d引擎
     * @author feng 2014-3-14
     */
    var Feng3D = (function () {
        function Feng3D() {
        }
        Feng3D.WEBSITE_URL = "http://www.feng3d.me";
        Feng3D.MAJOR_VERSION = 0;
        Feng3D.MINOR_VERSION = 0;
        Feng3D.REVISION = 0;
        return Feng3D;
    }());
    feng3d.Feng3D = Feng3D;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 判断a对象是否为b类型
     */
    function is(a, b) {
        var prototype = a.prototype ? a.prototype : Object.getPrototypeOf(a);
        while (prototype != null) {
            //类型==自身原型的构造函数
            if (prototype.constructor == b)
                return true;
            //父类就是原型的原型构造函数
            prototype = Object.getPrototypeOf(prototype);
        }
        return false;
    }
    feng3d.is = is;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 如果a为b类型则返回，否则返回null
     */
    function as(a, b) {
        if (!feng3d.is(a, b))
            return null;
        return a;
    }
    feng3d.as = as;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 构建Map类代替Dictionary
     */
    var Map = (function () {
        function Map() {
            /**
             * key,value组合列表
             */
            this.list = [];
        }
        /**
         * 删除
         */
        Map.prototype.delete = function (k) {
            for (var i = 0; i < this.list.length; i++) {
                var element = this.list[i];
                if (element.k == k) {
                    this.list.splice(i, 1);
                    break;
                }
            }
        };
        /**
         * 添加映射
         */
        Map.prototype.push = function (k, v) {
            var target = this._getKV(k);
            if (target != null)
                target.v = v;
            else {
                target = new KV(k, v);
                this.list.push(target);
            }
        };
        /**
         * 通过key获取value
         */
        Map.prototype.get = function (k) {
            var target = this._getKV(k);
            if (target != null)
                return target.v;
            return null;
        };
        /**
         * 获取键列表
         */
        Map.prototype.getKeys = function () {
            var keys = [];
            this.list.forEach(function (kv) {
                keys.push(kv.k);
            });
            return keys;
        };
        /**
         * 清理字典
         */
        Map.prototype.clear = function () {
            this.list.length = 0;
        };
        /**
         * 通过key获取(key,value)组合
         */
        Map.prototype._getKV = function (k) {
            var target;
            this.list.forEach(function (kv) {
                if (kv.k == k) {
                    target = kv;
                }
            });
            return target;
        };
        return Map;
    }());
    feng3d.Map = Map;
    /**
     * key,value组合
     */
    var KV = (function () {
        function KV(k, v) {
            this.k = k;
            this.v = v;
        }
        return KV;
    }());
})(feng3d || (feng3d = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var feng3d;
(function (feng3d) {
    /**
     * @private
     */
    var getDefinitionByNameCache = {};
    /**
     * @language en_US
     * Returns a reference to the class object of the class specified by the name parameter.
     * @param name The name of a class.
     * @version Egret 2.4
     * @platform Web,Native
     * @includeExample egret/utils/getDefinitionByName.ts
     */
    /**
     * @language zh_CN
     * 返回 name 参数指定的类的类对象引用。
     * @param name 类的名称。
     * @version Egret 2.4
     * @platform Web,Native
     * @includeExample egret/utils/getDefinitionByName.ts
     */
    function getDefinitionByName(name) {
        if (!name)
            return null;
        var definition = getDefinitionByNameCache[name];
        if (definition) {
            return definition;
        }
        var paths = name.split(".");
        var length = paths.length;
        definition = __global;
        for (var i = 0; i < length; i++) {
            var path = paths[i];
            definition = definition[path];
            if (!definition) {
                return null;
            }
        }
        getDefinitionByNameCache[name] = definition;
        return definition;
    }
    feng3d.getDefinitionByName = getDefinitionByName;
})(feng3d || (feng3d = {}));
var __global = __global || this;
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var feng3d;
(function (feng3d) {
    /**
     * @language en_US
     * Return the fully qualified class name of an object
     * @param value The object for which a fully qualified class name is desired. Any JavaScript value may be passed to
     * this method including all available JavaScript types, object instances, primitive types such as number, and class objects.
     * @returns A string containing the fully qualified class name.
     * @example
     * <pre>
     *  egret.getQualifiedClassName(egret.DisplayObject) //return "egret.DisplayObject"
     * </pre>
     * @version Egret 2.4
     * @platform Web,Native
     * @includeExample egret/utils/getQualifiedClassName.ts
     */
    /**
     * @language zh_CN
     * 返回对象的完全限定类名。
     * @param value 需要完全限定类名称的对象，可以将任何 JavaScript 值传递给此方法，包括所有可用的 JavaScript 类型、对象实例、原始类型
     * （如number)和类对象
     * @returns 包含完全限定类名称的字符串。
     * @example
     * <pre>
     *  egret.getQualifiedClassName(egret.DisplayObject) //返回 "egret.DisplayObject"
     * </pre>
     * @version Egret 2.4
     * @platform Web,Native
     * @includeExample egret/utils/getQualifiedClassName.ts
     */
    function getQualifiedClassName(value) {
        var type = typeof value;
        if (!value || (type != "object" && !value.prototype)) {
            return type;
        }
        var prototype = value.prototype ? value.prototype : Object.getPrototypeOf(value);
        if (prototype.hasOwnProperty("__class__")) {
            return prototype["__class__"];
        }
        var constructorString = prototype.constructor.toString().trim();
        var index = constructorString.indexOf("(");
        var className = constructorString.substring(9, index);
        Object.defineProperty(prototype, "__class__", {
            value: className,
            enumerable: false,
            writable: true
        });
        return className;
    }
    feng3d.getQualifiedClassName = getQualifiedClassName;
})(feng3d || (feng3d = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var feng3d;
(function (feng3d) {
    /** @language en_US
     * Returns the fully qualified class name of the base class of the object specified by the value parameter.
     * @param value The object for which a parent class is desired. Any JavaScript value may be passed to this method including
     * all available JavaScript types, object instances, primitive types such as number, and class objects.
     * @returns  A fully qualified base class name, or null if none exists.
     * @example
     * <pre>
     *  egret.getQualifiedSuperclassName(egret.Bitmap) //return "egret.DisplayObject"
     * </pre>
     * @version Egret 2.4
     * @platform Web,Native
     * @includeExample egret/utils/getQualifiedSuperclassName.ts
     */
    /**
     * @language zh_CN
     * 返回 value 参数指定的对象的基类的完全限定类名。
     * @param value 需要取得父类的对象，可以将任何 JavaScript 值传递给此方法，包括所有可用的 JavaScript 类型、对象实例、原始类型（如number）和类对象
     * @returns 完全限定的基类名称，或 null（如果不存在基类名称）。
     * @example
     * <pre>
     *  egret.getQualifiedSuperclassName(egret.Sprite) //返回 "egret.DisplayObject"
     * </pre>
     * @version Egret 2.4
     * @platform Web,Native
     * @includeExample egret/utils/getQualifiedSuperclassName.ts
     */
    function getQualifiedSuperclassName(value) {
        if (!value || (typeof value != "object" && !value.prototype)) {
            return null;
        }
        var prototype = value.prototype ? value.prototype : Object.getPrototypeOf(value);
        var superProto = Object.getPrototypeOf(prototype);
        if (!superProto) {
            return null;
        }
        var superClass = feng3d.getQualifiedClassName(superProto.constructor);
        if (!superClass) {
            return null;
        }
        return superClass;
    }
    feng3d.getQualifiedSuperclassName = getQualifiedSuperclassName;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 自定义事件
     * @author warden_feng 2014-5-7
     */
    var Event = (function () {
        /**
         * 创建一个作为参数传递给事件侦听器的 Event 对象。
         * @param type 事件的类型，可以作为 Event.type 访问。
         * @param bubbles 确定 Event 对象是否参与事件流的冒泡阶段。默认值为 false。
         * @param cancelable 确定是否可以取消 Event 对象。默认值为 false。
         */
        function Event(type, data, bubbles, cancelable) {
            if (data === void 0) { data = null; }
            if (bubbles === void 0) { bubbles = false; }
            if (cancelable === void 0) { cancelable = false; }
            this._type = type;
            this._data = data;
            this._bubbles = bubbles;
        }
        /**
         * 防止对事件流中当前节点中和所有后续节点中的事件侦听器进行处理。此方法会立即生效，并且会影响当前节点中的事件侦听器。相比之下，在当前节点中的所有事件侦听器都完成处理之前，stopPropagation() 方法不会生效。
         */
        Event.prototype.stopImmediatePropagation = function () {
            this._stopsPropagation = this._stopsImmediatePropagation = true;
        };
        /**
         * 防止对事件流中当前节点的后续节点中的所有事件侦听器进行处理。此方法不会影响当前节点 (currentTarget) 中的任何事件侦听器。相比之下，stopImmediatePropagation() 方法可以防止对当前节点中和后续节点中的事件侦听器进行处理。对此方法的其他调用没有任何效果。可以在事件流的任何阶段中调用此方法。
         */
        Event.prototype.stopPropagation = function () {
            this._stopsPropagation = true;
        };
        Event.prototype.tostring = function () {
            return "[" + (typeof this) + " type=\"" + this._type + "\" bubbles=" + this._bubbles + "]";
        };
        Object.defineProperty(Event.prototype, "bubbles", {
            /**
             * 表示事件是否为冒泡事件。如果事件可以冒泡，则此值为 true；否则为 false。
             */
            get: function () {
                return this._bubbles;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Event.prototype, "type", {
            /**
             * 事件的类型。类型区分大小写。
             */
            get: function () {
                return this._type;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Event.prototype, "data", {
            /** 事件携带的自定义数据 */
            get: function () {
                return this._data;
            },
            /**
             * @private
             */
            set: function (value) {
                this._data = value;
            },
            enumerable: true,
            configurable: true
        });
        Event.prototype.setData = function (value) {
            this.data = value;
        };
        Object.defineProperty(Event.prototype, "target", {
            /**
             * 事件目标。
             */
            get: function () {
                return this._target;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Event.prototype, "currentTarget", {
            /**
             * 当前正在使用某个事件侦听器处理 Event 对象的对象。
             */
            get: function () {
                return this._currentTarget;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Event.prototype, "stopsImmediatePropagation", {
            get: function () {
                return this._stopsImmediatePropagation;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Event.prototype, "stopsPropagation", {
            get: function () {
                return this._stopsPropagation;
            },
            enumerable: true,
            configurable: true
        });
        Event.prototype.setTarget = function (value) {
            this._target = value;
        };
        Event.prototype.setCurrentTarget = function (value) {
            this._currentTarget = value;
        };
        /**
         * [广播事件] 进入新的一帧,监听此事件将会在下一帧开始时触发一次回调。这是一个广播事件，可以在任何一个显示对象上监听，无论它是否在显示列表中。
         */
        Event.ENTER_FRAME = "enterFrame";
        Event.EXIT_FRAME = "EXIT_FRAME";
        Event.CHANGE = "change";
        Event.COMPLETE = "complete";
        Event.ADDED_TO_STAGE = "ADDED_TO_STAGE";
        Event.ADDED = "ADDED";
        Event.REMOVED_FROM_STAGE = "REMOVED_FROM_STAGE";
        Event.CONTEXT3D_CREATE = "CONTEXT3D_CREATE";
        return Event;
    }());
    feng3d.Event = Event;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 为了实现非flash原生显示列表的冒泡事件，自定义事件适配器
     * @author feng 2016-3-22
     */
    var EventDispatcher = (function () {
        /**
         * 构建事件适配器
         * @param target		事件适配主体
         */
        function EventDispatcher(target) {
            if (target === void 0) { target = null; }
            this._target = target;
            if (this._target == null)
                this._target = this;
            this._eventListeners = {};
        }
        EventDispatcher.prototype.addEventListener = function (type, listener, priority, useWeakReference) {
            if (priority === void 0) { priority = 0; }
            if (useWeakReference === void 0) { useWeakReference = false; }
            if (listener == null)
                return;
            var listeners = this._eventListeners[type];
            if (listeners == null)
                listeners = this._eventListeners[type] = [];
            var index = listeners.indexOf(listener);
            if (index == -1) {
                listeners.push(listener);
            }
        };
        EventDispatcher.prototype.removeEventListener = function (type, listener) {
            if (this._eventListeners) {
                var listeners = this._eventListeners[type];
                var index = listeners.indexOf(listener);
                listeners.splice(index, 1);
            }
        };
        EventDispatcher.prototype.removeEventListeners = function (type) {
            if (type === void 0) { type = null; }
            if (type && this._eventListeners)
                delete this._eventListeners[type];
            else
                this._eventListeners = {};
        };
        /**
         * @inheritDoc
         */
        EventDispatcher.prototype.dispatchEvent = function (event) {
            var _this = this;
            //停止事件流
            if (!event || event.stopsPropagation)
                return false;
            //设置目标
            if (!event.target)
                event.setTarget(this._target);
            //处理当前事件(目标阶段)
            var listeners = this._eventListeners[event.type];
            if (!event.stopsImmediatePropagation) {
                listeners.forEach(function (listener) {
                    //设置当前目标
                    event.setCurrentTarget(_this._target);
                    listener(event);
                });
            }
            //事件冒泡(冒泡阶段)
            if (event.bubbles && this.parentDispatcher) {
                this.parentDispatcher.dispatchEvent(event);
            }
            return event.stopsPropagation;
        };
        EventDispatcher.prototype.hasEventListener = function (type) {
            var listeners = this._eventListeners ? this._eventListeners[type] : null;
            for (var key in listeners) {
                return true;
            }
            return false;
        };
        /**
         * 该功能暂未实现
         * @param type
         * @return
         */
        EventDispatcher.prototype.willTrigger = function (type) {
            // TODO Auto Generated method stub
            return false;
        };
        Object.defineProperty(EventDispatcher.prototype, "parentDispatcher", {
            /**
             * 父事件适配器
             */
            get: function () {
                return this._target[EventDispatcher.BUBBLE_PROPERTY];
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 抛出错误事件
         * <p>该函数会抛出 ErrorEvent.ERROR 事件</p>
         * <p>仅当错误事件被正确处理（FErrorEvent.isProcessed == true）时不会使用throw抛出错误</p>
         * @see me.feng.events.FErrorEvent
         *
         * @author feng 2015-12-7
         */
        EventDispatcher.prototype.throwEvent = function (error) {
            var errorEvent = new feng3d.FErrorEvent(feng3d.FErrorEvent.ERROR_EVENT, error);
            this.dispatchEvent(errorEvent);
            if (!errorEvent.isProcessed)
                throw error;
        };
        /** 冒泡属性名称为“parent” */
        EventDispatcher.BUBBLE_PROPERTY = "parent";
        return EventDispatcher;
    }());
    feng3d.EventDispatcher = EventDispatcher;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 心跳计时器
     */
    var SystemTicker = (function (_super) {
        __extends(SystemTicker, _super);
        /**
         * @private
         */
        function SystemTicker() {
            feng3d.$feng3dStartTime = Date.now();
            _super.call(this);
            if (feng3d.$ticker) {
                throw "心跳计时器为单例";
            }
            this.init();
        }
        SystemTicker.prototype.init = function () {
            var requestAnimationFrame = window["requestAnimationFrame"] ||
                window["webkitRequestAnimationFrame"] ||
                window["mozRequestAnimationFrame"] ||
                window["oRequestAnimationFrame"] ||
                window["msRequestAnimationFrame"];
            if (!requestAnimationFrame) {
                requestAnimationFrame = function (callback) {
                    return window.setTimeout(callback, 1000 / 60);
                };
            }
            requestAnimationFrame.call(window, onTick);
            function onTick() {
                this.update();
                requestAnimationFrame.call(window, onTick);
            }
        };
        /**
         * @private
         * 执行一次刷新
         */
        SystemTicker.prototype.update = function () {
            this.dispatchEvent(new feng3d.Event(feng3d.Event.ENTER_FRAME));
        };
        return SystemTicker;
    }(feng3d.EventDispatcher));
    feng3d.SystemTicker = SystemTicker;
    /**
     * 心跳计时器单例
     */
    feng3d.$ticker = new SystemTicker();
    feng3d.$feng3dStartTime = -1;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 心跳基础类
     * @author cdz 2015-10-27
     */
    var BeatBase = (function () {
        function BeatBase() {
            this._isSuspend = false;
            this._beatInterval = 50 / 3; //设置默认时间
        }
        /**
         * 设置跳动间隔， 毫秒为单位
         * @param interval 时间间隔
         *
         */
        BeatBase.prototype.setInterval = function (interval) {
            this._beatInterval = interval;
        };
        /**
         * 开始跳动
         *
         */
        BeatBase.prototype.beginBeat = function () {
            this._lastBeatTime = new Date();
        };
        /**
         * 心跳
         * @param nowDate
         *
         */
        BeatBase.prototype.beat = function (nowDate) {
            if (this._isSuspend) {
                return;
            }
            var deltaTime = nowDate.getTime() - this._lastBeatTime.getTime();
            if (deltaTime >= this._beatInterval) {
                this._lastBeatTime = nowDate;
                feng3d.GlobalDispatcher.instance.dispatchEvent(new feng3d.HeartBeatEvent(this.BeatType));
            }
        };
        /**
         * 挂起
         */
        BeatBase.prototype.suspend = function () {
            this._isSuspend = true;
        };
        /**
         * 恢复
         */
        BeatBase.prototype.resume = function () {
            this._isSuspend = false;
        };
        /**
         * 析构
         */
        BeatBase.prototype.dispose = function () {
            this._lastBeatTime = null;
        };
        return BeatBase;
    }());
    feng3d.BeatBase = BeatBase;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     ** 心跳模块类
     * @includeExample HeatBeatModuleTest.as
     * @author cdz 2015-10-31
     */
    var HeartBeat = (function () {
        function HeartBeat() {
        }
        /**
         * 初始化模块
         */
        HeartBeat.init = function () {
            HeartBeat.heartBeatManager || (HeartBeat.heartBeatManager = new feng3d.HeartBeatManager());
        };
        return HeartBeat;
    }());
    feng3d.HeartBeat = HeartBeat;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 生成日志
     * <p>此处使用CommonDebug.loggerFunc方法输出日志</p>
     * @see	me.feng.debug.CommonDebug
     */
    function logger() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i - 0] = arguments[_i];
        }
        if (feng3d.DebugCommon.loggerFunc != null)
            feng3d.DebugCommon.loggerFunc.apply(null, args);
    }
    feng3d.logger = logger;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 添加组件事件数据
     * @author feng 2015-12-2
     */
    var AddedComponentEventVO = (function () {
        /**
         * 添加组件事件数据
         * @param container			组件容器
         * @param child				子组件
         */
        function AddedComponentEventVO(container, child) {
            this.container = container;
            this.child = child;
        }
        return AddedComponentEventVO;
    }());
    feng3d.AddedComponentEventVO = AddedComponentEventVO;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     *
     * @author feng 2015-12-2
     */
    var RemovedComponentEventVO = (function () {
        /**
         * 添加组件事件数据
         * @param container			组件容器
         * @param child				子组件
         */
        function RemovedComponentEventVO(container, child) {
            this.container = container;
            this.child = child;
        }
        return RemovedComponentEventVO;
    }());
    feng3d.RemovedComponentEventVO = RemovedComponentEventVO;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 模块管理者
     * <p>负责模块与外部的事件交互</p>
     * @author feng
     */
    var FModuleManager = (function () {
        /**
         * 创建一个模块
         */
        function FModuleManager() {
            /**
             * 全局事件
             */
            this.dispatcher = feng3d.GlobalDispatcher.instance;
        }
        /**
         * 初始化模块
         */
        FModuleManager.prototype.init = function () {
        };
        /**
         * 派发全局事件
         *
         * @param event						调度到事件流中的 Event 对象。如果正在重新调度事件，则会自动创建此事件的一个克隆。在调度了事件后，其 target 属性将无法更改，因此您必须创建此事件的一个新副本以能够重新调度。
         * @return 							如果成功调度了事件，则值为 true。值 false 表示失败或对事件调用了 preventDefault()。
         */
        FModuleManager.prototype.dispatchEvent = function (event) {
            return feng3d.GlobalDispatcher.instance.dispatchEvent(event);
        };
        /**
         * 监听全局事件
         * 使用 EventDispatcher 对象注册事件侦听器对象，以使侦听器能够接收事件通知. 可以为特定类型的事件、阶段和优先级在显示列表中的所有节点上注册事件侦听器。
         *
         * <p>成功注册一个事件侦听器后，无法通过额外调用 addEventListener() 来更改其优先级。要更改侦听器的优先级，必须首先调用 removeListener()。然后，可以使用新的优先级再次注册该侦听器。 </p>
         * <p>请记住，注册该侦听器后，如果继续调用具有不同 type 或 useCapture 值的 addEventListener()，则会创建单独的侦听器注册。例如，如果首先注册 useCapture 设置为 true 的侦听器，则该侦听器只在捕获阶段进行侦听。如果使用同一个侦听器对象再次调用 addEventListener()，并将 useCapture 设置为 false，那么便会拥有两个单独的侦听器：一个在捕获阶段进行侦听，另一个在目标和冒泡阶段进行侦听。 </p>
         * <p>不能只为目标阶段或冒泡阶段注册事件侦听器。这些阶段在注册期间是成对出现的，因为冒泡阶段只适用于目标节点的祖代。</p>
         * <p>如果不再需要某个事件侦听器，可调用 removeEventListener() 删除它，否则会产生内存问题。事件侦听器不会自动从内存中删除，因为只要调度对象存在，垃圾回收器就不会删除侦听器（除非 useWeakReference 参数设置为 true）。</p>
         * <p>复制 EventDispatcher 实例时并不复制其中附加的事件侦听器。（如果新近创建的节点需要一个事件侦听器，必须在创建该节点后附加该侦听器。）但是，如果移动 EventDispatcher 实例，则其中附加的事件侦听器也会随之移动。</p>
         * <p>如果在正在处理事件的节点上注册事件侦听器，则不会在当前阶段触发事件侦听器，但会在事件流的稍后阶段触发，如冒泡阶段。</p>
         * <p>如果从正在处理事件的节点中删除事件侦听器，则该事件侦听器仍由当前操作触发。删除事件侦听器后，决不会再次调用该事件侦听器（除非再次注册以备将来处理）。 </p>
         * <P>类级别成员函数不属于垃圾回收的对象，因此可以对类级别成员函数将 useWeakReference 设置为 true 而不会使它们受垃圾回收的影响。如果对作为嵌套内部函数的侦听器将 useWeakReference 设置为 true，则该函数将作为垃圾回收并且不再是永久函数。如果创建对该内部函数的引用（将该函数保存到另一个变量中），则该函数将不作为垃圾回收并仍将保持永久。</P>
         *
         * @param type						事件的类型。
         * @param listener					处理事件的侦听器函数。此函数必须接受 Event 对象作为其唯一的参数，并且不能返回任何结果，如下面的实例所示： <pre>function(evt:Event)</pre>函数可以有任何名称。
         * @param useCapture				确定侦听器是运行于捕获阶段还是运行于目标和冒泡阶段。如果将 useCapture 设置为 true，则侦听器只在捕获阶段处理事件，而不在目标或冒泡阶段处理事件。如果 useCapture 为 false，则侦听器只在目标或冒泡阶段处理事件。要在所有三个阶段都侦听事件，请调用 addEventListener 两次：一次将 useCapture 设置为 true，一次将 useCapture 设置为 false。
         * @param priority					事件侦听器的优先级。优先级由一个带符号的 32 位整数指定。数字越大，优先级越高。优先级为 n 的所有侦听器会在优先级为 n -1 的侦听器之前得到处理。如果两个或更多个侦听器共享相同的优先级，则按照它们的添加顺序进行处理。默认优先级为 0。
         * @param useWeakReference			确定对侦听器的引用是强引用，还是弱引用。强引用（默认值）可防止您的侦听器被当作垃圾回收。弱引用则没有此作用。
         *
         * @see flash.events.EventDispatcher.addEventListener()
         */
        FModuleManager.prototype.addEventListener = function (type, listener, priority, useWeakReference) {
            if (priority === void 0) { priority = 0; }
            if (useWeakReference === void 0) { useWeakReference = false; }
            feng3d.GlobalDispatcher.instance.addEventListener(type, listener, priority, useWeakReference);
        };
        return FModuleManager;
    }());
    feng3d.FModuleManager = FModuleManager;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     *
     * @author cdz 2015-10-28
     */
    var HeartBeatManager = (function (_super) {
        __extends(HeartBeatManager, _super);
        function HeartBeatManager() {
            _super.call(this);
            this.init();
            feng3d.$ticker.addEventListener(feng3d.Event.ENTER_FRAME, this.onEnterFrame);
        }
        /**
         * @inheritDoc
         */
        HeartBeatManager.prototype.init = function () {
            //初始化默认任务集合类型字典
            this._HeartBeatDic = {};
            this.addListeners();
        };
        /**
         * 添加事件监听器
         */
        HeartBeatManager.prototype.addListeners = function () {
            this.dispatcher.addEventListener(feng3d.HeartBeatModuleEvent.REGISTER_BEAT_TYPE, this.registerBeat);
            this.dispatcher.addEventListener(feng3d.HeartBeatModuleEvent.UNREGISTER_BEAT_TYPE, this.unregisterBeat);
            this.dispatcher.addEventListener(feng3d.HeartBeatModuleEvent.SUSPEND_ONE_BEAT, this.suspendOne);
            this.dispatcher.addEventListener(feng3d.HeartBeatModuleEvent.RESUME_ONE_BEAT, this.resumeOne);
            this.dispatcher.addEventListener(feng3d.HeartBeatModuleEvent.SUSPEND_All_BEAT, this.suspendAll);
            this.dispatcher.addEventListener(feng3d.HeartBeatModuleEvent.RESUME_ALL_BEAT, this.resumeAll);
        };
        /**
         * 注册心跳
         */
        HeartBeatManager.prototype.registerBeat = function (e) {
            var registerData = e.data;
            if (registerData) {
                var beatType = registerData.BeatType;
                var beatInterval = registerData.Interval;
                if (this._HeartBeatDic == null) {
                    this._HeartBeatDic = {};
                }
                if (this._HeartBeatDic[beatType] == null) {
                    var beat = new feng3d.BeatBase();
                    beat.BeatType = beatType;
                    beat.setInterval(beatInterval);
                    beat.beginBeat();
                    this._HeartBeatDic[beatType] = beat;
                }
            }
        };
        /**
         * 注销心跳
         */
        HeartBeatManager.prototype.unregisterBeat = function (e) {
            var beatType = e.data;
            if (beatType != null && beatType != "") {
                if (this._HeartBeatDic == null) {
                    return;
                }
                var beat = this._HeartBeatDic[beatType];
                beat.dispose();
                this._HeartBeatDic[beatType] = null;
            }
        };
        /**
         * 暂停一个
         */
        HeartBeatManager.prototype.suspendOne = function (e) {
            var beatType = e.data;
            if (beatType != null && beatType != "") {
                if (this._HeartBeatDic == null) {
                    return;
                }
                var pHeartBeat = this._HeartBeatDic[beatType];
                if (pHeartBeat) {
                    pHeartBeat.suspend();
                }
            }
        };
        /**
         * 恢复跳动一个
         */
        HeartBeatManager.prototype.resumeOne = function (e) {
            var beatType = e.data;
            if (beatType != null && beatType != "") {
                if (this._HeartBeatDic == null) {
                    return;
                }
                var pHeartBeat = this._HeartBeatDic[beatType];
                if (pHeartBeat) {
                    pHeartBeat.resume();
                }
            }
        };
        /**
         * 全部暂停
         */
        HeartBeatManager.prototype.suspendAll = function (e) {
            if (e === void 0) { e = null; }
            if (this._HeartBeatDic) {
                this._HeartBeatDic.forEach(function (pHeartBeat) {
                    if (pHeartBeat) {
                        pHeartBeat.suspend();
                    }
                });
            }
        };
        /**
         * 恢复跳动
         */
        HeartBeatManager.prototype.resumeAll = function (e) {
            if (this._HeartBeatDic) {
                this._HeartBeatDic.forEach(function (pHeartBeat) {
                    if (pHeartBeat) {
                        pHeartBeat.resume();
                    }
                });
            }
        };
        HeartBeatManager.prototype.onEnterFrame = function (e) {
            if (this._HeartBeatDic) {
                var date = new Date;
                this._HeartBeatDic.forEach(function (pHeartBeat) {
                    if (pHeartBeat) {
                        pHeartBeat.beat(date);
                    }
                });
            }
        };
        return HeartBeatManager;
    }(feng3d.FModuleManager));
    feng3d.HeartBeatManager = HeartBeatManager;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 加载管理器
     * @author feng 2014-7-25
     */
    var LoadManager = (function (_super) {
        __extends(LoadManager, _super);
        /**
         * 创建一个加载管理器
         */
        function LoadManager() {
            _super.call(this);
            /** 完成一个资源后执行的函数字典 */
            this.urlFuncsDic = {};
            /** 完成一组资源后执行的函数字典 */
            this.urlsFuncsDic = {};
            this.init();
        }
        /**
         * 初始化加载模块
         */
        LoadManager.prototype.init = function () {
            // creates a BulkLoader instance with a name of "main-site", that can be used to retrieve items without having a reference to this instance
            this.loader = new feng3d.BulkLoader("main-site");
            // set level to verbose, for debugging only
            this.loader.logLevel = feng3d.BulkLoader.LOG_ERRORS;
            this.addListeners();
        };
        /**
         * 添加事件监听器
         */
        LoadManager.prototype.addListeners = function () {
            this.loader.addEventListener(feng3d.BulkLoader.COMPLETE, this.onAllItemsLoaded);
            this.loader.addEventListener(feng3d.BulkLoader.PROGRESS, this.onAllItemsProgress);
            this.addEventListener(feng3d.LoadModuleEvent.LOAD_RESOURCE, this.onLoadResource);
        };
        /**
         * 处理加载资源事件
         * @param event
         */
        LoadManager.prototype.onLoadResource = function (event) {
            var taskModuleEventData = event.loadEventData.taskModuleEventData;
            taskModuleEventData.params = this.loader;
            this.dispatchEvent(new feng3d.TaskModuleEvent(feng3d.TaskModuleEvent.DISPATCH_TASK, taskModuleEventData));
            if (!this.loader.isRunning)
                this.loader.start();
        };
        /**
         * 加载完成所有资源事件
         * @param evt
         */
        LoadManager.prototype.onAllItemsLoaded = function (evt) {
            //			logger("every thing is loaded!");
        };
        /**
         * 加载进度事件
         */
        LoadManager.prototype.onAllItemsProgress = function (evt) {
            //			logger(evt.loadingStatus());
        };
        return LoadManager;
    }(feng3d.FModuleManager));
    feng3d.LoadManager = LoadManager;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 任务模块管理类
     * @author feng 2015-10-29
     */
    var TaskManager = (function (_super) {
        __extends(TaskManager, _super);
        /**
         * 创建一个任务管理器
         */
        function TaskManager() {
            _super.call(this);
            this.init();
        }
        /**
         * @inheritDoc
         */
        TaskManager.prototype.init = function () {
            //初始化默认任务集合类型字典
            this.taskCollectionTypeDic = {};
            this.registerTaskCollectionType(feng3d.TaskCollectionType.LIST, feng3d.TaskList);
            this.registerTaskCollectionType(feng3d.TaskCollectionType.QUEUE, feng3d.TaskQueue);
            this.addListeners();
        };
        /**
         * 注册任务集合类型
         * @param taskCollectionType			任务类型名称
         * @param taskCollectionTypeClass		任务类型定义
         */
        TaskManager.prototype.registerTaskCollectionType = function (taskCollectionType, taskCollectionTypeClass) {
            this.taskCollectionTypeDic[taskCollectionType] = taskCollectionTypeClass;
        };
        /**
         * 添加事件监听器
         */
        TaskManager.prototype.addListeners = function () {
            this.dispatcher.addEventListener(feng3d.TaskModuleEvent.DISPATCH_TASK, this.onDispatchTask);
            this.dispatcher.addEventListener(feng3d.TaskModuleEvent.REGISTER_TASKCOLLECTIONTYPE, this.onRegisterTaskCollectionType);
        };
        TaskManager.prototype.onRegisterTaskCollectionType = function (event) {
            var data = event.data;
            this.registerTaskCollectionType(data.taskCollectionType, data.taskCollectionTypeClass);
        };
        /**
         * 处理派发的任务事件
         */
        TaskManager.prototype.onDispatchTask = function (event) {
            var data = event.data;
            var taskCollectionCls = this.taskCollectionTypeDic[data.taskCollectionType];
            feng3d.assert(taskCollectionCls != null, "尝试使用未注册的（" + data.taskCollectionType + "）任务集合类型");
            var taskCollection = new taskCollectionCls();
            taskCollection.data = data;
            taskCollection.addEventListener(feng3d.TaskEvent.COMPLETEDITEM, this.onCompletedItem);
            taskCollection.addEventListener(feng3d.TaskEvent.COMPLETED, this.onCompleted);
            taskCollection.addItems(data.taskList);
            taskCollection.execute(data.params);
        };
        /**
         * 处理完成任务事件
         */
        TaskManager.prototype.onCompleted = function (event) {
            var taskCollection = event.currentTarget;
            var data = taskCollection.data;
            data.dispatchEvent(event);
            taskCollection.removeEventListener(feng3d.TaskEvent.COMPLETEDITEM, this.onCompletedItem);
            taskCollection.removeEventListener(feng3d.TaskEvent.COMPLETED, this.onCompleted);
            taskCollection.data = null;
        };
        /**
         * 处理完成单个任务事件
         */
        TaskManager.prototype.onCompletedItem = function (event) {
            var taskCollection = event.currentTarget;
            var data = taskCollection.data;
            data.dispatchEvent(event);
        };
        return TaskManager;
    }(feng3d.FModuleManager));
    feng3d.TaskManager = TaskManager;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 公共库调试类
     * @author feng 2015-7-23
     */
    var DebugCommon = (function () {
        function DebugCommon() {
        }
        /**
         * 日志方法
         */
        DebugCommon.loggerFunc = console.log;
        return DebugCommon;
    }());
    feng3d.DebugCommon = DebugCommon;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 断言
     * @b			判定为真的表达式
     * @msg			在表达式为假时将输出的错误信息
     * @author feng 2014-10-29
     */
    function assert(b, msg) {
        if (msg === void 0) { msg = "assert"; }
        if (!b)
            throw new Error(msg);
    }
    feng3d.assert = assert;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 动画类型
     * @author feng 2015-1-27
     */
    (function (AnimationType) {
        /** 没有动画 */
        AnimationType[AnimationType["NONE"] = 0] = "NONE";
        /** 顶点动画由GPU计算 */
        AnimationType[AnimationType["VERTEX_CPU"] = 1] = "VERTEX_CPU";
        /** 顶点动画由GPU计算 */
        AnimationType[AnimationType["VERTEX_GPU"] = 2] = "VERTEX_GPU";
        /** 骨骼动画由GPU计算 */
        AnimationType[AnimationType["SKELETON_CPU"] = 3] = "SKELETON_CPU";
        /** 骨骼动画由GPU计算 */
        AnimationType[AnimationType["SKELETON_GPU"] = 4] = "SKELETON_GPU";
        /** 粒子特效 */
        AnimationType[AnimationType["PARTICLE"] = 5] = "PARTICLE";
    })(feng3d.AnimationType || (feng3d.AnimationType = {}));
    var AnimationType = feng3d.AnimationType;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     *
     * @author cdz 2015-10-31
     */
    var HeartBeatModuleData = (function () {
        /**
         *
         * @param taskCollectionType			任务集合类型名称
         * @param taskCollectionTypeClass		任务集合类型定义
         */
        function HeartBeatModuleData(BeatType, Interval) {
            this.BeatType = BeatType;
            this.Interval = Interval;
        }
        return HeartBeatModuleData;
    }());
    feng3d.HeartBeatModuleData = HeartBeatModuleData;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 任务模块事件注册任务类型数据
     * @author feng 2015-10-30
     */
    var TaskModuleEventRegisterData = (function () {
        /**
         *
         * @param taskCollectionType			任务集合类型名称
         * @param taskCollectionTypeClass		任务集合类型定义
         */
        function TaskModuleEventRegisterData(taskCollectionType, taskCollectionTypeClass) {
            this.taskCollectionType = taskCollectionType;
            this.taskCollectionTypeClass = taskCollectionTypeClass;
        }
        return TaskModuleEventRegisterData;
    }());
    feng3d.TaskModuleEventRegisterData = TaskModuleEventRegisterData;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     *
     * @author cdz 2015-10-31
     */
    var HeartBeatEvent = (function (_super) {
        __extends(HeartBeatEvent, _super);
        function HeartBeatEvent(type, data, bubbles, cancelable) {
            if (data === void 0) { data = null; }
            if (bubbles === void 0) { bubbles = false; }
            if (cancelable === void 0) { cancelable = false; }
            _super.call(this, type, data, bubbles, cancelable);
        }
        /** 渲染心跳 */
        HeartBeatEvent.RENDER_BEAT = "renderBeat";
        /** 逻辑心跳 */
        HeartBeatEvent.LOGIC_BEAT = "logicBeat";
        /** 资源解析心跳 */
        HeartBeatEvent.RESOURCE_PARSE_BEAT = "resourceParseBeat";
        /** 物理心跳 */
        HeartBeatEvent.PHYSICS_BEAT = "physicsBeat";
        /** 鼠标检测心跳 */
        HeartBeatEvent.MOUSE_CHECK_BEAT = "MouseCheckBeat";
        return HeartBeatEvent;
    }(feng3d.Event));
    feng3d.HeartBeatEvent = HeartBeatEvent;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 组件事件
     * @author feng 2015-12-2
     */
    var ComponentEvent = (function (_super) {
        __extends(ComponentEvent, _super);
        function ComponentEvent(type, data, bubbles, cancelable) {
            if (data === void 0) { data = null; }
            if (bubbles === void 0) { bubbles = false; }
            if (cancelable === void 0) { cancelable = false; }
            _super.call(this, type, data, bubbles, cancelable);
        }
        /**
         * 添加子组件事件
         */
        ComponentEvent.ADDED_COMPONET = "addedComponet";
        /**
         * 被组件容器添加事件
         */
        ComponentEvent.BE_ADDED_COMPONET = "beAddedComponet";
        /**
         * 移除子组件事件
         */
        ComponentEvent.REMOVED_COMPONET = "removedComponet";
        /**
         * 被容器删除事件
         */
        ComponentEvent.BE_REMOVED_COMPONET = "beRemovedComponet";
        return ComponentEvent;
    }(feng3d.Event));
    feng3d.ComponentEvent = ComponentEvent;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 错误事件
     * <p>为了与flash.events.ErrorEvent区分添加前缀F</p>
     * @author feng 2015-12-7
     */
    var FErrorEvent = (function (_super) {
        __extends(FErrorEvent, _super);
        function FErrorEvent(type, data, bubbles, cancelable) {
            if (data === void 0) { data = null; }
            if (bubbles === void 0) { bubbles = false; }
            if (cancelable === void 0) { cancelable = false; }
            _super.call(this, type, data, bubbles, cancelable);
        }
        /**
         * 错误事件
         */
        FErrorEvent.ERROR_EVENT = "errorEvent";
        return FErrorEvent;
    }(feng3d.ComponentEvent));
    feng3d.FErrorEvent = FErrorEvent;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     *
     * @author cdz 2015-10-31
     */
    var HeartBeatModuleEvent = (function (_super) {
        __extends(HeartBeatModuleEvent, _super);
        /**
         * 创建任务模块事件
         * @param type 					事件的类型
         * @param data					事件携带的数据
         * @param bubbles 				确定 Event 对象是否参与事件流的冒泡阶段。默认值为 false。
         * @param cancelable 			确定是否可以取消 Event 对象。默认值为 false。
         */
        function HeartBeatModuleEvent(type, data, bubbles, cancelable) {
            if (data === void 0) { data = null; }
            if (bubbles === void 0) { bubbles = false; }
            if (cancelable === void 0) { cancelable = false; }
            _super.call(this, type, data, bubbles, cancelable);
        }
        /** 注册心跳类型 */
        HeartBeatModuleEvent.REGISTER_BEAT_TYPE = "registerBeatType";
        /** 注销心跳类型 */
        HeartBeatModuleEvent.UNREGISTER_BEAT_TYPE = "unregisterBeatType";
        /** 暂停一个心跳类型 */
        HeartBeatModuleEvent.SUSPEND_ONE_BEAT = "suspendOneBeat";
        /** 恢复心跳类型 */
        HeartBeatModuleEvent.RESUME_ONE_BEAT = "resumeOneBeat";
        /** 停止所有心跳 */
        HeartBeatModuleEvent.SUSPEND_All_BEAT = "suspendAllBeat";
        /** 停止所有心跳 */
        HeartBeatModuleEvent.RESUME_ALL_BEAT = "resumeAllBeat";
        return HeartBeatModuleEvent;
    }(feng3d.Event));
    feng3d.HeartBeatModuleEvent = HeartBeatModuleEvent;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 加载事件
     * @author feng 2014-7-25
     */
    var LoadModuleEvent = (function (_super) {
        __extends(LoadModuleEvent, _super);
        /**
         * 创建一个加载事件。
         * @param data					加载事件数据
         * @param type 					事件的类型，可以作为 Event.type 访问。
         * @param bubbles 				确定 Event 对象是否参与事件流的冒泡阶段。默认值为 false。
         * @param cancelable 			确定是否可以取消 Event 对象。默认值为 false。
         */
        function LoadModuleEvent(type, data, bubbles, cancelable) {
            if (bubbles === void 0) { bubbles = false; }
            if (cancelable === void 0) { cancelable = false; }
            _super.call(this, type, data, bubbles, cancelable);
        }
        Object.defineProperty(LoadModuleEvent.prototype, "loadEventData", {
            /**
             * 加载事件数据
             */
            get: function () {
                return this.data;
            },
            enumerable: true,
            configurable: true
        });
        /** 加载资源 */
        LoadModuleEvent.LOAD_RESOURCE = "loadResource";
        return LoadModuleEvent;
    }(feng3d.Event));
    feng3d.LoadModuleEvent = LoadModuleEvent;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 任务模块事件
     * @author feng 2015-10-29
     */
    var TaskModuleEvent = (function (_super) {
        __extends(TaskModuleEvent, _super);
        /**
         * 创建任务模块事件
         * @param type 					事件的类型
         * @param data					事件携带的数据
         * @param bubbles 				确定 Event 对象是否参与事件流的冒泡阶段。默认值为 false。
         * @param cancelable 			确定是否可以取消 Event 对象。默认值为 false。
         */
        function TaskModuleEvent(type, data, bubbles, cancelable) {
            if (data === void 0) { data = null; }
            if (bubbles === void 0) { bubbles = false; }
            if (cancelable === void 0) { cancelable = false; }
            _super.call(this, type, data, bubbles, cancelable);
        }
        /** 派发任务 */
        TaskModuleEvent.DISPATCH_TASK = "dispatchTask";
        /** 注册任务集合类型 */
        TaskModuleEvent.REGISTER_TASKCOLLECTIONTYPE = "registerTaskCollectionType";
        return TaskModuleEvent;
    }(feng3d.Event));
    feng3d.TaskModuleEvent = TaskModuleEvent;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 加载url事件
     * @author feng 2015-10-22
     */
    var LoadUrlEvent = (function (_super) {
        __extends(LoadUrlEvent, _super);
        /**
         * 创建一个加载事件。
         * @param data					加载事件数据
         * @param type 					事件的类型，可以作为 Event.type 访问。
         * @param bubbles 				确定 Event 对象是否参与事件流的冒泡阶段。默认值为 false。
         * @param cancelable 			确定是否可以取消 Event 对象。默认值为 false。
         */
        function LoadUrlEvent(type, data, bubbles, cancelable) {
            if (data === void 0) { data = null; }
            if (bubbles === void 0) { bubbles = false; }
            if (cancelable === void 0) { cancelable = false; }
            _super.call(this, type, data, bubbles, cancelable);
        }
        Object.defineProperty(LoadUrlEvent.prototype, "loadTaskItem", {
            /**
             * 加载事件数据
             */
            get: function () {
                return this.data;
            },
            enumerable: true,
            configurable: true
        });
        /** 单项资源加载完成 */
        LoadUrlEvent.LOAD_SINGLE_COMPLETE = "loadSingleComplete";
        /** 资源加载完成 */
        LoadUrlEvent.LOAD_COMPLETE = "loadComplete";
        return LoadUrlEvent;
    }(feng3d.Event));
    feng3d.LoadUrlEvent = LoadUrlEvent;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 任务事件
     * @author feng 2014-7-24
     */
    var TaskEvent = (function (_super) {
        __extends(TaskEvent, _super);
        /**
         * 创建任务事件
         * @param data					事件携带的数据
         * @param type 					事件的类型
         * @param bubbles 				确定 Event 对象是否参与事件流的冒泡阶段。默认值为 false。
         * @param cancelable 			确定是否可以取消 Event 对象。默认值为 false。
         */
        function TaskEvent(type, data, bubbles, cancelable) {
            if (data === void 0) { data = null; }
            if (bubbles === void 0) { bubbles = false; }
            if (cancelable === void 0) { cancelable = false; }
            _super.call(this, type, data, bubbles, cancelable);
        }
        /** 完成任务 */
        TaskEvent.COMPLETED = "completed";
        /** 完成一个任务单元 */
        TaskEvent.COMPLETEDITEM = "completedItem";
        return TaskEvent;
    }(feng3d.Event));
    feng3d.TaskEvent = TaskEvent;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * Dispatched to notify changes in an animation state's state.
     */
    var AnimationStateEvent = (function (_super) {
        __extends(AnimationStateEvent, _super);
        /**
         * Create a new <code>AnimatonStateEvent</code>
         *
         * @param type The event type.
         * @param animator The animation state object that is the subject of this event.
         * @param animationNode The animation node inside the animation state from which the event originated.
         */
        function AnimationStateEvent(type, animator, animationState, animationNode) {
            _super.call(this, type, false, false);
            this._animator = animator;
            this._animationState = animationState;
            this._animationNode = animationNode;
        }
        Object.defineProperty(AnimationStateEvent.prototype, "animator", {
            /**
             * The animator object that is the subject of this event.
             */
            get: function () {
                return this._animator;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AnimationStateEvent.prototype, "animationState", {
            /**
             * The animation state object that is the subject of this event.
             */
            get: function () {
                return this._animationState;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AnimationStateEvent.prototype, "animationNode", {
            /**
             * The animation node inside the animation state from which the event originated.
             */
            get: function () {
                return this._animationNode;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Clones the event.
         *
         * @return An exact duplicate of the current object.
         */
        AnimationStateEvent.prototype.clone = function () {
            return new AnimationStateEvent(this.type, this._animator, this._animationState, this._animationNode);
        };
        /**
         * Dispatched when a non-looping clip node inside an animation state reaches the end of its timeline.
         */
        AnimationStateEvent.PLAYBACK_COMPLETE = "playbackComplete";
        AnimationStateEvent.TRANSITION_COMPLETE = "transitionComplete";
        return AnimationStateEvent;
    }(feng3d.Event));
    feng3d.AnimationStateEvent = AnimationStateEvent;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 动画事件
     * @author feng 2014-5-27
     */
    var AnimatorEvent = (function (_super) {
        __extends(AnimatorEvent, _super);
        /**
         * 创建一个动画时间
         * @param type			事件类型
         * @param data			事件数据
         * @param bubbles		是否冒泡
         */
        function AnimatorEvent(type, data, bubbles) {
            if (data === void 0) { data = null; }
            if (bubbles === void 0) { bubbles = false; }
            _super.call(this, type, data, bubbles);
        }
        /** 开始播放动画 */
        AnimatorEvent.START = "start";
        /** 继续播放动画 */
        AnimatorEvent.PLAY = "play";
        /** 停止播放动画 */
        AnimatorEvent.STOP = "stop";
        /** 周期完成 */
        AnimatorEvent.CYCLE_COMPLETE = "cycle_complete";
        return AnimatorEvent;
    }(feng3d.Event));
    feng3d.AnimatorEvent = AnimatorEvent;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * Dispatched whenever a ressource (asset) is parsed and created completly.
     */
    var AssetEvent = (function (_super) {
        __extends(AssetEvent, _super);
        function AssetEvent(type, asset, prevName) {
            if (asset === void 0) { asset = null; }
            if (prevName === void 0) { prevName = null; }
            _super.call(this, type);
            this._asset = asset;
            this._prevName = prevName || (this._asset ? this._asset.namedAsset.name : null);
        }
        Object.defineProperty(AssetEvent.prototype, "asset", {
            get: function () {
                return this._asset;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AssetEvent.prototype, "assetPrevName", {
            get: function () {
                return this._prevName;
            },
            enumerable: true,
            configurable: true
        });
        AssetEvent.ASSET_COMPLETE = "assetComplete";
        AssetEvent.ENTITY_COMPLETE = "entityComplete";
        AssetEvent.SKYBOX_COMPLETE = "skyboxComplete";
        AssetEvent.CAMERA_COMPLETE = "cameraComplete";
        AssetEvent.MESH_COMPLETE = "meshComplete";
        AssetEvent.GEOMETRY_COMPLETE = "geometryComplete";
        AssetEvent.SKELETON_COMPLETE = "skeletonComplete";
        AssetEvent.SKELETON_POSE_COMPLETE = "skeletonPoseComplete";
        AssetEvent.CONTAINER_COMPLETE = "containerComplete";
        AssetEvent.TEXTURE_COMPLETE = "textureComplete";
        AssetEvent.TEXTURE_PROJECTOR_COMPLETE = "textureProjectorComplete";
        AssetEvent.MATERIAL_COMPLETE = "materialComplete";
        AssetEvent.ANIMATOR_COMPLETE = "animatorComplete";
        AssetEvent.ANIMATION_SET_COMPLETE = "animationSetComplete";
        AssetEvent.ANIMATION_STATE_COMPLETE = "animationStateComplete";
        AssetEvent.ANIMATION_NODE_COMPLETE = "animationNodeComplete";
        AssetEvent.STATE_TRANSITION_COMPLETE = "stateTransitionComplete";
        AssetEvent.SEGMENT_SET_COMPLETE = "segmentSetComplete";
        AssetEvent.LIGHT_COMPLETE = "lightComplete";
        AssetEvent.LIGHTPICKER_COMPLETE = "lightPickerComplete";
        AssetEvent.EFFECTMETHOD_COMPLETE = "effectMethodComplete";
        AssetEvent.SHADOWMAPMETHOD_COMPLETE = "shadowMapMethodComplete";
        AssetEvent.ASSET_RENAME = 'assetRename';
        AssetEvent.ASSET_CONFLICT_RESOLVED = 'assetConflictResolved';
        AssetEvent.TEXTURE_SIZE_ERROR = 'textureSizeError';
        return AssetEvent;
    }(feng3d.Event));
    feng3d.AssetEvent = AssetEvent;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 摄像机事件
     * @author feng 2014-10-14
     */
    var CameraEvent = (function (_super) {
        __extends(CameraEvent, _super);
        function CameraEvent(type, camera, bubbles) {
            if (camera === void 0) { camera = null; }
            if (bubbles === void 0) { bubbles = false; }
            _super.call(this, type, camera, bubbles);
        }
        Object.defineProperty(CameraEvent.prototype, "camera", {
            get: function () {
                return this.data;
            },
            enumerable: true,
            configurable: true
        });
        CameraEvent.LENS_CHANGED = "lensChanged";
        return CameraEvent;
    }(feng3d.Event));
    feng3d.CameraEvent = CameraEvent;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     *
     * @author feng 2014-9-10
     */
    var Container3DEvent = (function (_super) {
        __extends(Container3DEvent, _super);
        function Container3DEvent(type, data, bubbles) {
            if (data === void 0) { data = null; }
            if (bubbles === void 0) { bubbles = false; }
            _super.call(this, type, data, bubbles);
        }
        return Container3DEvent;
    }(feng3d.Event));
    feng3d.Container3DEvent = Container3DEvent;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 3D环境缓冲拥有者事件
     * @author feng 2015-7-18
     */
    var Context3DBufferOwnerEvent = (function (_super) {
        __extends(Context3DBufferOwnerEvent, _super);
        /**
         * 创建3D环境缓冲拥有者事件
         * @param type 					事件的类型，可以作为 Event.type 访问。
         * @param data					事件携带的数据
         * @param bubbles 				确定 Event 对象是否参与事件流的冒泡阶段。默认值为 false。
         * @param cancelable 			确定是否可以取消 Event 对象。默认值为 false。
         */
        function Context3DBufferOwnerEvent(type, data, bubbles, cancelable) {
            if (data === void 0) { data = null; }
            if (bubbles === void 0) { bubbles = false; }
            if (cancelable === void 0) { cancelable = false; }
            _super.call(this, type, data, bubbles, cancelable);
        }
        /**
         * 添加3D环境缓冲事件
         */
        Context3DBufferOwnerEvent.ADD_CONTEXT3DBUFFER = "addContext3DBuffer";
        /**
         * 移除3D环境缓冲事件
         */
        Context3DBufferOwnerEvent.REMOVE_CONTEXT3DBUFFER = "removeContext3DBuffer";
        /**
         * 添加子项3D环境缓冲拥有者事件
         */
        Context3DBufferOwnerEvent.ADDCHILD_CONTEXT3DBUFFEROWNER = "addChildContext3DBufferOwner";
        /**
         * 移除子项3D环境缓冲拥有者事件
         */
        Context3DBufferOwnerEvent.REMOVECHILD_CONTEXT3DBUFFEROWNER = "removeChildContext3DBufferOwner";
        return Context3DBufferOwnerEvent;
    }(feng3d.Event));
    feng3d.Context3DBufferOwnerEvent = Context3DBufferOwnerEvent;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * Fagal函数事件
     * @author feng 2015-8-8
     */
    var FagalMathEvent = (function (_super) {
        __extends(FagalMathEvent, _super);
        /**
         * 创建一个作为参数传递给事件侦听器的 Event 对象.
         * @param type 					事件的类型，可以作为 Event.type 访问。
         * @param code					fagal代码
         * @param bubbles 				确定 Event 对象是否参与事件流的冒泡阶段。默认值为 false。
         * @param cancelable 			确定是否可以取消 Event 对象。默认值为 false。
         */
        function FagalMathEvent(type, code, bubbles, cancelable) {
            if (bubbles === void 0) { bubbles = false; }
            if (cancelable === void 0) { cancelable = false; }
            _super.call(this, type, code, bubbles, cancelable);
        }
        Object.defineProperty(FagalMathEvent.prototype, "code", {
            /**
             * fagal代码
             */
            get: function () {
                return this.data;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Fagal函数追加代码事件
         */
        FagalMathEvent.FAGALMATHEVENT_APPEND = "fagalMathEventAppend";
        return FagalMathEvent;
    }(feng3d.Event));
    feng3d.FagalMathEvent = FagalMathEvent;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 几何体组件事件
     * @author feng 2015-12-8
     */
    var GeometryComponentEvent = (function (_super) {
        __extends(GeometryComponentEvent, _super);
        function GeometryComponentEvent(type, data, bubbles, cancelable) {
            if (data === void 0) { data = null; }
            if (bubbles === void 0) { bubbles = false; }
            if (cancelable === void 0) { cancelable = false; }
            _super.call(this, type, data, bubbles, cancelable);
        }
        /**
         * 获取几何体顶点数据
         */
        GeometryComponentEvent.GET_VA_DATA = "getVAData";
        /**
         * 改变几何体顶点数据事件
         */
        GeometryComponentEvent.CHANGED_VA_DATA = "changedVAData";
        /**
         * 改变顶点索引数据事件
         */
        GeometryComponentEvent.CHANGED_INDEX_DATA = "changedIndexData";
        return GeometryComponentEvent;
    }(feng3d.Event));
    feng3d.GeometryComponentEvent = GeometryComponentEvent;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 几何体事件
     * @author feng 2014-5-15
     */
    var GeometryEvent = (function (_super) {
        __extends(GeometryEvent, _super);
        function GeometryEvent(type, subGeometry, bubbles, cancelable) {
            if (subGeometry === void 0) { subGeometry = null; }
            if (bubbles === void 0) { bubbles = false; }
            if (cancelable === void 0) { cancelable = false; }
            _super.call(this, type, subGeometry, bubbles, cancelable);
            this._subGeometry = subGeometry;
        }
        Object.defineProperty(GeometryEvent.prototype, "subGeometry", {
            get: function () {
                return this._subGeometry;
            },
            enumerable: true,
            configurable: true
        });
        /** 添加子几何体 */
        GeometryEvent.SUB_GEOMETRY_ADDED = "SubGeometryAdded";
        /** 溢出子几何体 */
        GeometryEvent.SUB_GEOMETRY_REMOVED = "SubGeometryRemoved";
        /** 几何体外形发生改变 */
        GeometryEvent.SHAPE_CHANGE = "shapeChange";
        return GeometryEvent;
    }(feng3d.Event));
    feng3d.GeometryEvent = GeometryEvent;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 镜头事件
     * @author feng 2014-10-14
     */
    var LensEvent = (function (_super) {
        __extends(LensEvent, _super);
        function LensEvent(type, lens, bubbles, cancelable) {
            if (lens === void 0) { lens = null; }
            if (bubbles === void 0) { bubbles = false; }
            if (cancelable === void 0) { cancelable = false; }
            _super.call(this, type, lens, bubbles, cancelable);
        }
        Object.defineProperty(LensEvent.prototype, "lens", {
            get: function () {
                return this.data;
            },
            enumerable: true,
            configurable: true
        });
        LensEvent.MATRIX_CHANGED = "matrixChanged";
        return LensEvent;
    }(feng3d.Event));
    feng3d.LensEvent = LensEvent;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     *
     * @author feng 2015-5-28
     */
    var LightEvent = (function (_super) {
        __extends(LightEvent, _super);
        function LightEvent(type, data, bubbles, cancelable) {
            if (data === void 0) { data = null; }
            if (bubbles === void 0) { bubbles = false; }
            if (cancelable === void 0) { cancelable = false; }
            _super.call(this, type, data, bubbles, cancelable);
        }
        LightEvent.CASTS_SHADOW_CHANGE = "castsShadowChange";
        return LightEvent;
    }(feng3d.Event));
    feng3d.LightEvent = LightEvent;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 材质事件
     * @author feng 2014-9-9
     */
    var MaterialEvent = (function (_super) {
        __extends(MaterialEvent, _super);
        function MaterialEvent(type, data, bubbles) {
            if (data === void 0) { data = null; }
            if (bubbles === void 0) { bubbles = false; }
            _super.call(this, type, data, bubbles);
        }
        /** 添加pass */
        MaterialEvent.PASS_ADDED = "passAdded";
        /** 移除pass */
        MaterialEvent.PASS_REMOVED = "passRemoved";
        return MaterialEvent;
    }(feng3d.Event));
    feng3d.MaterialEvent = MaterialEvent;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 网格事件
     * @author feng 2015-3-20
     */
    var MeshEvent = (function (_super) {
        __extends(MeshEvent, _super);
        /**
         * 创建一个网格事件。
         * @param data					事件携带的数据
         * @param type 					事件的类型，可以作为 Event.type 访问。
         * @param bubbles 				确定 Event 对象是否参与事件流的冒泡阶段。默认值为 false。
         * @param cancelable 			确定是否可以取消 Event 对象。默认值为 false。
         */
        function MeshEvent(type, data, bubbles, cancelable) {
            if (data === void 0) { data = null; }
            if (bubbles === void 0) { bubbles = false; }
            if (cancelable === void 0) { cancelable = false; }
            _super.call(this, type, data, bubbles, cancelable);
        }
        /**
         * 材质发生变化
         */
        MeshEvent.MATERIAL_CHANGE = "materialChange";
        return MeshEvent;
    }(feng3d.Event));
    feng3d.MeshEvent = MeshEvent;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 3d鼠标事件
     * @author feng 2014-4-29
     * @see flash.events.MouseEvent
     */
    var MouseEvent3D = (function (_super) {
        __extends(MouseEvent3D, _super);
        /**
         * 创建一个3D鼠标事件
         * @param data					事件携带的数据
         * @param type 					事件的类型，可以作为 Event.type 访问。
         * @param bubbles 				确定 Event 对象是否参与事件流的冒泡阶段。默认值为 false。
         * @param cancelable 			确定是否可以取消 Event 对象。默认值为 false。
         */
        function MouseEvent3D(type, data, bubbles, cancelable) {
            if (data === void 0) { data = null; }
            if (bubbles === void 0) { bubbles = true; }
            if (cancelable === void 0) { cancelable = false; }
            _super.call(this, type, data, bubbles, cancelable);
        }
        /**
         * 单击
         */
        MouseEvent3D.CLICK = "click3d";
        /**
         * 鼠标移人对象
         */
        MouseEvent3D.MOUSE_OVER = "mouseOver3d";
        /**
         * 鼠标移出对象
         */
        MouseEvent3D.MOUSE_OUT = "mouseOut3d";
        /**
         * 鼠标在对象上移动
         */
        MouseEvent3D.MOUSE_MOVE = "mouseMove3d";
        /**
         * 鼠标在对象上双击
         */
        MouseEvent3D.DOUBLE_CLICK = "doubleClick3d";
        /**
         * 鼠标在对象上按下
         */
        MouseEvent3D.MOUSE_DOWN = "mouseDown3d";
        /**
         * 鼠标在对象上弹起
         */
        MouseEvent3D.MOUSE_UP = "mouseUp3d";
        /**
         * 鼠标在对象上滚轮滚动
         */
        MouseEvent3D.MOUSE_WHEEL = "mouseWheel3d";
        return MouseEvent3D;
    }(feng3d.Event));
    feng3d.MouseEvent3D = MouseEvent3D;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 解析事件
     * @author feng 2014-5-16
     */
    var ParserEvent = (function (_super) {
        __extends(ParserEvent, _super);
        function ParserEvent(type, message) {
            if (message === void 0) { message = ''; }
            _super.call(this, type);
            this._message = message;
        }
        Object.defineProperty(ParserEvent.prototype, "message", {
            /**
             * Additional human-readable message. Usually supplied for PARSE_ERROR events.
             */
            get: function () {
                return this._message;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Dispatched when parsing of an asset completed.
         */
        ParserEvent.PARSE_COMPLETE = 'parseComplete';
        /**
         * Dispatched when an error occurs while parsing the data (e.g. because it's
         * incorrectly formatted.)
         */
        ParserEvent.PARSE_ERROR = 'parseError';
        /**
         * Dispatched when a parser is ready to have dependencies retrieved and resolved.
         * This is an internal event that should rarely (if ever) be listened for by
         * external classes.
         */
        ParserEvent.READY_FOR_DEPENDENCIES = 'readyForDependencies';
        return ParserEvent;
    }(feng3d.Event));
    feng3d.ParserEvent = ParserEvent;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 渲染函数事件
     * @author feng 2014-7-1
     */
    var ShadingMethodEvent = (function (_super) {
        __extends(ShadingMethodEvent, _super);
        /**
         * 构建一个渲染函数失效事件
         * @param type 			事件的类型，可以作为 Event.type 访问。
         * @param data			数据
         * @param bubbles 		确定 Event 对象是否参与事件流的冒泡阶段。默认值为 false。
         * @param cancelable 	确定是否可以取消 Event 对象。默认值为 false。
         */
        function ShadingMethodEvent(type, data, bubbles, cancelable) {
            if (data === void 0) { data = null; }
            if (bubbles === void 0) { bubbles = false; }
            if (cancelable === void 0) { cancelable = false; }
            _super.call(this, type, data, bubbles, cancelable);
        }
        /** 渲染函数失效 */
        ShadingMethodEvent.SHADER_INVALIDATED = "ShaderInvalidated";
        return ShadingMethodEvent;
    }(feng3d.Event));
    feng3d.ShadingMethodEvent = ShadingMethodEvent;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 3D对象事件(3D状态发生改变、位置、旋转、缩放)
     * @author feng 2014-3-31
     */
    var Transform3DEvent = (function (_super) {
        __extends(Transform3DEvent, _super);
        /**
         * 创建3D对象事件
         * @param type			事件类型
         * @param element3D		发出事件的3D元素
         */
        function Transform3DEvent(type, element3D, bubbles, cancelable) {
            if (bubbles === void 0) { bubbles = false; }
            if (cancelable === void 0) { cancelable = false; }
            _super.call(this, type, element3D, bubbles, cancelable);
        }
        Object.defineProperty(Transform3DEvent.prototype, "element3D", {
            /**
             * 发出事件的3D元素
             */
            get: function () {
                return this.data;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 平移
         */
        Transform3DEvent.POSITION_CHANGED = "positionChanged";
        /**
         * 旋转
         */
        Transform3DEvent.ROTATION_CHANGED = "rotationChanged";
        /**
         * 缩放
         */
        Transform3DEvent.SCALE_CHANGED = "scaleChanged";
        /**
         * 变换
         */
        Transform3DEvent.TRANSFORM_CHANGED = "transformChanged";
        /**
         * 变换已更新
         */
        Transform3DEvent.TRANSFORM_UPDATED = "transformUpdated";
        /**
         * 场景变换矩阵发生变化
         */
        Transform3DEvent.SCENETRANSFORM_CHANGED = "scenetransformChanged";
        return Transform3DEvent;
    }(feng3d.Event));
    feng3d.Transform3DEvent = Transform3DEvent;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 组件容器（集合）
     * @author feng 2015-5-6
     */
    var Component = (function (_super) {
        __extends(Component, _super);
        /**
         * 创建一个组件容器
         */
        function Component() {
            _super.call(this);
            /**
             * 组件列表
             */
            this.components = []; //我并不喜欢使用vector，这使得我不得不去处理越界的问题，繁琐！此处重新修改为Array！
        }
        Object.defineProperty(Component.prototype, "componentName", {
            /**
             * 组件名称
             */
            get: function () {
                if (this._componentName == null)
                    this._componentName = feng3d.ClassUtils.getDefaultName(this);
                return this._componentName;
            },
            set: function (value) {
                this._componentName = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Component.prototype, "numComponents", {
            /**
             * 子组件个数
             */
            get: function () {
                return this.components.length;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 添加组件
         * @param com 被添加组件
         */
        Component.prototype.addComponent = function (com) {
            feng3d.assert(com != this, "子项与父项不能相同");
            if (this.hasComponent(com)) {
                this.setComponentIndex(com, this.components.length - 1);
                return;
            }
            this.addComponentAt(com, this.components.length);
        };
        /**
         * 添加组件到指定位置
         * @param component		被添加的组件
         * @param index			插入的位置
         */
        Component.prototype.addComponentAt = function (component, index) {
            feng3d.assert(component != this, "子项与父项不能相同");
            feng3d.assert(index >= 0 && index <= this.numComponents, "给出索引超出范围");
            if (this.hasComponent(component)) {
                index = Math.min(index, this.components.length - 1);
                this.setComponentIndex(component, index);
                return;
            }
            this.components.splice(index, 0, component);
            var addedComponentEventVO = new feng3d.AddedComponentEventVO(this, component);
            var addedComponentEvent = new feng3d.ComponentEvent(feng3d.ComponentEvent.ADDED_COMPONET, addedComponentEventVO);
            this.dispatchEvent(addedComponentEvent);
            var beAddedComponentEvent = new feng3d.ComponentEvent(feng3d.ComponentEvent.BE_ADDED_COMPONET, addedComponentEventVO);
            component.dispatchEvent(beAddedComponentEvent);
        };
        /**
         * 移除组件
         * @param com 被移除组件
         */
        Component.prototype.removeComponent = function (com) {
            feng3d.assert(this.hasComponent(com), "只能移除在容器中的组件");
            var index = this.getComponentIndex(com);
            this.removeComponentAt(index);
        };
        /**
         * 移除组件
         * @param index		要删除的 Component 的子索引。
         */
        Component.prototype.removeComponentAt = function (index) {
            feng3d.assert(index >= 0 && index < this.numComponents, "给出索引超出范围");
            var removeComponent = this.components.splice(index, 1)[0];
            return removeComponent;
        };
        /**
         * 获取组件在容器的索引位置
         * @param com			查询的组件
         * @return				组件在容器的索引位置
         */
        Component.prototype.getComponentIndex = function (com) {
            feng3d.assert(this.components.indexOf(com) != -1, "组件不在容器中");
            var index = this.components.indexOf(com);
            return index;
        };
        /**
         * 设置子组件的位置
         * @param com				子组件
         * @param index				位置索引
         */
        Component.prototype.setComponentIndex = function (com, index) {
            feng3d.assert(index >= 0 && index < this.numComponents, "给出索引超出范围");
            var oldIndex = this.components.indexOf(com);
            feng3d.assert(oldIndex >= 0 && oldIndex < this.numComponents, "子组件不在容器内");
            this.components.splice(oldIndex, 1);
            this.components.splice(index, 0, com);
        };
        /**
         * 获取指定位置索引的子组件
         * @param index			位置索引
         * @return				子组件
         */
        Component.prototype.getComponentAt = function (index) {
            feng3d.assert(index < this.numComponents, "给出索引超出范围");
            return this.components[index];
        };
        /**
         * 根据组件名称获取组件
         * <p>注意：此处比较的是componentName而非name</p>
         * @param componentName		组件名称
         * @return 					获取到的组件
         */
        Component.prototype.getComponentByName = function (componentName) {
            var filterResult = this.getComponentsByName(componentName);
            return filterResult[0];
        };
        /**
         * 获取与给出组件名称相同的所有组件
         * <p>注意：此处比较的是componentName而非name</p>
         * @param componentName		组件名称
         * @return 					获取到的组件
         */
        Component.prototype.getComponentsByName = function (componentName) {
            var filterResult = this.components.filter(function (item) {
                var args = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    args[_i - 1] = arguments[_i];
                }
                return item.componentName == componentName;
            });
            return filterResult;
        };
        /**
         * 根据类定义获取组件
         * <p>如果存在多个则返回第一个</p>
         * @param cls				类定义
         * @return
         */
        Component.prototype.getComponentByClass = function (cls) {
            var component = this.getComponentsByClass(cls)[0];
            return component;
        };
        /**
         * 根据类定义查找组件
         * @param cls		类定义
         * @return			返回与给出类定义一致的组件
         */
        Component.prototype.getComponentsByClass = function (cls) {
            var filterResult = this.components.filter(function (item) {
                var args = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    args[_i - 1] = arguments[_i];
                }
                return feng3d.ClassUtils.isSameClass(item, cls);
            });
            return filterResult;
        };
        /**
         * 根据类定义获取或创建组件
         * <p>当不存在该类型对象时创建一个该组件并且添加到容器中</p>
         * @param cls
         * @return
         */
        Component.prototype.getOrCreateComponentByClass = function (cls) {
            var component = this.getComponentByClass(cls);
            if (component == null) {
                component = new cls();
                this.addComponent(component);
            }
            return component;
        };
        /**
         * 判断是否拥有组件
         * @param com	被检测的组件
         * @return		true：拥有该组件；false：不拥有该组件。
         */
        Component.prototype.hasComponent = function (com) {
            return this.components.indexOf(com) != -1;
        };
        /**
         * 交换子组件位置
         * @param index1		第一个子组件的索引位置
         * @param index2		第二个子组件的索引位置
         */
        Component.prototype.swapComponentsAt = function (index1, index2) {
            feng3d.assert(index1 >= 0 && index1 < this.numComponents, "第一个子组件的索引位置超出范围");
            feng3d.assert(index2 >= 0 && index2 < this.numComponents, "第二个子组件的索引位置超出范围");
            var temp = this.components[index1];
            this.components[index1] = this.components[index2];
            this.components[index2] = temp;
        };
        /**
         * 交换子组件位置
         * @param com1		第一个子组件
         * @param com2		第二个子组件
         */
        Component.prototype.swapComponents = function (com1, com2) {
            feng3d.assert(this.hasComponent(com1), "第一个子组件不在容器中");
            feng3d.assert(this.hasComponent(com2), "第二个子组件不在容器中");
            this.swapComponentsAt(this.getComponentIndex(com1), this.getComponentIndex(com2));
        };
        /**
         * 派发子组件事件
         * <p>事件广播给子组件</p>
         * @param event
         */
        Component.prototype.dispatchChildrenEvent = function (event) {
            this.components.forEach(function (item) {
                var args = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    args[_i - 1] = arguments[_i];
                }
                item.dispatchEvent(event);
            });
        };
        return Component;
    }(feng3d.EventDispatcher));
    feng3d.Component = Component;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 唯一类型组件
     * <p>不允许容器内存在两个相同类型的子组件</p>
     * @author feng 2015-12-2
     */
    var UniqueClassComponent = (function (_super) {
        __extends(UniqueClassComponent, _super);
        function UniqueClassComponent() {
            _super.call(this);
            this.addEventListener(feng3d.ComponentEvent.BE_ADDED_COMPONET, this.onBeAddedComponet);
            this.addEventListener(feng3d.ComponentEvent.BE_REMOVED_COMPONET, this.onBeRemovedComponet);
        }
        /**
         * 处理被添加事件
         * @param event
         */
        UniqueClassComponent.prototype.onBeAddedComponet = function (event) {
            var addedComponentEventVO = event.data;
            feng3d.assert(addedComponentEventVO.child == this);
            addedComponentEventVO.container.addEventListener(feng3d.ComponentEvent.ADDED_COMPONET, this.onAddedComponetContainer);
            this.checkUniqueName(addedComponentEventVO.container);
        };
        /**
         * 处理被移除事件
         * @param event
         */
        UniqueClassComponent.prototype.onBeRemovedComponet = function (event) {
            var removedComponentEventVO = event.data;
            feng3d.assert(removedComponentEventVO.child == this);
            removedComponentEventVO.container.removeEventListener(feng3d.ComponentEvent.ADDED_COMPONET, this.onAddedComponetContainer);
        };
        /**
         * 处理添加组件事件
         * @param event
         */
        UniqueClassComponent.prototype.onAddedComponetContainer = function (event) {
            var addedComponentEventVO = event.data;
            this.checkUniqueName(addedComponentEventVO.container);
        };
        /**
         * 检查子组件中类型是否唯一
         * @param container
         */
        UniqueClassComponent.prototype.checkUniqueName = function (container) {
            var nameDic = {};
            for (var i = 0; i < container.numComponents; i++) {
                var component = container.getComponentAt(i);
                var classDefine = feng3d.getQualifiedClassName(component);
                if (nameDic[classDefine]) {
                    this.throwEvent(new Error("存在多个子组件拥有相同的类型"));
                }
                nameDic[classDefine] = true;
            }
        };
        return UniqueClassComponent;
    }(feng3d.Component));
    feng3d.UniqueClassComponent = UniqueClassComponent;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 唯一名称组件
     * <p>不允许容器内存在两个名称相同的子组件</p>
     * @author feng 2015-12-2
     */
    var UniqueNameComponent = (function (_super) {
        __extends(UniqueNameComponent, _super);
        function UniqueNameComponent() {
            _super.call(this);
            this.addEventListener(feng3d.ComponentEvent.BE_ADDED_COMPONET, this.onBeAddedComponet);
            this.addEventListener(feng3d.ComponentEvent.BE_REMOVED_COMPONET, this.onBeRemovedComponet);
        }
        /**
         * 处理被添加事件
         * @param event
         */
        UniqueNameComponent.prototype.onBeAddedComponet = function (event) {
            var addedComponentEventVO = event.data;
            addedComponentEventVO.container.addEventListener(feng3d.ComponentEvent.ADDED_COMPONET, this.onAddedComponetContainer);
            this.checkUniqueName(addedComponentEventVO.container);
        };
        /**
         * 处理被移除事件
         * @param event
         */
        UniqueNameComponent.prototype.onBeRemovedComponet = function (event) {
            var removedComponentEventVO = event.data;
            removedComponentEventVO.container.removeEventListener(feng3d.ComponentEvent.ADDED_COMPONET, this.onAddedComponetContainer);
        };
        /**
         * 处理添加组件事件
         * @param event
         */
        UniqueNameComponent.prototype.onAddedComponetContainer = function (event) {
            var addedComponentEventVO = event.data;
            this.checkUniqueName(addedComponentEventVO.container);
        };
        /**
         * 检查子组件中名称是否唯一
         * @param container
         */
        UniqueNameComponent.prototype.checkUniqueName = function (container) {
            var nameDic = {};
            for (var i = 0; i < container.numComponents; i++) {
                var component = container.getComponentAt(i);
                if (nameDic[component.componentName]) {
                    this.throwEvent(new Error("存在多个子组件拥有相同的名称"));
                }
                nameDic[component.componentName] = true;
            }
        };
        return UniqueNameComponent;
    }(feng3d.Component));
    feng3d.UniqueNameComponent = UniqueNameComponent;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 动画节点基类
     * @author feng 2014-5-20
     */
    var AnimationNodeBase = (function (_super) {
        __extends(AnimationNodeBase, _super);
        /**
         * 创建一个动画节点基类
         */
        function AnimationNodeBase() {
            _super.call(this);
            this._namedAsset = new feng3d.NamedAsset(this, feng3d.AssetType.ANIMATION_NODE);
            this.context3DBufferOwner = new feng3d.Context3DBufferOwner();
            this.initBuffers();
        }
        Object.defineProperty(AnimationNodeBase.prototype, "stateClass", {
            /**
             * 状态类
             */
            get: function () {
                return this._stateClass;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 初始化Context3d缓存
         */
        AnimationNodeBase.prototype.initBuffers = function () {
        };
        Object.defineProperty(AnimationNodeBase.prototype, "_", {
            /**
             * Fagal编号中心
             */
            get: function () {
                return feng3d.FagalIdCenter.instance;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AnimationNodeBase.prototype, "namedAsset", {
            get: function () {
                return this._namedAsset;
            },
            enumerable: true,
            configurable: true
        });
        return AnimationNodeBase;
    }(feng3d.Component));
    feng3d.AnimationNodeBase = AnimationNodeBase;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 动画剪辑节点基类(用于控制动画播放，包含每帧持续时间，是否循环播放等)
     * @author feng 2014-5-20
     */
    var AnimationClipNodeBase = (function (_super) {
        __extends(AnimationClipNodeBase, _super);
        /**
         * 创建一个动画剪辑节点基类
         */
        function AnimationClipNodeBase() {
            _super.call(this);
            this._looping = true;
            this._totalDuration = 0;
            this._stitchDirty = true;
            this._stitchFinalFrame = false;
            this._numFrames = 0;
            this._durations = [];
            this._totalDelta = new feng3d.Vector3D();
            /** 是否稳定帧率 */
            this.fixedFrameRate = true;
        }
        Object.defineProperty(AnimationClipNodeBase.prototype, "durations", {
            /**
             * 持续时间列表（ms）
             */
            get: function () {
                return this._durations;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AnimationClipNodeBase.prototype, "totalDelta", {
            /**
             * 总坐标偏移量
             */
            get: function () {
                if (this._stitchDirty)
                    this.updateStitch();
                return this._totalDelta;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AnimationClipNodeBase.prototype, "looping", {
            /**
             * 是否循环播放
             */
            get: function () {
                return this._looping;
            },
            set: function (value) {
                if (this._looping == value)
                    return;
                this._looping = value;
                this._stitchDirty = true;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AnimationClipNodeBase.prototype, "stitchFinalFrame", {
            /**
             * 是否过渡结束帧
             */
            get: function () {
                return this._stitchFinalFrame;
            },
            set: function (value) {
                if (this._stitchFinalFrame == value)
                    return;
                this._stitchFinalFrame = value;
                this._stitchDirty = true;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AnimationClipNodeBase.prototype, "totalDuration", {
            /**
             * 总持续时间
             */
            get: function () {
                if (this._stitchDirty)
                    this.updateStitch();
                return this._totalDuration;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AnimationClipNodeBase.prototype, "lastFrame", {
            /**
             * 最后帧数
             */
            get: function () {
                if (this._stitchDirty)
                    this.updateStitch();
                return this._lastFrame;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 更新动画播放控制状态
         */
        AnimationClipNodeBase.prototype.updateStitch = function () {
            this._stitchDirty = false;
            this._lastFrame = (this._looping && this._stitchFinalFrame) ? this._numFrames : this._numFrames - 1;
            this._totalDuration = 0;
            this._totalDelta.x = 0;
            this._totalDelta.y = 0;
            this._totalDelta.z = 0;
        };
        return AnimationClipNodeBase;
    }(feng3d.AnimationNodeBase));
    feng3d.AnimationClipNodeBase = AnimationClipNodeBase;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 骨骼动画节点（一般用于一个动画的帧列表）
     * 包含基于时间的动画数据作为单独的骨架构成。
     * @author feng 2014-5-20
     */
    var SkeletonClipNode = (function (_super) {
        __extends(SkeletonClipNode, _super);
        /**
         * 创建骨骼动画节点
         */
        function SkeletonClipNode() {
            _super.call(this);
            this._frames = [];
            this._stateClass = feng3d.SkeletonClipState;
        }
        Object.defineProperty(SkeletonClipNode.prototype, "frames", {
            /**
             * 骨骼姿势动画帧列表
             */
            get: function () {
                return this._frames;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 添加帧到动画
         * @param skeletonPose 骨骼姿势
         * @param duration 持续时间
         */
        SkeletonClipNode.prototype.addFrame = function (skeletonPose, duration) {
            this._frames.push(skeletonPose);
            this._durations.push(duration);
            this._totalDuration += duration;
            this._numFrames = this._durations.length;
            this._stitchDirty = true;
        };
        /**
         * @inheritDoc
         */
        SkeletonClipNode.prototype.updateStitch = function () {
            _super.prototype.updateStitch.call(this);
            var i = this._numFrames - 1;
            var p1, p2, delta;
            while (i--) {
                this._totalDuration += this._durations[i];
                p1 = this._frames[i].jointPoses[0].translation;
                p2 = this._frames[i + 1].jointPoses[0].translation;
                delta = p2.subtract(p1);
                this._totalDelta.x += delta.x;
                this._totalDelta.y += delta.y;
                this._totalDelta.z += delta.z;
            }
            if (this._stitchFinalFrame && this._looping) {
                this._totalDuration += this._durations[this._numFrames - 1];
                if (this._numFrames > 1) {
                    p1 = this._frames[0].jointPoses[0].translation;
                    p2 = this._frames[1].jointPoses[0].translation;
                    delta = p2.subtract(p1);
                    this._totalDelta.x += delta.x;
                    this._totalDelta.y += delta.y;
                    this._totalDelta.z += delta.z;
                }
            }
        };
        return SkeletonClipNode;
    }(feng3d.AnimationClipNodeBase));
    feng3d.SkeletonClipNode = SkeletonClipNode;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * sprite动画剪辑节点
     * @author feng 2015-9-18
     */
    var SpriteSheetClipNode = (function (_super) {
        __extends(SpriteSheetClipNode, _super);
        /**
         * 创建<code>SpriteSheetClipNode</code>实例.
         */
        function SpriteSheetClipNode() {
            _super.call(this);
            this._frames = [];
            this._stateClass = feng3d.SpriteSheetAnimationState;
        }
        Object.defineProperty(SpriteSheetClipNode.prototype, "frames", {
            /**
             * 帧列表
             */
            get: function () {
                return this._frames;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 添加帧到动画节点
         * @param spriteSheetAnimationFrame				sprite动画帧
         * @param duration								间隔时间
         */
        SpriteSheetClipNode.prototype.addFrame = function (spriteSheetAnimationFrame, duration) {
            this._frames.push(spriteSheetAnimationFrame);
            this._durations.push(duration);
            this._numFrames = this._durations.length;
            this._stitchDirty = false;
        };
        return SpriteSheetClipNode;
    }(feng3d.AnimationClipNodeBase));
    feng3d.SpriteSheetClipNode = SpriteSheetClipNode;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * A uv animation node containing time-based animation data as individual uv animation frames.
     */
    /**
     * UV动画剪辑节点
     * @author feng 2014-5-20
     */
    var UVClipNode = (function (_super) {
        __extends(UVClipNode, _super);
        /**
         * 创建<code>UVClipNode</code>实例
         */
        function UVClipNode() {
            _super.call(this);
            this._frames = [];
            this._stateClass = feng3d.UVClipState;
        }
        Object.defineProperty(UVClipNode.prototype, "frames", {
            /**
             * 帧数据列表
             */
            get: function () {
                return this._frames;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 添加帧
         * @param uvFrame				UV动画帧
         * @param duration				间隔时间
         */
        UVClipNode.prototype.addFrame = function (uvFrame, duration) {
            this._frames.push(uvFrame);
            this._durations.push(duration);
            this._numFrames = this._durations.length;
            this._stitchDirty = true;
        };
        /**
         * @inheritDoc
         */
        UVClipNode.prototype.updateStitch = function () {
            _super.prototype.updateStitch.call(this);
            var i;
            if (this._durations.length > 0) {
                i = this._numFrames - 1;
                while (i--)
                    this._totalDuration += this._durations[i];
                if (this._stitchFinalFrame || !this._looping)
                    this._totalDuration += this._durations[this._numFrames - 1];
            }
        };
        return UVClipNode;
    }(feng3d.AnimationClipNodeBase));
    feng3d.UVClipNode = UVClipNode;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 顶点动画剪辑节点
     * @author feng 2014-5-30
     */
    var VertexClipNode = (function (_super) {
        __extends(VertexClipNode, _super);
        /**
         * 创建一个顶点动画剪辑节点
         */
        function VertexClipNode() {
            _super.call(this);
            this._frames = [];
            this._translations = [];
            this._stateClass = feng3d.VertexClipState;
        }
        Object.defineProperty(VertexClipNode.prototype, "frames", {
            /**
             * 帧数据列表
             */
            get: function () {
                return this._frames;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 添加顶点动画帧
         * @param geometry 几何体
         * @param duration 持续时间
         * @param translation 偏移量
         */
        VertexClipNode.prototype.addFrame = function (geometry, duration, translation) {
            if (translation === void 0) { translation = null; }
            this._frames.push(geometry);
            this._durations.push(duration);
            this._translations.push(translation || new feng3d.Vector3D());
            this._numFrames = this._durations.length;
            this._stitchDirty = true;
        };
        /**
         * @inheritDoc
         */
        VertexClipNode.prototype.updateStitch = function () {
            _super.prototype.updateStitch.call(this);
            var i = this._numFrames - 1;
            var p1, p2, delta;
            while (i--) {
                this._totalDuration += this._durations[i];
                p1 = this._translations[i];
                p2 = this._translations[i + 1];
                delta = p2.subtract(p1);
                this._totalDelta.x += delta.x;
                this._totalDelta.y += delta.y;
                this._totalDelta.z += delta.z;
            }
            if (this._stitchFinalFrame && this._looping) {
                this._totalDuration += this._durations[this._numFrames - 1];
                if (this._numFrames > 1) {
                    p1 = this._translations[0];
                    p2 = this._translations[1];
                    delta = p2.subtract(p1);
                    this._totalDelta.x += delta.x;
                    this._totalDelta.y += delta.y;
                    this._totalDelta.z += delta.z;
                }
            }
        };
        return VertexClipNode;
    }(feng3d.AnimationClipNodeBase));
    feng3d.VertexClipNode = VertexClipNode;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 粒子节点
     * @author feng 2014-11-13
     */
    var ParticleNodeBase = (function (_super) {
        __extends(ParticleNodeBase, _super);
        /**
         * 创建一个粒子节点
         * @param animationName		节点名称
         * @param mode				模式
         * @param dataLength		数据长度
         * @param priority			优先级
         */
        function ParticleNodeBase(animationName, mode, dataLength, priority) {
            if (priority === void 0) { priority = 1; }
            _super.call(this);
            this._dataLength = 3;
            this.name = animationName + ParticleNodeBase.MODES[mode];
            this._mode = mode;
            this._priority = priority;
            this._dataLength = dataLength;
            this._oneData = [];
        }
        Object.defineProperty(ParticleNodeBase.prototype, "priority", {
            /**
             * 优先级
             */
            get: function () {
                return this._priority;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ParticleNodeBase.prototype, "dataLength", {
            /**
             * 数据长度
             */
            get: function () {
                return this._dataLength;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ParticleNodeBase.prototype, "oneData", {
            /**
             * 单个粒子数据
             */
            get: function () {
                return this._oneData;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ParticleNodeBase.prototype, "mode", {
            /**
             * 粒子属性模式
             */
            get: function () {
                return this._mode;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 创建单个粒子属性
         */
        ParticleNodeBase.prototype.generatePropertyOfOneParticle = function (param) {
        };
        /**
         * 设置渲染状态
         * @param stage3DProxy			显卡代理
         * @param renderable			渲染实体
         * @param camera				摄像机
         */
        ParticleNodeBase.prototype.setRenderState = function (renderable, camera) {
        };
        /** 模式列表 */
        ParticleNodeBase.MODES = {
            0: ParticleNodeBase.GLOBAL,
            1: ParticleNodeBase.LOCAL_STATIC,
            2: ParticleNodeBase.LOCAL_DYNAMIC //
        };
        //模式名称
        ParticleNodeBase.GLOBAL = 'Global';
        ParticleNodeBase.LOCAL_STATIC = 'LocalStatic';
        ParticleNodeBase.LOCAL_DYNAMIC = 'LocalDynamic';
        return ParticleNodeBase;
    }(feng3d.AnimationNodeBase));
    feng3d.ParticleNodeBase = ParticleNodeBase;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 广告牌节点
     * @author feng 2014-11-13
     */
    var ParticleBillboardNode = (function (_super) {
        __extends(ParticleBillboardNode, _super);
        /**
         * 创建一个广告牌节点
         * @param billboardAxis
         */
        function ParticleBillboardNode(billboardAxis) {
            if (billboardAxis === void 0) { billboardAxis = null; }
            _super.call(this, "ParticleBillboard", feng3d.ParticlePropertiesMode.GLOBAL, 0, 4);
            this._matrix = new feng3d.Matrix3D;
            this.billboardAxis = billboardAxis;
        }
        /**
         * 顶点数据编号
         */
        ParticleBillboardNode.prototype.getVaId = function () {
            return "";
        };
        /**
         * 顶点数据长度
         */
        ParticleBillboardNode.prototype.getVaLen = function () {
            return 0;
        };
        /**
         * @inheritDoc
         */
        ParticleBillboardNode.prototype.initBuffers = function () {
            _super.prototype.initBuffers.call(this);
            this.context3DBufferOwner.mapContext3DBuffer(this._.particleBillboard_vc_matrix, this.updateBillboardMatrixBuffer);
        };
        ParticleBillboardNode.prototype.updateBillboardMatrixBuffer = function (billboardMatrixBuffer) {
            billboardMatrixBuffer.update(this._matrix, true);
        };
        /**
         * @inheritDoc
         */
        ParticleBillboardNode.prototype.setRenderState = function (renderable, camera) {
            var comps;
            if (this._billboardAxis) {
                var pos = renderable.sourceEntity.sceneTransform.position;
                var look = camera.sceneTransform.position.subtract(pos);
                var right = look.crossProduct(this._billboardAxis);
                right.normalize();
                look = this._billboardAxis.crossProduct(right);
                look.normalize();
                //create a quick inverse projection matrix
                this._matrix.copyFrom(renderable.sourceEntity.sceneTransform);
                comps = feng3d.Matrix3DUtils.decompose(this._matrix, feng3d.Orientation3D.AXIS_ANGLE);
                this._matrix.copyColumnFrom(0, right);
                this._matrix.copyColumnFrom(1, this._billboardAxis);
                this._matrix.copyColumnFrom(2, look);
                this._matrix.copyColumnFrom(3, pos);
                this._matrix.appendRotation(-comps[1].w * feng3d.MathConsts.RADIANS_TO_DEGREES, comps[1]);
            }
            else {
                //create a quick inverse projection matrix
                this._matrix.copyFrom(renderable.sourceEntity.sceneTransform);
                this._matrix.append(camera.inverseSceneTransform);
                //decompose using axis angle rotations
                comps = feng3d.Matrix3DUtils.decompose(this._matrix, feng3d.Orientation3D.AXIS_ANGLE);
                //recreate the matrix with just the rotation data
                this._matrix.identity();
                this._matrix.appendRotation(-comps[1].w * feng3d.MathConsts.RADIANS_TO_DEGREES, comps[1]);
            }
            this.context3DBufferOwner.markBufferDirty(this._.particleBillboard_vc_matrix);
        };
        Object.defineProperty(ParticleBillboardNode.prototype, "billboardAxis", {
            /**
             * 广告牌轴线
             */
            get: function () {
                return this._billboardAxis;
            },
            set: function (value) {
                this._billboardAxis = value ? value.clone() : null;
                if (this._billboardAxis)
                    this._billboardAxis.normalize();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        ParticleBillboardNode.prototype.processAnimationSetting = function (shaderParams) {
            var particleShaderParams = shaderParams.getOrCreateComponentByClass(feng3d.ParticleShaderParams);
            particleShaderParams.changePosition++;
            particleShaderParams[this.name] = true;
        };
        return ParticleBillboardNode;
    }(feng3d.ParticleNodeBase));
    feng3d.ParticleBillboardNode = ParticleBillboardNode;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 粒子颜色节点
     * @author feng 2015-1-20
     */
    var ParticleColorNode = (function (_super) {
        __extends(ParticleColorNode, _super);
        /**
         * 创建一个粒子颜色节点
         * @param mode					属性模式
         * @param usesMultiplier		是否使用Multiplier数据对渲染中颜色进行变换
         * @param usesOffset			是否使用offset数据对渲染中颜色进行变换
         * @param usesCycle
         * @param usesPhase
         * @param startColor			开始颜色数据
         * @param endColor				结束颜色数据
         * @param cycleDuration
         * @param cyclePhase
         */
        function ParticleColorNode(mode, usesMultiplier, usesOffset, usesCycle, usesPhase, startColor, endColor, cycleDuration, cyclePhase) {
            if (usesMultiplier === void 0) { usesMultiplier = true; }
            if (usesOffset === void 0) { usesOffset = true; }
            if (usesCycle === void 0) { usesCycle = false; }
            if (usesPhase === void 0) { usesPhase = false; }
            if (startColor === void 0) { startColor = null; }
            if (endColor === void 0) { endColor = null; }
            if (cycleDuration === void 0) { cycleDuration = 1; }
            if (cyclePhase === void 0) { cyclePhase = 0; }
            _super.call(this, "ParticleColor", mode, (usesMultiplier && usesOffset) ? 16 : 8, feng3d.ParticleAnimationSet.COLOR_PRIORITY);
            this._usesMultiplier = usesMultiplier;
            this._usesOffset = usesOffset;
            this._startColor = startColor || new feng3d.ColorTransform();
            this._endColor = endColor || new feng3d.ColorTransform();
            this.updateColorData();
        }
        /**
          * 顶点数据编号
          */
        ParticleColorNode.prototype.getVaId = function () {
            return "";
        };
        /**
         * 顶点数据长度
         */
        ParticleColorNode.prototype.getVaLen = function () {
            return 0;
        };
        /**
         * @inheritDoc
         */
        ParticleColorNode.prototype.initBuffers = function () {
            _super.prototype.initBuffers.call(this);
            if (this.mode == feng3d.ParticlePropertiesMode.GLOBAL) {
                this.context3DBufferOwner.mapContext3DBuffer(this._.particleStartColorMultiplier_vc_vector, this.updateStartColorMultiplierConstBuffer);
                this.context3DBufferOwner.mapContext3DBuffer(this._.particleDeltaColorMultiplier_vc_vector, this.updateDeltaColorMultiplierConstBuffer);
                this.context3DBufferOwner.mapContext3DBuffer(this._.particleStartColorOffset_vc_vector, this.updateStartColorOffsetConstBuffer);
                this.context3DBufferOwner.mapContext3DBuffer(this._.particleDeltaColorOffset_vc_vector, this.updateDeltaColorOffsetConstBuffer);
            }
        };
        ParticleColorNode.prototype.updateStartColorMultiplierConstBuffer = function (vcVectorBuffer) {
            vcVectorBuffer.update(this._startMultiplierData);
        };
        ParticleColorNode.prototype.updateDeltaColorMultiplierConstBuffer = function (vcVectorBuffer) {
            vcVectorBuffer.update(this._deltaMultiplierData);
        };
        ParticleColorNode.prototype.updateStartColorOffsetConstBuffer = function (vcVectorBuffer) {
            vcVectorBuffer.update(this._startOffsetData);
        };
        ParticleColorNode.prototype.updateDeltaColorOffsetConstBuffer = function (vcVectorBuffer) {
            vcVectorBuffer.update(this._deltaOffsetData);
        };
        /**
         * @inheritDoc
         */
        ParticleColorNode.prototype.generatePropertyOfOneParticle = function (param) {
            var startColor = param[ParticleColorNode.COLOR_START_COLORTRANSFORM];
            if (!startColor)
                throw (new Error("there is no " + ParticleColorNode.COLOR_START_COLORTRANSFORM + " in param!"));
            var endColor = param[ParticleColorNode.COLOR_END_COLORTRANSFORM];
            if (!endColor)
                throw (new Error("there is no " + ParticleColorNode.COLOR_END_COLORTRANSFORM + " in param!"));
            var i;
            //multiplier
            if (this._usesMultiplier) {
                this._oneData[i++] = startColor.redMultiplier;
                this._oneData[i++] = startColor.greenMultiplier;
                this._oneData[i++] = startColor.blueMultiplier;
                this._oneData[i++] = startColor.alphaMultiplier;
                this._oneData[i++] = endColor.redMultiplier - startColor.redMultiplier;
                this._oneData[i++] = endColor.greenMultiplier - startColor.greenMultiplier;
                this._oneData[i++] = endColor.blueMultiplier - startColor.blueMultiplier;
                this._oneData[i++] = endColor.alphaMultiplier - startColor.alphaMultiplier;
            }
            //offset
            if (this._usesOffset) {
                this._oneData[i++] = startColor.redOffset / 255;
                this._oneData[i++] = startColor.greenOffset / 255;
                this._oneData[i++] = startColor.blueOffset / 255;
                this._oneData[i++] = startColor.alphaOffset / 255;
                this._oneData[i++] = (endColor.redOffset - startColor.redOffset) / 255;
                this._oneData[i++] = (endColor.greenOffset - startColor.greenOffset) / 255;
                this._oneData[i++] = (endColor.blueOffset - startColor.blueOffset) / 255;
                this._oneData[i++] = (endColor.alphaOffset - startColor.alphaOffset) / 255;
            }
        };
        /**
         * 更新颜色数据
         */
        ParticleColorNode.prototype.updateColorData = function () {
            if (this.mode == feng3d.ParticlePropertiesMode.GLOBAL) {
                if (this._usesMultiplier) {
                    this._startMultiplierData = ([this._startColor.redMultiplier, this._startColor.greenMultiplier, this._startColor.blueMultiplier, this._startColor.alphaMultiplier]);
                    this._deltaMultiplierData = ([(this._endColor.redMultiplier - this._startColor.redMultiplier), (this._endColor.greenMultiplier - this._startColor.greenMultiplier), (this._endColor.blueMultiplier - this._startColor.blueMultiplier), (this._endColor.alphaMultiplier - this._startColor.alphaMultiplier)]);
                }
                if (this._usesOffset) {
                    this._startOffsetData = ([this._startColor.redOffset / 255, this._startColor.greenOffset / 255, this._startColor.blueOffset / 255, this._startColor.alphaOffset / 255]);
                    this._deltaOffsetData = ([(this._endColor.redOffset - this._startColor.redOffset) / 255, (this._endColor.greenOffset - this._startColor.greenOffset) / 255, (this._endColor.blueOffset - this._startColor.blueOffset) / 255, (this._endColor.alphaOffset - this._startColor.alphaOffset) / 255]);
                }
            }
        };
        /**
         * @inheritDoc
         */
        ParticleColorNode.prototype.processAnimationSetting = function (shaderParams) {
            var particleShaderParams = shaderParams.getOrCreateComponentByClass(feng3d.ParticleShaderParams);
            particleShaderParams.changeColor++;
            particleShaderParams[this.name] = true;
        };
        /**
         * 开始颜色属性
         */
        ParticleColorNode.COLOR_START_COLORTRANSFORM = "ColorStartColorTransform";
        /**
         * 结束颜色属性
         */
        ParticleColorNode.COLOR_END_COLORTRANSFORM = "ColorEndColorTransform";
        return ParticleColorNode;
    }(feng3d.ParticleNodeBase));
    feng3d.ParticleColorNode = ParticleColorNode;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 粒子缩放节点
     * @author feng 2015-1-15
     */
    var ParticleScaleNode = (function (_super) {
        __extends(ParticleScaleNode, _super);
        /**
         * 创建一个粒子缩放节点
         * @param mode				模式
         * @param usesCycle
         * @param usesPhase
         * @param minScale			最小缩放
         * @param maxScale			最大缩放
         * @param cycleDuration
         * @param cyclePhase
         */
        function ParticleScaleNode(mode, usesCycle, usesPhase, minScale, maxScale, cycleDuration, cyclePhase) {
            if (minScale === void 0) { minScale = 1; }
            if (maxScale === void 0) { maxScale = 1; }
            if (cycleDuration === void 0) { cycleDuration = 1; }
            if (cyclePhase === void 0) { cyclePhase = 0; }
            var len = 2;
            if (usesCycle)
                len++;
            if (usesPhase)
                len++;
            _super.call(this, "ParticleScale", mode, len, 3);
            this._minScale = minScale;
            this._maxScale = maxScale;
            this.updateScaleData();
        }
        /**
         * 顶点数据编号
         */
        ParticleScaleNode.prototype.getVaId = function () {
            return "";
        };
        /**
         * 顶点数据长度
         */
        ParticleScaleNode.prototype.getVaLen = function () {
            return 0;
        };
        Object.defineProperty(ParticleScaleNode.prototype, "minScale", {
            /**
             * 最小缩放
             */
            get: function () {
                return this._minScale;
            },
            set: function (value) {
                this._minScale = value;
                this.updateScaleData();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ParticleScaleNode.prototype, "maxScale", {
            /**
             * 最大缩放
             */
            get: function () {
                return this._maxScale;
            },
            set: function (value) {
                this._maxScale = value;
                this.updateScaleData();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        ParticleScaleNode.prototype.initBuffers = function () {
            _super.prototype.initBuffers.call(this);
            if (this.mode == feng3d.ParticlePropertiesMode.GLOBAL)
                this.context3DBufferOwner.mapContext3DBuffer(this._.particleScale_vc_vector, this.updateVelocityConstBuffer);
        };
        ParticleScaleNode.prototype.updateVelocityConstBuffer = function (velocityConstBuffer) {
            velocityConstBuffer.update(this._scaleData);
        };
        ParticleScaleNode.prototype.updateScaleData = function () {
            if (this.mode == feng3d.ParticlePropertiesMode.GLOBAL) {
                this._scaleData = [this._minScale, this._maxScale - this._minScale, 0, 0];
            }
        };
        /**
         * @inheritDoc
         */
        ParticleScaleNode.prototype.generatePropertyOfOneParticle = function (param) {
            var scale = param[ParticleScaleNode.SCALE_VECTOR3D];
            if (!scale)
                throw (new Error("there is no " + ParticleScaleNode.SCALE_VECTOR3D + " in param!"));
            this._oneData[0] = scale.x;
            this._oneData[1] = scale.y - scale.x;
        };
        /**
         * @inheritDoc
         */
        ParticleScaleNode.prototype.processAnimationSetting = function (shaderParams) {
            var particleShaderParams = shaderParams.getOrCreateComponentByClass(feng3d.ParticleShaderParams);
            particleShaderParams.changePosition++;
            particleShaderParams[this.name] = true;
        };
        /**
         * 缩放属性名
         */
        ParticleScaleNode.SCALE_VECTOR3D = "ScaleVector3D";
        return ParticleScaleNode;
    }(feng3d.ParticleNodeBase));
    feng3d.ParticleScaleNode = ParticleScaleNode;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 粒子时间节点
     * @author feng 2014-11-17
     */
    var ParticleTimeNode = (function (_super) {
        __extends(ParticleTimeNode, _super);
        /**
         * 创建一个粒子时间节点
         * @param usesDuration	是否持续
         * @param usesLooping	是否延时
         * @param usesDelay		是否循环
         */
        function ParticleTimeNode() {
            _super.call(this, "ParticleTime", feng3d.ParticlePropertiesMode.LOCAL_STATIC, 4, 0);
        }
        /**
         * @inheritDoc
         */
        ParticleTimeNode.prototype.getVaId = function () {
            return this._.particleTime_va_4;
        };
        /**
         * @inheritDoc
         */
        ParticleTimeNode.prototype.getVaLen = function () {
            return 4;
        };
        /**
         * @inheritDoc
         */
        ParticleTimeNode.prototype.generatePropertyOfOneParticle = function (param) {
            this._oneData[0] = param.startTime;
            this._oneData[1] = param.duration;
            this._oneData[2] = param.delay + param.duration;
            this._oneData[3] = 1 / param.duration;
        };
        /**
         * @inheritDoc
         */
        ParticleTimeNode.prototype.processAnimationSetting = function (shaderParams) {
            var particleShaderParams = shaderParams.getOrCreateComponentByClass(feng3d.ParticleShaderParams);
            particleShaderParams[this.name] = true;
        };
        return ParticleTimeNode;
    }(feng3d.ParticleNodeBase));
    feng3d.ParticleTimeNode = ParticleTimeNode;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 粒子速度节点
     * @author feng 2014-11-13
     */
    var ParticleVelocityNode = (function (_super) {
        __extends(ParticleVelocityNode, _super);
        /**
         * 创建一个粒子速度节点
         * @param mode		模式
         * @param velocity	粒子速度
         */
        function ParticleVelocityNode(mode, velocity) {
            if (velocity === void 0) { velocity = null; }
            _super.call(this, "ParticleVelocity", mode, 3);
            /** 粒子速度 */
            this._velocity = [1, 1, 1, 0];
            if (velocity) {
                this._velocity[0] = velocity.x;
                this._velocity[1] = velocity.y;
                this._velocity[2] = velocity.z;
            }
            else {
                this._velocity[0] = 0;
                this._velocity[1] = 0;
                this._velocity[2] = 0;
            }
        }
        /**
         * @inheritDoc
         */
        ParticleVelocityNode.prototype.getVaId = function () {
            return this._.particleVelocity_va_3;
        };
        /**
         * @inheritDoc
         */
        ParticleVelocityNode.prototype.getVaLen = function () {
            return 3;
        };
        /**
         * @inheritDoc
         */
        ParticleVelocityNode.prototype.initBuffers = function () {
            _super.prototype.initBuffers.call(this);
            if (this.mode == feng3d.ParticlePropertiesMode.GLOBAL)
                this.context3DBufferOwner.mapContext3DBuffer(this._.particleVelocity_vc_vector, this.updateVelocityConstBuffer);
        };
        ParticleVelocityNode.prototype.updateVelocityConstBuffer = function (velocityConstBuffer) {
            velocityConstBuffer.update(this._velocity);
        };
        /**
         * @inheritDoc
         */
        ParticleVelocityNode.prototype.generatePropertyOfOneParticle = function (param) {
            var _tempVelocity = param[ParticleVelocityNode.VELOCITY_VECTOR3D];
            if (!_tempVelocity)
                throw new Error("there is no " + ParticleVelocityNode.VELOCITY_VECTOR3D + " in param!");
            this._oneData[0] = _tempVelocity.x;
            this._oneData[1] = _tempVelocity.y;
            this._oneData[2] = _tempVelocity.z;
        };
        /**
         * @inheritDoc
         */
        ParticleVelocityNode.prototype.processAnimationSetting = function (shaderParams) {
            var particleShaderParams = shaderParams.getOrCreateComponentByClass(feng3d.ParticleShaderParams);
            particleShaderParams.changePosition++;
            particleShaderParams[this.name] = true;
        };
        /**
         * 粒子的速度属性
         */
        ParticleVelocityNode.VELOCITY_VECTOR3D = "VelocityVector3D";
        return ParticleVelocityNode;
    }(feng3d.ParticleNodeBase));
    feng3d.ParticleVelocityNode = ParticleVelocityNode;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 两个骨骼动画节点间进行线性插值得出骨骼姿势
     * @author feng 2014-5-20
     */
    var SkeletonBinaryLERPNode = (function (_super) {
        __extends(SkeletonBinaryLERPNode, _super);
        /**
         * 创建<code>SkeletonBinaryLERPNode</code>对象
         */
        function SkeletonBinaryLERPNode() {
            _super.call(this);
            this._stateClass = feng3d.SkeletonBinaryLERPState;
        }
        /**
         * @inheritDoc
         */
        SkeletonBinaryLERPNode.prototype.getAnimationState = function (animator) {
            return animator.getAnimationState(this);
        };
        return SkeletonBinaryLERPNode;
    }(feng3d.AnimationNodeBase));
    feng3d.SkeletonBinaryLERPNode = SkeletonBinaryLERPNode;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 淡入淡出变换节点
     * @author feng 2014-5-20
     */
    var CrossfadeTransitionNode = (function (_super) {
        __extends(CrossfadeTransitionNode, _super);
        /**
         * 创建<code>CrossfadeTransitionNode</code>实例
         */
        function CrossfadeTransitionNode() {
            _super.call(this);
            this._stateClass = feng3d.CrossfadeTransitionState;
        }
        return CrossfadeTransitionNode;
    }(feng3d.SkeletonBinaryLERPNode));
    feng3d.CrossfadeTransitionNode = CrossfadeTransitionNode;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 动画集合基类
     * @author feng 2014-5-20
     */
    var AnimationSetBase = (function (_super) {
        __extends(AnimationSetBase, _super);
        /**
         * 创建一个动画集合基类
         */
        function AnimationSetBase() {
            _super.call(this);
            /** 动画节点列表 */
            this._animations = [];
            /** 动画名称列表 */
            this._animationNames = [];
            /** 动画字典 */
            this._animationDictionary = {};
            this._namedAsset = new feng3d.NamedAsset(this, feng3d.AssetType.ANIMATION_SET);
            this.context3DBufferOwner = new feng3d.Context3DBufferOwner();
            this.initBuffers();
        }
        /**
         * 初始化Context3d缓存
         */
        AnimationSetBase.prototype.initBuffers = function () {
        };
        Object.defineProperty(AnimationSetBase.prototype, "_", {
            /**
             * Fagal编号中心
             */
            get: function () {
                return feng3d.FagalIdCenter.instance;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AnimationSetBase.prototype, "usesCPU", {
            /**
             * 是否使用CPU
             */
            get: function () {
                return this._usesCPU;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AnimationSetBase.prototype, "animations", {
            /**
             * Returns a vector of animation state objects that make up the contents of the animation data set.
             */
            get: function () {
                return this._animations;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 添加动画
         * @param node 动画节点
         */
        AnimationSetBase.prototype.addAnimation = function (node) {
            if (this._animationDictionary[node.name])
                throw new feng3d.AnimationSetError("root node animationName '" + node.name + "' already exists in the set");
            this._animationDictionary[node.name] = node;
            this._animations.push(node);
            this._animationNames.push(node.name);
        };
        /**
         * 获取动画节点
         * @param name 动画名称
         * @return 动画节点
         */
        AnimationSetBase.prototype.getAnimation = function (animationName) {
            return this._animationDictionary[animationName];
        };
        /**
         * 是否有某动画
         * @param name 动画名称
         */
        AnimationSetBase.prototype.hasAnimation = function (animationName) {
            return this._animationDictionary[animationName] != null;
        };
        /**
         * 重置使用GPU
         */
        AnimationSetBase.prototype.resetGPUCompatibility = function () {
            this._usesCPU = false;
        };
        /**
         * 取消使用GPU
         */
        AnimationSetBase.prototype.cancelGPUCompatibility = function () {
            this._usesCPU = true;
        };
        Object.defineProperty(AnimationSetBase.prototype, "namedAsset", {
            get: function () {
                return this._namedAsset;
            },
            enumerable: true,
            configurable: true
        });
        return AnimationSetBase;
    }(feng3d.Component));
    feng3d.AnimationSetBase = AnimationSetBase;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 粒子动画set
     * @author feng 2014-11-13
     */
    var ParticleAnimationSet = (function (_super) {
        __extends(ParticleAnimationSet, _super);
        /**
         * 创建一个粒子动画集合
         * @param usesDuration	是否持续
         * @param usesLooping	是否循环
         * @param usesDelay		是否延时
         */
        function ParticleAnimationSet(usesDuration, usesLooping, usesDelay) {
            if (usesDuration === void 0) { usesDuration = false; }
            if (usesLooping === void 0) { usesLooping = false; }
            if (usesDelay === void 0) { usesDelay = false; }
            _super.call(this);
            this._particleNodes = [];
            this._localStaticNodes = [];
            /** 动画节点列表 */
            this._effects = [];
            /** 动画名称列表 */
            this._effectNames = [];
            /** 动画字典 */
            this._effectDictionary = {};
            this._usesDuration = false;
            this._usesLooping = false;
            this._usesDelay = false;
            this._usesDuration = usesDuration;
            this._usesLooping = usesLooping;
            this._usesDelay = usesDelay;
            //自动添加一个粒子的时间节点
            this.addParticleEffect(this._timeNode = new feng3d.ParticleTimeNode());
        }
        Object.defineProperty(ParticleAnimationSet.prototype, "particleNodes", {
            /**
             * 粒子节点列表
             */
            get: function () {
                return this._particleNodes;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 添加粒子特效
         * @param node
         */
        ParticleAnimationSet.prototype.addParticleEffect = function (node) {
            var i;
            if (node.mode == feng3d.ParticlePropertiesMode.LOCAL_STATIC) {
                this._localStaticNodes.push(node);
            }
            for (i = this._particleNodes.length - 1; i >= 0; i--) {
                if (this._particleNodes[i].priority <= node.priority)
                    break;
            }
            this._particleNodes.splice(i + 1, 0, node);
            this._effectDictionary[node.name] = node;
            this._effects.push(node);
            this.context3DBufferOwner.addChildBufferOwner(node.context3DBufferOwner);
            this._effectNames.push(node.name);
        };
        /**
         * @inheritDoc
         */
        ParticleAnimationSet.prototype.activate = function (shaderParams, pass) {
            var particleShaderParams = shaderParams.getOrCreateComponentByClass(feng3d.ParticleShaderParams);
            particleShaderParams.usesDuration = this._usesDuration;
            particleShaderParams.usesLooping = this._usesLooping;
            particleShaderParams.usesDelay = this._usesDelay;
            for (var i = 0; i < this._effects.length; i++) {
                this._effects[i].processAnimationSetting(shaderParams);
            }
            var animationShaderParams = shaderParams.getOrCreateComponentByClass(feng3d.AnimationShaderParams);
            animationShaderParams.animationType = feng3d.AnimationType.PARTICLE;
        };
        /**
         * 生成粒子动画数据
         * @param mesh
         */
        ParticleAnimationSet.prototype.generateAnimationSubGeometries = function (mesh) {
            var _this = this;
            if (this.initParticleFunc == null)
                throw (new Error("no this.initParticleFunc set"));
            var geometry = mesh.geometry;
            if (!geometry)
                throw (new Error("Particle animation can only be performed on a ParticleGeometry object"));
            var i;
            var particleSubGeometry;
            var subGeometry;
            var localNode;
            //注册顶点数据
            mesh.subMeshes.forEach(function (subMesh) {
                particleSubGeometry = new feng3d.AnimationSubGeometry();
                //遍历静态本地节点
                _this._localStaticNodes.forEach(function (localNode) {
                    particleSubGeometry.mapVABuffer(localNode.getVaId(), localNode.getVaLen());
                });
                particleSubGeometry.numVertices = subMesh.subGeometry.numVertices;
                subMesh.animationSubGeometry = particleSubGeometry;
            });
            //粒子数据
            var particles = geometry.particles;
            //粒子数量
            var numParticles = geometry.numParticles;
            //粒子属性
            var particleProperties = new feng3d.ParticleProperties();
            var particle;
            var counterForVertex;
            var counterForOneData;
            var oneData;
            var numVertices;
            var vertexOffset;
            //设置默认数据
            particleProperties.total = numParticles;
            particleProperties.startTime = 0;
            particleProperties.duration = 1000;
            particleProperties.delay = 0.1;
            i = 0;
            while (i < numParticles) {
                particleProperties.index = i;
                particle = particles[i];
                //调用函数初始化粒子属性
                this.initParticleFunc(particleProperties);
                //创建本地节点粒子属性
                this._localStaticNodes.forEach(function (localNode) {
                    localNode.generatePropertyOfOneParticle(particleProperties);
                });
                for (var i = 0; i < mesh.subMeshes.length; i++) {
                    var subMesh = mesh.subMeshes[i];
                    if (subMesh.subGeometry == particle.subGeometry) {
                        particleSubGeometry = subMesh.animationSubGeometry;
                        break;
                    }
                }
                numVertices = particle.numVertices;
                //遍历静态本地节点
                this._localStaticNodes.forEach(function (localNode) {
                    oneData = localNode.oneData;
                    /** 粒子所在子几何体的顶点位置 */
                    var startVertexIndex = particle.startVertexIndex;
                    var vaData = particleSubGeometry.getVAData(localNode.getVaId());
                    var vaLen = particleSubGeometry.getVALen(localNode.getVaId());
                    //收集该粒子的每个顶点数据
                    for (var j = 0; j < numVertices; j++) {
                        vertexOffset = (startVertexIndex + j) * vaLen;
                        for (counterForOneData = 0; counterForOneData < vaLen; counterForOneData++)
                            vaData[vertexOffset + counterForOneData] = oneData[counterForOneData];
                    }
                });
                //下一个粒子
                i++;
            }
        };
        /**
         * 设置渲染状态
         * @param renderable		可渲染对象
         * @param camera			摄像机
         */
        ParticleAnimationSet.prototype.setRenderState = function (renderable, camera) {
            for (var i = 0; i < this._particleNodes.length; i++) {
                this._particleNodes[i].setRenderState(renderable, camera);
            }
        };
        /**
         * 颜色优先级
         */
        ParticleAnimationSet.COLOR_PRIORITY = 18;
        return ParticleAnimationSet;
    }(feng3d.AnimationSetBase));
    feng3d.ParticleAnimationSet = ParticleAnimationSet;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 骨骼动画集合
     * @author feng 2014-5-20
     */
    var SkeletonAnimationSet = (function (_super) {
        __extends(SkeletonAnimationSet, _super);
        /**
         * 创建一个骨骼动画集合
         * @param jointsPerVertex 每个顶点关联关节的数量
         */
        function SkeletonAnimationSet(jointsPerVertex) {
            if (jointsPerVertex === void 0) { jointsPerVertex = 4; }
            _super.call(this);
            this._jointsPerVertex = jointsPerVertex;
        }
        Object.defineProperty(SkeletonAnimationSet.prototype, "jointsPerVertex", {
            /**
             * 每个顶点关联关节的数量
             */
            get: function () {
                return this._jointsPerVertex;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        SkeletonAnimationSet.prototype.activate = function (shaderParams, pass) {
            var animationShaderParams = shaderParams.getOrCreateComponentByClass(feng3d.AnimationShaderParams);
            animationShaderParams.numJoints = this._numJoints;
            animationShaderParams.jointsPerVertex = this._jointsPerVertex;
            if (this.usesCPU)
                animationShaderParams.animationType = feng3d.AnimationType.SKELETON_CPU;
            else
                animationShaderParams.animationType = feng3d.AnimationType.SKELETON_GPU;
        };
        Object.defineProperty(SkeletonAnimationSet.prototype, "numJoints", {
            /**
             * 设置关节数量
             */
            set: function (value) {
                this._numJoints = value;
            },
            enumerable: true,
            configurable: true
        });
        return SkeletonAnimationSet;
    }(feng3d.AnimationSetBase));
    feng3d.SkeletonAnimationSet = SkeletonAnimationSet;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * sprite动画集合
     * @author feng 2015-9-18
     */
    var SpriteSheetAnimationSet = (function (_super) {
        __extends(SpriteSheetAnimationSet, _super);
        /**
         * 创建sprite动画集合
         */
        function SpriteSheetAnimationSet() {
            _super.call(this);
        }
        /**
         * @inheritDoc
         */
        SpriteSheetAnimationSet.prototype.activate = function (shaderParams, pass) {
            var animationShaderParams = shaderParams.getOrCreateComponentByClass(feng3d.AnimationShaderParams);
            animationShaderParams.useSpriteSheetAnimation++;
        };
        return SpriteSheetAnimationSet;
    }(feng3d.AnimationSetBase));
    feng3d.SpriteSheetAnimationSet = SpriteSheetAnimationSet;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * UV动画集合
     * @author feng 2014-5-20
     */
    var UVAnimationSet = (function (_super) {
        __extends(UVAnimationSet, _super);
        /**
         * 创建UV动画集合实例
         */
        function UVAnimationSet() {
            _super.call(this);
        }
        /**
         * @inheritDoc
         */
        UVAnimationSet.prototype.activate = function (shaderParams, pass) {
            var animationShaderParams = shaderParams.getOrCreateComponentByClass(feng3d.AnimationShaderParams);
            animationShaderParams.useUVAnimation++;
        };
        return UVAnimationSet;
    }(feng3d.AnimationSetBase));
    feng3d.UVAnimationSet = UVAnimationSet;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 顶点动画集合
     * @author feng 2014-5-30
     */
    var VertexAnimationSet = (function (_super) {
        __extends(VertexAnimationSet, _super);
        /**
         * 创建一个顶点动画集合
         * @param numPoses		姿势数量
         */
        function VertexAnimationSet(numPoses) {
            if (numPoses === void 0) { numPoses = 2; }
            _super.call(this);
            this._numPoses = numPoses;
        }
        Object.defineProperty(VertexAnimationSet.prototype, "numPoses", {
            /**
             * 姿势数量
             */
            get: function () {
                return this._numPoses;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        VertexAnimationSet.prototype.activate = function (shaderParams, pass) {
            var animationShaderParams = shaderParams.getOrCreateComponentByClass(feng3d.AnimationShaderParams);
            if (this.getUsesCPU())
                animationShaderParams.animationType = feng3d.AnimationType.VERTEX_CPU;
            else
                animationShaderParams.animationType = feng3d.AnimationType.VERTEX_GPU;
        };
        return VertexAnimationSet;
    }(feng3d.AnimationSetBase));
    feng3d.VertexAnimationSet = VertexAnimationSet;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 当开始播放动画时触发
     * @eventType me.feng3d.events.AnimatorEvent
     */
    //[Event(name = "start", type = "me.feng3d.events.AnimatorEvent")]
    /**
     * 当动画停止时触发
     * @eventType me.feng3d.events.AnimatorEvent
     */
    //[Event(name = "stop", type = "me.feng3d.events.AnimatorEvent")]
    /**
     * 当动画播放完一次时触发
     * @eventType me.feng3d.events.AnimatorEvent
     */
    //[Event(name = "cycle_complete", type = "me.feng3d.events.AnimatorEvent")]
    /**
     * 动画基类
     * @author feng 2014-5-27
     */
    var AnimatorBase = (function (_super) {
        __extends(AnimatorBase, _super);
        /**
         * 创建一个动画基类
         * @param animationSet
         */
        function AnimatorBase(animationSet) {
            _super.call(this);
            this._autoUpdate = true;
            /** 播放速度 */
            this._playbackSpeed = 1;
            this._owners = [];
            this._animationStates = {};
            /**
             * 是否更新位置
             * @see me.feng3d.animators.base.states.IAnimationState#positionDelta
             */
            this.updatePosition = true;
            this._namedAsset = new feng3d.NamedAsset(this, feng3d.AssetType.ANIMATOR);
            this.context3DBufferOwner = new feng3d.Context3DBufferOwner();
            this._animationSet = animationSet;
            this.initBuffers();
        }
        /**
         * 初始化Context3d缓存
         */
        AnimatorBase.prototype.initBuffers = function () {
        };
        Object.defineProperty(AnimatorBase.prototype, "_", {
            /**
             * Fagal编号中心
             */
            get: function () {
                return feng3d.FagalIdCenter.instance;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 获取动画状态
         * @param node		动画节点
         * @return			动画状态
         */
        AnimatorBase.prototype.getAnimationState = function (node) {
            var cls = node.stateClass;
            var className = feng3d.getQualifiedClassName(cls);
            if (this._animationStates[className] == null)
                this._animationStates[className] = new cls(this, node);
            return this._animationStates[className];
        };
        /**
         * 根据名字获取动画状态
         * @param name			动作名称
         * @return				动画状态
         */
        AnimatorBase.prototype.getAnimationStateByName = function (name) {
            return this.getAnimationState(this._animationSet.getAnimation(name));
        };
        Object.defineProperty(AnimatorBase.prototype, "absoluteTime", {
            /**
             * 绝对时间（游戏时间）
             * @see #time
             * @see #playbackSpeed
             */
            get: function () {
                return this._absoluteTime;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AnimatorBase.prototype, "animationSet", {
            /**
             * 动画设置
             */
            get: function () {
                return this._animationSet;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AnimatorBase.prototype, "activeState", {
            /**
             * 活动的动画状态
             */
            get: function () {
                return this._activeState;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AnimatorBase.prototype, "activeAnimation", {
            /**
             * 活动的动画节点
             */
            get: function () {
                return this._animationSet.getAnimation(this._activeAnimationName);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AnimatorBase.prototype, "activeAnimationName", {
            /**
             * 活动的动作名
             */
            get: function () {
                return this._activeAnimationName;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AnimatorBase.prototype, "autoUpdate", {
            /**
             * 是否自动更新，当值为true时，动画将会随时间播放
             * @see #time
             * @see #update()
             */
            get: function () {
                return this._autoUpdate;
            },
            set: function (value) {
                if (this._autoUpdate == value)
                    return;
                this._autoUpdate = value;
                if (this._autoUpdate)
                    this.start();
                else
                    this.stop();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AnimatorBase.prototype, "time", {
            /**
             * 动画时间
             */
            get: function () {
                return this._time;
            },
            set: function (value) {
                if (this._time == value)
                    return;
                this.update(value);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 设置当前活动状态的动画剪辑的播放进度(0,1)
         * @param	播放进度。 0：动画起点，1：动画终点。
         */
        AnimatorBase.prototype.phase = function (value) {
            this._activeState.phase(value);
        };
        Object.defineProperty(AnimatorBase.prototype, "playbackSpeed", {
            /**
             * The amount by which passed time should be scaled. Used to slow down or speed up animations. Defaults to 1.
             */
            /**
             * 播放速度
             * <p>默认为1，表示正常速度</p>
             */
            get: function () {
                return this._playbackSpeed;
            },
            set: function (value) {
                this._playbackSpeed = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 开始动画，当自动更新为true时有效
         * @see #autoUpdate
         */
        AnimatorBase.prototype.start = function () {
            if (this._isPlaying || !this._autoUpdate)
                return;
            this._time = this._absoluteTime = getTimer();
            this._isPlaying = true;
            if (!feng3d.$ticker.hasEventListener(feng3d.Event.ENTER_FRAME))
                feng3d.$ticker.addEventListener(feng3d.Event.ENTER_FRAME, this.onEnterFrame);
            if (!this.hasEventListener(feng3d.AnimatorEvent.START))
                return;
            this.dispatchEvent(new feng3d.AnimatorEvent(feng3d.AnimatorEvent.START, this));
        };
        /**
         * 暂停播放动画
         * @see #time
         * @see #update()
         */
        AnimatorBase.prototype.stop = function () {
            if (!this._isPlaying)
                return;
            this._isPlaying = false;
            if (feng3d.$ticker.hasEventListener(feng3d.Event.ENTER_FRAME))
                feng3d.$ticker.removeEventListener(feng3d.Event.ENTER_FRAME, this.onEnterFrame);
            if (!this.hasEventListener(feng3d.AnimatorEvent.STOP))
                return;
            this.dispatchEvent(new feng3d.AnimatorEvent(feng3d.AnimatorEvent.STOP, this));
        };
        /**
         * 更新动画
         * @param time			动画时间
         *
         * @see #stop()
         * @see #autoUpdate
         */
        AnimatorBase.prototype.update = function (time) {
            var dt = (time - this._time) * this.playbackSpeed;
            this.updateDeltaTime(dt);
            this._time = time;
        };
        /**
         * 重置动画
         * @param name			动画名称
         * @param offset		动画时间偏移
         */
        AnimatorBase.prototype.reset = function (name, offset) {
            if (offset === void 0) { offset = 0; }
            this.getAnimationState(this._animationSet.getAnimation(name)).offset(offset + this._absoluteTime);
        };
        /**
         * 添加应用动画的网格
         * @private
         */
        AnimatorBase.prototype.addOwner = function (mesh) {
            this._owners.push(mesh);
        };
        /**
         * 移除应用动画的网格
         * @private
         */
        AnimatorBase.prototype.removeOwner = function (mesh) {
            this._owners.splice(this._owners.indexOf(mesh), 1);
        };
        /**
         * 更新偏移时间
         * @private
         */
        AnimatorBase.prototype.updateDeltaTime = function (dt) {
            this._absoluteTime += dt;
            this._activeState.update(this._absoluteTime);
            if (this.updatePosition)
                this.applyPositionDelta();
        };
        /**
         * 自动更新动画时帧更新事件
         */
        AnimatorBase.prototype.onEnterFrame = function (event) {
            if (event === void 0) { event = null; }
            this.update(getTimer());
        };
        /**
         * 应用位置偏移量
         */
        AnimatorBase.prototype.applyPositionDelta = function () {
            var delta = this._activeState.positionDelta;
            var dist = delta.length;
            var len;
            if (dist > 0) {
                len = this._owners.length;
                for (var i = 0; i < len; ++i)
                    this._owners[i].transform3D.translateLocal(delta, dist);
            }
        };
        /**
         * 派发动画播放完成一周期事件
         * @private
         */
        AnimatorBase.prototype.dispatchCycleEvent = function () {
            if (this.hasEventListener(feng3d.AnimatorEvent.CYCLE_COMPLETE))
                this.dispatchEvent(new feng3d.AnimatorEvent(feng3d.AnimatorEvent.CYCLE_COMPLETE, this));
        };
        Object.defineProperty(AnimatorBase.prototype, "namedAsset", {
            get: function () {
                return this._namedAsset;
            },
            enumerable: true,
            configurable: true
        });
        return AnimatorBase;
    }(feng3d.Component));
    feng3d.AnimatorBase = AnimatorBase;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 粒子动画
     * @author feng 2014-11-13
     */
    var ParticleAnimator = (function (_super) {
        __extends(ParticleAnimator, _super);
        /**
         * 创建粒子动画
         * @param particleAnimationSet 粒子动画集合
         */
        function ParticleAnimator(particleAnimationSet) {
            _super.call(this, particleAnimationSet);
            this._animationParticleStates = [];
            this._timeParticleStates = [];
            /** 常量数据 */
            this.vertexZeroConst = [];
            /** 时间常数（粒子当前时间） */
            this.timeConstData = [];
            this._particleAnimationSet = particleAnimationSet;
            this.context3DBufferOwner.addChildBufferOwner(this._particleAnimationSet.context3DBufferOwner);
        }
        /**
         * @inheritDoc
         */
        ParticleAnimator.prototype.initBuffers = function () {
            _super.prototype.initBuffers.call(this);
            this.context3DBufferOwner.mapContext3DBuffer(this._.particleCommon_vc_vector, this.updateParticleConstDataBuffer);
            this.context3DBufferOwner.mapContext3DBuffer(this._.particleTime_vc_vector, this.updateTimeConstBuffer);
        };
        ParticleAnimator.prototype.updateTimeConstBuffer = function (timeConstBuffer) {
            timeConstBuffer.update(this.timeConstData);
        };
        ParticleAnimator.prototype.updateParticleConstDataBuffer = function (particleConstDataBuffer) {
            particleConstDataBuffer.update(this.vertexZeroConst);
        };
        /**
         * @inheritDoc
         */
        ParticleAnimator.prototype.setRenderState = function (renderable, camera) {
            var meshRenderable = renderable;
            var subMesh = meshRenderable.subMesh;
            if (!subMesh)
                throw (new Error("Must be subMesh"));
            if (!subMesh.animationSubGeometry)
                this._particleAnimationSet.generateAnimationSubGeometries(subMesh.parentMesh);
            this.timeConstData[0] = this.timeConstData[1] = this.timeConstData[2] = this.timeConstData[3] = this.time / 1000;
            this._particleAnimationSet.setRenderState(renderable, camera);
        };
        /**
         * @inheritDoc
         */
        ParticleAnimator.prototype.start = function () {
            var _this = this;
            _super.prototype.start.call(this);
            this._timeParticleStates.forEach(function (state) {
                state.offset(_this._absoluteTime);
            });
        };
        /**
         * @inheritDoc
         */
        ParticleAnimator.prototype.updateDeltaTime = function (dt) {
            var _this = this;
            this._absoluteTime += dt;
            this._timeParticleStates.forEach(function (state) {
                state.update(_this._absoluteTime);
            });
        };
        return ParticleAnimator;
    }(feng3d.AnimatorBase));
    feng3d.ParticleAnimator = ParticleAnimator;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 骨骼动画
     * @author feng 2014-5-27
     */
    var SkeletonAnimator = (function (_super) {
        __extends(SkeletonAnimator, _super);
        /**
         * 创建一个骨骼动画类
         * @param animationSet 动画集合
         * @param skeleton 骨骼
         * @param forceCPU 是否强行使用cpu
         */
        function SkeletonAnimator(animationSet, skeleton, forceCPU) {
            if (forceCPU === void 0) { forceCPU = false; }
            _super.call(this, animationSet);
            this._globalMatrices = [];
            this._globalPose = new feng3d.SkeletonPose();
            this._animationStates1 = new feng3d.Map();
            this._skeleton = skeleton;
            this._forceCPU = forceCPU;
            this._jointsPerVertex = animationSet.jointsPerVertex;
            if (this._forceCPU || this._jointsPerVertex > 4)
                this._animationSet.cancelGPUCompatibility();
            animationSet.numJoints = this._skeleton.numJoints;
            this._numJoints = this._skeleton.numJoints;
            this._globalMatrices.length = this._numJoints * 12;
            //初始化骨骼变换矩阵
            var j;
            for (var i = 0; i < this._numJoints; ++i) {
                this._globalMatrices[j++] = 1;
                this._globalMatrices[j++] = 0;
                this._globalMatrices[j++] = 0;
                this._globalMatrices[j++] = 0;
                this._globalMatrices[j++] = 0;
                this._globalMatrices[j++] = 1;
                this._globalMatrices[j++] = 0;
                this._globalMatrices[j++] = 0;
                this._globalMatrices[j++] = 0;
                this._globalMatrices[j++] = 0;
                this._globalMatrices[j++] = 1;
                this._globalMatrices[j++] = 0;
            }
        }
        Object.defineProperty(SkeletonAnimator.prototype, "globalMatrices", {
            /**
             * 当前骨骼姿势的全局矩阵
             * @see #globalPose
             */
            get: function () {
                if (this._globalPropertiesDirty)
                    this.updateGlobalProperties();
                return this._globalMatrices;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SkeletonAnimator.prototype, "globalPose", {
            /**
             * 当前全局骨骼姿势
             */
            get: function () {
                if (this._globalPropertiesDirty)
                    this.updateGlobalProperties();
                return this._globalPose;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SkeletonAnimator.prototype, "skeleton", {
            /**
             * 骨骼
             */
            get: function () {
                return this._skeleton;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SkeletonAnimator.prototype, "forceCPU", {
            /**
             * 是否强行使用cpu
             */
            get: function () {
                return this._forceCPU;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        SkeletonAnimator.prototype.initBuffers = function () {
            _super.prototype.initBuffers.call(this);
            this.context3DBufferOwner.mapContext3DBuffer(this._.globalmatrices_vc_vector, this.updateGlobalmatricesBuffer);
        };
        SkeletonAnimator.prototype.updateGlobalmatricesBuffer = function (globalmatricesBuffer) {
            globalmatricesBuffer.update(this._globalMatrices);
        };
        /**
         * 播放动画
         * @param name 动作名称
         * @param offset 偏移量
         */
        SkeletonAnimator.prototype.play = function (name, transition, offset) {
            if (transition === void 0) { transition = null; }
            if (offset === void 0) { offset = NaN; }
            if (this._activeAnimationName != name) {
                this._activeAnimationName = name;
                if (!this._animationSet.hasAnimation(name))
                    throw new Error("Animation root node " + name + " not found!");
                if (transition && this._activeNode) {
                    //setup the transition
                    this._activeNode = transition.getAnimationNode(this, this._activeNode, this._animationSet.getAnimation(name), this._absoluteTime);
                    this._activeNode.addEventListener(feng3d.AnimationStateEvent.TRANSITION_COMPLETE, this.onTransitionComplete);
                }
                else
                    this._activeNode = this._animationSet.getAnimation(name);
                this._activeState = this.getAnimationState(this._activeNode);
                if (this.updatePosition) {
                    //this.update straight away to this.reset position deltas
                    this._activeState.update(this._absoluteTime);
                    this._activeState.positionDelta;
                }
                this._activeSkeletonState = this._activeState;
            }
            this.start();
            //使用时间偏移量处理特殊情况
            if (!isNaN(offset))
                this.reset(name, offset);
        };
        /**
         * @inheritDoc
         */
        SkeletonAnimator.prototype.setRenderState = function (renderable, camera) {
            //检查全局变换矩阵
            if (this._globalPropertiesDirty)
                this.updateGlobalProperties();
            var meshRenderable = renderable;
            var subGeometry = meshRenderable.subMesh.subGeometry;
            if (this._animationSet.usesCPU) {
                var subGeomAnimState = this._animationStates1.get(subGeometry);
                if (subGeomAnimState == null) {
                    subGeomAnimState = new SubGeomAnimationState(subGeometry);
                    this._animationStates1.push(subGeometry, subGeomAnimState);
                }
                //检查动画数据
                if (subGeomAnimState.dirty) {
                    this.morphGeometry(subGeomAnimState, subGeometry);
                    subGeomAnimState.dirty = false;
                }
                //更新动画数据到几何体
                var skinnedGeom = subGeometry.getOrCreateComponentByClass(feng3d.SkinnedSubGeometry);
                skinnedGeom.updateAnimatedData(subGeomAnimState.animatedVertexData);
            }
        };
        /**
         * @inheritDoc
         */
        SkeletonAnimator.prototype.updateDeltaTime = function (dt) {
            var _this = this;
            _super.prototype.updateDeltaTime.call(this, dt);
            this.context3DBufferOwner.markBufferDirty(this._.globalmatrices_vc_vector);
            //invalidate pose matrices
            this._globalPropertiesDirty = true;
            this._animationStates1.getKeys().forEach(function (key) {
                _this._animationStates1.get(key).dirty = true;
            });
        };
        /**
         * 更新骨骼全局变换矩阵
         */
        SkeletonAnimator.prototype.updateGlobalProperties = function () {
            this._globalPropertiesDirty = false;
            //获取全局骨骼姿势
            this.localToGlobalPose(this._activeSkeletonState.getSkeletonPose(this._skeleton), this._globalPose, this._skeleton);
            //姿势变换矩阵
            //矩阵偏移量
            var mtxOffset;
            var globalPoses = this._globalPose.jointPoses;
            var raw;
            var ox, oy, oz, ow;
            var xy2, xz2, xw2;
            var yz2, yw2, zw2;
            var n11, n12, n13;
            var n21, n22, n23;
            var n31, n32, n33;
            var m11, m12, m13, m14;
            var m21, m22, m23, m24;
            var m31, m32, m33, m34;
            var joints = this._skeleton.joints;
            var pose;
            var quat;
            var vec;
            var t;
            //遍历每个关节
            for (var i = 0; i < this._numJoints; ++i) {
                //读取关节全局姿势数据
                pose = globalPoses[i];
                quat = pose.orientation;
                vec = pose.translation;
                ox = quat.x;
                oy = quat.y;
                oz = quat.z;
                ow = quat.w;
                //计算关节的全局变换矩阵
                xy2 = (t = 2.0 * ox) * oy;
                xz2 = t * oz;
                xw2 = t * ow;
                yz2 = (t = 2.0 * oy) * oz;
                yw2 = t * ow;
                zw2 = 2.0 * oz * ow;
                yz2 = 2.0 * oy * oz;
                yw2 = 2.0 * oy * ow;
                zw2 = 2.0 * oz * ow;
                ox *= ox;
                oy *= oy;
                oz *= oz;
                ow *= ow;
                //保存关节的全局变换矩阵
                n11 = (t = ox - oy) - oz + ow;
                n12 = xy2 - zw2;
                n13 = xz2 + yw2;
                n21 = xy2 + zw2;
                n22 = -t - oz + ow;
                n23 = yz2 - xw2;
                n31 = xz2 - yw2;
                n32 = yz2 + xw2;
                n33 = -ox - oy + oz + ow;
                //初始状态 下关节的 逆矩阵
                raw = joints[i].inverseBindPose;
                m11 = raw[0];
                m12 = raw[4];
                m13 = raw[8];
                m14 = raw[12];
                m21 = raw[1];
                m22 = raw[5];
                m23 = raw[9];
                m24 = raw[13];
                m31 = raw[2];
                m32 = raw[6];
                m33 = raw[10];
                m34 = raw[14];
                //计算关节全局变换矩阵(通过初始状态 关节逆矩阵与全局变换矩阵 计算 当前状态的关节矩阵)
                this._globalMatrices[mtxOffset] = n11 * m11 + n12 * m21 + n13 * m31;
                this._globalMatrices[mtxOffset + 1] = n11 * m12 + n12 * m22 + n13 * m32;
                this._globalMatrices[mtxOffset + 2] = n11 * m13 + n12 * m23 + n13 * m33;
                this._globalMatrices[mtxOffset + 3] = n11 * m14 + n12 * m24 + n13 * m34 + vec.x;
                this._globalMatrices[mtxOffset + 4] = n21 * m11 + n22 * m21 + n23 * m31;
                this._globalMatrices[mtxOffset + 5] = n21 * m12 + n22 * m22 + n23 * m32;
                this._globalMatrices[mtxOffset + 6] = n21 * m13 + n22 * m23 + n23 * m33;
                this._globalMatrices[mtxOffset + 7] = n21 * m14 + n22 * m24 + n23 * m34 + vec.y;
                this._globalMatrices[mtxOffset + 8] = n31 * m11 + n32 * m21 + n33 * m31;
                this._globalMatrices[mtxOffset + 9] = n31 * m12 + n32 * m22 + n33 * m32;
                this._globalMatrices[mtxOffset + 10] = n31 * m13 + n32 * m23 + n33 * m33;
                this._globalMatrices[mtxOffset + 11] = n31 * m14 + n32 * m24 + n33 * m34 + vec.z;
                //跳到下个矩阵位置
                mtxOffset = mtxOffset + 12;
            }
        };
        /**
         * 几何体变形
         * @param state 动画几何体数据
         * @param subGeom 蒙皮几何体
         */
        SkeletonAnimator.prototype.morphGeometry = function (state, subGeom) {
            var skinnedGeom = subGeom.getOrCreateComponentByClass(feng3d.SkinnedSubGeometry);
            //几何体顶点数据
            var vertexData = subGeom.vertexPositionData;
            //动画顶点数据（目标数据）
            var targetData = state.animatedVertexData;
            var jointIndices = skinnedGeom.jointIndexData;
            var jointWeights = skinnedGeom.jointWeightsData;
            var index;
            var j, k;
            var vx, vy, vz;
            var len = vertexData.length;
            var weight;
            var vertX, vertY, vertZ;
            var m11, m12, m13, m14;
            var m21, m22, m23, m24;
            var m31, m32, m33, m34;
            //计算每个顶点的坐标，法线、切线
            while (index < len) {
                //提取原始顶点坐标、法线、切线数据
                vertX = vertexData[index];
                vertY = vertexData[index + 1];
                vertZ = vertexData[index + 2];
                vx = 0;
                vy = 0;
                vz = 0;
                k = 0;
                //遍历与该顶点相关的关节权重
                while (k < this._jointsPerVertex) {
                    weight = jointWeights[j];
                    if (weight > 0) {
                        //读取该关节的全局变换矩阵
                        var mtxOffset = jointIndices[j++] << 2;
                        m11 = this._globalMatrices[mtxOffset];
                        m12 = this._globalMatrices[mtxOffset + 1];
                        m13 = this._globalMatrices[mtxOffset + 2];
                        m14 = this._globalMatrices[mtxOffset + 3];
                        m21 = this._globalMatrices[mtxOffset + 4];
                        m22 = this._globalMatrices[mtxOffset + 5];
                        m23 = this._globalMatrices[mtxOffset + 6];
                        m24 = this._globalMatrices[mtxOffset + 7];
                        m31 = this._globalMatrices[mtxOffset + 8];
                        m32 = this._globalMatrices[mtxOffset + 9];
                        m33 = this._globalMatrices[mtxOffset + 10];
                        m34 = this._globalMatrices[mtxOffset + 11];
                        //根据关节的全局变换矩阵与对应权重计算出对该坐标的影响值
                        vx += weight * (m11 * vertX + m12 * vertY + m13 * vertZ + m14);
                        vy += weight * (m21 * vertX + m22 * vertY + m23 * vertZ + m24);
                        vz += weight * (m31 * vertX + m32 * vertY + m33 * vertZ + m34);
                        ++k;
                    }
                    else {
                        j += this._jointsPerVertex - k;
                        k = this._jointsPerVertex;
                    }
                }
                //保存最终计算得出的坐标、法线、切线数据
                targetData[index] = vx;
                targetData[index + 1] = vy;
                targetData[index + 2] = vz;
                //跳到下个顶点的起始位置
                index = index + subGeom.vertexPositionStride;
            }
        };
        /**
         * 本地转换到全局姿势
         * @param sourcePose 原姿势
         * @param targetPose 目标姿势
         * @param skeleton 骨骼
         */
        SkeletonAnimator.prototype.localToGlobalPose = function (sourcePose, targetPose, skeleton) {
            var globalPoses = targetPose.jointPoses;
            var globalJointPose;
            var joints = skeleton.joints;
            var len = sourcePose.numJointPoses;
            var jointPoses = sourcePose.jointPoses;
            var parentIndex;
            var joint;
            var parentPose;
            var pose;
            var or;
            var tr;
            var gTra;
            var gOri;
            var x1, y1, z1, w1;
            var x2, y2, z2, w2;
            var x3, y3, z3;
            //初始化全局骨骼姿势长度
            if (globalPoses.length != len)
                globalPoses.length = len;
            for (var i = 0; i < len; ++i) {
                //初始化单个全局骨骼姿势
                if (globalPoses[i] == null) {
                    globalPoses[i] = new feng3d.JointPose();
                }
                globalJointPose = globalPoses[i];
                joint = joints[i];
                parentIndex = joint.parentIndex;
                pose = jointPoses[i];
                //世界方向偏移
                gOri = globalJointPose.orientation;
                //全局位置偏移
                gTra = globalJointPose.translation;
                //计算全局骨骼的 方向偏移与位置偏移
                if (parentIndex < 0) {
                    //处理跟骨骼(直接赋值)
                    tr = pose.translation;
                    or = pose.orientation;
                    gOri.x = or.x;
                    gOri.y = or.y;
                    gOri.z = or.z;
                    gOri.w = or.w;
                    gTra.x = tr.x;
                    gTra.y = tr.y;
                    gTra.z = tr.z;
                }
                else {
                    //处理其他骨骼
                    //找到父骨骼全局姿势
                    parentPose = globalPoses[parentIndex];
                    or = parentPose.orientation;
                    tr = pose.translation;
                    //提取父姿势的世界方向数据
                    x2 = or.x;
                    y2 = or.y;
                    z2 = or.z;
                    w2 = or.w;
                    //提取当前姿势相对父姿势的位置数据
                    x3 = tr.x;
                    y3 = tr.y;
                    z3 = tr.z;
                    //计算当前姿势相对父姿势在全局中的位置偏移方向(有点没搞懂，我只能这么说如果一定要我来计算的话，我一定能做出来)
                    w1 = -x2 * x3 - y2 * y3 - z2 * z3;
                    x1 = w2 * x3 + y2 * z3 - z2 * y3;
                    y1 = w2 * y3 - x2 * z3 + z2 * x3;
                    z1 = w2 * z3 + x2 * y3 - y2 * x3;
                    //计算当前骨骼全局姿势的位置数据（父姿势的世界坐标加上当前姿势相对父姿势转换为全局的坐标变化量）
                    tr = parentPose.translation;
                    gTra.x = -w1 * x2 + x1 * w2 - y1 * z2 + z1 * y2 + tr.x;
                    gTra.y = -w1 * y2 + x1 * z2 + y1 * w2 - z1 * x2 + tr.y;
                    gTra.z = -w1 * z2 - x1 * y2 + y1 * x2 + z1 * w2 + tr.z;
                    //提取父姿势的世界方向数据
                    x1 = or.x;
                    y1 = or.y;
                    z1 = or.z;
                    w1 = or.w;
                    //提取当前姿势相对父姿势的方向数据
                    or = pose.orientation;
                    x2 = or.x;
                    y2 = or.y;
                    z2 = or.z;
                    w2 = or.w;
                    //根据父姿势的世界方向数据与当前姿势的方向数据计算当前姿势的世界方向数据
                    gOri.w = w1 * w2 - x1 * x2 - y1 * y2 - z1 * z2;
                    gOri.x = w1 * x2 + x1 * w2 + y1 * z2 - z1 * y2;
                    gOri.y = w1 * y2 - x1 * z2 + y1 * w2 + z1 * x2;
                    gOri.z = w1 * z2 + x1 * y2 - y1 * x2 + z1 * w2;
                }
            }
        };
        /**
         * 处理动画变换完成时间
         */
        SkeletonAnimator.prototype.onTransitionComplete = function (event) {
            if (event.type == feng3d.AnimationStateEvent.TRANSITION_COMPLETE) {
                event.animationNode.removeEventListener(feng3d.AnimationStateEvent.TRANSITION_COMPLETE, this.onTransitionComplete);
                if (this._activeState == event.animationState) {
                    this._activeNode = this._animationSet.getAnimation(this._activeAnimationName);
                    this._activeState = this.getAnimationState(this._activeNode);
                    this._activeSkeletonState = this._activeState;
                }
            }
        };
        return SkeletonAnimator;
    }(feng3d.AnimatorBase));
    feng3d.SkeletonAnimator = SkeletonAnimator;
    /**
     * 动画状态几何体数据
     */
    var SubGeomAnimationState = (function () {
        /**
         * 创建一个动画当前状态的数据类(用来保存动画顶点数据)
         */
        function SubGeomAnimationState(subGeom) {
            this.dirty = true;
            this.animatedVertexData = subGeom.vertexPositionData.concat();
        }
        return SubGeomAnimationState;
    }());
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * sprite动画
     * @author feng 2014-5-27
     */
    var SpriteSheetAnimator = (function (_super) {
        __extends(SpriteSheetAnimator, _super);
        /**
         * 创建sprite动画实例
         * @param spriteSheetAnimationSet			sprite动画集合
         */
        function SpriteSheetAnimator(spriteSheetAnimationSet) {
            _super.call(this, spriteSheetAnimationSet);
            this._vectorFrame = [0, 0, 0, 0];
            this._frame = new feng3d.SpriteSheetAnimationFrame();
            this._fps = 10;
            this._ms = 100;
            this._spriteSheetAnimationSet = spriteSheetAnimationSet;
        }
        Object.defineProperty(SpriteSheetAnimator.prototype, "fps", {
            /**
             * 帧率
             */
            get: function () {
                return this._fps;
            },
            set: function (val) {
                this._ms = 1000 / val;
                this._fps = val;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SpriteSheetAnimator.prototype, "reverse", {
            /**
             * 是否反向
             */
            get: function () {
                return this._reverse;
            },
            set: function (b) {
                this._reverse = b;
                this._specsDirty = true;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SpriteSheetAnimator.prototype, "backAndForth", {
            /**
             * 改变播放方向
             */
            get: function () {
                return this._backAndForth;
            },
            set: function (b) {
                this._backAndForth = b;
                this._specsDirty = true;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 跳到某帧播放（起始帧为1）
         * @param frameNumber			帧编号
         */
        SpriteSheetAnimator.prototype.gotoAndPlay = function (frameNumber) {
            this.gotoFrame(frameNumber, true);
        };
        /**
         * 跳到某帧停止（起始帧为1）
         * @param frameNumber			帧编号
         */
        SpriteSheetAnimator.prototype.gotoAndStop = function (frameNumber) {
            this.gotoFrame(frameNumber, false);
        };
        Object.defineProperty(SpriteSheetAnimator.prototype, "currentFrameNumber", {
            /**
             * 当前帧编号
             */
            get: function () {
                return (this._activeState).currentFrameNumber;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SpriteSheetAnimator.prototype, "totalFrames", {
            /**
             * 总帧数
             */
            get: function () {
                return (this._activeState).totalFrames;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        SpriteSheetAnimator.prototype.initBuffers = function () {
            _super.prototype.initBuffers.call(this);
            this.context3DBufferOwner.mapContext3DBuffer(this._.spriteSheetVectorFrame_vc_vector, this.updateVectorFrameBuffer);
        };
        SpriteSheetAnimator.prototype.updateVectorFrameBuffer = function (vcVectorBuffer) {
            vcVectorBuffer.update(this._vectorFrame);
        };
        /**
         * @inheritDoc
         */
        SpriteSheetAnimator.prototype.setRenderState = function (renderable, camera) {
            var material = renderable.material;
            if (!material || !feng3d.is(material, feng3d.TextureMaterial))
                return;
            var subMesh = feng3d.as(renderable, feng3d.MeshRenderable).subMesh;
            if (!subMesh)
                return;
            //because textures are already uploaded, we can't offset the uv's yet
            var swapped;
            if (feng3d.is(material, feng3d.SpriteSheetMaterial) && this._mapDirty)
                swapped = feng3d.as(material, feng3d.SpriteSheetMaterial).swap(this._frame.mapID);
            if (!swapped) {
                this._vectorFrame[0] = this._frame.offsetU;
                this._vectorFrame[1] = this._frame.offsetV;
                this._vectorFrame[2] = this._frame.scaleU;
                this._vectorFrame[3] = this._frame.scaleV;
            }
        };
        /**
         * @inheritDoc
         */
        SpriteSheetAnimator.prototype.play = function (name, transition, offset) {
            if (transition === void 0) { transition = null; }
            if (offset === void 0) { offset = NaN; }
            transition = transition;
            offset = offset;
            if (this._activeAnimationName == name)
                return;
            this._activeAnimationName = name;
            if (!this._animationSet.hasAnimation(name))
                throw new Error("Animation root node " + name + " not found!");
            this._activeNode = this._animationSet.getAnimation(name);
            this._activeState = this.getAnimationState(this._activeNode);
            this._frame = feng3d.as(this._activeState, feng3d.SpriteSheetAnimationState).currentFrameData;
            this._activeSpriteSheetState = this._activeState;
            this.start();
        };
        /**
         * @inheritDoc
         */
        SpriteSheetAnimator.prototype.updateDeltaTime = function (dt) {
            if (this._specsDirty) {
                feng3d.as(this._activeSpriteSheetState, feng3d.SpriteSheetAnimationState).reverse = this._reverse;
                feng3d.as(this._activeSpriteSheetState, feng3d.SpriteSheetAnimationState).backAndForth = this._backAndForth;
                this._specsDirty = false;
            }
            this._absoluteTime += dt;
            var now = getTimer();
            if ((now - this._lastTime) > this._ms) {
                this._mapDirty = true;
                this._activeSpriteSheetState.update(this._absoluteTime);
                this._frame = feng3d.as(this._activeSpriteSheetState, feng3d.SpriteSheetAnimationState).currentFrameData;
                this._lastTime = now;
            }
            else
                this._mapDirty = false;
        };
        /**
         * 克隆
         */
        SpriteSheetAnimator.prototype.clone = function () {
            return new SpriteSheetAnimator(this._spriteSheetAnimationSet);
        };
        /**
         * 跳转某帧
         * @param frameNumber			帧编号
         * @param doPlay				是否播放
         */
        SpriteSheetAnimator.prototype.gotoFrame = function (frameNumber, doPlay) {
            if (!this._activeState)
                return;
            feng3d.as(this._activeState, feng3d.SpriteSheetAnimationState).currentFrameNumber = (frameNumber == 0) ? frameNumber : frameNumber - 1;
            var currentMapID = this._frame.mapID;
            this._frame = feng3d.as(this._activeSpriteSheetState, feng3d.SpriteSheetAnimationState).currentFrameData;
            if (doPlay)
                this.start();
            else {
                if (currentMapID != this._frame.mapID) {
                    this._mapDirty = true;
                    setTimeout(this.stop, this._fps);
                }
                else
                    this.stop();
            }
        };
        return SpriteSheetAnimator;
    }(feng3d.AnimatorBase));
    feng3d.SpriteSheetAnimator = SpriteSheetAnimator;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * UV动画
     * @author feng 2014-5-27
     */
    var UVAnimator = (function (_super) {
        __extends(UVAnimator, _super);
        /**
         * 创建<code>UVAnimator</code>实例
         * @param uvAnimationSet			UV动画集合
         */
        function UVAnimator(uvAnimationSet) {
            _super.call(this, uvAnimationSet);
            this._matrix2d = [1, 0, 0, 0, 1, 0, 0, 0];
            this._translate = [0, 0, 0.5, 0.5];
            this._deltaFrame = new feng3d.UVAnimationFrame();
            this._rotationIncrease = 1;
            this._uvTransform = new feng3d.Matrix();
            this._uvAnimationSet = uvAnimationSet;
        }
        Object.defineProperty(UVAnimator.prototype, "autoRotation", {
            /**
             * 是否自动旋转
             */
            get: function () {
                return this._autoRotation;
            },
            set: function (b) {
                this._autoRotation = b;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UVAnimator.prototype, "rotationIncrease", {
            /**
             * 旋转增量（当autoRotation = true生效）
             */
            get: function () {
                return this._rotationIncrease;
            },
            set: function (value) {
                this._rotationIncrease = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UVAnimator.prototype, "autoTranslate", {
            /**
             * 是否自动转换
             */
            get: function () {
                return this._autoTranslate;
            },
            set: function (b) {
                this._autoTranslate = b;
                if (b && !this._translateIncrease)
                    this._translateIncrease = [0, 0];
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 设置转换值
         * @param u
         * @param v
         */
        UVAnimator.prototype.setTranslateIncrease = function (u, v) {
            if (!this._translateIncrease)
                this._translateIncrease = [0, 0];
            this._translateIncrease[0] = u;
            this._translateIncrease[1] = v;
        };
        Object.defineProperty(UVAnimator.prototype, "translateIncrease", {
            /**
             * 转换值
             */
            get: function () {
                return this._translateIncrease;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        UVAnimator.prototype.initBuffers = function () {
            _super.prototype.initBuffers.call(this);
            this.context3DBufferOwner.mapContext3DBuffer(this._.uvAnimatorTranslate_vc_vector, this.updateTranslateBuffer);
            this.context3DBufferOwner.mapContext3DBuffer(this._.uvAnimatorMatrix2d_vc_vector, this.updateMatrix2dBuffer);
        };
        UVAnimator.prototype.updateTranslateBuffer = function (buffer) {
            buffer.update(this._translate);
        };
        UVAnimator.prototype.updateMatrix2dBuffer = function (buffer) {
            buffer.update(this._matrix2d);
        };
        /**
         * @inheritDoc
         */
        UVAnimator.prototype.setRenderState = function (renderable, camera) {
            var material = feng3d.as(renderable.material, feng3d.TextureMaterial);
            var subMesh = feng3d.as(renderable, feng3d.MeshRenderable).subMesh;
            if (!material || !subMesh)
                return;
            if (this.autoTranslate) {
                this._deltaFrame.offsetU += this._translateIncrease[0];
                this._deltaFrame.offsetV += this._translateIncrease[1];
            }
            this._translate[0] = this._deltaFrame.offsetU;
            this._translate[1] = this._deltaFrame.offsetV;
            this._uvTransform.identity();
            if (this._autoRotation)
                this._deltaFrame.rotation += this._rotationIncrease;
            if (this._deltaFrame.rotation != 0)
                this._uvTransform.rotate(this._deltaFrame.rotation * feng3d.MathConsts.DEGREES_TO_RADIANS);
            if (this._deltaFrame.scaleU != 1 || this._deltaFrame.scaleV != 1)
                this._uvTransform.scale(this._deltaFrame.scaleU, this._deltaFrame.scaleV);
            this._matrix2d[0] = this._uvTransform.a;
            this._matrix2d[1] = this._uvTransform.b;
            this._matrix2d[3] = this._uvTransform.tx;
            this._matrix2d[4] = this._uvTransform.c;
            this._matrix2d[5] = this._uvTransform.d;
            this._matrix2d[7] = this._uvTransform.ty;
        };
        /**
         * @inheritDoc
         */
        UVAnimator.prototype.play = function (name, transition, offset) {
            if (transition === void 0) { transition = null; }
            if (offset === void 0) { offset = NaN; }
            transition = transition;
            offset = offset;
            if (this._activeAnimationName == name)
                return;
            this._activeAnimationName = name;
            if (!this._animationSet.hasAnimation(name))
                throw new Error("Animation root node " + name + " not found!");
            this._activeNode = this._animationSet.getAnimation(name);
            this._activeState = this.getAnimationState(this._activeNode);
            this._activeUVState = this._activeState;
            this.start();
        };
        /**
         * @inheritDoc
         */
        UVAnimator.prototype.updateDeltaTime = function (dt) {
            this._absoluteTime += dt;
            this._activeUVState.update(this._absoluteTime);
            var currentUVFrame = this._activeUVState.currentUVFrame;
            var nextUVFrame = this._activeUVState.nextUVFrame;
            var blendWeight = this._activeUVState.blendWeight;
            if (currentUVFrame && nextUVFrame) {
                this._deltaFrame.offsetU = currentUVFrame.offsetU + blendWeight * (nextUVFrame.offsetU - currentUVFrame.offsetU);
                this._deltaFrame.offsetV = currentUVFrame.offsetV + blendWeight * (nextUVFrame.offsetV - currentUVFrame.offsetV);
                this._deltaFrame.scaleU = currentUVFrame.scaleU + blendWeight * (nextUVFrame.scaleU - currentUVFrame.scaleU);
                this._deltaFrame.scaleV = currentUVFrame.scaleV + blendWeight * (nextUVFrame.scaleV - currentUVFrame.scaleV);
                this._deltaFrame.rotation = currentUVFrame.rotation + blendWeight * (nextUVFrame.rotation - currentUVFrame.rotation);
            }
        };
        /**
         * @inheritDoc
         */
        UVAnimator.prototype.clone = function () {
            return new UVAnimator(this._uvAnimationSet);
        };
        return UVAnimator;
    }(feng3d.AnimatorBase));
    feng3d.UVAnimator = UVAnimator;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 顶点动画
     * @author feng 2014-5-13
     */
    var VertexAnimator = (function (_super) {
        __extends(VertexAnimator, _super);
        /**
         * 创建一个顶点动画
         * @param vertexAnimationSet 顶点动画集合
         */
        function VertexAnimator(vertexAnimationSet) {
            _super.call(this, vertexAnimationSet);
            this._weights = [1, 0, 0, 0];
            this._poses = [];
            this._vertexAnimationSet = vertexAnimationSet;
            this._numPoses = vertexAnimationSet.numPoses;
        }
        /**
         * @inheritDoc
         */
        VertexAnimator.prototype.initBuffers = function () {
            _super.prototype.initBuffers.call(this);
            this.context3DBufferOwner.mapContext3DBuffer(this._.weights_vc_vector, this.updateWeightsBuffer);
        };
        VertexAnimator.prototype.updateWeightsBuffer = function (weightsBuffer) {
            weightsBuffer.update(this._weights);
        };
        /**
         * 播放动画
         * @param name 动作名称
         * @param offset 时间偏移量
         */
        VertexAnimator.prototype.play = function (name, transition, offset) {
            if (transition === void 0) { transition = null; }
            if (offset === void 0) { offset = NaN; }
            if (this._activeAnimationName != name) {
                this._activeAnimationName = name;
                if (!this._vertexAnimationSet.hasAnimation(name))
                    throw new Error("Animation root node " + name + " not found!");
                //获取活动的骨骼状态
                this._activeNode = this._vertexAnimationSet.getAnimation(name);
                this._activeState = this.getAnimationState(this._activeNode);
                if (this.updatePosition) {
                    //this.update straight away to this.reset position deltas
                    this._activeState.update(this._absoluteTime);
                    this._activeState.positionDelta;
                }
                this._activeVertexState = this._activeState;
            }
            this.start();
            //使用时间偏移量处理特殊情况
            if (!isNaN(offset))
                this.reset(name, offset);
        };
        /**
         * @inheritDoc
         */
        VertexAnimator.prototype.updateDeltaTime = function (dt) {
            _super.prototype.updateDeltaTime.call(this, dt);
            this._poses[0] = this._activeVertexState.getCurrentGeometry();
            this._poses[1] = this._activeVertexState.getNextGeometry();
            this._weights[0] = 1 - (this._weights[1] = this._activeVertexState.getBlendWeight());
        };
        /**
         * @inheritDoc
         */
        VertexAnimator.prototype.setRenderState = function (renderable, camera) {
            //没有姿势时，使用默认姿势
            if (!this._poses.length) {
                this.setNullPose(renderable);
                return;
            }
            // this type of animation can only be SubMesh
            var subMesh = feng3d.as(renderable, feng3d.MeshRenderable).subMesh;
            var subGeom = subMesh.subGeometry;
            var vertexSubGeom = subGeom.getOrCreateComponentByClass(feng3d.VertexSubGeometry);
            //				//获取默认姿势几何体数据
            subGeom = this._poses[0].subGeometries[subMesh._index] || subMesh.subGeometry;
            vertexSubGeom.updateVertexData0(subGeom.vertexPositionData.concat());
            subGeom = this._poses[1].subGeometries[subMesh._index] || subMesh.subGeometry;
            vertexSubGeom.updateVertexData1(subGeom.vertexPositionData.concat());
        };
        /**
         * 设置空姿势
         * @param renderable		渲染对象
         */
        VertexAnimator.prototype.setNullPose = function (renderable) {
            var subMesh = feng3d.as(renderable, feng3d.MeshRenderable).subMesh;
            var subGeom = subMesh.subGeometry;
        };
        VertexAnimator.prototype.addOwner = function (mesh) {
            var geometry = mesh.geometry;
            var i;
            var subGeometry;
            for (i = 0; i < geometry.subGeometries.length; i++) {
                subGeometry = geometry.subGeometries[i];
                subGeometry.getOrCreateComponentByClass(feng3d.VertexSubGeometry);
            }
            _super.prototype.addOwner.call(this, mesh);
        };
        return VertexAnimator;
    }(feng3d.AnimatorBase));
    feng3d.VertexAnimator = VertexAnimator;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 骨骼数据
     * @author feng 2014-5-20
     */
    var Skeleton = (function (_super) {
        __extends(Skeleton, _super);
        function Skeleton() {
            _super.call(this);
            this._namedAsset = new feng3d.NamedAsset(this, feng3d.AssetType.SKELETON);
            this.joints = [];
        }
        Object.defineProperty(Skeleton.prototype, "numJoints", {
            get: function () {
                return this.joints.length;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Skeleton.prototype, "namedAsset", {
            get: function () {
                return this._namedAsset;
            },
            enumerable: true,
            configurable: true
        });
        return Skeleton;
    }(feng3d.Component));
    feng3d.Skeleton = Skeleton;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 骨骼pose
     * @author feng 2014-5-20
     */
    var SkeletonPose = (function (_super) {
        __extends(SkeletonPose, _super);
        function SkeletonPose() {
            _super.call(this);
            this._namedAsset = new feng3d.NamedAsset(this, feng3d.AssetType.SKELETON_POSE);
            this.jointPoses = [];
        }
        Object.defineProperty(SkeletonPose.prototype, "numJointPoses", {
            get: function () {
                return this.jointPoses.length;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SkeletonPose.prototype, "namedAsset", {
            get: function () {
                return this._namedAsset;
            },
            enumerable: true,
            configurable: true
        });
        return SkeletonPose;
    }(feng3d.Component));
    feng3d.SkeletonPose = SkeletonPose;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 子几何体组件
     * @author feng 2015-12-10
     */
    var SubGeometryComponent = (function (_super) {
        __extends(SubGeometryComponent, _super);
        function SubGeometryComponent() {
            _super.call(this);
            this.addEventListener(feng3d.ComponentEvent.BE_ADDED_COMPONET, this.onBeAddedComponet);
            this.addEventListener(feng3d.ComponentEvent.BE_REMOVED_COMPONET, this.onBeRemovedComponet);
        }
        Object.defineProperty(SubGeometryComponent.prototype, "subGeometry", {
            get: function () {
                return this._subGeometry;
            },
            set: function (value) {
                this._subGeometry = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 处理被添加事件
         * @param event
         */
        SubGeometryComponent.prototype.onBeAddedComponet = function (event) {
            var addedComponentEventVO = event.data;
            this.subGeometry = addedComponentEventVO.container;
        };
        /**
         * 处理被移除事件
         * @param event
         */
        SubGeometryComponent.prototype.onBeRemovedComponet = function (event) {
            var removedComponentEventVO = event.data;
            this.subGeometry = null;
        };
        Object.defineProperty(SubGeometryComponent.prototype, "_", {
            /**
             * Fagal编号中心
             */
            get: function () {
                return feng3d.FagalIdCenter.instance;
            },
            enumerable: true,
            configurable: true
        });
        return SubGeometryComponent;
    }(feng3d.Component));
    feng3d.SubGeometryComponent = SubGeometryComponent;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 自动生成顶点法线数据
     * @author feng 2015-12-8
     */
    var AutoDeriveVertexNormals = (function (_super) {
        __extends(AutoDeriveVertexNormals, _super);
        function AutoDeriveVertexNormals() {
            _super.call(this);
            /** 面法线脏标记 */
            this._faceNormalsDirty = true;
            /** 是否使用面权重 */
            this._useFaceWeights = false;
            this.dataTypeId = this._.normal_va_3;
        }
        Object.defineProperty(AutoDeriveVertexNormals.prototype, "subGeometry", {
            set: function (value) {
                if (this._subGeometry != null) {
                    this._subGeometry.removeEventListener(feng3d.GeometryComponentEvent.GET_VA_DATA, this.onGetVAData);
                    this._subGeometry.removeEventListener(feng3d.GeometryComponentEvent.CHANGED_VA_DATA, this.onChangedVAData);
                    this._subGeometry.removeEventListener(feng3d.GeometryComponentEvent.CHANGED_INDEX_DATA, this.onChangedIndexData);
                }
                this._subGeometry = value;
                if (this._subGeometry != null) {
                    this._subGeometry.addEventListener(feng3d.GeometryComponentEvent.GET_VA_DATA, this.onGetVAData);
                    this._subGeometry.addEventListener(feng3d.GeometryComponentEvent.CHANGED_VA_DATA, this.onChangedVAData);
                    this._subGeometry.addEventListener(feng3d.GeometryComponentEvent.CHANGED_INDEX_DATA, this.onChangedIndexData);
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 处理被添加事件
         * @param event
         */
        AutoDeriveVertexNormals.prototype.onBeAddedComponet = function (event) {
            _super.prototype.onBeAddedComponet.call(this, event);
            this.needGenerate = true;
            this.subGeometry.invalidVAData(this.dataTypeId);
        };
        AutoDeriveVertexNormals.prototype.onGetVAData = function (event) {
            if (event.data != this.dataTypeId)
                return;
            if (!this.needGenerate)
                return;
            this.target = this.updateVertexNormals(this.target);
            this.subGeometry.setVAData(this.dataTypeId, this.target);
            this.needGenerate = false;
        };
        AutoDeriveVertexNormals.prototype.onChangedVAData = function (event) {
            if (event.data == this._.position_va_3) {
                this.needGenerate = true;
                //标记面法线脏数据
                this._faceNormalsDirty = true;
                this.subGeometry.invalidVAData(this.dataTypeId);
            }
        };
        AutoDeriveVertexNormals.prototype.onChangedIndexData = function (event) {
            this._faceNormalsDirty = true;
            this.subGeometry.invalidVAData(this.dataTypeId);
        };
        Object.defineProperty(AutoDeriveVertexNormals.prototype, "faceNormals", {
            /** 面法线 */
            get: function () {
                if (this._faceNormalsDirty)
                    this.updateFaceNormals();
                return this._faceNormals;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AutoDeriveVertexNormals.prototype, "useFaceWeights", {
            /**
             * Indicates whether or not to take the size of faces into account when auto-deriving vertex normals and tangents.
             */
            get: function () {
                return this._useFaceWeights;
            },
            set: function (value) {
                this._useFaceWeights = value;
                this.subGeometry.invalidVAData(this.dataTypeId);
                this._faceNormalsDirty = true;
            },
            enumerable: true,
            configurable: true
        });
        /** 更新面法线数据 */
        AutoDeriveVertexNormals.prototype.updateFaceNormals = function () {
            var i, j, k;
            var index;
            var _indices = this.subGeometry.indices;
            var len = _indices.length;
            var x1, x2, x3;
            var y1, y2, y3;
            var z1, z2, z3;
            var dx1, dy1, dz1;
            var dx2, dy2, dz2;
            var cx, cy, cz;
            var d;
            var vertices = this.subGeometry.getVAData(this._.position_va_3);
            var posStride = 3;
            var posOffset = 0;
            if (this._faceNormals == null) {
                this._faceNormals = [];
                this._faceNormals.length = len;
            }
            if (this._useFaceWeights) {
                if (this._faceWeights == null) {
                    this._faceWeights = [];
                    this._faceWeights.length = len / 3;
                }
            }
            while (i < len) {
                index = posOffset + _indices[i++] * posStride;
                x1 = vertices[index];
                y1 = vertices[index + 1];
                z1 = vertices[index + 2];
                index = posOffset + _indices[i++] * posStride;
                x2 = vertices[index];
                y2 = vertices[index + 1];
                z2 = vertices[index + 2];
                index = posOffset + _indices[i++] * posStride;
                x3 = vertices[index];
                y3 = vertices[index + 1];
                z3 = vertices[index + 2];
                dx1 = x3 - x1;
                dy1 = y3 - y1;
                dz1 = z3 - z1;
                dx2 = x2 - x1;
                dy2 = y2 - y1;
                dz2 = z2 - z1;
                cx = dz1 * dy2 - dy1 * dz2;
                cy = dx1 * dz2 - dz1 * dx2;
                cz = dy1 * dx2 - dx1 * dy2;
                d = Math.sqrt(cx * cx + cy * cy + cz * cz);
                // length of cross product = 2*triangle area
                if (this._useFaceWeights) {
                    var w = d * 10000;
                    if (w < 1)
                        w = 1;
                    this._faceWeights[k++] = w;
                }
                d = 1 / d;
                this._faceNormals[j++] = cx * d;
                this._faceNormals[j++] = cy * d;
                this._faceNormals[j++] = cz * d;
            }
            this._faceNormalsDirty = false;
        };
        /**
         * 更新顶点法线数据
         * @param target 顶点法线数据
         * @return 顶点法线数据
         */
        AutoDeriveVertexNormals.prototype.updateVertexNormals = function (target) {
            if (this._faceNormalsDirty)
                this.updateFaceNormals();
            var v1;
            var f1 = 0, f2 = 1, f3 = 2;
            var lenV = this.subGeometry.numVertices * 3;
            var normalStride = 3;
            var normalOffset = 0;
            if (target == null) {
                target = [];
                target.length = lenV;
            }
            v1 = normalOffset;
            while (v1 < lenV) {
                target[v1] = 0.0;
                target[v1 + 1] = 0.0;
                target[v1 + 2] = 0.0;
                v1 += normalStride;
            }
            var i, k;
            var _indices = this.subGeometry.indices;
            var lenI = _indices.length;
            var index;
            var weight;
            while (i < lenI) {
                weight = this._useFaceWeights ? this._faceWeights[k++] : 1;
                index = normalOffset + _indices[i++] * normalStride;
                target[index++] += this._faceNormals[f1] * weight;
                target[index++] += this._faceNormals[f2] * weight;
                target[index] += this._faceNormals[f3] * weight;
                index = normalOffset + _indices[i++] * normalStride;
                target[index++] += this._faceNormals[f1] * weight;
                target[index++] += this._faceNormals[f2] * weight;
                target[index] += this._faceNormals[f3] * weight;
                index = normalOffset + _indices[i++] * normalStride;
                target[index++] += this._faceNormals[f1] * weight;
                target[index++] += this._faceNormals[f2] * weight;
                target[index] += this._faceNormals[f3] * weight;
                f1 += 3;
                f2 += 3;
                f3 += 3;
            }
            v1 = normalOffset;
            while (v1 < lenV) {
                var vx = target[v1];
                var vy = target[v1 + 1];
                var vz = target[v1 + 2];
                var d = 1.0 / Math.sqrt(vx * vx + vy * vy + vz * vz);
                target[v1] = vx * d;
                target[v1 + 1] = vy * d;
                target[v1 + 2] = vz * d;
                v1 += normalStride;
            }
            return target;
        };
        return AutoDeriveVertexNormals;
    }(feng3d.SubGeometryComponent));
    feng3d.AutoDeriveVertexNormals = AutoDeriveVertexNormals;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 自动生成切线组件
     * @author feng 2014-12-19
     */
    var AutoDeriveVertexTangents = (function (_super) {
        __extends(AutoDeriveVertexTangents, _super);
        function AutoDeriveVertexTangents() {
            _super.call(this);
            /** 面切线脏标记 */
            this._faceTangentsDirty = true;
            /** 是否使用面权重 */
            this._useFaceWeights = false;
            this.dataTypeId = this._.tangent_va_3;
        }
        Object.defineProperty(AutoDeriveVertexTangents.prototype, "subGeometry", {
            set: function (value) {
                if (this._subGeometry != null) {
                    this._subGeometry.removeEventListener(feng3d.GeometryComponentEvent.GET_VA_DATA, this.onGetVAData);
                    this._subGeometry.removeEventListener(feng3d.GeometryComponentEvent.CHANGED_VA_DATA, this.onChangedVAData);
                    this._subGeometry.removeEventListener(feng3d.GeometryComponentEvent.CHANGED_INDEX_DATA, this.onChangedIndexData);
                }
                this._subGeometry = value;
                if (this._subGeometry != null) {
                    this._subGeometry.addEventListener(feng3d.GeometryComponentEvent.GET_VA_DATA, this.onGetVAData);
                    this._subGeometry.addEventListener(feng3d.GeometryComponentEvent.CHANGED_VA_DATA, this.onChangedVAData);
                    this._subGeometry.addEventListener(feng3d.GeometryComponentEvent.CHANGED_INDEX_DATA, this.onChangedIndexData);
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 处理被添加事件
         * @param event
         */
        AutoDeriveVertexTangents.prototype.onBeAddedComponet = function (event) {
            _super.prototype.onBeAddedComponet.call(this, event);
            this.needGenerate = true;
            this.subGeometry.invalidVAData(this.dataTypeId);
        };
        AutoDeriveVertexTangents.prototype.onGetVAData = function (event) {
            if (event.data != this.dataTypeId)
                return;
            if (!this.needGenerate)
                return;
            this.target = this.updateVertexTangents(this.target);
            this.subGeometry.setVAData(this.dataTypeId, this.target);
            this.needGenerate = false;
        };
        AutoDeriveVertexTangents.prototype.onChangedVAData = function (event) {
            if (event.data == this._.position_va_3) {
                this.needGenerate = true;
                //标记面切线脏数据
                this._faceTangentsDirty = true;
                this.subGeometry.invalidVAData(this._.tangent_va_3);
            }
        };
        AutoDeriveVertexTangents.prototype.onChangedIndexData = function (event) {
            this._faceTangentsDirty = true;
            this.subGeometry.invalidVAData(this._.tangent_va_3);
        };
        Object.defineProperty(AutoDeriveVertexTangents.prototype, "faceTangents", {
            /** 面切线 */
            get: function () {
                if (this._faceTangentsDirty)
                    this.updateFaceTangents();
                return this._faceTangents;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AutoDeriveVertexTangents.prototype, "useFaceWeights", {
            /**
             * Indicates whether or not to take the size of faces into account when auto-deriving vertex normals and tangents.
             */
            get: function () {
                return this._useFaceWeights;
            },
            set: function (value) {
                this._useFaceWeights = value;
                this.subGeometry.invalidVAData(this._.tangent_va_3);
            },
            enumerable: true,
            configurable: true
        });
        /** 更新面切线数据 */
        AutoDeriveVertexTangents.prototype.updateFaceTangents = function () {
            var i;
            var index1, index2, index3;
            var _indices = this.subGeometry.indices;
            var len = _indices.length;
            var ui, vi;
            var v0;
            var dv1, dv2;
            var denom;
            var x0, y0, z0;
            var dx1, dy1, dz1;
            var dx2, dy2, dz2;
            var cx, cy, cz;
            var vertices = this.subGeometry.getVAData(this._.position_va_3);
            var uvs = this.subGeometry.getVAData(this._.uv_va_2);
            var posStride = this.subGeometry.getVALen(this._.position_va_3);
            var posOffset = 0;
            var texStride = this.subGeometry.getVALen(this._.uv_va_2);
            var texOffset = 0;
            if (this._faceTangents == null) {
                this._faceTangents = [];
                this._faceTangents.length = _indices.length;
            }
            while (i < len) {
                index1 = _indices[i];
                index2 = _indices[i + 1];
                index3 = _indices[i + 2];
                ui = texOffset + index1 * texStride + 1;
                v0 = uvs[ui];
                ui = texOffset + index2 * texStride + 1;
                dv1 = uvs[ui] - v0;
                ui = texOffset + index3 * texStride + 1;
                dv2 = uvs[ui] - v0;
                vi = posOffset + index1 * posStride;
                x0 = vertices[vi];
                y0 = vertices[vi + 1];
                z0 = vertices[vi + 2];
                vi = posOffset + index2 * posStride;
                dx1 = vertices[vi] - x0;
                dy1 = vertices[vi + 1] - y0;
                dz1 = vertices[vi + 2] - z0;
                vi = posOffset + index3 * posStride;
                dx2 = vertices[vi] - x0;
                dy2 = vertices[vi + 1] - y0;
                dz2 = vertices[vi + 2] - z0;
                cx = dv2 * dx1 - dv1 * dx2;
                cy = dv2 * dy1 - dv1 * dy2;
                cz = dv2 * dz1 - dv1 * dz2;
                denom = 1 / Math.sqrt(cx * cx + cy * cy + cz * cz);
                this._faceTangents[i++] = denom * cx;
                this._faceTangents[i++] = denom * cy;
                this._faceTangents[i++] = denom * cz;
            }
            this._faceTangentsDirty = false;
        };
        /**
         * 更新顶点切线数据
         * @param target 顶点切线数据
         * @return 顶点切线数据
         */
        AutoDeriveVertexTangents.prototype.updateVertexTangents = function (target) {
            if (this._faceTangentsDirty)
                this.updateFaceTangents();
            var i;
            var lenV = this.subGeometry.numVertices * 3;
            var tangentStride = 3;
            var tangentOffset = 0;
            if (target == null) {
                target = [];
                target.length = lenV;
            }
            i = tangentOffset;
            while (i < lenV) {
                target[i] = 0.0;
                target[i + 1] = 0.0;
                target[i + 2] = 0.0;
                i += tangentStride;
            }
            var k;
            var _indices = this.subGeometry.indices;
            var lenI = _indices.length;
            var index;
            var weight;
            var f1 = 0, f2 = 1, f3 = 2;
            i = 0;
            while (i < lenI) {
                weight = this._useFaceWeights ? this._faceWeights[k++] : 1;
                index = tangentOffset + _indices[i++] * tangentStride;
                target[index++] += this._faceTangents[f1] * weight;
                target[index++] += this._faceTangents[f2] * weight;
                target[index] += this._faceTangents[f3] * weight;
                index = tangentOffset + _indices[i++] * tangentStride;
                target[index++] += this._faceTangents[f1] * weight;
                target[index++] += this._faceTangents[f2] * weight;
                target[index] += this._faceTangents[f3] * weight;
                index = tangentOffset + _indices[i++] * tangentStride;
                target[index++] += this._faceTangents[f1] * weight;
                target[index++] += this._faceTangents[f2] * weight;
                target[index] += this._faceTangents[f3] * weight;
                f1 += 3;
                f2 += 3;
                f3 += 3;
            }
            i = tangentOffset;
            while (i < lenV) {
                var vx = target[i];
                var vy = target[i + 1];
                var vz = target[i + 2];
                var d = 1.0 / Math.sqrt(vx * vx + vy * vy + vz * vz);
                target[i] = vx * d;
                target[i + 1] = vy * d;
                target[i + 2] = vz * d;
                i += tangentStride;
            }
            return target;
        };
        return AutoDeriveVertexTangents;
    }(feng3d.SubGeometryComponent));
    feng3d.AutoDeriveVertexTangents = AutoDeriveVertexTangents;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 自动生成虚拟UV
     * @author feng 2015-12-8
     */
    var AutoGenerateDummyUVs = (function (_super) {
        __extends(AutoGenerateDummyUVs, _super);
        function AutoGenerateDummyUVs() {
            _super.call(this);
            this.dataTypeId = this._.uv_va_2;
        }
        Object.defineProperty(AutoGenerateDummyUVs.prototype, "subGeometry", {
            set: function (value) {
                if (this._subGeometry != null) {
                    this._subGeometry.removeEventListener(feng3d.GeometryComponentEvent.GET_VA_DATA, this.onGetVAData);
                    this._subGeometry.removeEventListener(feng3d.GeometryComponentEvent.CHANGED_VA_DATA, this.onChangedVAData);
                }
                this._subGeometry = value;
                if (this._subGeometry != null) {
                    this._subGeometry.addEventListener(feng3d.GeometryComponentEvent.GET_VA_DATA, this.onGetVAData);
                    this._subGeometry.addEventListener(feng3d.GeometryComponentEvent.CHANGED_VA_DATA, this.onChangedVAData);
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 处理被添加事件
         * @param event
         */
        AutoGenerateDummyUVs.prototype.onBeAddedComponet = function (event) {
            _super.prototype.onBeAddedComponet.call(this, event);
            this.needGenerate = true;
            this.subGeometry.invalidVAData(this.dataTypeId);
        };
        AutoGenerateDummyUVs.prototype.onGetVAData = function (event) {
            if (event.data != this.dataTypeId)
                return;
            if (!this.needGenerate)
                return;
            this.target = this.updateDummyUVs(this.target);
            this.subGeometry.setVAData(this.dataTypeId, this.target);
            this.needGenerate = false;
        };
        /**
         * 更新虚拟uv
         * @param target 虚拟uv(输出)
         * @return 虚拟uv
         */
        AutoGenerateDummyUVs.prototype.updateDummyUVs = function (target) {
            var idx, uvIdx;
            var stride = 2;
            var len = this.subGeometry.numVertices * stride;
            if (!target)
                target = [];
            target.length = len;
            idx = 0;
            uvIdx = 0;
            while (idx < len) {
                target[idx++] = uvIdx * .5;
                target[idx++] = 1.0 - (uvIdx & 1);
                if (++uvIdx == 3)
                    uvIdx = 0;
            }
            return target;
        };
        AutoGenerateDummyUVs.prototype.onChangedVAData = function (event) {
            if (event.data == this._.position_va_3) {
                this.needGenerate = true;
            }
        };
        return AutoGenerateDummyUVs;
    }(feng3d.SubGeometryComponent));
    feng3d.AutoGenerateDummyUVs = AutoGenerateDummyUVs;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 蒙皮子网格
     * 提供了关节 索引数据与权重数据
     */
    var SkinnedSubGeometry = (function (_super) {
        __extends(SkinnedSubGeometry, _super);
        /**
         * 创建蒙皮子网格
         */
        function SkinnedSubGeometry(jointsPerVertex) {
            _super.call(this);
            this._jointsPerVertex = jointsPerVertex;
        }
        /**
         * 处理被添加事件
         * @param event
         */
        SkinnedSubGeometry.prototype.onBeAddedComponet = function (event) {
            _super.prototype.onBeAddedComponet.call(this, event);
            this.subGeometry.mapVABuffer(this._.animated_va_3, 3);
            this.subGeometry.mapVABuffer(this._.jointweights_va_x, this._jointsPerVertex);
            this.subGeometry.mapVABuffer(this._.jointindex_va_x, this._jointsPerVertex);
        };
        /**
         * 更新动画顶点数据
         */
        SkinnedSubGeometry.prototype.updateAnimatedData = function (value) {
            this.subGeometry.setVAData(this._.animated_va_3, value);
        };
        Object.defineProperty(SkinnedSubGeometry.prototype, "jointWeightsData", {
            /**
             * 关节权重数据
             */
            get: function () {
                var data = this.subGeometry.getVAData(this._.jointweights_va_x);
                return data;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SkinnedSubGeometry.prototype, "jointIndexData", {
            /**
             * 关节索引数据
             */
            get: function () {
                var data = this.subGeometry.getVAData(this._.jointindex_va_x);
                return data;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 更新关节权重数据
         */
        SkinnedSubGeometry.prototype.updateJointWeightsData = function (value) {
            this.subGeometry.setVAData(this._.jointweights_va_x, value);
        };
        /**
         * 更新关节索引数据
         */
        SkinnedSubGeometry.prototype.updateJointIndexData = function (value) {
            this.subGeometry.setVAData(this._.jointindex_va_x, value);
        };
        return SkinnedSubGeometry;
    }(feng3d.SubGeometryComponent));
    feng3d.SkinnedSubGeometry = SkinnedSubGeometry;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 子几何体形变组件
     * @author feng 2015-12-10
     */
    var SubGeometryTransformation = (function (_super) {
        __extends(SubGeometryTransformation, _super);
        function SubGeometryTransformation() {
            _super.call(this);
            this._scaleU = 1;
            this._scaleV = 1;
        }
        Object.defineProperty(SubGeometryTransformation.prototype, "scaleU", {
            get: function () {
                return this._scaleU;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SubGeometryTransformation.prototype, "scaleV", {
            get: function () {
                return this._scaleV;
            },
            enumerable: true,
            configurable: true
        });
        SubGeometryTransformation.prototype.scaleUV = function (scaleU, scaleV) {
            if (scaleU === void 0) { scaleU = 1; }
            if (scaleV === void 0) { scaleV = 1; }
            var stride = this.subGeometry.getVALen(this._.uv_va_2);
            var uvs = this.subGeometry.UVData;
            var len = uvs.length;
            var ratioU = scaleU / this._scaleU;
            var ratioV = scaleV / this._scaleV;
            for (var i = 0; i < len; i += stride) {
                uvs[i] *= ratioU;
                uvs[i + 1] *= ratioV;
            }
            this._scaleU = scaleU;
            this._scaleV = scaleV;
            this.subGeometry.setVAData(this._.uv_va_2, uvs);
        };
        /**
         * 缩放网格尺寸
         */
        SubGeometryTransformation.prototype.scale = function (scale) {
            var vertices = this.subGeometry.getVAData(this._.position_va_3);
            var len = vertices.length;
            var stride = this.subGeometry.getVALen(this._.position_va_3);
            for (var i = 0; i < len; i += stride) {
                vertices[i] *= scale;
                vertices[i + 1] *= scale;
                vertices[i + 2] *= scale;
            }
            this.subGeometry.setVAData(this._.position_va_3, vertices);
        };
        /**
         * 应用变换矩阵
         * @param transform 变换矩阵
         */
        SubGeometryTransformation.prototype.applyTransformation = function (transform) {
            var vertices = this.subGeometry.vertexPositionData;
            var normals = this.subGeometry.vertexNormalData;
            var tangents = this.subGeometry.vertexTangentData;
            var posStride = this.subGeometry.vertexPositionStride;
            var normalStride = this.subGeometry.vertexNormalStride;
            var tangentStride = this.subGeometry.vertexTangentStride;
            var len = vertices.length / posStride;
            var i, i1, i2;
            var vector = new feng3d.Vector3D();
            var bakeNormals = normals != null;
            var bakeTangents = tangents != null;
            var invTranspose;
            if (bakeNormals || bakeTangents) {
                invTranspose = transform.clone();
                invTranspose.invert();
                invTranspose.transpose();
            }
            var vi0 = 0;
            var ni0 = 0;
            var ti0 = 0;
            for (i = 0; i < len; ++i) {
                i1 = vi0 + 1;
                i2 = vi0 + 2;
                // bake position
                vector.x = vertices[vi0];
                vector.y = vertices[i1];
                vector.z = vertices[i2];
                vector = transform.transformVector(vector);
                vertices[vi0] = vector.x;
                vertices[i1] = vector.y;
                vertices[i2] = vector.z;
                vi0 += posStride;
                // bake normal
                if (bakeNormals) {
                    i1 = ni0 + 1;
                    i2 = ni0 + 2;
                    vector.x = normals[ni0];
                    vector.y = normals[i1];
                    vector.z = normals[i2];
                    vector = invTranspose.deltaTransformVector(vector);
                    vector.normalize();
                    normals[ni0] = vector.x;
                    normals[i1] = vector.y;
                    normals[i2] = vector.z;
                    ni0 += normalStride;
                }
                // bake tangent
                if (bakeTangents) {
                    i1 = ti0 + 1;
                    i2 = ti0 + 2;
                    vector.x = tangents[ti0];
                    vector.y = tangents[i1];
                    vector.z = tangents[i2];
                    vector = invTranspose.deltaTransformVector(vector);
                    vector.normalize();
                    tangents[ti0] = vector.x;
                    tangents[i1] = vector.y;
                    tangents[i2] = vector.z;
                    ti0 += tangentStride;
                }
            }
            this.subGeometry.setVAData(this._.position_va_3, vertices);
            this.subGeometry.setVAData(this._.normal_va_3, normals);
            this.subGeometry.setVAData(this._.tangent_va_3, tangents);
        };
        return SubGeometryTransformation;
    }(feng3d.SubGeometryComponent));
    feng3d.SubGeometryTransformation = SubGeometryTransformation;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 顶点动画 子网格
     * @author feng 2014-8-28
     */
    var VertexSubGeometry = (function (_super) {
        __extends(VertexSubGeometry, _super);
        function VertexSubGeometry() {
            _super.call(this);
        }
        /**
         * 处理被添加事件
         * @param event
         */
        VertexSubGeometry.prototype.onBeAddedComponet = function (event) {
            _super.prototype.onBeAddedComponet.call(this, event);
            this.subGeometry.mapVABuffer(this._.position0_va_3, 3);
            this.subGeometry.mapVABuffer(this._.position1_va_3, 3);
            this.updateVertexData0(this.subGeometry.vertexPositionData.concat());
            this.updateVertexData1(this.subGeometry.vertexPositionData.concat());
        };
        VertexSubGeometry.prototype.updateVertexData0 = function (vertices) {
            this.subGeometry.updateVertexPositionData(vertices);
            this.subGeometry.setVAData(this._.position0_va_3, vertices);
        };
        VertexSubGeometry.prototype.updateVertexData1 = function (vertices) {
            this.subGeometry.setVAData(this._.position1_va_3, vertices);
        };
        return VertexSubGeometry;
    }(feng3d.SubGeometryComponent));
    feng3d.VertexSubGeometry = VertexSubGeometry;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 3d容器变换组件
     * @author feng 2016-3-9
     */
    var ContainerTransform3D = (function (_super) {
        __extends(ContainerTransform3D, _super);
        /**
         * 创建一个3d容器变换组件
         */
        function ContainerTransform3D() {
            _super.call(this);
            this.addEventListener(feng3d.ComponentEvent.BE_ADDED_COMPONET, this.onBeAddedComponet);
        }
        /**
         * 处理组件被添加事件
         * @param event
         */
        ContainerTransform3D.prototype.onBeAddedComponet = function (event) {
            var data = event.data;
            this.objectContainer3D = feng3d.as(data.container, feng3d.Container3D);
            this.objectContainer3D.transform3D.addEventListener(feng3d.Transform3DEvent.TRANSFORM_CHANGED, this.onContainer3DTranformChange);
        };
        /**
         * 处理容器变换事件
         * @param event
         */
        ContainerTransform3D.prototype.onContainer3DTranformChange = function (event) {
            var len = this.objectContainer3D.numChildren;
            for (var i = 0; i < len; i++) {
                var transform3D = this.objectContainer3D.getChildAt(i).transform3D;
                transform3D.invalidateTransform();
            }
        };
        return ContainerTransform3D;
    }(feng3d.Component));
    feng3d.ContainerTransform3D = ContainerTransform3D;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 位移时抛出
     */
    //[Event(name = "positionChanged", type = "me.feng3d.events.Transform3DEvent")]
    /**
     * 旋转时抛出
     */
    //[Event(name = "rotationChanged", type = "me.feng3d.events.Transform3DEvent")]
    /**
     * 缩放时抛出
     */
    //[Event(name = "scaleChanged", type = "me.feng3d.events.Transform3DEvent")]
    /**
     * 变换状态抛出
     */
    //[Event(name = "transformChanged", type = "me.feng3d.events.Transform3DEvent")]
    /**
     * 变换已更新
     */
    //[Event(name = "transformUpdated", type = "me.feng3d.events.Transform3DEvent")]
    /**
     * 3D元素<br/><br/>
     *
     * 主要功能:
     * <ul>
     *     <li>管理3D元素的位置、旋转、缩放状态</li>
     * </ul>
     * @author feng 2014-3-31
     */
    var Element3D = (function (_super) {
        __extends(Element3D, _super);
        function Element3D() {
            _super.call(this);
            this._smallestNumber = 0.0000000000000000000001;
            this._transformDirty = true;
            this._eulers = new feng3d.Vector3D();
            this._transform = new feng3d.Matrix3D();
            this._x = 0;
            this._y = 0;
            this._z = 0;
            this._rotationX = 0;
            this._rotationY = 0;
            this._rotationZ = 0;
            this._scaleX = 1;
            this._scaleY = 1;
            this._scaleZ = 1;
            this._pivotPoint = new feng3d.Vector3D();
            this._pivotZero = true;
            this._pos = new feng3d.Vector3D();
            this._rot = new feng3d.Vector3D();
            this._sca = new feng3d.Vector3D();
            // Cached vector of transformation components used when
            // recomposing the this.transform matrix in this.updateTransform()
            this._transformComponents = [];
            this._transformComponents[0] = this._pos;
            this._transformComponents[1] = this._rot;
            this._transformComponents[2] = this._sca;
            this._transform.identity();
        }
        Object.defineProperty(Element3D.prototype, "x", {
            /**
             * 相对父容器的X坐标
             */
            get: function () {
                return this._x;
            },
            set: function (val) {
                if (this._x == val)
                    return;
                this._x = val;
                this.invalidatePosition();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Element3D.prototype, "y", {
            /**
             * 相对父容器的Y坐标
             */
            get: function () {
                return this._y;
            },
            set: function (val) {
                if (this._y == val)
                    return;
                this._y = val;
                this.invalidatePosition();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Element3D.prototype, "z", {
            /**
             * 相对父容器的Z坐标
             */
            get: function () {
                return this._z;
            },
            set: function (val) {
                if (this._z == val)
                    return;
                this._z = val;
                this.invalidatePosition();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Element3D.prototype, "rotationX", {
            /**
             * 绕X轴旋转角度
             */
            get: function () {
                return this._rotationX * feng3d.MathConsts.RADIANS_TO_DEGREES;
            },
            set: function (val) {
                if (this.rotationX == val)
                    return;
                this._rotationX = val * feng3d.MathConsts.DEGREES_TO_RADIANS;
                this.invalidateRotation();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Element3D.prototype, "rotationY", {
            /**
             * 绕Y轴旋转角度
             */
            get: function () {
                return this._rotationY * feng3d.MathConsts.RADIANS_TO_DEGREES;
            },
            set: function (val) {
                if (this.rotationY == val)
                    return;
                this._rotationY = val * feng3d.MathConsts.DEGREES_TO_RADIANS;
                this.invalidateRotation();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Element3D.prototype, "rotationZ", {
            /**
             * 绕Z轴旋转角度
             */
            get: function () {
                return this._rotationZ * feng3d.MathConsts.RADIANS_TO_DEGREES;
            },
            set: function (val) {
                if (this.rotationZ == val)
                    return;
                this._rotationZ = val * feng3d.MathConsts.DEGREES_TO_RADIANS;
                this.invalidateRotation();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Element3D.prototype, "scaleX", {
            /**
             * X轴旋方向缩放
             */
            get: function () {
                return this._scaleX;
            },
            set: function (val) {
                if (this._scaleX == val)
                    return;
                this._scaleX = val;
                this.invalidateScale();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Element3D.prototype, "scaleY", {
            /**
             * Y轴旋方向缩放
             */
            get: function () {
                return this._scaleY;
            },
            set: function (val) {
                if (this._scaleY == val)
                    return;
                this._scaleY = val;
                this.invalidateScale();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Element3D.prototype, "scaleZ", {
            /**
             * Z轴旋方向缩放
             */
            get: function () {
                return this._scaleZ;
            },
            set: function (val) {
                if (this._scaleZ == val)
                    return;
                this._scaleZ = val;
                this.invalidateScale();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Element3D.prototype, "eulers", {
            /**
             * 欧拉角
             * <ul>
             *     <li>使用Vector3D对象表示 相对x、y、z轴上的旋转角度</li>
             * </ul>
             */
            get: function () {
                this._eulers.x = this._rotationX * feng3d.MathConsts.RADIANS_TO_DEGREES;
                this._eulers.y = this._rotationY * feng3d.MathConsts.RADIANS_TO_DEGREES;
                this._eulers.z = this._rotationZ * feng3d.MathConsts.RADIANS_TO_DEGREES;
                return this._eulers;
            },
            set: function (value) {
                this._rotationX = value.x * feng3d.MathConsts.DEGREES_TO_RADIANS;
                this._rotationY = value.y * feng3d.MathConsts.DEGREES_TO_RADIANS;
                this._rotationZ = value.z * feng3d.MathConsts.DEGREES_TO_RADIANS;
                this.invalidateRotation();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Element3D.prototype, "transform", {
            /**
             * 3d元素变换矩阵
             */
            get: function () {
                if (this._transformDirty)
                    this.updateTransform();
                return this._transform;
            },
            set: function (val) {
                //ridiculous matrix error
                var raw = feng3d.Matrix3DUtils.RAW_DATA_CONTAINER;
                val.copyRawDataTo(raw);
                if (!raw[0]) {
                    raw[0] = this._smallestNumber;
                    val.copyRawDataFrom(raw);
                }
                var elements = feng3d.Matrix3DUtils.decompose(val);
                var vec;
                vec = elements[0];
                if (this._x != vec.x || this._y != vec.y || this._z != vec.z) {
                    this._x = vec.x;
                    this._y = vec.y;
                    this._z = vec.z;
                    this.invalidatePosition();
                }
                vec = elements[1];
                if (this._rotationX != vec.x || this._rotationY != vec.y || this._rotationZ != vec.z) {
                    this._rotationX = vec.x;
                    this._rotationY = vec.y;
                    this._rotationZ = vec.z;
                    this.invalidateRotation();
                }
                vec = elements[2];
                if (this._scaleX != vec.x || this._scaleY != vec.y || this._scaleZ != vec.z) {
                    this._scaleX = vec.x;
                    this._scaleY = vec.y;
                    this._scaleZ = vec.z;
                    this.invalidateScale();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Element3D.prototype, "pivotPoint", {
            /**
             * 中心点坐标（本地对象旋转点）
             */
            get: function () {
                return this._pivotPoint;
            },
            set: function (pivot) {
                if (!this._pivotPoint)
                    this._pivotPoint = new feng3d.Vector3D();
                this._pivotPoint.x = pivot.x;
                this._pivotPoint.y = pivot.y;
                this._pivotPoint.z = pivot.z;
                this.invalidatePivot();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Element3D.prototype, "position", {
            /**
             * 获取在父容器中的坐标
             */
            get: function () {
                this.transform.copyColumnTo(3, this._pos);
                return this._pos.clone();
            },
            set: function (value) {
                this._x = value.x;
                this._y = value.y;
                this._z = value.z;
                this.invalidatePosition();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 使位置数据无效
         */
        Element3D.prototype.invalidatePosition = function () {
            if (this._positionDirty)
                return;
            this._positionDirty = true;
            this.invalidateTransform();
            if (this._listenToPositionChanged)
                this.notifyPositionChanged();
        };
        /**
         * 发出平移事件
         */
        Element3D.prototype.notifyPositionChanged = function () {
            if (!this._positionChanged)
                this._positionChanged = new feng3d.Transform3DEvent(feng3d.Transform3DEvent.POSITION_CHANGED, this);
            this.dispatchEvent(this._positionChanged);
        };
        /**
         * 使变换矩阵失效
         */
        Element3D.prototype.invalidateTransform = function () {
            this._transformDirty = true;
            if (this._listenToTransformChanged)
                this.notifyTransformChanged();
        };
        /**
         * 发出状态改变消息
         */
        Element3D.prototype.notifyTransformChanged = function () {
            if (!this._transformChanged)
                this._transformChanged = new feng3d.Transform3DEvent(feng3d.Transform3DEvent.TRANSFORM_CHANGED, this);
            this.dispatchEvent(this._transformChanged);
        };
        /**
         * 更新变换矩阵
         */
        Element3D.prototype.updateTransform = function () {
            this._pos.x = this._x;
            this._pos.y = this._y;
            this._pos.z = this._z;
            this._rot.x = this._rotationX;
            this._rot.y = this._rotationY;
            this._rot.z = this._rotationZ;
            if (!this._pivotZero) {
                this._sca.x = 1;
                this._sca.y = 1;
                this._sca.z = 1;
                this._transform.recompose(this._transformComponents);
                this._transform.appendTranslation(this._pivotPoint.x, this._pivotPoint.y, this._pivotPoint.z);
                this._transform.prependTranslation(-this._pivotPoint.x, -this._pivotPoint.y, -this._pivotPoint.z);
                this._transform.prependScale(this._scaleX, this._scaleY, this._scaleZ);
                this._sca.x = this._scaleX;
                this._sca.y = this._scaleY;
                this._sca.z = this._scaleZ;
            }
            else {
                this._sca.x = this._scaleX;
                this._sca.y = this._scaleY;
                this._sca.z = this._scaleZ;
                this._transform.recompose(this._transformComponents);
            }
            this._transformDirty = false;
            this._positionDirty = false;
            this._rotationDirty = false;
            this._scaleDirty = false;
            this.dispatchEvent(new feng3d.Transform3DEvent(feng3d.Transform3DEvent.TRANSFORM_UPDATED, this));
        };
        /**
         * 使中心点无效
         */
        Element3D.prototype.invalidatePivot = function () {
            this._pivotZero = (this._pivotPoint.x == 0) && (this._pivotPoint.y == 0) && (this._pivotPoint.z == 0);
            this.invalidateTransform();
        };
        /**
         * 监听事件
         * @param type 事件类型
         * @param listener 回调函数
         */
        Element3D.prototype.addEventListener = function (type, listener, priority, useWeakReference) {
            if (priority === void 0) { priority = 0; }
            if (useWeakReference === void 0) { useWeakReference = false; }
            _super.prototype.addEventListener.call(this, type, listener, priority, useWeakReference);
            switch (type) {
                case feng3d.Transform3DEvent.POSITION_CHANGED:
                    this._listenToPositionChanged = true;
                    break;
                case feng3d.Transform3DEvent.ROTATION_CHANGED:
                    this._listenToRotationChanged = true;
                    break;
                case feng3d.Transform3DEvent.SCALE_CHANGED:
                    this._listenToRotationChanged = true;
                    break;
                case feng3d.Transform3DEvent.TRANSFORM_CHANGED:
                    this._listenToTransformChanged = true;
                    break;
            }
        };
        /**
         * 移除事件
         * @param type 事件类型
         * @param listener 回调函数
         */
        Element3D.prototype.removeEventListener = function (type, listener) {
            _super.prototype.removeEventListener.call(this, type, listener);
            if (this.hasEventListener(type))
                return;
            switch (type) {
                case feng3d.Transform3DEvent.POSITION_CHANGED:
                    this._listenToPositionChanged = false;
                    break;
                case feng3d.Transform3DEvent.ROTATION_CHANGED:
                    this._listenToRotationChanged = false;
                    break;
                case feng3d.Transform3DEvent.SCALE_CHANGED:
                    this._listenToScaleChanged = false;
                    break;
                case feng3d.Transform3DEvent.TRANSFORM_CHANGED:
                    this._listenToTransformChanged = false;
                    break;
            }
        };
        /**
         * 使旋转角度无效
         */
        Element3D.prototype.invalidateRotation = function () {
            if (this._rotationDirty)
                return;
            this._rotationDirty = true;
            this.invalidateTransform();
            if (this._listenToRotationChanged)
                this.notifyRotationChanged();
        };
        /**
         * 抛出旋转事件
         */
        Element3D.prototype.notifyRotationChanged = function () {
            if (!this._rotationChanged)
                this._rotationChanged = new feng3d.Transform3DEvent(feng3d.Transform3DEvent.ROTATION_CHANGED, this);
            this.dispatchEvent(this._rotationChanged);
        };
        /**
         * 使缩放无效
         */
        Element3D.prototype.invalidateScale = function () {
            if (this._scaleDirty)
                return;
            this._scaleDirty = true;
            this.invalidateTransform();
            if (this._listenToScaleChanged)
                this.notifyScaleChanged();
        };
        /**
         * 抛出缩放事件
         */
        Element3D.prototype.notifyScaleChanged = function () {
            if (!this._scaleChanged)
                this._scaleChanged = new feng3d.Transform3DEvent(feng3d.Transform3DEvent.SCALE_CHANGED, this);
            this.dispatchEvent(this._scaleChanged);
        };
        return Element3D;
    }(feng3d.Component));
    feng3d.Element3D = Element3D;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 3D元素状态变换<br/><br/>
     *
     * 主要功能:
     * <ul>
     *     <li>处理3d元素的平移、旋转、缩放等操作</li>
     * </ul>
     *
     * @author feng 2014-3-31
     */
    var Transform3D = (function (_super) {
        __extends(Transform3D, _super);
        /**
         * 创建3D元素状态变换实例
         */
        function Transform3D() {
            _super.call(this);
        }
        Object.defineProperty(Transform3D.prototype, "forwardVector", {
            /**
             * 前方单位向量
             * <ul>
             * 		<li>自身的Z轴方向</li>
             * </ul>
             */
            get: function () {
                return feng3d.Matrix3DUtils.getForward(this.transform);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Transform3D.prototype, "rightVector", {
            /**
             * 右方单位向量
             * <ul>
             * 		<li>自身的X轴方向</li>
             * </ul>
             */
            get: function () {
                return feng3d.Matrix3DUtils.getRight(this.transform);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Transform3D.prototype, "upVector", {
            /**
             * 上方单位向量
             * <ul>
             * 		<li>自身的Y轴方向</li>
             * </ul>
             */
            get: function () {
                return feng3d.Matrix3DUtils.getUp(this.transform);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Transform3D.prototype, "backVector", {
            /**
             * 后方单位向量
             * <ul>
             * 		<li>自身的Z轴负方向</li>
             * </ul>
             */
            get: function () {
                var director = feng3d.Matrix3DUtils.getForward(this.transform);
                director.negate();
                return director;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Transform3D.prototype, "leftVector", {
            /**
             * 左方单位向量
             * <ul>
             * 		<li>自身的X轴负方向</li>
             * </ul>
             */
            get: function () {
                var director = feng3d.Matrix3DUtils.getRight(this.transform);
                director.negate();
                return director;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Transform3D.prototype, "downVector", {
            /**
             * 下方单位向量
             * <ul>
             * 		<li>自身的Y轴负方向</li>
             * </ul>
             */
            get: function () {
                var director = feng3d.Matrix3DUtils.getUp(this.transform);
                director.negate();
                return director;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 等比缩放
         * @param value 缩放比例
         */
        Transform3D.prototype.scale = function (value) {
            this._scaleX *= value;
            this._scaleY *= value;
            this._scaleZ *= value;
            this.invalidateScale();
        };
        /**
         * 向前（Z轴方向）位移
         * @param distance 位移距离
         */
        Transform3D.prototype.moveForward = function (distance) {
            this.translateLocal(feng3d.Vector3D.Z_AXIS, distance);
        };
        /**
         * 向后（Z轴负方向）位移
         * @param distance 位移距离
         */
        Transform3D.prototype.moveBackward = function (distance) {
            this.translateLocal(feng3d.Vector3D.Z_AXIS, -distance);
        };
        /**
         * 向左（X轴负方向）位移
         * @param distance 位移距离
         */
        Transform3D.prototype.moveLeft = function (distance) {
            this.translateLocal(feng3d.Vector3D.X_AXIS, -distance);
        };
        /**
         * 向右（X轴方向）位移
         * @param distance 位移距离
         */
        Transform3D.prototype.moveRight = function (distance) {
            this.translateLocal(feng3d.Vector3D.X_AXIS, distance);
        };
        /**
         * 向上（Y轴方向）位移
         * @param distance 位移距离
         */
        Transform3D.prototype.moveUp = function (distance) {
            this.translateLocal(feng3d.Vector3D.Y_AXIS, distance);
        };
        /**
         * 向下（Y轴负方向）位移
         * @param distance 位移距离
         */
        Transform3D.prototype.moveDown = function (distance) {
            this.translateLocal(feng3d.Vector3D.Y_AXIS, -distance);
        };
        /**
         * 直接移到空间的某个位置
         * @param newX x坐标
         * @param newY y坐标
         * @param newZ z坐标
         */
        Transform3D.prototype.moveTo = function (newX, newY, newZ) {
            if (this._x == newX && this._y == newY && this._z == newZ)
                return;
            this._x = newX;
            this._y = newY;
            this._z = newZ;
            this.invalidatePosition();
        };
        /**
         * 移动中心点（旋转点）
         * @param dx X轴方向位移
         * @param dy Y轴方向位移
         * @param dz Z轴方向位移
         */
        Transform3D.prototype.movePivot = function (dx, dy, dz) {
            if (!this._pivotPoint)
                this._pivotPoint = new feng3d.Vector3D();
            this._pivotPoint.x += dx;
            this._pivotPoint.y += dy;
            this._pivotPoint.z += dz;
            this.invalidatePivot();
        };
        /**
         * 在自定义轴上位移
         * @param axis 自定义轴
         * @param distance 位移距离
         */
        Transform3D.prototype.translate = function (axis, distance) {
            var x = axis.x, y = axis.y, z = axis.z;
            var len = distance / Math.sqrt(x * x + y * y + z * z);
            this._x += x * len;
            this._y += y * len;
            this._z += z * len;
            this.invalidatePosition();
        };
        /**
         * 在自定义轴上位移<br/>
         *
         * 注意：
         * <ul>
         * 		<li>没太理解 与 translate的区别</li>
         * </ul>
         * @param axis 自定义轴
         * @param distance 位移距离
         */
        Transform3D.prototype.translateLocal = function (axis, distance) {
            var len = distance / axis.length;
            this.transform.prependTranslation(axis.x * len, axis.y * len, axis.z * len);
            this._transform.copyColumnTo(3, this._pos);
            this._x = this._pos.x;
            this._y = this._pos.y;
            this._z = this._pos.z;
            this.invalidatePosition();
        };
        /**
         * 绕X轴旋转
         * @param angle 旋转角度
         */
        Transform3D.prototype.pitch = function (angle) {
            this.rotate(feng3d.Vector3D.X_AXIS, angle);
        };
        /**
         * 绕Y轴旋转
         * @param angle 旋转角度
         */
        Transform3D.prototype.yaw = function (angle) {
            this.rotate(feng3d.Vector3D.Y_AXIS, angle);
        };
        /**
         * 绕Z轴旋转
         * @param angle 旋转角度
         */
        Transform3D.prototype.roll = function (angle) {
            this.rotate(feng3d.Vector3D.Z_AXIS, angle);
        };
        /**
         * 直接修改欧拉角
         * @param ax X轴旋转角度
         * @param ay Y轴旋转角度
         * @param az Z轴旋转角度
         */
        Transform3D.prototype.rotateTo = function (ax, ay, az) {
            this._rotationX = ax * feng3d.MathConsts.DEGREES_TO_RADIANS;
            this._rotationY = ay * feng3d.MathConsts.DEGREES_TO_RADIANS;
            this._rotationZ = az * feng3d.MathConsts.DEGREES_TO_RADIANS;
            this.invalidateRotation();
        };
        /**
         * 绕所给轴旋转
         * @param axis 任意轴
         * @param angle 旋转角度
         */
        Transform3D.prototype.rotate = function (axis, angle) {
            var m = new feng3d.Matrix3D();
            m.prependRotation(angle, axis);
            var vec = m.decompose()[1];
            this._rotationX += vec.x;
            this._rotationY += vec.y;
            this._rotationZ += vec.z;
            this.invalidateRotation();
        };
        /**
         * 观察目标
         * <ul>
         * 		<li>旋转至朝向给出的点</li>
         * </ul>
         * @param target 	目标点
         * @param upAxis 	旋转后向上方向（并非绝对向上），默认为null，当值为null时会以Y轴为向上方向计算
         */
        Transform3D.prototype.lookAt = function (target, upAxis) {
            if (upAxis === void 0) { upAxis = null; }
            var tempAxeX;
            var tempAxeY;
            var tempAxeZ;
            if (!tempAxeX)
                tempAxeX = new feng3d.Vector3D();
            if (!tempAxeY)
                tempAxeY = new feng3d.Vector3D();
            if (!tempAxeZ)
                tempAxeZ = new feng3d.Vector3D();
            //旋转后的X轴
            var xAxis = tempAxeX;
            //旋转后的Y轴
            var yAxis = tempAxeY;
            //旋转后的Z轴
            var zAxis = tempAxeZ;
            var raw;
            //向上方向默认值为Y轴
            if (upAxis == null)
                upAxis = feng3d.Vector3D.Y_AXIS;
            if (this._transformDirty) {
                this.updateTransform();
            }
            //物体与目标点在相同位置时，稍作偏移
            if (new feng3d.Vector3D(this._x, this._y, this._z).subtract(target).length == 0) {
                this._z = target.z + 0.1;
            }
            //获得Z轴
            zAxis.x = target.x - this._x;
            zAxis.y = target.y - this._y;
            zAxis.z = target.z - this._z;
            zAxis.normalize();
            //向上方向与Z轴 叉乘 得到X轴
            xAxis.x = upAxis.y * zAxis.z - upAxis.z * zAxis.y;
            xAxis.y = upAxis.z * zAxis.x - upAxis.x * zAxis.z;
            xAxis.z = upAxis.x * zAxis.y - upAxis.y * zAxis.x;
            xAxis.normalize();
            if (xAxis.length < .05) {
                xAxis.x = upAxis.y;
                xAxis.y = upAxis.x;
                xAxis.z = 0;
                xAxis.normalize();
            }
            //Z轴叉乘X轴 得到 Y轴，Z与X为标准化向量，得到的Y轴也将是标准化向量
            yAxis.x = zAxis.y * xAxis.z - zAxis.z * xAxis.y;
            yAxis.y = zAxis.z * xAxis.x - zAxis.x * xAxis.z;
            yAxis.z = zAxis.x * xAxis.y - zAxis.y * xAxis.x;
            raw = feng3d.Matrix3DUtils.RAW_DATA_CONTAINER;
            //根据XYZ轴计算变换矩阵
            raw[0] = this._scaleX * xAxis.x;
            raw[1] = this._scaleX * xAxis.y;
            raw[2] = this._scaleX * xAxis.z;
            raw[3] = 0;
            raw[4] = this._scaleY * yAxis.x;
            raw[5] = this._scaleY * yAxis.y;
            raw[6] = this._scaleY * yAxis.z;
            raw[7] = 0;
            raw[8] = this._scaleZ * zAxis.x;
            raw[9] = this._scaleZ * zAxis.y;
            raw[10] = this._scaleZ * zAxis.z;
            raw[11] = 0;
            raw[12] = this._x;
            raw[13] = this._y;
            raw[14] = this._z;
            raw[15] = 1;
            this._transform.copyRawDataFrom(raw);
            this.transform = this.transform;
            if (zAxis.z < 0) {
                this.rotationY = (180 - this.rotationY);
                this.rotationX -= 180;
                this.rotationZ -= 180;
            }
        };
        return Transform3D;
    }(feng3d.Element3D));
    feng3d.Transform3D = Transform3D;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 可渲染对象基类
     * @author feng 2015-5-27
     */
    var Renderable = (function (_super) {
        __extends(Renderable, _super);
        /**
         * 创建一个可渲染对象基类
         */
        function Renderable() {
            _super.call(this);
            this._context3dCache = new feng3d.Context3DCache();
        }
        Object.defineProperty(Renderable.prototype, "_", {
            /**
             * Fagal编号中心
             */
            get: function () {
                return feng3d.FagalIdCenter.instance;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Renderable.prototype, "context3dCache", {
            /**
             * @inheritDoc
             */
            get: function () {
                return this._context3dCache;
            },
            enumerable: true,
            configurable: true
        });
        return Renderable;
    }(feng3d.Component));
    feng3d.Renderable = Renderable;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 可渲染对象基类
     * @author feng 2015-5-27
     */
    var MeshRenderable = (function (_super) {
        __extends(MeshRenderable, _super);
        /**
         * 创建一个可渲染对象基类
         */
        function MeshRenderable(subMesh) {
            _super.call(this);
            this.subMesh = subMesh;
            this._context3dCache.addChildBufferOwner(subMesh.context3DBufferOwner);
        }
        /**
         * @inheritDoc
         */
        MeshRenderable.prototype.getMouseEnabled = function () {
            return this.subMesh.mouseEnabled;
        };
        /**
         * @inheritDoc
         */
        MeshRenderable.prototype.getNumTriangles = function () {
            return this.subMesh.numTriangles;
        };
        /**
         * @inheritDoc
         */
        MeshRenderable.prototype.getSourceEntity = function () {
            return this.subMesh.sourceEntity;
        };
        /**
         * @inheritDoc
         */
        MeshRenderable.prototype.getMaterial = function () {
            return this.subMesh.material;
        };
        /**
         * @inheritDoc
         */
        MeshRenderable.prototype.getAnimator = function () {
            return this.subMesh.animator;
        };
        /**
         * @inheritDoc
         */
        MeshRenderable.prototype.getCastsShadows = function () {
            return this.subMesh.castsShadows;
        };
        return MeshRenderable;
    }(feng3d.Renderable));
    feng3d.MeshRenderable = MeshRenderable;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     *
     * @author feng 2015-12-30
     */
    var SegmentRenderable = (function (_super) {
        __extends(SegmentRenderable, _super);
        /**
         * 创建一个可渲染对象基类
         */
        function SegmentRenderable(subMesh) {
            _super.call(this);
            this.segmentSet = subMesh;
            //			this._context3dCache.addChildBufferOwner(subMesh.context3DBufferOwner);
        }
        /**
         * @inheritDoc
         */
        SegmentRenderable.prototype.getMouseEnabled = function () {
            return this.segmentSet.mouseEnabled;
        };
        /**
         * @inheritDoc
         */
        SegmentRenderable.prototype.getNumTriangles = function () {
            return this.segmentSet.numTriangles;
        };
        /**
         * @inheritDoc
         */
        SegmentRenderable.prototype.getSourceEntity = function () {
            return this.segmentSet.sourceEntity;
        };
        /**
         * @inheritDoc
         */
        SegmentRenderable.prototype.getMaterial = function () {
            return this.segmentSet.material;
        };
        /**
         * @inheritDoc
         */
        SegmentRenderable.prototype.getAnimator = function () {
            return this.segmentSet.animator;
        };
        /**
         * @inheritDoc
         */
        SegmentRenderable.prototype.getCastsShadows = function () {
            return this.segmentSet.castsShadows;
        };
        return SegmentRenderable;
    }(feng3d.Renderable));
    feng3d.SegmentRenderable = SegmentRenderable;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 子网格，可渲染对象
     */
    var SubMesh = (function (_super) {
        __extends(SubMesh, _super);
        /**
         * 创建一个子网格
         * @param subGeometry 子几何体
         * @param parentMesh 父网格
         * @param material 材质
         */
        function SubMesh(subGeometry, parentMesh, material) {
            if (material === void 0) { material = null; }
            _super.call(this);
            this.context3DBufferOwner = new feng3d.Context3DBufferOwner();
            this.renderableBase = new feng3d.MeshRenderable(this);
            this._parentMesh = parentMesh;
            this.subGeometry = subGeometry;
            this.material = material;
            this._parentMesh.addEventListener(feng3d.MeshEvent.MATERIAL_CHANGE, this.onMaterialChange);
        }
        Object.defineProperty(SubMesh.prototype, "material", {
            /**
             * 渲染材质
             */
            get: function () {
                if (this._materialDirty)
                    this.updateMaterial();
                return this._material;
            },
            set: function (value) {
                this._materialSelf = value;
                this._materialDirty = true;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SubMesh.prototype, "materialSelf", {
            /**
             * 自身材质
             */
            get: function () {
                return this._materialSelf;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 更新材质
         */
        SubMesh.prototype.updateMaterial = function () {
            var value = this._materialSelf ? this._materialSelf : this._parentMesh.material;
            if (value == this._material)
                return;
            if (this._material) {
                this._material.removeOwner(this.renderableBase);
            }
            this._material = value;
            if (this._material) {
                this._material.addOwner(this.renderableBase);
            }
        };
        Object.defineProperty(SubMesh.prototype, "sourceEntity", {
            /**
             * 所属实体
             */
            get: function () {
                return this._parentMesh;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SubMesh.prototype, "subGeometry", {
            /**
             * 子网格
             */
            get: function () {
                return this._subGeometry;
            },
            set: function (value) {
                if (this._subGeometry) {
                    this.context3DBufferOwner.removeChildBufferOwner(this._subGeometry.context3DBufferOwner);
                }
                this._subGeometry = value;
                if (this._subGeometry) {
                    this.context3DBufferOwner.addChildBufferOwner(this._subGeometry.context3DBufferOwner);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SubMesh.prototype, "animationSubGeometry", {
            /**
             * 动画顶点数据(例如粒子特效的时间、位置偏移、速度等等)
             */
            get: function () {
                return this._animationSubGeometry;
            },
            set: function (value) {
                if (this._animationSubGeometry) {
                    this.context3DBufferOwner.removeChildBufferOwner(this._animationSubGeometry.context3DBufferOwner);
                }
                this._animationSubGeometry = value;
                if (this._animationSubGeometry) {
                    this.context3DBufferOwner.addChildBufferOwner(this._animationSubGeometry.context3DBufferOwner);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SubMesh.prototype, "animator", {
            /**
             * @inheritDoc
             */
            get: function () {
                return this._animator;
            },
            set: function (value) {
                if (this._animator) {
                    this.context3DBufferOwner.removeChildBufferOwner(this._animator.context3DBufferOwner);
                    this.material.animationSet = null;
                }
                this._animator = value;
                if (this._animator) {
                    this.context3DBufferOwner.addChildBufferOwner(this._animator.context3DBufferOwner);
                    this.material.animationSet = this._animator.animationSet;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SubMesh.prototype, "parentMesh", {
            /**
             * 父网格
             */
            get: function () {
                return this._parentMesh;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SubMesh.prototype, "castsShadows", {
            get: function () {
                return this._parentMesh.castsShadows;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SubMesh.prototype, "mouseEnabled", {
            /**
             * @inheritDoc
             */
            get: function () {
                return this._parentMesh.mouseEnabled || this._parentMesh.ancestorsAllowMouseEnabled;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SubMesh.prototype, "numTriangles", {
            /**
             * @inheritDoc
             */
            get: function () {
                return this._subGeometry.numTriangles;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 处理材质变化事件
         */
        SubMesh.prototype.onMaterialChange = function (event) {
            this._materialDirty = true;
        };
        /**
         * 销毁
         */
        SubMesh.prototype.dispose = function () {
            this.material = null;
        };
        return SubMesh;
    }(feng3d.Component));
    feng3d.SubMesh = SubMesh;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 添加3D环境缓冲事件
     */
    //[Event(name = "addContext3DBuffer", type = "me.feng3d.events.Context3DBufferOwnerEvent")]
    /**
     * 移除3D环境缓冲事件
     */
    //[Event(name = "removeContext3DBuffer", type = "me.feng3d.events.Context3DBufferOwnerEvent")]
    /**
     * 添加子项3D环境缓冲拥有者事件
     */
    //[Event(name = "addChildContext3DBufferOwner", type = "me.feng3d.events.Context3DBufferOwnerEvent")]
    /**
     * 移除子项3D环境缓冲拥有者事件
     */
    //[Event(name = "removeChildContext3DBufferOwner", type = "me.feng3d.events.Context3DBufferOwnerEvent")]
    /**
     * Context3D缓存拥有者
     * @author feng 2014-11-26
     */
    var Context3DBufferOwner = (function (_super) {
        __extends(Context3DBufferOwner, _super);
        /**
         * 创建Context3D缓存拥有者
         */
        function Context3DBufferOwner() {
            _super.call(this);
            /**
             * 所有缓冲列表是否有效
             */
            this.bufferInvalid = true;
            this.childrenBufferOwner = [];
            this.initBuffers();
        }
        Object.defineProperty(Context3DBufferOwner.prototype, "_", {
            /**
             * Fagal编号中心
             */
            get: function () {
                return feng3d.FagalIdCenter.instance;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Context3DBufferOwner.prototype, "bufferDic", {
            /**
             * @inheritDoc
             */
            get: function () {
                if (this._bufferDic == null)
                    this._bufferDic = {};
                return this._bufferDic;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Context3DBufferOwner.prototype, "bufferList", {
            /**
             * @inheritDoc
             */
            get: function () {
                if (this._bufferList == null)
                    this._bufferList = [];
                return this._bufferList;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 初始化Context3d缓存
         */
        Context3DBufferOwner.prototype.initBuffers = function () {
        };
        /**
         * 添加子项缓存拥有者
         * @param childBufferOwner
         */
        Context3DBufferOwner.prototype.addChildBufferOwner = function (childBufferOwner) {
            var index = this.childrenBufferOwner.indexOf(childBufferOwner);
            feng3d.assert(index == -1, "不能重复添加子项缓存拥有者");
            this.childrenBufferOwner.push(childBufferOwner);
            //添加事件
            childBufferOwner.addEventListener(feng3d.Context3DBufferOwnerEvent.ADD_CONTEXT3DBUFFER, this.bubbleDispatchEvent);
            childBufferOwner.addEventListener(feng3d.Context3DBufferOwnerEvent.REMOVE_CONTEXT3DBUFFER, this.bubbleDispatchEvent);
            childBufferOwner.addEventListener(feng3d.Context3DBufferOwnerEvent.ADDCHILD_CONTEXT3DBUFFEROWNER, this.bubbleDispatchEvent);
            childBufferOwner.addEventListener(feng3d.Context3DBufferOwnerEvent.REMOVECHILD_CONTEXT3DBUFFEROWNER, this.bubbleDispatchEvent);
            //派发添加子项缓冲拥有者事件
            this.dispatchEvent(new feng3d.Context3DBufferOwnerEvent(feng3d.Context3DBufferOwnerEvent.ADDCHILD_CONTEXT3DBUFFEROWNER, childBufferOwner));
        };
        /**
         * 移除子项缓存拥有者
         * @param childBufferOwner
         */
        Context3DBufferOwner.prototype.removeChildBufferOwner = function (childBufferOwner) {
            var index = this.childrenBufferOwner.indexOf(childBufferOwner);
            feng3d.assert(index != -1, "无法移除不存在的子项缓存拥有者");
            this.childrenBufferOwner.splice(index, 1);
            //移除事件
            childBufferOwner.removeEventListener(feng3d.Context3DBufferOwnerEvent.ADD_CONTEXT3DBUFFER, this.bubbleDispatchEvent);
            childBufferOwner.removeEventListener(feng3d.Context3DBufferOwnerEvent.REMOVE_CONTEXT3DBUFFER, this.bubbleDispatchEvent);
            childBufferOwner.removeEventListener(feng3d.Context3DBufferOwnerEvent.ADDCHILD_CONTEXT3DBUFFEROWNER, this.bubbleDispatchEvent);
            childBufferOwner.removeEventListener(feng3d.Context3DBufferOwnerEvent.REMOVECHILD_CONTEXT3DBUFFEROWNER, this.bubbleDispatchEvent);
            //派发添加子项缓冲拥有者事件
            this.dispatchEvent(new feng3d.Context3DBufferOwnerEvent(feng3d.Context3DBufferOwnerEvent.REMOVECHILD_CONTEXT3DBUFFEROWNER, childBufferOwner));
        };
        /**
         * 向上冒泡
         */
        Context3DBufferOwner.prototype.bubbleDispatchEvent = function (event) {
            this.bufferInvalid = true;
            this.dispatchEvent(event);
        };
        /**
         * 标记Context3d缓存脏了
         * @param dataTypeId
         */
        Context3DBufferOwner.prototype.markBufferDirty = function (dataTypeId) {
            var context3DBuffer = this.bufferDic[dataTypeId];
            context3DBuffer.invalid();
        };
        /**
         * @inheritDoc
         */
        Context3DBufferOwner.prototype.mapContext3DBuffer = function (dataTypeId, updateFunc) {
            var bufferCls = feng3d.Context3DBufferTypeManager.getBufferClass(dataTypeId);
            var context3DBuffer = new bufferCls(dataTypeId, updateFunc);
            this.bufferDic[dataTypeId] = context3DBuffer;
            this.bufferList.push(context3DBuffer);
            this.dispatchEvent(new feng3d.Context3DBufferOwnerEvent(feng3d.Context3DBufferOwnerEvent.ADD_CONTEXT3DBUFFER, context3DBuffer));
            return context3DBuffer;
        };
        /**
         * @inheritDoc
         */
        Context3DBufferOwner.prototype.getAllBufferList = function () {
            if (this.bufferInvalid) {
                //收集本拥有者缓冲列表
                this.allBufferList = this.bufferList.concat();
                var childAllBufferList;
                //遍历子项拥有者收集缓冲列表
                for (var i = 0; i < this.childrenBufferOwner.length; i++) {
                    childAllBufferList = this.childrenBufferOwner[i].getAllBufferList();
                    this.allBufferList = this.allBufferList.concat(childAllBufferList);
                }
                this.bufferInvalid = false;
            }
            return this.allBufferList;
        };
        return Context3DBufferOwner;
    }(feng3d.Component));
    feng3d.Context3DBufferOwner = Context3DBufferOwner;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 几何体
     * @author feng 2014-3-17
     */
    var Geometry = (function (_super) {
        __extends(Geometry, _super);
        function Geometry() {
            _super.call(this);
            this._namedAsset = new feng3d.NamedAsset(this, feng3d.AssetType.GEOMETRY);
            this._subGeometries = [];
        }
        Object.defineProperty(Geometry.prototype, "subGeometries", {
            get: function () {
                return this._subGeometries;
            },
            enumerable: true,
            configurable: true
        });
        Geometry.prototype.getSubGeometries = function () {
            return this._subGeometries;
        };
        Object.defineProperty(Geometry.prototype, "numVertices", {
            /**
             * 顶点个数
             */
            get: function () {
                var _numVertices;
                for (var i = 0; i < this._subGeometries.length; i++) {
                    _numVertices += this._subGeometries[i].numVertices;
                }
                return _numVertices;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 应用变换矩阵
         * @param transform 变换矩阵
         */
        Geometry.prototype.applyTransformation = function (transform) {
            var len = this._subGeometries.length;
            for (var i = 0; i < len; ++i)
                this._subGeometries[i].applyTransformation(transform);
        };
        /**
         * 添加子几何体
         * @param subGeometry 子几何体
         */
        Geometry.prototype.addSubGeometry = function (subGeometry) {
            this._subGeometries.push(subGeometry);
            subGeometry.parent = this;
            this.dispatchEvent(new feng3d.GeometryEvent(feng3d.GeometryEvent.SUB_GEOMETRY_ADDED, subGeometry));
        };
        /**
         * 移除子几何体
         * @param subGeometry 子几何体
         */
        Geometry.prototype.removeSubGeometry = function (subGeometry) {
            this._subGeometries.splice(this._subGeometries.indexOf(subGeometry), 1);
            subGeometry.parent = null;
            this.dispatchEvent(new feng3d.GeometryEvent(feng3d.GeometryEvent.SUB_GEOMETRY_REMOVED, subGeometry));
        };
        Geometry.prototype.removeAllSubGeometry = function () {
            for (var i = this._subGeometries.length - 1; i >= 0; i--) {
                this.removeSubGeometry(this._subGeometries[i]);
            }
        };
        Geometry.prototype.clone = function () {
            var cls = feng3d.getDefinitionByName(feng3d.getQualifiedClassName(this));
            var clone = new cls();
            var len = this._subGeometries.length;
            for (var i = 0; i < len; ++i)
                clone.addSubGeometry(this._subGeometries[i].clone());
            return clone;
        };
        /**
         * 缩放几何体
         * @param scale 缩放系数
         */
        Geometry.prototype.scale = function (scale) {
            var numSubGeoms = this._subGeometries.length;
            for (var i = 0; i < numSubGeoms; ++i) {
                var subGeometryTransformation = this._subGeometries[i].getOrCreateComponentByClass(feng3d.SubGeometryTransformation);
                subGeometryTransformation.scale(scale);
            }
        };
        /**
         * 缩放uv
         * @param scaleU u缩放系数
         * @param scaleV v缩放系数
         */
        Geometry.prototype.scaleUV = function (scaleU, scaleV) {
            if (scaleU === void 0) { scaleU = 1; }
            if (scaleV === void 0) { scaleV = 1; }
            var numSubGeoms = this._subGeometries.length;
            for (var i = 0; i < numSubGeoms; ++i) {
                var subGeometryTransformation = this._subGeometries[i].getOrCreateComponentByClass(feng3d.SubGeometryTransformation);
                subGeometryTransformation.scaleUV(scaleU, scaleV);
            }
        };
        Geometry.prototype.dispose = function () {
            var numSubGeoms = this._subGeometries.length;
            for (var i = 0; i < numSubGeoms; ++i) {
                var subGeom = this._subGeometries[0];
                this.removeSubGeometry(subGeom);
                subGeom.dispose();
            }
        };
        Object.defineProperty(Geometry.prototype, "namedAsset", {
            get: function () {
                return this._namedAsset;
            },
            enumerable: true,
            configurable: true
        });
        return Geometry;
    }(feng3d.Component));
    feng3d.Geometry = Geometry;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 粒子几何体
     */
    var ParticleGeometry = (function (_super) {
        __extends(ParticleGeometry, _super);
        function ParticleGeometry() {
            _super.call(this);
        }
        ParticleGeometry.prototype.clone = function () {
            var particleGeometry = _super.prototype.clone.call(this);
            particleGeometry.particles = this.particles;
            particleGeometry.numParticles = this.numParticles;
            return particleGeometry;
        };
        return ParticleGeometry;
    }(feng3d.Geometry));
    feng3d.ParticleGeometry = ParticleGeometry;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     *
     * @author feng 2015-12-30
     */
    var SegmentGeometry = (function (_super) {
        __extends(SegmentGeometry, _super);
        function SegmentGeometry() {
            _super.call(this);
            this._segments = [];
        }
        /**
         * 添加线段
         * @param segment		线段数据
         */
        SegmentGeometry.prototype.addSegment = function (segment, needUpdateGeometry) {
            if (needUpdateGeometry === void 0) { needUpdateGeometry = true; }
            this._segments.push(segment);
            if (needUpdateGeometry) {
                this.updateGeometry();
            }
        };
        SegmentGeometry.prototype.updateGeometry = function () {
            this.removeAllSubGeometry();
            var _segmentSubGeometry = feng3d.SegmentUtils.getSegmentSubGeometrys(this._segments);
            this.addSubGeometry(_segmentSubGeometry);
        };
        /**
         * 获取线段数据
         * @param index 		线段索引
         * @return				线段数据
         */
        SegmentGeometry.prototype.getSegment = function (index) {
            if (index < this._segments.length)
                return this._segments[index];
            return null;
        };
        /**
         * 移除所有线段
         */
        SegmentGeometry.prototype.removeAllSegments = function () {
            this.segments.length = 0;
            this.removeAllSubGeometry();
        };
        Object.defineProperty(SegmentGeometry.prototype, "segments", {
            /**
             * 线段列表
             */
            get: function () {
                return this._segments;
            },
            enumerable: true,
            configurable: true
        });
        return SegmentGeometry;
    }(feng3d.Geometry));
    feng3d.SegmentGeometry = SegmentGeometry;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 基础网格
     * @author feng 2014-10-11
     */
    var PrimitiveBase = (function (_super) {
        __extends(PrimitiveBase, _super);
        function PrimitiveBase() {
            _super.call(this);
            this._geomDirty = true;
            this._uvDirty = true;
            this._subGeometry = new feng3d.SubGeometry();
            this.addSubGeometry(this._subGeometry);
        }
        Object.defineProperty(PrimitiveBase.prototype, "subGeometries", {
            /**
             * @inheritDoc
             */
            get: function () {
                if (this._geomDirty)
                    this.updateGeometry();
                if (this._uvDirty)
                    this.updateUVs();
                return _super.prototype.getSubGeometries.call(this);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        PrimitiveBase.prototype.clone = function () {
            if (this._geomDirty)
                this.updateGeometry();
            if (this._uvDirty)
                this.updateUVs();
            return _super.prototype.clone.call(this);
        };
        /**
         * @inheritDoc
         */
        PrimitiveBase.prototype.scale = function (scale) {
            if (this._geomDirty)
                this.updateGeometry();
            _super.prototype.scale.call(this, scale);
        };
        /**
         * @inheritDoc
         */
        PrimitiveBase.prototype.scaleUV = function (scaleU, scaleV) {
            if (scaleU === void 0) { scaleU = 1; }
            if (scaleV === void 0) { scaleV = 1; }
            if (this._uvDirty)
                this.updateUVs();
            _super.prototype.scaleUV.call(this, scaleU, scaleV);
        };
        /**
         * @inheritDoc
         */
        PrimitiveBase.prototype.applyTransformation = function (transform) {
            if (this._geomDirty)
                this.updateGeometry();
            _super.prototype.applyTransformation.call(this, transform);
        };
        /**
         * 几何体失效
         */
        PrimitiveBase.prototype.invalidateGeometry = function () {
            this._geomDirty = true;
        };
        /**
         * uv失效
         */
        PrimitiveBase.prototype.invalidateUVs = function () {
            this._uvDirty = true;
        };
        /**
         * 更新几何体
         */
        PrimitiveBase.prototype.updateGeometry = function () {
            this.buildGeometry(this._subGeometry);
            this._geomDirty = false;
        };
        /**
         * 更新uv
         */
        PrimitiveBase.prototype.updateUVs = function () {
            this.buildUVs(this._subGeometry);
            this._uvDirty = false;
        };
        return PrimitiveBase;
    }(feng3d.Geometry));
    feng3d.PrimitiveBase = PrimitiveBase;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * A Cube primitive mesh.
     */
    var CubeGeometry = (function (_super) {
        __extends(CubeGeometry, _super);
        /**
         * Creates a new Cube object.
         * @param width The size of the cube along its X-axis.
         * @param height The size of the cube along its Y-axis.
         * @param depth The size of the cube along its Z-axis.
         * @param segmentsW The number of segments that make up the cube along the X-axis.
         * @param segmentsH The number of segments that make up the cube along the Y-axis.
         * @param segmentsD The number of segments that make up the cube along the Z-axis.
         * @param tile6 The type of uv mapping to use. When true, a texture will be subdivided in a 2x3 grid, each used for a single face. When false, the entire image is mapped on each face.
         */
        function CubeGeometry(width, height, depth, segmentsW, segmentsH, segmentsD, tile6) {
            if (width === void 0) { width = 100; }
            if (height === void 0) { height = 100; }
            if (depth === void 0) { depth = 100; }
            if (segmentsW === void 0) { segmentsW = 1; }
            if (segmentsH === void 0) { segmentsH = 1; }
            if (segmentsD === void 0) { segmentsD = 1; }
            if (tile6 === void 0) { tile6 = true; }
            _super.call(this);
            this._width = width;
            this._height = height;
            this._depth = depth;
            this._segmentsW = segmentsW;
            this._segmentsH = segmentsH;
            this._segmentsD = segmentsD;
            this._tile6 = tile6;
        }
        Object.defineProperty(CubeGeometry.prototype, "width", {
            /**
             * The size of the cube along its X-axis.
             */
            get: function () {
                return this._width;
            },
            set: function (value) {
                this._width = value;
                this.invalidateGeometry();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CubeGeometry.prototype, "height", {
            /**
             * The size of the cube along its Y-axis.
             */
            get: function () {
                return this._height;
            },
            set: function (value) {
                this._height = value;
                this.invalidateGeometry();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CubeGeometry.prototype, "depth", {
            /**
             * The size of the cube along its Z-axis.
             */
            get: function () {
                return this._depth;
            },
            set: function (value) {
                this._depth = value;
                this.invalidateGeometry();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CubeGeometry.prototype, "tile6", {
            /**
             * The type of uv mapping to use. When false, the entire image is mapped on each face.
             * When true, a texture will be subdivided in a 3x2 grid, each used for a single face.
             * Reading the tiles from left to right, top to bottom they represent the faces of the
             * cube in the following order: bottom, top, back, left, front, right. This creates
             * several shared edges (between the top, front, left and right faces) which simplifies
             * texture painting.
             */
            get: function () {
                return this._tile6;
            },
            set: function (value) {
                this._tile6 = value;
                this.invalidateUVs();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CubeGeometry.prototype, "segmentsW", {
            /**
             * The number of segments that make up the cube along the X-axis. Defaults to 1.
             */
            get: function () {
                return this._segmentsW;
            },
            set: function (value) {
                this._segmentsW = value;
                this.invalidateGeometry();
                this.invalidateUVs();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CubeGeometry.prototype, "segmentsH", {
            /**
             * The number of segments that make up the cube along the Y-axis. Defaults to 1.
             */
            get: function () {
                return this._segmentsH;
            },
            set: function (value) {
                this._segmentsH = value;
                this.invalidateGeometry();
                this.invalidateUVs();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CubeGeometry.prototype, "segmentsD", {
            /**
             * The number of segments that make up the cube along the Z-axis. Defaults to 1.
             */
            get: function () {
                return this._segmentsD;
            },
            set: function (value) {
                this._segmentsD = value;
                this.invalidateGeometry();
                this.invalidateUVs();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        CubeGeometry.prototype.buildGeometry = function (target) {
            var vertexPositionData;
            var vertexNormalData;
            var vertexTangentData;
            var indices;
            var tl, tr, bl, br;
            var i, j, inc = 0;
            var hw, hh, hd; // halves
            var dw, dh, dd; // deltas
            var outer_pos;
            var numVerts = ((this._segmentsW + 1) * (this._segmentsH + 1) + (this._segmentsW + 1) * (this._segmentsD + 1) + (this._segmentsH + 1) * (this._segmentsD + 1)) * 2;
            var vertexPositionStride = target.vertexPositionStride;
            var vertexNormalStride = target.vertexNormalStride;
            var vertexTangentStride = target.vertexTangentStride;
            if (numVerts == target.numVertices) {
                vertexPositionData = target.vertexPositionData;
                vertexNormalData = target.vertexNormalData;
                vertexTangentData = target.vertexTangentData;
                indices = target.indexData || [];
                indices.length = (this._segmentsW * this._segmentsH + this._segmentsW * this._segmentsD + this._segmentsH * this._segmentsD) * 12;
            }
            else {
                vertexPositionData = [];
                vertexPositionData.length = numVerts * vertexPositionStride;
                vertexNormalData = [];
                vertexNormalData.length = numVerts * vertexNormalStride;
                vertexTangentData = [];
                vertexTangentData.length = numVerts * vertexTangentStride;
                indices = [];
                indices.length = (this._segmentsW * this._segmentsH + this._segmentsW * this._segmentsD + this._segmentsH * this._segmentsD) * 12;
                this.invalidateUVs();
            }
            // Indices
            var positionIndex = 0;
            var normalIndex = 0;
            var tangentIndex = 0;
            var fidx = 0;
            // half cube dimensions
            hw = this._width / 2;
            hh = this._height / 2;
            hd = this._depth / 2;
            // Segment dimensions
            dw = this._width / this._segmentsW;
            dh = this._height / this._segmentsH;
            dd = this._depth / this._segmentsD;
            for (i = 0; i <= this._segmentsW; i++) {
                outer_pos = -hw + i * dw;
                for (j = 0; j <= this._segmentsH; j++) {
                    // front
                    vertexPositionData[positionIndex++] = outer_pos;
                    vertexPositionData[positionIndex++] = -hh + j * dh;
                    vertexPositionData[positionIndex++] = -hd;
                    vertexNormalData[normalIndex++] = 0;
                    vertexNormalData[normalIndex++] = 0;
                    vertexNormalData[normalIndex++] = -1;
                    vertexTangentData[tangentIndex++] = 1;
                    vertexTangentData[tangentIndex++] = 0;
                    vertexTangentData[tangentIndex++] = 0;
                    // back
                    vertexPositionData[positionIndex++] = outer_pos;
                    vertexPositionData[positionIndex++] = -hh + j * dh;
                    vertexPositionData[positionIndex++] = hd;
                    vertexNormalData[normalIndex++] = 0;
                    vertexNormalData[normalIndex++] = 0;
                    vertexNormalData[normalIndex++] = 1;
                    vertexTangentData[tangentIndex++] = -1;
                    vertexTangentData[tangentIndex++] = 0;
                    vertexTangentData[tangentIndex++] = 0;
                    if (i && j) {
                        tl = 2 * ((i - 1) * (this._segmentsH + 1) + (j - 1));
                        tr = 2 * (i * (this._segmentsH + 1) + (j - 1));
                        bl = tl + 2;
                        br = tr + 2;
                        indices[fidx++] = tl;
                        indices[fidx++] = bl;
                        indices[fidx++] = br;
                        indices[fidx++] = tl;
                        indices[fidx++] = br;
                        indices[fidx++] = tr;
                        indices[fidx++] = tr + 1;
                        indices[fidx++] = br + 1;
                        indices[fidx++] = bl + 1;
                        indices[fidx++] = tr + 1;
                        indices[fidx++] = bl + 1;
                        indices[fidx++] = tl + 1;
                    }
                }
            }
            inc += 2 * (this._segmentsW + 1) * (this._segmentsH + 1);
            for (i = 0; i <= this._segmentsW; i++) {
                outer_pos = -hw + i * dw;
                for (j = 0; j <= this._segmentsD; j++) {
                    // top
                    vertexPositionData[positionIndex++] = outer_pos;
                    vertexPositionData[positionIndex++] = hh;
                    vertexPositionData[positionIndex++] = -hd + j * dd;
                    vertexNormalData[normalIndex++] = 0;
                    vertexNormalData[normalIndex++] = 1;
                    vertexNormalData[normalIndex++] = 0;
                    vertexTangentData[tangentIndex++] = 1;
                    vertexTangentData[tangentIndex++] = 0;
                    vertexTangentData[tangentIndex++] = 0;
                    // bottom
                    vertexPositionData[positionIndex++] = outer_pos;
                    vertexPositionData[positionIndex++] = -hh;
                    vertexPositionData[positionIndex++] = -hd + j * dd;
                    vertexNormalData[normalIndex++] = 0;
                    vertexNormalData[normalIndex++] = -1;
                    vertexNormalData[normalIndex++] = 0;
                    vertexTangentData[tangentIndex++] = 1;
                    vertexTangentData[tangentIndex++] = 0;
                    vertexTangentData[tangentIndex++] = 0;
                    if (i && j) {
                        tl = inc + 2 * ((i - 1) * (this._segmentsD + 1) + (j - 1));
                        tr = inc + 2 * (i * (this._segmentsD + 1) + (j - 1));
                        bl = tl + 2;
                        br = tr + 2;
                        indices[fidx++] = tl;
                        indices[fidx++] = bl;
                        indices[fidx++] = br;
                        indices[fidx++] = tl;
                        indices[fidx++] = br;
                        indices[fidx++] = tr;
                        indices[fidx++] = tr + 1;
                        indices[fidx++] = br + 1;
                        indices[fidx++] = bl + 1;
                        indices[fidx++] = tr + 1;
                        indices[fidx++] = bl + 1;
                        indices[fidx++] = tl + 1;
                    }
                }
            }
            inc += 2 * (this._segmentsW + 1) * (this._segmentsD + 1);
            for (i = 0; i <= this._segmentsD; i++) {
                outer_pos = hd - i * dd;
                for (j = 0; j <= this._segmentsH; j++) {
                    // left
                    vertexPositionData[positionIndex++] = -hw;
                    vertexPositionData[positionIndex++] = -hh + j * dh;
                    vertexPositionData[positionIndex++] = outer_pos;
                    vertexNormalData[normalIndex++] = -1;
                    vertexNormalData[normalIndex++] = 0;
                    vertexNormalData[normalIndex++] = 0;
                    vertexTangentData[tangentIndex++] = 0;
                    vertexTangentData[tangentIndex++] = 0;
                    vertexTangentData[tangentIndex++] = -1;
                    // right
                    vertexPositionData[positionIndex++] = hw;
                    vertexPositionData[positionIndex++] = -hh + j * dh;
                    vertexPositionData[positionIndex++] = outer_pos;
                    vertexNormalData[normalIndex++] = 1;
                    vertexNormalData[normalIndex++] = 0;
                    vertexNormalData[normalIndex++] = 0;
                    vertexTangentData[tangentIndex++] = 0;
                    vertexTangentData[tangentIndex++] = 0;
                    vertexTangentData[tangentIndex++] = 1;
                    if (i && j) {
                        tl = inc + 2 * ((i - 1) * (this._segmentsH + 1) + (j - 1));
                        tr = inc + 2 * (i * (this._segmentsH + 1) + (j - 1));
                        bl = tl + 2;
                        br = tr + 2;
                        indices[fidx++] = tl;
                        indices[fidx++] = bl;
                        indices[fidx++] = br;
                        indices[fidx++] = tl;
                        indices[fidx++] = br;
                        indices[fidx++] = tr;
                        indices[fidx++] = tr + 1;
                        indices[fidx++] = br + 1;
                        indices[fidx++] = bl + 1;
                        indices[fidx++] = tr + 1;
                        indices[fidx++] = bl + 1;
                        indices[fidx++] = tl + 1;
                    }
                }
            }
            target.numVertices = numVerts;
            target.updateVertexPositionData(vertexPositionData);
            target.updateVertexNormalData(vertexNormalData);
            target.updateVertexTangentData(vertexTangentData);
            target.updateIndexData(indices);
        };
        /**
         * @inheritDoc
         */
        CubeGeometry.prototype.buildUVs = function (target) {
            var i, j, uidx;
            var data;
            var u_tile_dim, v_tile_dim;
            var u_tile_step, v_tile_step;
            var tl0u, tl0v;
            var tl1u, tl1v;
            var du, dv;
            var stride = target.UVStride;
            var numUvs = ((this._segmentsW + 1) * (this._segmentsH + 1) + (this._segmentsW + 1) * (this._segmentsD + 1) + (this._segmentsH + 1) * (this._segmentsD + 1)) * 2 * stride;
            var skip = stride - 2;
            data = target.UVData;
            if (data == null || numUvs != data.length) {
                data = [];
                data.length = numUvs;
                this.invalidateGeometry();
            }
            if (this._tile6) {
                u_tile_dim = u_tile_step = 1 / 3;
                v_tile_dim = v_tile_step = 1 / 2;
            }
            else {
                u_tile_dim = v_tile_dim = 1;
                u_tile_step = v_tile_step = 0;
            }
            // Create planes two and two, the same way that they were
            // constructed in the this.buildGeometry() function. First calculate
            // the top-left UV coordinate for both planes, and then loop
            // over the points, calculating the UVs from these numbers.
            // When this.tile6 is true, the layout is as follows:
            //       .-----.-----.-----. (1,1)
            //       | Bot |  T  | Bak |
            //       |-----+-----+-----|
            //       |  L  |  F  |  R  |
            // (0,0)'-----'-----'-----'
            uidx = 0;
            // FRONT / BACK
            tl0u = 1 * u_tile_step;
            tl0v = 1 * v_tile_step;
            tl1u = 2 * u_tile_step;
            tl1v = 0 * v_tile_step;
            du = u_tile_dim / this._segmentsW;
            dv = v_tile_dim / this._segmentsH;
            for (i = 0; i <= this._segmentsW; i++) {
                for (j = 0; j <= this._segmentsH; j++) {
                    data[uidx++] = tl0u + i * du;
                    data[uidx++] = tl0v + (v_tile_dim - j * dv);
                    uidx += skip;
                    data[uidx++] = tl1u + (u_tile_dim - i * du);
                    data[uidx++] = tl1v + (v_tile_dim - j * dv);
                    uidx += skip;
                }
            }
            // TOP / BOTTOM
            tl0u = 1 * u_tile_step;
            tl0v = 0 * v_tile_step;
            tl1u = 0 * u_tile_step;
            tl1v = 0 * v_tile_step;
            du = u_tile_dim / this._segmentsW;
            dv = v_tile_dim / this._segmentsD;
            for (i = 0; i <= this._segmentsW; i++) {
                for (j = 0; j <= this._segmentsD; j++) {
                    data[uidx++] = tl0u + i * du;
                    data[uidx++] = tl0v + (v_tile_dim - j * dv);
                    uidx += skip;
                    data[uidx++] = tl1u + i * du;
                    data[uidx++] = tl1v + j * dv;
                    uidx += skip;
                }
            }
            // LEFT / RIGHT
            tl0u = 0 * u_tile_step;
            tl0v = 1 * v_tile_step;
            tl1u = 2 * u_tile_step;
            tl1v = 1 * v_tile_step;
            du = u_tile_dim / this._segmentsD;
            dv = v_tile_dim / this._segmentsH;
            for (i = 0; i <= this._segmentsD; i++) {
                for (j = 0; j <= this._segmentsH; j++) {
                    data[uidx++] = tl0u + i * du;
                    data[uidx++] = tl0v + (v_tile_dim - j * dv);
                    uidx += skip;
                    data[uidx++] = tl1u + (u_tile_dim - i * du);
                    data[uidx++] = tl1v + (v_tile_dim - j * dv);
                    uidx += skip;
                }
            }
            target.updateUVData(data);
        };
        return CubeGeometry;
    }(feng3d.PrimitiveBase));
    feng3d.CubeGeometry = CubeGeometry;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 平面网格（四边形）
     * @author feng 2014-4-15
     */
    var PlaneGeometry = (function (_super) {
        __extends(PlaneGeometry, _super);
        /**
         * 创建一个平面
         * @param width 宽度
         * @param height 高度
         * @param segmentsW 横向分割数
         * @param segmentsH 纵向分割数
         * @param yUp 正面朝向 true:Y+ false:Z+
         * @param doubleSided 是否双面
         */
        function PlaneGeometry(width, height, segmentsW, segmentsH, yUp, doubleSided) {
            if (width === void 0) { width = 100; }
            if (height === void 0) { height = 100; }
            if (segmentsW === void 0) { segmentsW = 1; }
            if (segmentsH === void 0) { segmentsH = 1; }
            if (yUp === void 0) { yUp = true; }
            if (doubleSided === void 0) { doubleSided = false; }
            _super.call(this);
            this._segmentsW = segmentsW;
            this._segmentsH = segmentsH;
            this._yUp = yUp;
            this._width = width;
            this._height = height;
            this._doubleSided = doubleSided;
        }
        Object.defineProperty(PlaneGeometry.prototype, "segmentsW", {
            /**
             * 横向分割数
             */
            get: function () {
                return this._segmentsW;
            },
            set: function (value) {
                this._segmentsW = value;
                this.invalidateGeometry();
                this.invalidateUVs();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PlaneGeometry.prototype, "segmentsH", {
            /**
             * 纵向分割数
             */
            get: function () {
                return this._segmentsH;
            },
            set: function (value) {
                this._segmentsH = value;
                this.invalidateGeometry();
                this.invalidateUVs();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PlaneGeometry.prototype, "yUp", {
            /**
             * 正面朝向 true:Y+ false:Z+
             */
            get: function () {
                return this._yUp;
            },
            set: function (value) {
                this._yUp = value;
                this.invalidateGeometry();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PlaneGeometry.prototype, "doubleSided", {
            /**
             * 是否双面
             */
            get: function () {
                return this._doubleSided;
            },
            set: function (value) {
                this._doubleSided = value;
                this.invalidateGeometry();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PlaneGeometry.prototype, "width", {
            /**
             * 宽度
             */
            get: function () {
                return this._width;
            },
            set: function (value) {
                this._width = value;
                this.invalidateGeometry();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PlaneGeometry.prototype, "height", {
            /**
             * 高度
             */
            get: function () {
                return this._height;
            },
            set: function (value) {
                this._height = value;
                this.invalidateGeometry();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        PlaneGeometry.prototype.buildGeometry = function (target) {
            var vertexPositionData;
            var vertexNormalData;
            var vertexTangentData;
            var indices;
            var x, y;
            var numIndices;
            var base;
            var tw = this._segmentsW + 1;
            var numVertices = (this._segmentsH + 1) * tw;
            var vertexPositionStride = target.vertexPositionStride;
            var vertexNormalStride = target.vertexNormalStride;
            var vertexTangentStride = target.vertexTangentStride;
            if (this._doubleSided)
                numVertices *= 2;
            numIndices = this._segmentsH * this._segmentsW * 6;
            if (this._doubleSided)
                numIndices <<= 1;
            if (numVertices == target.numVertices) {
                vertexPositionData = target.vertexPositionData;
                vertexNormalData = target.vertexNormalData;
                vertexTangentData = target.vertexTangentData;
                indices = target.indexData || [];
                indices.length = numIndices;
            }
            else {
                vertexPositionData = [];
                vertexPositionData.length = numVertices * vertexPositionStride;
                vertexNormalData = [];
                vertexNormalData.length = numVertices * vertexNormalStride;
                vertexTangentData = [];
                vertexTangentData.length = numVertices * vertexTangentStride;
                indices = [];
                indices.length = numIndices;
                this.invalidateUVs();
            }
            target.numVertices = numVertices;
            numIndices = 0;
            var positionIndex = 0;
            var normalIndex = 0;
            var tangentIndex = 0;
            for (var yi = 0; yi <= this._segmentsH; ++yi) {
                for (var xi = 0; xi <= this._segmentsW; ++xi) {
                    x = (xi / this._segmentsW - .5) * this._width;
                    y = (yi / this._segmentsH - .5) * this._height;
                    //设置坐标数据
                    vertexPositionData[positionIndex++] = x;
                    if (this._yUp) {
                        vertexPositionData[positionIndex++] = 0;
                        vertexPositionData[positionIndex++] = y;
                    }
                    else {
                        vertexPositionData[positionIndex++] = y;
                        vertexPositionData[positionIndex++] = 0;
                    }
                    //设置法线数据
                    vertexNormalData[normalIndex++] = 0;
                    if (this._yUp) {
                        vertexNormalData[normalIndex++] = 1;
                        vertexNormalData[normalIndex++] = 0;
                    }
                    else {
                        vertexNormalData[normalIndex++] = 0;
                        vertexNormalData[normalIndex++] = -1;
                    }
                    vertexTangentData[tangentIndex++] = 1;
                    vertexTangentData[tangentIndex++] = 0;
                    vertexTangentData[tangentIndex++] = 0;
                    //复制反面数据
                    if (this._doubleSided) {
                        for (var i = 0; i < 3; ++i) {
                            vertexPositionData[positionIndex] = vertexPositionData[positionIndex - vertexPositionStride];
                            ++positionIndex;
                        }
                        for (i = 0; i < 3; ++i) {
                            vertexPositionData[normalIndex] = -vertexPositionData[normalIndex - vertexNormalStride];
                            ++normalIndex;
                        }
                        for (i = 0; i < 3; ++i) {
                            vertexTangentData[tangentIndex] = -vertexTangentData[tangentIndex - vertexTangentStride];
                            ++tangentIndex;
                        }
                    }
                    //生成索引数据
                    if (xi != this._segmentsW && yi != this._segmentsH) {
                        base = xi + yi * tw;
                        var mult = this._doubleSided ? 2 : 1;
                        indices[numIndices++] = base * mult;
                        indices[numIndices++] = (base + tw) * mult;
                        indices[numIndices++] = (base + tw + 1) * mult;
                        indices[numIndices++] = base * mult;
                        indices[numIndices++] = (base + tw + 1) * mult;
                        indices[numIndices++] = (base + 1) * mult;
                        //设置反面索引数据
                        if (this._doubleSided) {
                            indices[numIndices++] = (base + tw + 1) * mult + 1;
                            indices[numIndices++] = (base + tw) * mult + 1;
                            indices[numIndices++] = base * mult + 1;
                            indices[numIndices++] = (base + 1) * mult + 1;
                            indices[numIndices++] = (base + tw + 1) * mult + 1;
                            indices[numIndices++] = base * mult + 1;
                        }
                    }
                }
            }
            target.updateVertexPositionData(vertexPositionData);
            target.updateVertexNormalData(vertexNormalData);
            target.updateVertexTangentData(vertexTangentData);
            target.updateIndexData(indices);
        };
        PlaneGeometry.prototype.buildUVs = function (target) {
            var data;
            var stride = target.UVStride;
            var numUvs = (this._segmentsH + 1) * (this._segmentsW + 1) * stride;
            if (this._doubleSided)
                numUvs *= 2;
            data = target.UVData;
            if (data == null || numUvs != data.length) {
                data = [];
                data.length = numUvs;
                this.invalidateGeometry();
            }
            var index = 0;
            for (var yi = 0; yi <= this._segmentsH; ++yi) {
                for (var xi = 0; xi <= this._segmentsW; ++xi) {
                    data[index++] = xi / this._segmentsW;
                    data[index++] = 1 - yi / this._segmentsH;
                    if (this._doubleSided) {
                        data[index++] = xi / this._segmentsW;
                        data[index++] = 1 - yi / this._segmentsH;
                    }
                }
            }
            target.updateUVData(data);
        };
        return PlaneGeometry;
    }(feng3d.PrimitiveBase));
    feng3d.PlaneGeometry = PlaneGeometry;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 球体网格
     */
    var SphereGeometry = (function (_super) {
        __extends(SphereGeometry, _super);
        /**
         * 创建一个球体
         * @param radius 半径
         * @param segmentsW 横向分割数，默认值16
         * @param segmentsH 纵向分割数，默认值12
         * @param yUp 球体朝向 true:Y+ false:Z+
         */
        function SphereGeometry(radius, segmentsW, segmentsH, yUp) {
            if (radius === void 0) { radius = 50; }
            if (segmentsW === void 0) { segmentsW = 16; }
            if (segmentsH === void 0) { segmentsH = 12; }
            if (yUp === void 0) { yUp = true; }
            _super.call(this);
            this._radius = radius;
            this._segmentsW = segmentsW;
            this._segmentsH = segmentsH;
            this._yUp = yUp;
        }
        /**
         * @inheritDoc
         */
        SphereGeometry.prototype.buildGeometry = function (target) {
            var vertexPositionData;
            var vertexNormalData;
            var vertexTangentData;
            var indices;
            var i, j, triIndex;
            var numVerts = (this._segmentsH + 1) * (this._segmentsW + 1);
            var vertexPositionStride = target.vertexPositionStride;
            var vertexNormalStride = target.vertexNormalStride;
            var vertexTangentStride = target.vertexTangentStride;
            if (numVerts == target.numVertices) {
                vertexPositionData = target.vertexPositionData;
                vertexNormalData = target.vertexNormalData;
                vertexTangentData = target.vertexTangentData;
                indices = target.indexData || [];
                indices.length = (this._segmentsH - 1) * this._segmentsW * 6;
            }
            else {
                vertexPositionData = [];
                vertexPositionData.length = numVerts * vertexPositionStride;
                vertexNormalData = [];
                vertexNormalData.length = numVerts * vertexNormalStride;
                vertexTangentData = [];
                vertexTangentData.length = numVerts * vertexTangentStride;
                indices = [];
                indices.length = (this._segmentsH - 1) * this._segmentsW * 6;
                this.invalidateGeometry();
            }
            var startPositionIndex;
            var startNormalIndex;
            var positionIndex = 0;
            var normalIndex = 0;
            var tangentIndex = 0;
            var comp1, comp2, t1, t2;
            for (j = 0; j <= this._segmentsH; ++j) {
                startPositionIndex = positionIndex;
                startNormalIndex = normalIndex;
                var horangle = Math.PI * j / this._segmentsH;
                var z = -this._radius * Math.cos(horangle);
                var ringradius = this._radius * Math.sin(horangle);
                for (i = 0; i <= this._segmentsW; ++i) {
                    var verangle = 2 * Math.PI * i / this._segmentsW;
                    var x = ringradius * Math.cos(verangle);
                    var y = ringradius * Math.sin(verangle);
                    var normLen = 1 / Math.sqrt(x * x + y * y + z * z);
                    var tanLen = Math.sqrt(y * y + x * x);
                    if (this._yUp) {
                        t1 = 0;
                        t2 = tanLen > .007 ? x / tanLen : 0;
                        comp1 = -z;
                        comp2 = y;
                    }
                    else {
                        t1 = tanLen > .007 ? x / tanLen : 0;
                        t2 = 0;
                        comp1 = y;
                        comp2 = z;
                    }
                    if (i == this._segmentsW) {
                        vertexPositionData[positionIndex++] = vertexPositionData[startPositionIndex];
                        vertexPositionData[positionIndex++] = vertexPositionData[startPositionIndex + 1];
                        vertexPositionData[positionIndex++] = vertexPositionData[startPositionIndex + 2];
                        vertexNormalData[normalIndex++] = vertexNormalData[startNormalIndex] + (x * normLen) * .5;
                        vertexNormalData[normalIndex++] = vertexNormalData[startNormalIndex + 1] + (comp1 * normLen) * .5;
                        vertexNormalData[normalIndex++] = vertexNormalData[startNormalIndex + 2] + (comp2 * normLen) * .5;
                        vertexTangentData[tangentIndex++] = tanLen > .007 ? -y / tanLen : 1;
                        vertexTangentData[tangentIndex++] = t1;
                        vertexTangentData[tangentIndex++] = t2;
                    }
                    else {
                        vertexPositionData[positionIndex++] = x;
                        vertexPositionData[positionIndex++] = comp1;
                        vertexPositionData[positionIndex++] = comp2;
                        vertexNormalData[normalIndex++] = x * normLen;
                        vertexNormalData[normalIndex++] = comp1 * normLen;
                        vertexNormalData[normalIndex++] = comp2 * normLen;
                        vertexTangentData[tangentIndex++] = tanLen > .007 ? -y / tanLen : 1;
                        vertexTangentData[tangentIndex++] = t1;
                        vertexTangentData[tangentIndex++] = t2;
                    }
                    if (i > 0 && j > 0) {
                        var a = (this._segmentsW + 1) * j + i;
                        var b = (this._segmentsW + 1) * j + i - 1;
                        var c = (this._segmentsW + 1) * (j - 1) + i - 1;
                        var d = (this._segmentsW + 1) * (j - 1) + i;
                        if (j == this._segmentsH) {
                            indices[triIndex++] = a;
                            indices[triIndex++] = c;
                            indices[triIndex++] = d;
                        }
                        else if (j == 1) {
                            indices[triIndex++] = a;
                            indices[triIndex++] = b;
                            indices[triIndex++] = c;
                        }
                        else {
                            indices[triIndex++] = a;
                            indices[triIndex++] = b;
                            indices[triIndex++] = c;
                            indices[triIndex++] = a;
                            indices[triIndex++] = c;
                            indices[triIndex++] = d;
                        }
                    }
                }
            }
            target.numVertices = numVerts;
            target.updateVertexPositionData(vertexPositionData);
            target.updateVertexNormalData(vertexNormalData);
            target.updateVertexTangentData(vertexTangentData);
            target.updateIndexData(indices);
        };
        /**
         * @inheritDoc
         */
        SphereGeometry.prototype.buildUVs = function (target) {
            var i, j;
            var stride = target.UVStride;
            var numUvs = (this._segmentsH + 1) * (this._segmentsW + 1) * stride;
            var data;
            var skip = stride - 2;
            data = target.UVData;
            if (data == null || numUvs != data.length) {
                data = [];
                data.length = numUvs;
                this.invalidateGeometry();
            }
            var index = 0;
            for (j = 0; j <= this._segmentsH; ++j) {
                for (i = 0; i <= this._segmentsW; ++i) {
                    data[index++] = i / this._segmentsW;
                    data[index++] = j / this._segmentsH;
                    index += skip;
                }
            }
            target.updateUVData(data);
        };
        Object.defineProperty(SphereGeometry.prototype, "radius", {
            /**
             * 半径
             */
            get: function () {
                return this._radius;
            },
            set: function (value) {
                this._radius = value;
                this.invalidateGeometry();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SphereGeometry.prototype, "segmentsW", {
            /**
             * 横向分割数，默认值16
             */
            get: function () {
                return this._segmentsW;
            },
            set: function (value) {
                this._segmentsW = value;
                this.invalidateGeometry();
                this.invalidateUVs();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SphereGeometry.prototype, "segmentsH", {
            /**
             * 纵向分割数，默认值12
             */
            get: function () {
                return this._segmentsH;
            },
            set: function (value) {
                this._segmentsH = value;
                this.invalidateGeometry();
                this.invalidateUVs();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SphereGeometry.prototype, "yUp", {
            /**
             * 球体朝向 true:Y+ false:Z+
             */
            get: function () {
                return this._yUp;
            },
            set: function (value) {
                this._yUp = value;
                this.invalidateGeometry();
            },
            enumerable: true,
            configurable: true
        });
        return SphereGeometry;
    }(feng3d.PrimitiveBase));
    feng3d.SphereGeometry = SphereGeometry;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 圆环几何体
     */
    var TorusGeometry = (function (_super) {
        __extends(TorusGeometry, _super);
        /**
         * 创建<code>Torus</code>实例
         * @param radius						圆环半径
         * @param tuebRadius					管道半径
         * @param segmentsR						横向段数
         * @param segmentsT						纵向段数
         * @param yUp							Y轴是否朝上
         */
        function TorusGeometry(radius, tubeRadius, segmentsR, segmentsT, yUp) {
            if (radius === void 0) { radius = 50; }
            if (tubeRadius === void 0) { tubeRadius = 50; }
            if (segmentsR === void 0) { segmentsR = 16; }
            if (segmentsT === void 0) { segmentsT = 8; }
            if (yUp === void 0) { yUp = true; }
            _super.call(this);
            this._radius = radius;
            this._tubeRadius = tubeRadius;
            this._segmentsR = segmentsR;
            this._segmentsT = segmentsT;
            this._yUp = yUp;
        }
        /**
         * 添加顶点数据
         */
        TorusGeometry.prototype.addVertex = function (vertexIndex, px, py, pz, nx, ny, nz, tx, ty, tz) {
            this.vertexPositionData[vertexIndex * this.vertexPositionStride] = px;
            this.vertexPositionData[vertexIndex * this.vertexPositionStride + 1] = py;
            this.vertexPositionData[vertexIndex * this.vertexPositionStride + 2] = pz;
            this.vertexNormalData[vertexIndex * this.vertexNormalStride] = nx;
            this.vertexNormalData[vertexIndex * this.vertexNormalStride + 1] = ny;
            this.vertexNormalData[vertexIndex * this.vertexNormalStride + 2] = nz;
            this.vertexTangentData[vertexIndex * this.vertexTangentStride] = tx;
            this.vertexTangentData[vertexIndex * this.vertexTangentStride + 1] = ty;
            this.vertexTangentData[vertexIndex * this.vertexTangentStride + 2] = tz;
        };
        /**
         * 添加三角形索引数据
         * @param currentTriangleIndex		当前三角形索引
         * @param cwVertexIndex0			索引0
         * @param cwVertexIndex1			索引1
         * @param cwVertexIndex2			索引2
         */
        TorusGeometry.prototype.addTriangleClockWise = function (currentTriangleIndex, cwVertexIndex0, cwVertexIndex1, cwVertexIndex2) {
            this._rawIndices[currentTriangleIndex * 3] = cwVertexIndex0;
            this._rawIndices[currentTriangleIndex * 3 + 1] = cwVertexIndex1;
            this._rawIndices[currentTriangleIndex * 3 + 2] = cwVertexIndex2;
        };
        /**
         * @inheritDoc
         */
        TorusGeometry.prototype.buildGeometry = function (target) {
            var i, j;
            var x, y, z, nx, ny, nz, revolutionAngleR, revolutionAngleT;
            var numTriangles;
            // reset utility variables
            this._numVertices = 0;
            this._vertexIndex = 0;
            this._currentTriangleIndex = 0;
            this.vertexPositionStride = target.vertexPositionStride;
            this.vertexNormalStride = target.vertexNormalStride;
            this.vertexTangentStride = target.vertexTangentStride;
            // evaluate target number of vertices, triangles and indices
            this._numVertices = (this._segmentsT + 1) * (this._segmentsR + 1); // this.segmentsT + 1 because of closure, this.segmentsR + 1 because of closure
            numTriangles = this._segmentsT * this._segmentsR * 2; // each level has segmentR quads, each of 2 triangles
            // need to initialize raw arrays or can be reused?
            if (this._numVertices == target.numVertices) {
                this.vertexPositionData = target.vertexPositionData;
                this.vertexNormalData = target.vertexNormalData;
                this.vertexTangentData = target.vertexTangentData;
                this._rawIndices = target.indexData || [];
                this._rawIndices.length = numTriangles * 3;
            }
            else {
                this.vertexPositionData = [];
                this.vertexPositionData.length = this._numVertices * this.vertexPositionStride;
                this.vertexNormalData = [];
                this.vertexNormalData.length = this._numVertices * this.vertexNormalStride;
                this.vertexTangentData = [];
                this.vertexTangentData.length = this._numVertices * this.vertexTangentStride;
                this._rawIndices = [];
                this._rawIndices.length = numTriangles * 3;
                this.invalidateUVs();
            }
            // evaluate revolution steps
            var revolutionAngleDeltaR = 2 * Math.PI / this._segmentsR;
            var revolutionAngleDeltaT = 2 * Math.PI / this._segmentsT;
            var comp1, comp2;
            var t1, t2, n1, n2;
            var startPositionIndex;
            // surface
            var a, b, c, d, length;
            for (j = 0; j <= this._segmentsT; ++j) {
                startPositionIndex = j * (this._segmentsR + 1) * this.vertexPositionStride;
                for (i = 0; i <= this._segmentsR; ++i) {
                    this._vertexIndex = j * (this._segmentsR + 1) + i;
                    // revolution vertex
                    revolutionAngleR = i * revolutionAngleDeltaR;
                    revolutionAngleT = j * revolutionAngleDeltaT;
                    length = Math.cos(revolutionAngleT);
                    nx = length * Math.cos(revolutionAngleR);
                    ny = length * Math.sin(revolutionAngleR);
                    nz = Math.sin(revolutionAngleT);
                    x = this._radius * Math.cos(revolutionAngleR) + this._tubeRadius * nx;
                    y = this._radius * Math.sin(revolutionAngleR) + this._tubeRadius * ny;
                    z = (j == this._segmentsT) ? 0 : this._tubeRadius * nz;
                    if (this._yUp) {
                        n1 = -nz;
                        n2 = ny;
                        t1 = 0;
                        t2 = (length ? nx / length : x / this._radius);
                        comp1 = -z;
                        comp2 = y;
                    }
                    else {
                        n1 = ny;
                        n2 = nz;
                        t1 = (length ? nx / length : x / this._radius);
                        t2 = 0;
                        comp1 = y;
                        comp2 = z;
                    }
                    if (i == this._segmentsR) {
                        this.addVertex(this._vertexIndex, x, this.vertexPositionData[startPositionIndex + 1], this.vertexPositionData[startPositionIndex + 2], nx, n1, n2, -(length ? ny / length : y / this._radius), t1, t2);
                    }
                    else {
                        this.addVertex(this._vertexIndex, x, comp1, comp2, nx, n1, n2, -(length ? ny / length : y / this._radius), t1, t2);
                    }
                    // close triangle
                    if (i > 0 && j > 0) {
                        a = this._vertexIndex; // current
                        b = this._vertexIndex - 1; // previous
                        c = b - this._segmentsR - 1; // previous of last level
                        d = a - this._segmentsR - 1; // current of last level
                        this.addTriangleClockWise(this._currentTriangleIndex++, a, b, c);
                        this.addTriangleClockWise(this._currentTriangleIndex++, a, c, d);
                    }
                }
            }
            target.numVertices = this._numVertices;
            target.updateVertexPositionData(this.vertexPositionData);
            target.updateVertexNormalData(this.vertexNormalData);
            target.updateVertexTangentData(this.vertexTangentData);
            target.updateIndexData(this._rawIndices);
        };
        /**
         * @inheritDoc
         */
        TorusGeometry.prototype.buildUVs = function (target) {
            var i, j;
            var data;
            var stride = target.UVStride;
            // evaluate num uvs
            var numUvs = this._numVertices * stride;
            // need to initialize raw array or can be reused?
            data = target.UVData;
            if (data == null || numUvs != data.length) {
                data = [];
                data.length = numUvs;
            }
            // current uv component index
            var currentUvCompIndex = 0;
            var index = 0;
            // surface
            for (j = 0; j <= this._segmentsT; ++j) {
                for (i = 0; i <= this._segmentsR; ++i) {
                    index = j * (this._segmentsR + 1) + i;
                    // revolution vertex
                    data[index * stride] = i / this._segmentsR;
                    data[index * stride + 1] = j / this._segmentsT;
                }
            }
            // build real data from raw data
            target.updateUVData(data);
        };
        Object.defineProperty(TorusGeometry.prototype, "radius", {
            /**
             * 圆环半径
             */
            get: function () {
                return this._radius;
            },
            set: function (value) {
                this._radius = value;
                this.invalidateGeometry();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TorusGeometry.prototype, "tubeRadius", {
            /**
             * 管子半径
             */
            get: function () {
                return this._tubeRadius;
            },
            set: function (value) {
                this._tubeRadius = value;
                this.invalidateGeometry();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TorusGeometry.prototype, "segmentsR", {
            /**
             * 横向段数
             */
            get: function () {
                return this._segmentsR;
            },
            set: function (value) {
                this._segmentsR = value;
                this.invalidateGeometry();
                this.invalidateUVs();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TorusGeometry.prototype, "segmentsT", {
            /**
             * 纵向段数
             */
            get: function () {
                return this._segmentsT;
            },
            set: function (value) {
                this._segmentsT = value;
                this.invalidateGeometry();
                this.invalidateUVs();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TorusGeometry.prototype, "yUp", {
            /**
             * Y轴是否朝上
             */
            get: function () {
                return this._yUp;
            },
            set: function (value) {
                this._yUp = value;
                this.invalidateGeometry();
            },
            enumerable: true,
            configurable: true
        });
        return TorusGeometry;
    }(feng3d.PrimitiveBase));
    feng3d.TorusGeometry = TorusGeometry;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 3D对象<br/><br/>
     * 主要功能:
     * <ul>
     *     <li>能够被addChild添加到3d场景中</li>
     *     <li>维护场景变换矩阵sceneTransform、inverseSceneTransform</li>
     *     <li>维护父对象parent</li>
     * </ul>
     *
     * @author feng
     */
    var Object3D = (function (_super) {
        __extends(Object3D, _super);
        /**
         * 创建3D对象
         */
        function Object3D() {
            _super.call(this);
            this._sceneTransform = new feng3d.Matrix3D();
            this._sceneTransformDirty = true;
            this._inverseSceneTransform = new feng3d.Matrix3D();
            this._inverseSceneTransformDirty = true;
            this._scenePosition = new feng3d.Vector3D();
            this._scenePositionDirty = true;
            this._visible = true;
            this._zOffset = 0;
            this.transform3D = new feng3d.Transform3D();
        }
        Object.defineProperty(Object3D.prototype, "transform3D", {
            get: function () {
                return this._transform3D;
            },
            set: function (value) {
                if (this.transform3D != null) {
                    this.transform3D.removeEventListener(feng3d.Transform3DEvent.TRANSFORM_CHANGED, this.onTransformChanged);
                    this.transform3D.removeEventListener(feng3d.Transform3DEvent.POSITION_CHANGED, this.onPositionChanged);
                }
                this._transform3D = value;
                this.transform3D.addEventListener(feng3d.Transform3DEvent.TRANSFORM_CHANGED, this.onTransformChanged);
                this.transform3D.addEventListener(feng3d.Transform3DEvent.POSITION_CHANGED, this.onPositionChanged);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "scene", {
            /**
             * 场景
             */
            get: function () {
                return this._scene;
            },
            set: function (value) {
                if (this._scene != value) {
                    if (this._scene)
                        this._scene.removedObject3d(this);
                    this._scene = value;
                    if (this._scene)
                        this._scene.addedObject3d(this);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object3D.prototype.setScene = function (value) {
            this.scene = value;
        };
        /**
         * 克隆3D对象
         */
        Object3D.prototype.clone = function () {
            var clone = new Object3D();
            clone.transform3D = new feng3d.Transform3D();
            clone.transform3D.pivotPoint = this.transform3D.pivotPoint;
            clone.transform3D.transform = this.transform3D.transform;
            return clone;
        };
        Object.defineProperty(Object3D.prototype, "inverseSceneTransform", {
            /**
             * 场景变换逆矩阵，场景空间转模型空间
             */
            get: function () {
                if (this._inverseSceneTransformDirty) {
                    this._inverseSceneTransform.copyFrom(this.sceneTransform);
                    this._inverseSceneTransform.invert();
                    this._inverseSceneTransformDirty = false;
                }
                return this._inverseSceneTransform;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "sceneTransform", {
            /**
             * 场景变换矩阵，模型空间转场景空间
             */
            get: function () {
                if (this._sceneTransformDirty)
                    this.updateSceneTransform();
                return this._sceneTransform;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 更新场景变换矩阵
         */
        Object3D.prototype.updateSceneTransform = function () {
            if (this._parent && !this._parent._isRoot) {
                this._sceneTransform.copyFrom(this._parent.sceneTransform);
                this._sceneTransform.prepend(this.transform3D.transform);
            }
            else
                this._sceneTransform.copyFrom(this.transform3D.transform);
            this._sceneTransformDirty = false;
        };
        /**
         * 使变换矩阵失效，场景变换矩阵也将失效
         */
        Object3D.prototype.onTransformChanged = function (event) {
            this.notifySceneTransformChange();
        };
        /**
         * 场景变化失效
         */
        Object3D.prototype.invalidateSceneTransform = function () {
            this._sceneTransformDirty = true;
            this._inverseSceneTransformDirty = true;
            this._scenePositionDirty = true;
        };
        /**
         * 通知场景变换改变
         */
        Object3D.prototype.notifySceneTransformChange = function () {
            if (this._sceneTransformDirty)
                return;
            //处理场景变换事件
            if (this._listenToSceneTransformChanged) {
                if (!this._sceneTransformChanged)
                    this._sceneTransformChanged = new feng3d.Transform3DEvent(feng3d.Transform3DEvent.SCENETRANSFORM_CHANGED, this.transform3D);
                this.dispatchEvent(this._sceneTransformChanged);
            }
            this.invalidateSceneTransform();
        };
        Object.defineProperty(Object3D.prototype, "parent", {
            /**
             * 父容器
             */
            get: function () {
                return this._parent;
            },
            set: function (value) {
                if (this._parent != null)
                    this._parent.removeChild(this);
                this._parent = value;
                this.transform3D.invalidateTransform();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "scenePosition", {
            /**
             * 获取场景坐标
             */
            get: function () {
                if (this._scenePositionDirty) {
                    this.sceneTransform.copyColumnTo(3, this._scenePosition);
                    this._scenePositionDirty = false;
                }
                return this._scenePosition;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 本地坐标转换为世界坐标
         * @param localVector3D 本地坐标
         * @return
         */
        Object3D.prototype.positionLocalToGlobal = function (localPosition) {
            var globalPosition = this.sceneTransform.transformVector(localPosition);
            return globalPosition;
        };
        /**
         * 世界坐标转换为本地坐标
         * @param globalPosition 世界坐标
         * @return
         */
        Object3D.prototype.positionGlobalToLocal = function (globalPosition) {
            var localPosition = this.inverseSceneTransform.transformVector(globalPosition);
            return localPosition;
        };
        /**
         * 本地方向转换为世界方向
         * @param localDirection 本地方向
         * @return
         */
        Object3D.prototype.directionLocalToGlobal = function (localDirection) {
            var globalDirection = this.sceneTransform.deltaTransformVector(localDirection);
            feng3d.Matrix3DUtils.deltaTransformVector(this.sceneTransform, localDirection, globalDirection);
            return globalDirection;
        };
        /**
         * 世界方向转换为本地方向
         * @param globalDirection 世界方向
         * @return
         */
        Object3D.prototype.directionGlobalToLocal = function (globalDirection) {
            var localDirection = this.inverseSceneTransform.deltaTransformVector(globalDirection);
            feng3d.Matrix3DUtils.deltaTransformVector(this.inverseSceneTransform, globalDirection, localDirection);
            return localDirection;
        };
        /**
         * @inheritDoc
         */
        Object3D.prototype.dispatchEvent = function (event) {
            if (feng3d.is(event, feng3d.MouseEvent3D) && this.parent && !this.parent.ancestorsAllowMouseEnabled) {
                if (this.parent) {
                    return this.parent.dispatchEvent(event);
                }
                return false;
            }
            return _super.prototype.dispatchEvent.call(this, event);
        };
        Object.defineProperty(Object3D.prototype, "visible", {
            /**
             * 是否可见
             */
            get: function () {
                return this._visible;
            },
            set: function (value) {
                this._visible = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "sceneVisible", {
            /**
             * 是否在场景上可见
             */
            get: function () {
                //从这里开始一直找父容器到场景了，且visible全为true则为场景上可见
                return this.visible && (this.scene != null) && ((feng3d.is(this.parent, feng3d.Scene3D)) ? true : (this.parent ? this.parent.sceneVisible : false));
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        Object3D.prototype.addEventListener = function (type, listener, priority, useWeakReference) {
            if (priority === void 0) { priority = 0; }
            if (useWeakReference === void 0) { useWeakReference = false; }
            _super.prototype.addEventListener.call(this, type, listener, priority, useWeakReference);
            switch (type) {
                case feng3d.Transform3DEvent.SCENETRANSFORM_CHANGED:
                    this._listenToSceneTransformChanged = true;
                    break;
            }
        };
        /**
         * @inheritDoc
         */
        Object3D.prototype.removeEventListener = function (type, listener, useCapture) {
            if (useCapture === void 0) { useCapture = false; }
            _super.prototype.removeEventListener.call(this, type, listener);
            if (this.hasEventListener(type))
                return;
            switch (type) {
                case feng3d.Transform3DEvent.SCENETRANSFORM_CHANGED:
                    this._listenToSceneTransformChanged = false;
                    break;
            }
        };
        Object.defineProperty(Object3D.prototype, "partition", {
            /**
             * 空间分区
             */
            get: function () {
                return this._explicitPartition;
            },
            set: function (value) {
                this._explicitPartition = value;
                this.implicitPartition = value ? value : (this._parent ? this._parent.implicitPartition : null);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "implicitPartition", {
            /**
             * 隐式空间分区
             */
            get: function () {
                return this._implicitPartition;
            },
            set: function (value) {
                if (value == this._implicitPartition)
                    return;
                this._implicitPartition = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "zOffset", {
            /**
             * Z偏移值
             */
            get: function () {
                return this._zOffset;
            },
            set: function (value) {
                this._zOffset = value;
            },
            enumerable: true,
            configurable: true
        });
        Object3D.prototype.onPositionChanged = function (event) {
            this.notifySceneTransformChange();
        };
        Object.defineProperty(Object3D.prototype, "minX", {
            /**
             * The minimum extremum of the object along the X-axis.
             */
            get: function () {
                return 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "minY", {
            /**
             * The minimum extremum of the object along the Y-axis.
             */
            get: function () {
                return 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "minZ", {
            /**
             * The minimum extremum of the object along the Z-axis.
             */
            get: function () {
                return 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "maxX", {
            /**
             * The maximum extremum of the object along the X-axis.
             */
            get: function () {
                return 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "maxY", {
            /**
             * The maximum extremum of the object along the Y-axis.
             */
            get: function () {
                return 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "maxZ", {
            /**
             * The maximum extremum of the object along the Z-axis.
             */
            get: function () {
                return 0;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Cleans up any resources used by the current object.
         */
        Object3D.prototype.dispose = function () {
        };
        return Object3D;
    }(feng3d.Component));
    feng3d.Object3D = Object3D;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 当鼠标点击时触发
     * @eventType me.feng3d.events.MouseEvent3D
     */
    //[Event(name = "click3d", type = "me.feng3d.events.MouseEvent3D")]
    /**
     * 当鼠标移上时触发
     * @eventType me.feng3d.events.MouseEvent3D
     */
    //[Event(name = "mouseOver3d", type = "me.feng3d.events.MouseEvent3D")]
    /**
     * 当鼠标移出时触发
     * @eventType me.feng3d.events.MouseEvent3D
     */
    //[Event(name = "mouseOut3d", type = "me.feng3d.events.MouseEvent3D")]
    /**
     * 当鼠标移动时触发
     * @eventType me.feng3d.events.MouseEvent3D
     */
    //[Event(name = "mouseMove3d", type = "me.feng3d.events.MouseEvent3D")]
    /**
     * 当鼠标双击时触发
     * @eventType me.feng3d.events.MouseEvent3D
     */
    //[Event(name = "doubleClick3d", type = "me.feng3d.events.MouseEvent3D")]
    /**
     * 当鼠标按下时触发
     * @eventType me.feng3d.events.MouseEvent3D
     */
    //[Event(name = "mouseDown3d", type = "me.feng3d.events.MouseEvent3D")]
    /**
     * 当鼠标弹起时触发
     * @eventType me.feng3d.events.MouseEvent3D
     */
    //[Event(name = "mouseUp3d", type = "me.feng3d.events.MouseEvent3D")]
    /**
     * 当滚动鼠标滚轮时触发
     * @eventType me.feng3d.events.MouseEvent3D
     */
    //[Event(name = "mouseWheel3d", type = "me.feng3d.events.MouseEvent3D")]
    /**
     * InteractiveObject3D 类是用户可以使用鼠标、键盘或其他用户输入设备与之交互的所有显示对象的抽象基类。
     * @see		flash.display.InteractiveObject
     * @author 	warden_feng 2014-5-5
     */
    var InteractiveObject3D = (function (_super) {
        __extends(InteractiveObject3D, _super);
        /**
         * 调用新的 InteractiveObject3D() 构造函数会引发 ArgumentError 异常。
         * @throws	me.feng.error.AbstractClassError
         */
        function InteractiveObject3D() {
            _super.call(this);
            this._mouseEnabled = false;
        }
        Object.defineProperty(InteractiveObject3D.prototype, "mouseEnabled", {
            /**
             * 是否开启鼠标事件
             */
            get: function () {
                return this._mouseEnabled;
            },
            set: function (value) {
                this._mouseEnabled = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        InteractiveObject3D.prototype.dispatchEvent = function (event) {
            //处理3D鼠标事件禁用
            if (feng3d.is(event, feng3d.MouseEvent3D) && !this.mouseEnabled) {
                if (this.parent) {
                    return this.parent.dispatchEvent(event);
                }
                return false;
            }
            return _super.prototype.dispatchEvent.call(this, event);
        };
        return InteractiveObject3D;
    }(feng3d.Object3D));
    feng3d.InteractiveObject3D = InteractiveObject3D;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 3d对象容器
     * @author feng 2014-3-21
     */
    var Container3D = (function (_super) {
        __extends(Container3D, _super);
        function Container3D() {
            _super.call(this);
            /** 容器内对象列表 */
            this._children = [];
            this._mouseChildren = true;
            /** 是否给根容器 */
            this._isRoot = false;
            this._namedAsset = new feng3d.NamedAsset(this, feng3d.AssetType.CONTAINER);
            this.addComponent(new feng3d.ContainerTransform3D());
        }
        /**
         * 添加子对象
         * @param child		子对象
         * @return			新增的子对象
         */
        Container3D.prototype.addChild = function (child) {
            if (!child._explicitPartition)
                child.implicitPartition = this._implicitPartition;
            child.parent = this;
            child.scene = this.scene;
            this._children.push(child);
            return child;
        };
        /**
         * 移出指定索引的子对象
         * @param childIndex	子对象索引
         * @return				被移除对象
         */
        Container3D.prototype.removeChildAt = function (childIndex) {
            var child = this.getChildAt(childIndex);
            this.removeChildInternal(childIndex, child);
            return child;
        };
        /**
         * 移除子对象
         * @param child		子对象
         */
        Container3D.prototype.removeChild = function (child) {
            var childIndex = this._children.indexOf(child);
            if (childIndex != -1) {
                this.removeChildInternal(childIndex, child);
            }
        };
        /**
         * 移除所有子对象
         */
        Container3D.prototype.removeAllChild = function () {
            for (var i = this._children.length - 1; i >= 0; i--) {
                this.removeChildAt(i);
            }
        };
        /**
         * 内部移除子对象
         * @param childIndex	移除子对象所在索引
         * @param child			移除子对象
         */
        Container3D.prototype.removeChildInternal = function (childIndex, child) {
            this._children.splice(childIndex, 1);
            child.parent = null;
            child.scene = null;
        };
        Object.defineProperty(Container3D.prototype, "scene", {
            set: function (scene) {
                _super.prototype.setScene.call(this, scene);
                var len = this._children.length;
                for (var i = 0; i < len; i++) {
                    this._children[i].scene = scene;
                }
            },
            enumerable: true,
            configurable: true
        });
        Container3D.prototype.setScene = function (scene) {
            this.scene = scene;
        };
        Object.defineProperty(Container3D.prototype, "numChildren", {
            /**
             * 子对象个数
             */
            get: function () {
                return this._children.length;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 获取子对象
         * @param index
         * @return
         */
        Container3D.prototype.getChildAt = function (index) {
            return this._children[index];
        };
        /**
         * 是否包含该对象
         * @param child
         * @return
         */
        Container3D.prototype.contains = function (child) {
            return this._children.indexOf(child) >= 0;
        };
        Object.defineProperty(Container3D.prototype, "mouseChildren", {
            /**
             * 确定对象的子级是否支持鼠标或用户输入设备。
             */
            get: function () {
                return this._mouseChildren;
            },
            set: function (value) {
                this._mouseChildren = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Container3D.prototype, "ancestorsAllowMouseEnabled", {
            /**
             * 祖先是否允许鼠标事件
             */
            get: function () {
                return this.mouseChildren && (this.parent ? this.parent.ancestorsAllowMouseEnabled : true);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Container3D.prototype, "implicitPartition", {
            /**
             * @inheritDoc
             */
            set: function (value) {
                if (value == this._implicitPartition)
                    return;
                this._implicitPartition = value;
                var i;
                var len = this._children.length;
                var child;
                while (i < len) {
                    child = this._children[i];
                    i++;
                    if (!child._explicitPartition)
                        child.implicitPartition = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        Container3D.prototype.setImplicitPartition = function (value) {
            this.implicitPartition = value;
        };
        Object.defineProperty(Container3D.prototype, "minX", {
            /**
             * The minimum extremum of the object along the X-axis.
             */
            get: function () {
                var i;
                var len = this._children.length;
                var min = Number.POSITIVE_INFINITY;
                var m;
                while (i < len) {
                    var child = this._children[i++];
                    m = child.minX + child.transform3D.x;
                    if (m < min)
                        min = m;
                }
                return min;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Container3D.prototype, "minY", {
            /**
             * The minimum extremum of the object along the Y-axis.
             */
            get: function () {
                var i;
                var len = this._children.length;
                var min = Number.POSITIVE_INFINITY;
                var m;
                while (i < len) {
                    var child = this._children[i++];
                    m = child.minY + child.transform3D.y;
                    if (m < min)
                        min = m;
                }
                return min;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Container3D.prototype, "minZ", {
            /**
             * The minimum extremum of the object along the Z-axis.
             */
            get: function () {
                var i;
                var len = this._children.length;
                var min = Number.POSITIVE_INFINITY;
                var m;
                while (i < len) {
                    var child = this._children[i++];
                    m = child.minZ + child.transform3D.z;
                    if (m < min)
                        min = m;
                }
                return min;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Container3D.prototype, "maxX", {
            /**
             * The maximum extremum of the object along the X-axis.
             */
            get: function () {
                // todo: this isn't right, doesn't take into account transforms
                var i;
                var len = this._children.length;
                var max = Number.NEGATIVE_INFINITY;
                var m;
                while (i < len) {
                    var child = this._children[i++];
                    m = child.maxX + child.transform3D.x;
                    if (m > max)
                        max = m;
                }
                return max;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Container3D.prototype, "maxY", {
            /**
             * The maximum extremum of the object along the Y-axis.
             */
            get: function () {
                var i;
                var len = this._children.length;
                var max = Number.NEGATIVE_INFINITY;
                var m;
                while (i < len) {
                    var child = this._children[i++];
                    m = child.maxY + child.transform3D.y;
                    if (m > max)
                        max = m;
                }
                return max;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Container3D.prototype, "maxZ", {
            /**
             * The maximum extremum of the object along the Z-axis.
             */
            get: function () {
                var i;
                var len = this._children.length;
                var max = Number.NEGATIVE_INFINITY;
                var m;
                while (i < len) {
                    var child = this._children[i++];
                    m = child.maxZ + child.transform3D.z;
                    if (m > max)
                        max = m;
                }
                return max;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        Container3D.prototype.dispose = function () {
            if (this.parent)
                this.parent.removeChild(this);
        };
        Object.defineProperty(Container3D.prototype, "namedAsset", {
            get: function () {
                return this._namedAsset;
            },
            enumerable: true,
            configurable: true
        });
        return Container3D;
    }(feng3d.InteractiveObject3D));
    feng3d.Container3D = Container3D;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 3d场景
     * @author feng 2014-3-17
     */
    var Scene3D = (function (_super) {
        __extends(Scene3D, _super);
        /**
         * 创建一个3d场景
         */
        function Scene3D() {
            _super.call(this);
            this._isRoot = true;
            this._scene = this;
            this._entityDic = {};
            this._displayEntityDic = {};
            this._mouseCollisionEntitys = [];
            this._partitions = [];
            this.partition = new feng3d.Partition3D(new feng3d.NodeBase());
        }
        Object.defineProperty(Scene3D.prototype, "displayEntityDic", {
            /** 显示实体字典 */
            get: function () {
                return this._displayEntityDic;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 添加对象到场景
         * @param object3D		3d对象
         */
        Scene3D.prototype.addedObject3d = function (object3D) {
            if (feng3d.is(object3D, feng3d.Entity)) {
                this._entityDic[object3D.name] = object3D;
                if (object3D.visible) {
                    this._displayEntityDic[object3D.name] = object3D;
                }
            }
        };
        /**
         * 从场景中移除对象
         * @param object3D	3d对象
         */
        Scene3D.prototype.removedObject3d = function (object3D) {
            delete this._entityDic[object3D.name];
            delete this._displayEntityDic[object3D.name];
        };
        /**
         * 收集需要检测鼠标碰撞的实体
         */
        Scene3D.prototype.collectMouseCollisionEntitys = function () {
            this._mouseCollisionEntitys.length = 0;
            //3d对象堆栈
            var mouseCollisionStack = [];
            mouseCollisionStack.push(this);
            var object3D;
            var entity;
            var container3D;
            //遍历堆栈中需要检测鼠标碰撞的实体
            while (mouseCollisionStack.length > 0) {
                object3D = mouseCollisionStack.pop();
                if (!object3D.visible)
                    continue;
                entity = object3D;
                container3D = object3D;
                //收集需要检测鼠标碰撞的实体到检测列表
                if (entity && entity.mouseEnabled) {
                    this._mouseCollisionEntitys.push(object3D);
                }
                //收集容器内子对象到堆栈
                if (container3D && container3D.mouseChildren) {
                    var len = container3D.numChildren;
                    for (var i = 0; i < len; i++) {
                        mouseCollisionStack.push(container3D.getChildAt(i));
                    }
                }
            }
        };
        Object.defineProperty(Scene3D.prototype, "mouseCollisionEntitys", {
            /**
             * 需要检测鼠标碰撞的实体
             */
            get: function () {
                return this._mouseCollisionEntitys;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 横穿分区
         * @param traverser 横越者
         */
        Scene3D.prototype.traversePartitions = function (traverser) {
            var i;
            var len = this._partitions.length;
            traverser.scene = this;
            while (i < len) {
                this._partitions[i].traverse(traverser);
                i = i + 1;
            }
        };
        /**
         * 注销实体
         * @param entity	实体
         */
        Scene3D.prototype.unregisterEntity = function (entity) {
            entity.implicitPartition.removeEntity(entity);
        };
        /**
         * 注册实体
         * @param entity		实体
         */
        Scene3D.prototype.registerEntity = function (entity) {
            var partition = entity.implicitPartition;
            this.addPartitionUnique(partition);
            partition.markForUpdate(entity);
        };
        /**
         * 添加分区，如果不在列表中
         * @param partition		分区
         */
        Scene3D.prototype.addPartitionUnique = function (partition) {
            if (this._partitions.indexOf(partition) == -1)
                this._partitions.push(partition);
        };
        /**
         * 注册分区
         * @param entity	注册分区的实体
         */
        Scene3D.prototype.registerPartition = function (entity) {
            this.addPartitionUnique(entity.implicitPartition);
        };
        /**
         * 注销分区
         * @param entity	注销分区的实体
         */
        Scene3D.prototype.unregisterPartition = function (entity) {
            // todo: wait... is this even correct?
            // shouldn't we check the number of children in this.implicitPartition and remove this.partition if 0?
            entity.implicitPartition.removeEntity(entity);
        };
        return Scene3D;
    }(feng3d.Container3D));
    feng3d.Scene3D = Scene3D;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * Entity为所有场景绘制对象提供一个基类，表示存在场景中。可以被entityCollector收集。
     * @author feng 2014-3-24
     */
    var Entity = (function (_super) {
        __extends(Entity, _super);
        /**
         * 创建一个实体，该类为虚类
         */
        function Entity() {
            _super.call(this);
            this._boundsIsShown = false;
            this._boundsInvalid = true;
            this._worldBoundsInvalid = true;
            this._bounds = this.getDefaultBoundingVolume();
            this._worldBounds = this.getDefaultBoundingVolume();
        }
        Object.defineProperty(Entity.prototype, "showBounds", {
            /**
             * 是否显示边界
             */
            get: function () {
                return this._showBounds;
            },
            set: function (value) {
                if (value == this._showBounds)
                    return;
                this._showBounds = value;
                if (this._showBounds)
                    this.addBounds();
                else
                    this.removeBounds();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 添加边界
         */
        Entity.prototype.addBounds = function () {
            if (!this._boundsIsShown) {
                this._boundsIsShown = true;
                this.addChild(this.bounds.boundingRenderable);
            }
        };
        /**
         * 移除边界
         */
        Entity.prototype.removeBounds = function () {
            if (this._boundsIsShown) {
                this._boundsIsShown = false;
                this.removeChild(this._bounds.boundingRenderable);
                this._bounds.disposeRenderable();
            }
        };
        Object.defineProperty(Entity.prototype, "minX", {
            /**
             * @inheritDoc
             */
            get: function () {
                if (this._boundsInvalid)
                    this.updateBounds();
                return this._bounds.min.x;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Entity.prototype, "minY", {
            /**
             * @inheritDoc
             */
            get: function () {
                if (this._boundsInvalid)
                    this.updateBounds();
                return this._bounds.min.y;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Entity.prototype, "minZ", {
            /**
             * @inheritDoc
             */
            get: function () {
                if (this._boundsInvalid)
                    this.updateBounds();
                return this._bounds.min.z;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Entity.prototype, "maxX", {
            /**
             * @inheritDoc
             */
            get: function () {
                if (this._boundsInvalid)
                    this.updateBounds();
                return this._bounds.max.x;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Entity.prototype, "maxY", {
            /**
             * @inheritDoc
             */
            get: function () {
                if (this._boundsInvalid)
                    this.updateBounds();
                return this._bounds.max.y;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Entity.prototype, "maxZ", {
            /**
             * @inheritDoc
             */
            get: function () {
                if (this._boundsInvalid)
                    this.updateBounds();
                return this._bounds.max.z;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Entity.prototype, "bounds", {
            /**
             * 边界
             */
            get: function () {
                if (this._boundsInvalid)
                    this.updateBounds();
                return this._bounds;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        Entity.prototype.invalidateSceneTransform = function () {
            _super.prototype.invalidateSceneTransform.call(this);
            this._worldBoundsInvalid = true;
        };
        /**
         * 边界失效
         */
        Entity.prototype.invalidateBounds = function () {
            this._boundsInvalid = true;
        };
        /**
         * 获取默认边界（默认盒子边界）
         * @return
         */
        Entity.prototype.getDefaultBoundingVolume = function () {
            return new feng3d.AxisAlignedBoundingBox();
        };
        Object.defineProperty(Entity.prototype, "pickingCollisionVO", {
            /**
             * 获取碰撞数据
             */
            get: function () {
                if (!this._pickingCollisionVO)
                    this._pickingCollisionVO = new feng3d.PickingCollisionVO(this);
                return this._pickingCollisionVO;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 判断射线是否穿过实体
         * @param ray3D
         * @return
         */
        Entity.prototype.isIntersectingRay = function (ray3D) {
            if (!this.pickingCollisionVO.localNormal)
                this.pickingCollisionVO.localNormal = new feng3d.Vector3D();
            //转换到当前实体坐标系空间
            var localRay = this.pickingCollisionVO.localRay;
            feng3d.Matrix3DUtils.updateLocalRay(this.inverseSceneTransform, ray3D, localRay);
            //检测射线与边界的碰撞
            var rayEntryDistance = this.bounds.rayIntersection(localRay, this.pickingCollisionVO.localNormal);
            if (rayEntryDistance < 0)
                return false;
            //保存碰撞数据
            this.pickingCollisionVO.rayEntryDistance = rayEntryDistance;
            this.pickingCollisionVO.ray3D = ray3D;
            this.pickingCollisionVO.rayOriginIsInsideBounds = rayEntryDistance == 0;
            return true;
        };
        Object.defineProperty(Entity.prototype, "pickingCollider", {
            /**
             * 获取采集的碰撞
             */
            get: function () {
                return this._pickingCollider;
            },
            set: function (value) {
                this._pickingCollider = value;
            },
            enumerable: true,
            configurable: true
        });
        Entity.prototype.setPickingCollider = function (value) {
            this.pickingCollider = value;
        };
        /**
         * 碰撞前设置碰撞状态
         * @param shortestCollisionDistance 最短碰撞距离
         * @param findClosest 是否寻找最优碰撞
         * @return
         */
        Entity.prototype.collidesBefore = function (shortestCollisionDistance, findClosest) {
            return true;
        };
        Object.defineProperty(Entity.prototype, "implicitPartition", {
            /**
             * @inheritDoc
             */
            set: function (value) {
                if (value == this._implicitPartition)
                    return;
                if (this._implicitPartition)
                    this.notifyPartitionUnassigned();
                _super.prototype.setImplicitPartition.call(this, value);
                this.notifyPartitionAssigned();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 通知场景一个新分区已分配
         */
        Entity.prototype.notifyPartitionAssigned = function () {
            if (this._scene)
                this._scene.registerPartition(this);
        };
        /**
         * 通知场景一个分区取消分配
         */
        Entity.prototype.notifyPartitionUnassigned = function () {
            if (this._scene)
                this._scene.unregisterPartition(this);
        };
        Object.defineProperty(Entity.prototype, "scene", {
            /**
             * @inheritDoc
             */
            set: function (value) {
                if (value == this._scene)
                    return;
                if (this._scene)
                    this._scene.unregisterEntity(this);
                if (value)
                    value.registerEntity(this);
                _super.prototype.setScene.call(this, value);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 获取实体分区节点
         */
        Entity.prototype.getEntityPartitionNode = function () {
            return this._partitionNode = this._partitionNode || this.createEntityPartitionNode();
        };
        /**
         * 内部更新
         */
        Entity.prototype.internalUpdate = function () {
            if (this._controller)
                this._controller.update();
        };
        Object.defineProperty(Entity.prototype, "worldBounds", {
            /**
             * 世界边界
             */
            get: function () {
                if (this._worldBoundsInvalid)
                    this.updateWorldBounds();
                return this._worldBounds;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 更新世界边界
         */
        Entity.prototype.updateWorldBounds = function () {
            this._worldBounds.transformFrom(this.bounds, this.sceneTransform);
            this._worldBoundsInvalid = false;
        };
        /**
         * The transformation matrix that transforms from model to world space, adapted with any special operations needed to render.
         * For example, assuring certain alignedness which is not inherent in the scene transform. By default, this would
         * return the scene transform.
         */
        Entity.prototype.getRenderSceneTransform = function (camera) {
            return this.sceneTransform;
        };
        return Entity;
    }(feng3d.Container3D));
    feng3d.Entity = Entity;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 摄像机
     * @author feng 2014-3-17
     */
    var Camera3D = (function (_super) {
        __extends(Camera3D, _super);
        /**
         * 创建一个摄像机
         * @param lens 摄像机镜头
         */
        function Camera3D(lens) {
            if (lens === void 0) { lens = null; }
            _super.call(this);
            this._viewProjection = new feng3d.Matrix3D();
            this._viewProjectionDirty = true;
            this._frustumPlanesDirty = true;
            this._namedAsset._assetType = feng3d.AssetType.CAMERA;
            this._lens = lens || new feng3d.PerspectiveLens();
            this._lens.addEventListener(feng3d.LensEvent.MATRIX_CHANGED, this.onLensMatrixChanged);
            //setup default frustum planes
            this._frustumPlanes = [];
            for (var i = 0; i < 6; ++i)
                this._frustumPlanes[i] = new feng3d.Plane3D();
            this.transform3D.z = -1000;
        }
        /**
         * 处理镜头变化事件
         */
        Camera3D.prototype.onLensMatrixChanged = function (event) {
            this._viewProjectionDirty = true;
            this._frustumPlanesDirty = true;
            this.dispatchEvent(event);
        };
        /**
         * @inheritDoc
         */
        Camera3D.prototype.invalidateSceneTransform = function () {
            _super.prototype.invalidateSceneTransform.call(this);
            this._viewProjectionDirty = true;
            this._frustumPlanesDirty = true;
        };
        /**
         * @inheritDoc
         */
        Camera3D.prototype.createEntityPartitionNode = function () {
            return new feng3d.CameraNode(this);
        };
        Object.defineProperty(Camera3D.prototype, "lens", {
            /**
             * 镜头
             */
            get: function () {
                return this._lens;
            },
            set: function (value) {
                if (this._lens == value)
                    return;
                if (!value)
                    throw new Error("Lens cannot be null!");
                this._lens.removeEventListener(feng3d.LensEvent.MATRIX_CHANGED, this.onLensMatrixChanged);
                this._lens = value;
                this._lens.addEventListener(feng3d.LensEvent.MATRIX_CHANGED, this.onLensMatrixChanged);
                this.dispatchEvent(new feng3d.CameraEvent(feng3d.CameraEvent.LENS_CHANGED, this));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Camera3D.prototype, "viewProjection", {
            /**
             * 场景投影矩阵，世界空间转投影空间
             */
            get: function () {
                if (this._viewProjectionDirty) {
                    //场景空间转摄像机空间
                    this._viewProjection.copyFrom(this.inverseSceneTransform);
                    //+摄像机空间转投影空间 = 场景空间转投影空间
                    this._viewProjection.append(this._lens.matrix);
                    this._viewProjectionDirty = false;
                }
                return this._viewProjection;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Camera3D.prototype, "frustumPlanes", {
            /**
             * 视锥体面
             */
            get: function () {
                if (this._frustumPlanesDirty)
                    this.updateFrustum();
                return this._frustumPlanes;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 更新视锥体6个面，平面均朝向视锥体内部
         * @see http://www.linuxgraphics.cn/graphics/opengl_view_frustum_culling.html
         */
        Camera3D.prototype.updateFrustum = function () {
            var a, b, c;
            //var d :number;
            var c11, c12, c13, c14;
            var c21, c22, c23, c24;
            var c31, c32, c33, c34;
            var c41, c42, c43, c44;
            var p;
            var raw = feng3d.Matrix3DUtils.RAW_DATA_CONTAINER;
            //长度倒数
            var invLen;
            this.viewProjection.copyRawDataTo(raw);
            c11 = raw[0];
            c12 = raw[4];
            c13 = raw[8];
            c14 = raw[12];
            c21 = raw[1];
            c22 = raw[5];
            c23 = raw[9];
            c24 = raw[13];
            c31 = raw[2];
            c32 = raw[6];
            c33 = raw[10];
            c34 = raw[14];
            c41 = raw[3];
            c42 = raw[7];
            c43 = raw[11];
            c44 = raw[15];
            // left plane
            p = this._frustumPlanes[0];
            a = c41 + c11;
            b = c42 + c12;
            c = c43 + c13;
            invLen = 1 / Math.sqrt(a * a + b * b + c * c);
            p.a = a * invLen;
            p.b = b * invLen;
            p.c = c * invLen;
            p.d = -(c44 + c14) * invLen;
            // right plane
            p = this._frustumPlanes[1];
            a = c41 - c11;
            b = c42 - c12;
            c = c43 - c13;
            invLen = 1 / Math.sqrt(a * a + b * b + c * c);
            p.a = a * invLen;
            p.b = b * invLen;
            p.c = c * invLen;
            p.d = (c14 - c44) * invLen;
            // bottom
            p = this._frustumPlanes[2];
            a = c41 + c21;
            b = c42 + c22;
            c = c43 + c23;
            invLen = 1 / Math.sqrt(a * a + b * b + c * c);
            p.a = a * invLen;
            p.b = b * invLen;
            p.c = c * invLen;
            p.d = -(c44 + c24) * invLen;
            // top
            p = this._frustumPlanes[3];
            a = c41 - c21;
            b = c42 - c22;
            c = c43 - c23;
            invLen = 1 / Math.sqrt(a * a + b * b + c * c);
            p.a = a * invLen;
            p.b = b * invLen;
            p.c = c * invLen;
            p.d = (c24 - c44) * invLen;
            // near
            p = this._frustumPlanes[4];
            a = c31;
            b = c32;
            c = c33;
            invLen = 1 / Math.sqrt(a * a + b * b + c * c);
            p.a = a * invLen;
            p.b = b * invLen;
            p.c = c * invLen;
            p.d = -c34 * invLen;
            // far
            p = this._frustumPlanes[5];
            a = c41 - c31;
            b = c42 - c32;
            c = c43 - c33;
            invLen = 1 / Math.sqrt(a * a + b * b + c * c);
            p.a = a * invLen;
            p.b = b * invLen;
            p.c = c * invLen;
            p.d = (c34 - c44) * invLen;
            this._frustumPlanesDirty = false;
        };
        /**
         * 屏幕坐标投影到场景坐标
         * @param nX 屏幕坐标X -1（左） -> 1（右）
         * @param nY 屏幕坐标Y -1（上） -> 1（下）
         * @param sZ 到屏幕的距离
         * @param v 场景坐标（输出）
         * @return 场景坐标
         */
        Camera3D.prototype.unproject = function (nX, nY, sZ, v) {
            if (v === void 0) { v = null; }
            return feng3d.Matrix3DUtils.transformVector(this.sceneTransform, this.lens.unproject(nX, nY, sZ, v), v);
        };
        /**
         * 场景坐标投影到屏幕坐标
         * @param point3d 场景坐标
         * @param v 屏幕坐标（输出）
         * @return 屏幕坐标
         */
        Camera3D.prototype.project = function (point3d, v) {
            if (v === void 0) { v = null; }
            return this.lens.project(feng3d.Matrix3DUtils.transformVector(this.inverseSceneTransform, point3d, v), v);
        };
        /**
         * @inheritDoc
         */
        Camera3D.prototype.getDefaultBoundingVolume = function () {
            return new feng3d.NullBounds();
        };
        /**
 * 更新边界
 */
        Camera3D.prototype.updateBounds = function () {
        };
        return Camera3D;
    }(feng3d.Entity));
    feng3d.Camera3D = Camera3D;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 材质发生变化时抛出
     */
    //[Event(name = "materialChange", type = "me.feng3d.events.MeshEvent")]
    /**
     * 网格
     * @author feng 2014-4-9
     */
    var Mesh = (function (_super) {
        __extends(Mesh, _super);
        /**
         * 新建网格
         * @param geometry 几何体
         * @param material 材质
         */
        function Mesh(geometry, material) {
            if (geometry === void 0) { geometry = null; }
            if (material === void 0) { material = null; }
            _super.call(this);
            this._castsShadows = true;
            this._namedAsset._assetType = feng3d.AssetType.MESH;
            this._subMeshes = [];
            this.geometry = geometry || new feng3d.Geometry();
            this.material = material || feng3d.DefaultMaterialManager.getDefaultMaterial();
        }
        Object.defineProperty(Mesh.prototype, "geometry", {
            /** 几何形状 */
            get: function () {
                return this._geometry;
            },
            set: function (value) {
                var i;
                if (this._geometry) {
                    this._geometry.removeEventListener(feng3d.GeometryEvent.SHAPE_CHANGE, this.onGeometryBoundsInvalid);
                    this._geometry.removeEventListener(feng3d.GeometryEvent.SUB_GEOMETRY_ADDED, this.onSubGeometryAdded);
                    this._geometry.removeEventListener(feng3d.GeometryEvent.SUB_GEOMETRY_REMOVED, this.onSubGeometryRemoved);
                    for (i = 0; i < this._subMeshes.length; ++i)
                        this._subMeshes[i].dispose();
                    this._subMeshes.length = 0;
                }
                this._geometry = value;
                if (this._geometry) {
                    this._geometry.addEventListener(feng3d.GeometryEvent.SHAPE_CHANGE, this.onGeometryBoundsInvalid);
                    this._geometry.addEventListener(feng3d.GeometryEvent.SUB_GEOMETRY_ADDED, this.onSubGeometryAdded);
                    this._geometry.addEventListener(feng3d.GeometryEvent.SUB_GEOMETRY_REMOVED, this.onSubGeometryRemoved);
                    var subGeoms = this._geometry.subGeometries;
                    for (i = 0; i < subGeoms.length; ++i)
                        this.addSubMesh(subGeoms[i]);
                }
                this.invalidateBounds();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 渲染材质
         */
        Mesh.prototype.getMaterial = function () {
            return this._materialSelf;
        };
        Object.defineProperty(Mesh.prototype, "materialSelf", {
            /**
             * 自身材质
             */
            get: function () {
                return this._materialSelf;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Mesh.prototype, "material", {
            set: function (value) {
                if (value == this._materialSelf)
                    return;
                if (this._materialSelf)
                    this._materialSelf.removeOwner(this);
                this._materialSelf = value;
                if (this._materialSelf)
                    this._materialSelf.addOwner(this);
                this.dispatchEvent(new feng3d.MeshEvent(feng3d.MeshEvent.MATERIAL_CHANGE));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Mesh.prototype, "sourceEntity", {
            /**
             * 源实体
             */
            get: function () {
                return this;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        Mesh.prototype.updateBounds = function () {
            this._bounds.fromGeometry(this.geometry);
            this._boundsInvalid = false;
        };
        /**
         * @inheritDoc
         */
        Mesh.prototype.collidesBefore = function (shortestCollisionDistance, findClosest) {
            this._pickingCollider.setLocalRay(this._pickingCollisionVO.localRay);
            this._pickingCollisionVO.renderable = null;
            var len = this._subMeshes.length;
            for (var i = 0; i < len; ++i) {
                var subMesh = this._subMeshes[i];
                //var ignoreFacesLookingAway:boolean = _material ? !_material.bothSides : true;
                if (this._pickingCollider.testSubMeshCollision(subMesh, this._pickingCollisionVO, shortestCollisionDistance, false)) {
                    shortestCollisionDistance = this._pickingCollisionVO.rayEntryDistance;
                    this._pickingCollisionVO.renderable = subMesh.renderableBase;
                    if (!findClosest)
                        return true;
                }
            }
            return this._pickingCollisionVO.renderable != null;
        };
        /**
         * @inheritDoc
         */
        Mesh.prototype.getAnimator = function () {
            return this._animator;
        };
        Object.defineProperty(Mesh.prototype, "animator", {
            set: function (value) {
                if (this._animator)
                    this._animator.removeOwner(this);
                this._animator = value;
                var i;
                for (i = 0; i < this.subMeshes.length; i++) {
                    var subMesh = this.subMeshes[i];
                    subMesh.animator = this._animator;
                }
                if (this._animator)
                    this._animator.addOwner(this);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Mesh.prototype, "subMeshes", {
            /**
             * 子网格列表
             */
            get: function () {
                return this._subMeshes;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 添加子网格包装子几何体
         * @param subGeometry		被添加的子几何体
         */
        Mesh.prototype.addSubMesh = function (subGeometry) {
            var subMesh = new feng3d.SubMesh(subGeometry, this, null);
            var len = this._subMeshes.length;
            subMesh._index = len;
            this._subMeshes[len] = subMesh;
            this.invalidateBounds();
        };
        /**
         * 处理几何体边界变化事件
         */
        Mesh.prototype.onGeometryBoundsInvalid = function (event) {
            this.invalidateBounds();
        };
        /**
         * 处理子几何体添加事件
         */
        Mesh.prototype.onSubGeometryAdded = function (event) {
            this.addSubMesh(event.subGeometry);
            this.invalidateBounds();
        };
        /**
         * 处理子几何体移除事件
         */
        Mesh.prototype.onSubGeometryRemoved = function (event) {
            var subMesh;
            var subGeom = event.subGeometry;
            var len = this._subMeshes.length;
            var i;
            for (i = 0; i < len; ++i) {
                subMesh = this._subMeshes[i];
                if (subMesh.subGeometry == subGeom) {
                    subMesh.dispose();
                    this._subMeshes.splice(i, 1);
                    break;
                }
            }
            --len;
            for (; i < len; ++i)
                this._subMeshes[i]._index = i;
            this.invalidateBounds();
        };
        Object.defineProperty(Mesh.prototype, "castsShadows", {
            /**
             * 是否捕获阴影
             */
            get: function () {
                return this._castsShadows;
            },
            set: function (value) {
                this._castsShadows = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        Mesh.prototype.createEntityPartitionNode = function () {
            return new feng3d.MeshNode(this);
        };
        return Mesh;
    }(feng3d.Entity));
    feng3d.Mesh = Mesh;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 高度地形
     * @author feng 2014-7-16
     */
    var Elevation = (function (_super) {
        __extends(Elevation, _super);
        /**
         * 创建高度地形 拥有segmentsW*segmentsH个顶点
         * @param    material	地形纹理
         * @param    heightMap	高度图
         * @param    width	地形宽度
         * @param    height	地形高度
         * @param    depth	地形深度
         * @param    segmentsW	x轴上网格段数
         * @param    segmentsH	y轴上网格段数
         * @param    maxElevation	最大地形高度
         * @param    minElevation	最小地形高度
         * @param    smoothMap	是否平滑
         */
        function Elevation(material, heightMap, width, height, depth, segmentsW, segmentsH, maxElevation, minElevation) {
            if (width === void 0) { width = 1000; }
            if (height === void 0) { height = 100; }
            if (depth === void 0) { depth = 1000; }
            if (segmentsW === void 0) { segmentsW = 30; }
            if (segmentsH === void 0) { segmentsH = 30; }
            if (maxElevation === void 0) { maxElevation = 255; }
            if (minElevation === void 0) { minElevation = 0; }
            _super.call(this, new feng3d.Geometry(), material);
            this._geomDirty = true;
            this._uvDirty = true;
            this._subGeometry = new feng3d.SubGeometry();
            this.geometry.addSubGeometry(this._subGeometry);
            this._heightMap = heightMap;
            this._segmentsW = segmentsW;
            this._segmentsH = segmentsH;
            this._width = width;
            this._height = height;
            this._depth = depth;
            this._maxElevation = maxElevation;
            this._minElevation = minElevation;
            this._subGeometry.numVertices = (this._segmentsH + 1) * (this._segmentsW + 1);
            this.buildUVs();
            this.buildGeometry();
        }
        /**
         * 创建顶点坐标
         */
        Elevation.prototype.buildGeometry = function () {
            var vertices;
            var indices;
            var x, z;
            var numInds;
            var base;
            //一排顶点数据
            var tw = this._segmentsW + 1;
            //总顶点数量
            var numVerts = (this._segmentsH + 1) * tw;
            //一个格子所占高度图X轴像素数
            var uDiv = (this._heightMap.width - 1) / this._segmentsW;
            //一个格子所占高度图Y轴像素数
            var vDiv = (this._heightMap.height - 1) / this._segmentsH;
            var u, v;
            var y;
            vertices = this._subGeometry.vertexPositionData;
            if (vertices == null) {
                vertices = [];
                vertices.length = numVerts * 3;
            }
            indices = this._subGeometry.indexData;
            if (indices == null) {
                indices = [];
                indices.length = this._segmentsH * this._segmentsW * 6;
            }
            numVerts = 0;
            var col;
            for (var zi = 0; zi <= this._segmentsH; ++zi) {
                for (var xi = 0; xi <= this._segmentsW; ++xi) {
                    //顶点坐标
                    x = (xi / this._segmentsW - .5) * this._width;
                    z = (zi / this._segmentsH - .5) * this._depth;
                    //格子对应高度图uv坐标
                    u = xi * uDiv;
                    v = (this._segmentsH - zi) * vDiv;
                    //获取颜色值
                    col = this._heightMap.getPixel(u, v) & 0xff;
                    //计算高度值
                    y = (col > this._maxElevation) ? (this._maxElevation / 0xff) * this._height : ((col < this._minElevation) ? (this._minElevation / 0xff) * this._height : (col / 0xff) * this._height);
                    //保存顶点坐标
                    vertices[numVerts++] = x;
                    vertices[numVerts++] = y;
                    vertices[numVerts++] = z;
                    if (xi != this._segmentsW && zi != this._segmentsH) {
                        //增加 一个顶点同时 生成一个格子或两个三角形
                        base = xi + zi * tw;
                        indices[numInds++] = base;
                        indices[numInds++] = base + tw;
                        indices[numInds++] = base + tw + 1;
                        indices[numInds++] = base;
                        indices[numInds++] = base + tw + 1;
                        indices[numInds++] = base + 1;
                    }
                }
            }
            this._subGeometry.updateVertexPositionData(vertices);
            this._subGeometry.updateIndexData(indices);
        };
        /**
         * 创建uv坐标
         */
        Elevation.prototype.buildUVs = function () {
            var uvs = [];
            var numUvs = (this._segmentsH + 1) * (this._segmentsW + 1) * 2;
            uvs = this._subGeometry.UVData;
            if (uvs == null || numUvs != uvs.length) {
                uvs = [];
                uvs.length = numUvs;
            }
            numUvs = 0;
            //计算每个顶点的uv坐标
            for (var yi = 0; yi <= this._segmentsH; ++yi) {
                for (var xi = 0; xi <= this._segmentsW; ++xi) {
                    uvs[numUvs++] = xi / this._segmentsW;
                    uvs[numUvs++] = 1 - yi / this._segmentsH;
                }
            }
            this._subGeometry.updateUVData(uvs);
        };
        /**
         * 获取位置在（x，z）处的高度y值
         * @param x x坐标
         * @param z z坐标
         * @return 高度
         */
        Elevation.prototype.getHeightAt = function (x, z) {
            //得到高度图中的值
            var u = (x / this._width + .5) * (this._heightMap.width - 1);
            var v = (-z / this._depth + .5) * (this._heightMap.height - 1);
            var col = this._heightMap.getPixel(u, v) & 0xff;
            var h;
            if (col > this._maxElevation) {
                h = (this._maxElevation / 0xff) * this._height;
            }
            else if (col < this._minElevation) {
                h = (this._minElevation / 0xff) * this._height;
            }
            else {
                h = (col / 0xff) * this._height;
            }
            return h;
        };
        return Elevation;
    }(feng3d.Mesh));
    feng3d.Elevation = Elevation;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 线段集合
     * @author feng 2014-4-9
     */
    var SegmentSet = (function (_super) {
        __extends(SegmentSet, _super);
        /**
         * 创建一个线段集合
         */
        function SegmentSet() {
            _super.call(this);
            this.geometry = this.segmentGeometry = new feng3d.SegmentGeometry();
            this.material = new feng3d.SegmentMaterial();
        }
        /**
         * 添加线段
         * @param segment		线段数据
         */
        SegmentSet.prototype.addSegment = function (segment, needUpdateGeometry) {
            if (needUpdateGeometry === void 0) { needUpdateGeometry = true; }
            this.segmentGeometry.addSegment(segment, needUpdateGeometry);
        };
        Object.defineProperty(SegmentSet.prototype, "context3dCache", {
            /**
             * @inheritDoc
             */
            get: function () {
                return null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SegmentSet.prototype, "numTriangles", {
            /**
             * @inheritDoc
             */
            get: function () {
                return this._numIndices / 3;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SegmentSet.prototype, "castsShadows", {
            /**
             * 线段不会投射阴影，始终为false
             */
            get: function () {
                return false;
            },
            enumerable: true,
            configurable: true
        });
        return SegmentSet;
    }(feng3d.Mesh));
    feng3d.SegmentSet = SegmentSet;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 坐标系,三叉戟
     * @param length 长度
     * @param showLetters 显示字母
     */
    var Trident = (function (_super) {
        __extends(Trident, _super);
        function Trident(length, showLetters) {
            if (length === void 0) { length = 100; }
            if (showLetters === void 0) { showLetters = true; }
            _super.call(this);
            this.buildTrident(Math.abs((length == 0) ? 10 : length), showLetters);
        }
        Trident.prototype.buildTrident = function (length, showLetters) {
            var scaleH = length / 10;
            var scaleW = length / 20;
            var scl1 = scaleW * 1.5;
            var scl2 = scaleH * 3;
            var scl3 = scaleH * 2;
            var scl4 = scaleH * 3.4;
            var cross = length + (scl3) + (((length + scl4) - (length + scl3)) / 3 * 2);
            var arr = [
                [new feng3d.Vector3D(), new feng3d.Vector3D(length, 0, 0), 0x880000, 0xff0000, 1],
                //X
                [new feng3d.Vector3D(length + scl2, scl1, 0), new feng3d.Vector3D(length + scl3, -scl1, 0), 0xff0000, 0xff0000, 1],
                [new feng3d.Vector3D(length + scl3, scl1, 0), new feng3d.Vector3D(length + scl2, -scl1, 0), 0xff0000, 0xff0000, 1],
                [new feng3d.Vector3D(), new feng3d.Vector3D(0, length, 0), 0x008800, 0x00ff00, 1],
                //Y
                [new feng3d.Vector3D(-scaleW * 1.2, length + scl4, 0), new feng3d.Vector3D(0, cross, 0), 0x00ff00, 0x00ff00, 1],
                [new feng3d.Vector3D(scaleW * 1.2, length + scl4, 0), new feng3d.Vector3D(0, cross, 0), 0x00ff00, 0x00ff00, 1],
                [new feng3d.Vector3D(0, cross, 0), new feng3d.Vector3D(0, length + scl3, 0), 0x00ff00, 0x00ff00, 1],
                [new feng3d.Vector3D(), new feng3d.Vector3D(0, 0, length), 0x000088, 0x0000ff, 1],
                //Z
                [new feng3d.Vector3D(0, scl1, length + scl2), new feng3d.Vector3D(0, scl1, length + scl3), 0x0000ff, 0x0000ff, 1],
                [new feng3d.Vector3D(0, -scl1, length + scl2), new feng3d.Vector3D(0, -scl1, length + scl3), 0x0000ff, 0x0000ff, 1],
                [new feng3d.Vector3D(0, -scl1, length + scl3), new feng3d.Vector3D(0, scl1, length + scl2), 0x0000ff, 0x0000ff, 1],
            ];
            var segmentX;
            for (var i = 0; i < arr.length; i++) {
                segmentX = new feng3d.Segment(feng3d.as(arr[i][0], feng3d.Vector3D), feng3d.as(arr[i][1], feng3d.Vector3D), Number(arr[i][2]), Number(arr[i][3]), Number(arr[i][4]));
                this.segmentGeometry.addSegment(segmentX);
            }
        };
        return Trident;
    }(feng3d.SegmentSet));
    feng3d.Trident = Trident;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 线框基元基类
     * @author feng 2014-4-27
     */
    var WireframePrimitiveBase = (function (_super) {
        __extends(WireframePrimitiveBase, _super);
        /**
         * @param color 线框颜色
         * @param thickness 线框厚度
         */
        function WireframePrimitiveBase(color, thickness) {
            if (color === void 0) { color = 0xffffff; }
            if (thickness === void 0) { thickness = 1; }
            _super.call(this);
            this._color = 0xffffff;
            this._thickness = 1;
            if (thickness <= 0)
                thickness = 1;
            this.color = color;
            this.thickness = thickness;
        }
        Object.defineProperty(WireframePrimitiveBase.prototype, "color", {
            /** 线框颜色 */
            get: function () {
                return this._color;
            },
            set: function (value) {
                this._color = value;
                this.segmentGeometry.segments.forEach(function (segment) {
                    segment.startColor = segment.endColor = value;
                });
                this.segmentGeometry.updateGeometry();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WireframePrimitiveBase.prototype, "thickness", {
            /** 线条粗细值 */
            get: function () {
                return this._thickness;
            },
            set: function (value) {
                this._thickness = value;
                this.segmentGeometry.segments.forEach(function (segment) {
                    segment.thickness = segment.thickness = value;
                });
                this.segmentGeometry.updateGeometry();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 更新线条
         * @param index 线段编号
         * @param v0 线段起点
         * @param v1 线段终点
         */
        WireframePrimitiveBase.prototype.updateOrAddSegment = function (index, v0, v1) {
            var segment;
            if ((segment = this.segmentGeometry.getSegment(index)) != null) {
                segment.start = v0;
                segment.end = v1;
            }
            else {
                this.segmentGeometry.addSegment(new feng3d.Segment(v0.clone(), v1.clone(), this._color, this._color, this._thickness));
            }
        };
        return WireframePrimitiveBase;
    }(feng3d.SegmentSet));
    feng3d.WireframePrimitiveBase = WireframePrimitiveBase;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 线框立方体
     * @author feng 2014-4-27
     */
    var WireframeCube = (function (_super) {
        __extends(WireframeCube, _super);
        /**
         * @param width X轴方向宽度
         * @param height Y轴方向高度
         * @param depth Z轴方向深度
         * @param color 线条颜色
         * @param thickness 线条厚度
         */
        function WireframeCube(width, height, depth, color, thickness) {
            if (width === void 0) { width = 100; }
            if (height === void 0) { height = 100; }
            if (depth === void 0) { depth = 100; }
            if (color === void 0) { color = 0xFFFFFF; }
            if (thickness === void 0) { thickness = 1; }
            _super.call(this, color, thickness);
            this._cubeWidth = width;
            this._cubeHeight = height;
            this._cubeDepth = depth;
            this.buildGeometry();
        }
        Object.defineProperty(WireframeCube.prototype, "cubeWidth", {
            /**
             * The size of the cube along its X-axis.
             */
            get: function () {
                return this._cubeWidth;
            },
            set: function (value) {
                this._cubeWidth = value;
                this.buildGeometry();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WireframeCube.prototype, "cubeHeight", {
            /**
             * The size of the cube along its Y-axis.
             */
            get: function () {
                return this._cubeHeight;
            },
            set: function (value) {
                if (value <= 0)
                    throw new Error("Value needs to be greater than 0");
                this._cubeHeight = value;
                this.buildGeometry();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WireframeCube.prototype, "cubeDepth", {
            /**
             * The size of the cube along its Z-axis.
             */
            get: function () {
                return this._cubeDepth;
            },
            set: function (value) {
                this._cubeDepth = value;
                this.buildGeometry();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        WireframeCube.prototype.buildGeometry = function () {
            this.segmentGeometry.removeAllSegments();
            var v0 = new feng3d.Vector3D();
            var v1 = new feng3d.Vector3D();
            var hw = this._cubeWidth * .5;
            var hh = this._cubeHeight * .5;
            var hd = this._cubeDepth * .5;
            v0.x = -hw;
            v0.y = hh;
            v0.z = -hd;
            v1.x = -hw;
            v1.y = -hh;
            v1.z = -hd;
            this.updateOrAddSegment(0, v0, v1);
            v0.z = hd;
            v1.z = hd;
            this.updateOrAddSegment(1, v0, v1);
            v0.x = hw;
            v1.x = hw;
            this.updateOrAddSegment(2, v0, v1);
            v0.z = -hd;
            v1.z = -hd;
            this.updateOrAddSegment(3, v0, v1);
            v0.x = -hw;
            v0.y = -hh;
            v0.z = -hd;
            v1.x = hw;
            v1.y = -hh;
            v1.z = -hd;
            this.updateOrAddSegment(4, v0, v1);
            v0.y = hh;
            v1.y = hh;
            this.updateOrAddSegment(5, v0, v1);
            v0.z = hd;
            v1.z = hd;
            this.updateOrAddSegment(6, v0, v1);
            v0.y = -hh;
            v1.y = -hh;
            this.updateOrAddSegment(7, v0, v1);
            v0.x = -hw;
            v0.y = -hh;
            v0.z = -hd;
            v1.x = -hw;
            v1.y = -hh;
            v1.z = hd;
            this.updateOrAddSegment(8, v0, v1);
            v0.y = hh;
            v1.y = hh;
            this.updateOrAddSegment(9, v0, v1);
            v0.x = hw;
            v1.x = hw;
            this.updateOrAddSegment(10, v0, v1);
            v0.y = -hh;
            v1.y = -hh;
            this.updateOrAddSegment(11, v0, v1);
        };
        return WireframeCube;
    }(feng3d.WireframePrimitiveBase));
    feng3d.WireframeCube = WireframeCube;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
    * 线框几何体
     * @author feng 2014-5-8
     */
    var WireframeGeometry = (function (_super) {
        __extends(WireframeGeometry, _super);
        /**
         * 创建几何体线框
         * @param geometry 几何体
         * @param color 线条颜色
         * @param thickness 线条粗细
         */
        function WireframeGeometry(color, thickness) {
            if (color === void 0) { color = 0xffffff; }
            if (thickness === void 0) { thickness = 1; }
            _super.call(this, color, thickness);
            this._drawGeometry = new feng3d.Geometry();
        }
        Object.defineProperty(WireframeGeometry.prototype, "drawGeometry", {
            get: function () {
                return this._drawGeometry;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 绘制几何体线框
         */
        WireframeGeometry.prototype.setDrawGeometry = function (value) {
            this._drawGeometry = value;
            this.buildGeometry();
        };
        WireframeGeometry.prototype.buildGeometry = function () {
            this.segmentGeometry.removeAllSegments();
            if (this.drawGeometry == null)
                return;
            //避免重复绘制同一条线段
            var segmentDic = {};
            var subGeometries = this.drawGeometry.subGeometries;
            var subGeometry;
            for (var j = 0; j < subGeometries.length; j++) {
                subGeometry = subGeometries[j];
                //顶点索引
                var _vertexIndices = subGeometry.indexData;
                //顶点位置
                var _vertices = subGeometry.vertexPositionData;
                var numTriangle = _vertexIndices.length / 3;
                var indexA;
                var indexB;
                var indexC;
                var posA;
                var posB;
                var posC;
                var segmentIndex = 0;
                for (var i = 0; i < numTriangle; i++) {
                    indexA = _vertexIndices[i * 3];
                    indexB = _vertexIndices[i * 3 + 1];
                    indexC = _vertexIndices[i * 3 + 2];
                    posA = new feng3d.Vector3D(_vertices[indexA * 3], _vertices[indexA * 3 + 1], _vertices[indexA * 3 + 2]);
                    posB = new feng3d.Vector3D(_vertices[indexB * 3], _vertices[indexB * 3 + 1], _vertices[indexB * 3 + 2]);
                    posC = new feng3d.Vector3D(_vertices[indexC * 3], _vertices[indexC * 3 + 1], _vertices[indexC * 3 + 2]);
                    //线段AB
                    if (!segmentDic[posA.toString() + "-" + posB.toString()]) {
                        this.updateOrAddSegment(++segmentIndex, posA, posB);
                        segmentDic[posA.toString() + "-" + posB.toString()] = segmentDic[posB.toString() + "-" + posA.toString()] = true;
                    }
                    //线段BC
                    if (!segmentDic[posB.toString() + "-" + posC.toString()]) {
                        this.updateOrAddSegment(++segmentIndex, posB, posC);
                        segmentDic[posB.toString() + "-" + posC.toString()] = segmentDic[posC.toString() + "-" + posB.toString()] = true;
                    }
                    //线段CA
                    if (!segmentDic[posC.toString() + "-" + posA.toString()]) {
                        this.updateOrAddSegment(++segmentIndex, posC, posA);
                        segmentDic[posC.toString() + "-" + posA.toString()] = segmentDic[posA.toString() + "-" + posC.toString()] = true;
                    }
                }
            }
        };
        return WireframeGeometry;
    }(feng3d.WireframePrimitiveBase));
    feng3d.WireframeGeometry = WireframeGeometry;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * A WireframePlane primitive mesh.
     */
    var WireframePlane = (function (_super) {
        __extends(WireframePlane, _super);
        /**
         * Creates a new WireframePlane object.
         * @param width The size of the cube along its X-axis.
         * @param height The size of the cube along its Y-axis.
         * @param segmentsW The number of segments that make up the cube along the X-axis.
         * @param segmentsH The number of segments that make up the cube along the Y-axis.
         * @param color The colour of the wireframe lines
         * @param thickness The thickness of the wireframe lines
         * @param orientation The orientaion in which the plane lies.
         */
        function WireframePlane(width, height, segmentsW, segmentsH, color, thickness, orientation) {
            if (segmentsW === void 0) { segmentsW = 10; }
            if (segmentsH === void 0) { segmentsH = 10; }
            if (color === void 0) { color = 0xFFFFFF; }
            if (thickness === void 0) { thickness = 1; }
            if (orientation === void 0) { orientation = "yz"; }
            _super.call(this, color, thickness);
            this._width = width;
            this._height = height;
            this._segmentsW = segmentsW;
            this._segmentsH = segmentsH;
            this._orientation = orientation;
            this.buildGeometry();
        }
        Object.defineProperty(WireframePlane.prototype, "orientation", {
            /**
             * The orientaion in which the plane lies.
             */
            get: function () {
                return this._orientation;
            },
            set: function (value) {
                this._orientation = value;
                this.buildGeometry();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WireframePlane.prototype, "width", {
            /**
             * The size of the cube along its X-axis.
             */
            get: function () {
                return this._width;
            },
            set: function (value) {
                this._width = value;
                this.buildGeometry();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WireframePlane.prototype, "height", {
            /**
             * The size of the cube along its Y-axis.
             */
            get: function () {
                return this._height;
            },
            set: function (value) {
                if (value <= 0)
                    throw new Error("Value needs to be greater than 0");
                this._height = value;
                this.buildGeometry();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WireframePlane.prototype, "segmentsW", {
            /**
             * The number of segments that make up the plane along the X-axis.
             */
            get: function () {
                return this._segmentsW;
            },
            set: function (value) {
                this._segmentsW = value;
                this.buildGeometry();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WireframePlane.prototype, "segmentsH", {
            /**
             * The number of segments that make up the plane along the Y-axis.
             */
            get: function () {
                return this._segmentsH;
            },
            set: function (value) {
                this._segmentsH = value;
                this.buildGeometry();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        WireframePlane.prototype.buildGeometry = function () {
            this.segmentGeometry.removeAllSegments();
            var v0 = new feng3d.Vector3D();
            var v1 = new feng3d.Vector3D();
            var hw = this._width * .5;
            var hh = this._height * .5;
            var index;
            var ws, hs;
            if (this._orientation == WireframePlane.ORIENTATION_XY) {
                v0.y = hh;
                v0.z = 0;
                v1.y = -hh;
                v1.z = 0;
                for (ws = 0; ws <= this._segmentsW; ++ws) {
                    v0.x = v1.x = (ws / this._segmentsW - .5) * this._width;
                    this.updateOrAddSegment(index++, v0, v1);
                }
                v0.x = -hw;
                v1.x = hw;
                for (hs = 0; hs <= this._segmentsH; ++hs) {
                    v0.y = v1.y = (hs / this._segmentsH - .5) * this._height;
                    this.updateOrAddSegment(index++, v0, v1);
                }
            }
            else if (this._orientation == WireframePlane.ORIENTATION_XZ) {
                v0.z = hh;
                v0.y = 0;
                v1.z = -hh;
                v1.y = 0;
                for (ws = 0; ws <= this._segmentsW; ++ws) {
                    v0.x = v1.x = (ws / this._segmentsW - .5) * this._width;
                    this.updateOrAddSegment(index++, v0, v1);
                }
                v0.x = -hw;
                v1.x = hw;
                for (hs = 0; hs <= this._segmentsH; ++hs) {
                    v0.z = v1.z = (hs / this._segmentsH - .5) * this._height;
                    this.updateOrAddSegment(index++, v0, v1);
                }
            }
            else if (this._orientation == WireframePlane.ORIENTATION_YZ) {
                v0.y = hh;
                v0.x = 0;
                v1.y = -hh;
                v1.x = 0;
                for (ws = 0; ws <= this._segmentsW; ++ws) {
                    v0.z = v1.z = (ws / this._segmentsW - .5) * this._width;
                    this.updateOrAddSegment(index++, v0, v1);
                }
                v0.z = hw;
                v1.z = -hw;
                for (hs = 0; hs <= this._segmentsH; ++hs) {
                    v0.y = v1.y = (hs / this._segmentsH - .5) * this._height;
                    this.updateOrAddSegment(index++, v0, v1);
                }
            }
        };
        WireframePlane.ORIENTATION_YZ = "yz";
        WireframePlane.ORIENTATION_XY = "xy";
        WireframePlane.ORIENTATION_XZ = "xz";
        return WireframePlane;
    }(feng3d.WireframePrimitiveBase));
    feng3d.WireframePlane = WireframePlane;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 球体线框
     * @author feng 2015-3-21
     */
    var WireframeSphere = (function (_super) {
        __extends(WireframeSphere, _super);
        /**
         * 创建一个球体线框对象
         * @param radius			球体半径
         * @param segmentsW			球体的横向分割数
         * @param segmentsH			球体的纵向分割数
         * @param color				线框颜色
         * @param thickness			线条粗细
         */
        function WireframeSphere(radius, segmentsW, segmentsH, color, thickness) {
            if (radius === void 0) { radius = 50; }
            if (segmentsW === void 0) { segmentsW = 16; }
            if (segmentsH === void 0) { segmentsH = 12; }
            if (color === void 0) { color = 0xFFFFFF; }
            if (thickness === void 0) { thickness = 1; }
            _super.call(this, color, thickness);
            this._radius = radius;
            this._segmentsW = segmentsW;
            this._segmentsH = segmentsH;
            this.buildGeometry();
        }
        /**
         * @inheritDoc
         */
        WireframeSphere.prototype.buildGeometry = function () {
            this.segmentGeometry.removeAllSegments();
            var vertices = [];
            var v0 = new feng3d.Vector3D();
            var v1 = new feng3d.Vector3D();
            var i, j;
            var numVerts = 0;
            var index;
            for (j = 0; j <= this._segmentsH; ++j) {
                var horangle = Math.PI * j / this._segmentsH;
                var z = -this._radius * Math.cos(horangle);
                var ringradius = this._radius * Math.sin(horangle);
                for (i = 0; i <= this._segmentsW; ++i) {
                    var verangle = 2 * Math.PI * i / this._segmentsW;
                    var x = ringradius * Math.cos(verangle);
                    var y = ringradius * Math.sin(verangle);
                    vertices[numVerts++] = x;
                    vertices[numVerts++] = -z;
                    vertices[numVerts++] = y;
                }
            }
            for (j = 1; j <= this._segmentsH; ++j) {
                for (i = 1; i <= this._segmentsW; ++i) {
                    var a = ((this._segmentsW + 1) * j + i) * 3;
                    var b = ((this._segmentsW + 1) * j + i - 1) * 3;
                    var c = ((this._segmentsW + 1) * (j - 1) + i - 1) * 3;
                    var d = ((this._segmentsW + 1) * (j - 1) + i) * 3;
                    if (j == this._segmentsH) {
                        v0.x = vertices[c];
                        v0.y = vertices[c + 1];
                        v0.z = vertices[c + 2];
                        v1.x = vertices[d];
                        v1.y = vertices[d + 1];
                        v1.z = vertices[d + 2];
                        this.updateOrAddSegment(index++, v0, v1);
                        v0.x = vertices[a];
                        v0.y = vertices[a + 1];
                        v0.z = vertices[a + 2];
                        this.updateOrAddSegment(index++, v0, v1);
                    }
                    else if (j == 1) {
                        v1.x = vertices[b];
                        v1.y = vertices[b + 1];
                        v1.z = vertices[b + 2];
                        v0.x = vertices[c];
                        v0.y = vertices[c + 1];
                        v0.z = vertices[c + 2];
                        this.updateOrAddSegment(index++, v0, v1);
                    }
                    else {
                        v1.x = vertices[b];
                        v1.y = vertices[b + 1];
                        v1.z = vertices[b + 2];
                        v0.x = vertices[c];
                        v0.y = vertices[c + 1];
                        v0.z = vertices[c + 2];
                        this.updateOrAddSegment(index++, v0, v1);
                        v1.x = vertices[d];
                        v1.y = vertices[d + 1];
                        v1.z = vertices[d + 2];
                        this.updateOrAddSegment(index++, v0, v1);
                    }
                }
            }
        };
        return WireframeSphere;
    }(feng3d.WireframePrimitiveBase));
    feng3d.WireframeSphere = WireframeSphere;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 天空盒类用于渲染的场景中的天空。
     * 总是被认为是静态的,在无穷远处,并且总是集中在相机的位置和大小符合在相机的视锥体,
     * 确保天空盒总是尽可能大而不被裁剪。
     * @author feng 2014-7-11
     */
    var SkyBox = (function (_super) {
        __extends(SkyBox, _super);
        /**
         * 创建天空盒实例
         * @param cubeMap		立方体贴图
         */
        function SkyBox(cubeMap) {
            _super.call(this);
            this._namedAsset._assetType = feng3d.AssetType.SKYBOX;
            this.material = new feng3d.SkyBoxMaterial(cubeMap);
            this.subGeometry = new feng3d.SubGeometry();
            this.geometry.addSubGeometry(this.subGeometry);
            this.buildGeometry();
        }
        /**
         * 创建天空盒 顶点与索引数据
         */
        SkyBox.prototype.buildGeometry = function () {
            this.subGeometry.numVertices = 8;
            //八个顶点，32个number
            var vertexData = [
                -1, 1, -1, 1, 1, -1,
                1, 1, 1, -1, 1, 1,
                -1, -1, -1, 1, -1, -1,
                1, -1, 1, -1, -1, 1 //
            ];
            this.subGeometry.updateVertexPositionData(vertexData);
            //6个面，12个三角形，36个顶点索引
            var indexData = [
                0, 1, 2, 2, 3, 0,
                6, 5, 4, 4, 7, 6,
                2, 6, 7, 7, 3, 2,
                4, 5, 1, 1, 0, 4,
                4, 0, 3, 3, 7, 4,
                2, 1, 5, 5, 6, 2 //
            ];
            this.subGeometry.updateIndexData(indexData);
        };
        /**
         * @inheritDoc
         */
        SkyBox.prototype.createEntityPartitionNode = function () {
            return new feng3d.SkyBoxNode(this);
        };
        /**
         * @inheritDoc
         */
        SkyBox.prototype.updateBounds = function () {
            this._boundsInvalid = false;
        };
        Object.defineProperty(SkyBox.prototype, "castsShadows", {
            /**
             * 天空盒不会投射阴影，始终为false
             */
            get: function () {
                return false;
            },
            enumerable: true,
            configurable: true
        });
        return SkyBox;
    }(feng3d.Mesh));
    feng3d.SkyBox = SkyBox;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * Sprite3D is a 3D billboard, a renderable rectangular area that is always aligned with the projection plane.
     * As a result, no perspective transformation occurs on a Sprite3D object.
     *
     * todo: mvp generation or vertex shader code can be optimized
     */
    var Sprite3D = (function (_super) {
        __extends(Sprite3D, _super);
        function Sprite3D(material, width, height) {
            _super.call(this);
            this._shadowCaster = false;
            this.transform3D.addEventListener(feng3d.Transform3DEvent.TRANSFORM_UPDATED, this.onTransformUpdated);
            this.material = material;
            this._width = width;
            this._height = height;
            this._spriteMatrix = new feng3d.Matrix3D();
            if (!Sprite3D._sprite3DGeometry) {
                Sprite3D._sprite3DGeometry = new feng3d.SubGeometry();
                Sprite3D._sprite3DGeometry.numVertices = 4;
                Sprite3D._sprite3DGeometry.updateVertexPositionData([-.5, .5, .0, .5, .5, .0, .5, -.5, .0, -.5, -.5, .0]);
                Sprite3D._sprite3DGeometry.updateUVData([.0, .0, 1.0, .0, 1.0, 1.0, .0, 1.0]);
                Sprite3D._sprite3DGeometry.updateIndexData([0, 1, 2, 0, 2, 3]);
                Sprite3D._sprite3DGeometry.updateVertexTangentData([1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0]);
                Sprite3D._sprite3DGeometry.updateVertexNormalData([.0, .0, -1.0, .0, .0, -1.0, .0, .0, -1.0, .0, .0, -1.0]);
            }
            this.geometry.addSubGeometry(Sprite3D._sprite3DGeometry);
        }
        Object.defineProperty(Sprite3D.prototype, "pickingCollider", {
            set: function (value) {
                _super.prototype.setPickingCollider.call(this, value);
                if (value) {
                    this._pickingSubMesh = new feng3d.SubMesh(Sprite3D._sprite3DGeometry, null);
                    this._pickingTransform = new feng3d.Matrix3D();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Sprite3D.prototype, "width", {
            get: function () {
                return this._width;
            },
            set: function (value) {
                if (this._width == value)
                    return;
                this._width = value;
                this.transform3D.invalidateTransform();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Sprite3D.prototype, "height", {
            get: function () {
                return this._height;
            },
            set: function (value) {
                if (this._height == value)
                    return;
                this._height = value;
                this.transform3D.invalidateTransform();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Sprite3D.prototype, "castsShadows", {
            get: function () {
                return this._shadowCaster;
            },
            enumerable: true,
            configurable: true
        });
        Sprite3D.prototype.updateBounds = function () {
            this._bounds.fromExtremes(-.5 * this.transform3D.scaleX, -.5 * this.transform3D.scaleY, -.5 * this.transform3D.scaleZ, .5 * this.transform3D.scaleX, .5 * this.transform3D.scaleY, .5 * this.transform3D.scaleZ);
            this._boundsInvalid = false;
        };
        Sprite3D.prototype.onTransformUpdated = function (event) {
            this.transform3D.transform.prependScale(this._width, this._height, Math.max(this._width, this._height));
        };
        Sprite3D.prototype.collidesBefore = function (shortestCollisionDistance, findClosest) {
            findClosest = findClosest;
            var viewTransform = this._camera.inverseSceneTransform.clone();
            viewTransform.transpose();
            var rawViewTransform = feng3d.Matrix3DUtils.RAW_DATA_CONTAINER;
            viewTransform.copyRawDataTo(rawViewTransform);
            rawViewTransform[3] = 0;
            rawViewTransform[7] = 0;
            rawViewTransform[11] = 0;
            rawViewTransform[12] = 0;
            rawViewTransform[13] = 0;
            rawViewTransform[14] = 0;
            this._pickingTransform.copyRawDataFrom(rawViewTransform);
            this._pickingTransform.prependScale(this._width, this._height, Math.max(this._width, this._height));
            this._pickingTransform.appendTranslation(this.scenePosition.x, this.scenePosition.y, this.scenePosition.z);
            this._pickingTransform.invert();
            var localRayPosition = this._pickingTransform.transformVector(this._pickingCollisionVO.ray3D.position);
            var localRayDirection = this._pickingTransform.deltaTransformVector(this._pickingCollisionVO.ray3D.direction);
            var ray3D = new feng3d.Ray3D(localRayPosition, localRayDirection);
            this._pickingCollider.setLocalRay(ray3D);
            this._pickingCollisionVO.renderable = null;
            if (this._pickingCollider.testSubMeshCollision(this._pickingSubMesh, this._pickingCollisionVO, shortestCollisionDistance, false))
                this._pickingCollisionVO.renderable = this._pickingSubMesh.renderableBase;
            return this._pickingCollisionVO.renderable != null;
        };
        Sprite3D.prototype.getRenderSceneTransform = function (camera) {
            var comps = feng3d.Matrix3DUtils.decompose(camera.sceneTransform);
            var scale = comps[2];
            comps[0].x = this.scenePosition.x;
            comps[0].y = this.scenePosition.y;
            comps[0].z = this.scenePosition.z;
            scale.x = this._width * this.transform3D.scaleX;
            scale.y = this._height * this.transform3D.scaleY;
            this._spriteMatrix.recompose(comps);
            return this._spriteMatrix;
        };
        return Sprite3D;
    }(feng3d.Mesh));
    feng3d.Sprite3D = Sprite3D;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 灯光基类
     * @author feng 2014-9-11
     */
    var LightBase = (function (_super) {
        __extends(LightBase, _super);
        /**
         * 创建一个灯光
         */
        function LightBase() {
            _super.call(this);
            this._color = 0xffffff;
            this._colorR = 1;
            this._colorG = 1;
            this._colorB = 1;
            this._ambientColor = 0xffffff;
            this._ambient = 0;
            this._ambientR = 0;
            this._ambientG = 0;
            this._ambientB = 0;
            this._specular = 1;
            this._specularR = 1;
            this._specularG = 1;
            this._specularB = 1;
            this._diffuse = 1;
            this._diffuseR = 1;
            this._diffuseG = 1;
            this._diffuseB = 1;
            this._namedAsset._assetType = feng3d.AssetType.LIGHT;
        }
        Object.defineProperty(LightBase.prototype, "castsShadows", {
            get: function () {
                return this._castsShadows;
            },
            set: function (value) {
                if (this._castsShadows == value)
                    return;
                this._castsShadows = value;
                if (value) {
                    this._shadowMapper = this._shadowMapper || this.createShadowMapper();
                    this._shadowMapper.light = this;
                }
                else {
                    this._shadowMapper.dispose();
                    this._shadowMapper = null;
                }
                this.dispatchEvent(new feng3d.LightEvent(feng3d.LightEvent.CASTS_SHADOW_CHANGE));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LightBase.prototype, "color", {
            /**
             * 灯光颜色。默认为<code>0xffffff</code>。
             */
            get: function () {
                return this._color;
            },
            set: function (value) {
                this._color = value;
                this._colorR = ((this._color >> 16) & 0xff) / 0xff;
                this._colorG = ((this._color >> 8) & 0xff) / 0xff;
                this._colorB = (this._color & 0xff) / 0xff;
                this.updateDiffuse();
                this.updateSpecular();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LightBase.prototype, "ambient", {
            /**
             * 环境光强。默认为<code>0</code>。
             */
            get: function () {
                return this._ambient;
            },
            set: function (value) {
                if (value < 0)
                    value = 0;
                else if (value > 1)
                    value = 1;
                this._ambient = value;
                this.updateAmbient();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LightBase.prototype, "ambientColor", {
            /**
             * 环境光颜色。默认为<code>0xffffff</code>。
             */
            get: function () {
                return this._ambientColor;
            },
            set: function (value) {
                this._ambientColor = value;
                this.updateAmbient();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LightBase.prototype, "diffuse", {
            /**
             * 漫反射光强。默认为<code>1</code>。
             */
            get: function () {
                return this._diffuse;
            },
            set: function (value) {
                if (value < 0)
                    value = 0;
                this._diffuse = value;
                this.updateDiffuse();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LightBase.prototype, "specular", {
            /**
             * 镜面反射光强。默认为<code>1</code>。
             */
            get: function () {
                return this._specular;
            },
            set: function (value) {
                if (value < 0)
                    value = 0;
                this._specular = value;
                this.updateSpecular();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 更新镜面反射光成分
         */
        LightBase.prototype.updateSpecular = function () {
            this._specularR = this._colorR * this._specular;
            this._specularG = this._colorG * this._specular;
            this._specularB = this._colorB * this._specular;
        };
        /**
         * 更新漫反射光成分
         */
        LightBase.prototype.updateDiffuse = function () {
            this._diffuseR = this._colorR * this._diffuse;
            this._diffuseG = this._colorG * this._diffuse;
            this._diffuseB = this._colorB * this._diffuse;
        };
        /**
         * 更新环境光成分
         */
        LightBase.prototype.updateAmbient = function () {
            this._ambientR = ((this._ambientColor >> 16) & 0xff) / 0xff * this._ambient;
            this._ambientG = ((this._ambientColor >> 8) & 0xff) / 0xff * this._ambient;
            this._ambientB = (this._ambientColor & 0xff) / 0xff * this._ambient;
        };
        Object.defineProperty(LightBase.prototype, "shadowMapper", {
            get: function () {
                return this._shadowMapper;
            },
            set: function (value) {
                this._shadowMapper = value;
                this._shadowMapper.light = this;
            },
            enumerable: true,
            configurable: true
        });
        return LightBase;
    }(feng3d.Entity));
    feng3d.LightBase = LightBase;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 方向灯光
     * @author feng 2014-9-11
     */
    var DirectionalLight = (function (_super) {
        __extends(DirectionalLight, _super);
        /**
         * 创建一个方向灯光
         * @param xDir		方向X值
         * @param yDir		方向Y值
         * @param zDir		方向Z值
         */
        function DirectionalLight(xDir, yDir, zDir) {
            if (xDir === void 0) { xDir = 0; }
            if (yDir === void 0) { yDir = -1; }
            if (zDir === void 0) { zDir = 1; }
            _super.call(this);
            this.direction = new feng3d.Vector3D(xDir, yDir, zDir);
            this._sceneDirection = new feng3d.Vector3D();
        }
        Object.defineProperty(DirectionalLight.prototype, "direction", {
            /**
             * 灯光方向
             */
            get: function () {
                return this._direction;
            },
            set: function (value) {
                this._direction = value;
                //lookAt(new Vector3D(x + this._direction.x, y + this._direction.y, z + this._direction.z));
                if (!this._tmpLookAt)
                    this._tmpLookAt = new feng3d.Vector3D();
                this._tmpLookAt.x = this.transform3D.x + this._direction.x;
                this._tmpLookAt.y = this.transform3D.y + this._direction.y;
                this._tmpLookAt.z = this.transform3D.z + this._direction.z;
                this.transform3D.lookAt(this._tmpLookAt);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DirectionalLight.prototype, "sceneDirection", {
            /**
             * 灯光场景方向
             */
            get: function () {
                if (this._sceneTransformDirty)
                    this.updateSceneTransform();
                return this._sceneDirection;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        DirectionalLight.prototype.updateSceneTransform = function () {
            _super.prototype.updateSceneTransform.call(this);
            this.sceneTransform.copyColumnTo(2, this._sceneDirection);
            this._sceneDirection.normalize();
        };
        /**
         * @inheritDoc
         */
        DirectionalLight.prototype.createEntityPartitionNode = function () {
            return new feng3d.DirectionalLightNode(this);
        };
        /**
         * @inheritDoc
         */
        DirectionalLight.prototype.getDefaultBoundingVolume = function () {
            // 方向光源并没有坐标，因此永远在3D场景中
            return new feng3d.NullBounds();
        };
        /**
         * @inheritDoc
         */
        DirectionalLight.prototype.updateBounds = function () {
        };
        DirectionalLight.prototype.createShadowMapper = function () {
            return new feng3d.DirectionalShadowMapper();
        };
        DirectionalLight.prototype.getObjectProjectionMatrix = function (renderable, target) {
            return null;
        };
        return DirectionalLight;
    }(feng3d.LightBase));
    feng3d.DirectionalLight = DirectionalLight;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 点灯光
     * @author feng 2014-10-9
     */
    var PointLight = (function (_super) {
        __extends(PointLight, _super);
        function PointLight() {
            _super.call(this);
            this._radius = 90000;
            this._fallOff = 100000;
            this._fallOffFactor = 1 / (this._fallOff * this._fallOff - this._radius * this._radius);
        }
        Object.defineProperty(PointLight.prototype, "radius", {
            /**
             * 灯光可照射的最小距离
             */
            get: function () {
                return this._radius;
            },
            set: function (value) {
                this._radius = value;
                if (this._radius < 0)
                    this._radius = 0;
                else if (this._radius > this._fallOff) {
                    this._fallOff = this._radius;
                    this.invalidateBounds();
                }
                this._fallOffFactor = 1 / (this._fallOff * this._fallOff - this._radius * this._radius);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PointLight.prototype, "fallOff", {
            /**
             * 灯光可照射的最大距离
             */
            get: function () {
                return this._fallOff;
            },
            set: function (value) {
                this._fallOff = value;
                if (this._fallOff < 0)
                    this._fallOff = 0;
                if (this._fallOff < this._radius)
                    this._radius = this._fallOff;
                this._fallOffFactor = 1 / (this._fallOff * this._fallOff - this._radius * this._radius);
                this.invalidateBounds();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        PointLight.prototype.createEntityPartitionNode = function () {
            return new feng3d.PointLightNode(this);
        };
        /**
         * @inheritDoc
         */
        PointLight.prototype.updateBounds = function () {
            //			super.updateBounds();
            //			this._bounds.fromExtremes(-this._fallOff, -this._fallOff, -this._fallOff, this._fallOff, this._fallOff, this._fallOff);
            this._bounds.fromSphere(new feng3d.Vector3D(), this._fallOff);
            this._boundsInvalid = false;
        };
        PointLight.prototype.createShadowMapper = function () {
            return null;
        };
        PointLight.prototype.getObjectProjectionMatrix = function (renderable, target) {
            return null;
        };
        return PointLight;
    }(feng3d.LightBase));
    feng3d.PointLight = PointLight;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 顶点数据拥有者
     * @author feng 2015-1-14
     */
    var VertexBufferOwner = (function (_super) {
        __extends(VertexBufferOwner, _super);
        /**
         * 创建顶点数据拥有者
         */
        function VertexBufferOwner() {
            _super.call(this);
            this._vaIdList = [];
            /** 顶点属性数据缓存字典 */
            this.vaBufferDic = {};
            /** 顶点数据长度字典 */
            this.data32PerVertexDic = {};
            /** 顶点数据字典 */
            this.vertexDataDic = {};
            /** 数据有效(与脏相反)标记字典 */
            this.dataValidDic = {};
            this.context3DBufferOwner = new feng3d.Context3DBufferOwner();
        }
        Object.defineProperty(VertexBufferOwner.prototype, "numVertices", {
            /**
             * 顶点个数
             */
            get: function () {
                return this._numVertices;
            },
            set: function (value) {
                if (this._numVertices != value) {
                    for (var key in this.vaBufferDic) {
                        if (this.vaBufferDic.hasOwnProperty(key)) {
                            var vaBuffer = this.vaBufferDic[key];
                            vaBuffer.invalid();
                        }
                    }
                }
                this._numVertices = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 注册顶点数据
         * @param dataTypeId
         * @param data32PerVertex
         */
        VertexBufferOwner.prototype.mapVABuffer = function (dataTypeId, data32PerVertex) {
            this.data32PerVertexDic[dataTypeId] = data32PerVertex;
            this.vertexDataDic[dataTypeId] = [];
            this._vaIdList.push(dataTypeId);
            this.vaBufferDic[dataTypeId] = this.context3DBufferOwner.mapContext3DBuffer(dataTypeId, this.updateVABuffer);
        };
        /**
         * 更新顶点数据缓冲
         * @param vaBuffer
         */
        VertexBufferOwner.prototype.updateVABuffer = function (vaBuffer) {
            var data32PerVertex = this.getVALen(vaBuffer.dataTypeId);
            var data = this.getVAData(vaBuffer.dataTypeId);
            vaBuffer.update(data, this.numVertices, data32PerVertex);
        };
        /**
         * 使顶点数据失效
         * @param dataTypeId
         */
        VertexBufferOwner.prototype.invalidVAData = function (dataTypeId) {
            this.dataValidDic[dataTypeId] = false;
            this.context3DBufferOwner.markBufferDirty(dataTypeId);
        };
        /**
         * 获取顶点属性长度(1-4)
         * @param dataTypeId 数据类型编号
         * @return 顶点属性长度
         */
        VertexBufferOwner.prototype.getVALen = function (dataTypeId) {
            return this.data32PerVertexDic[dataTypeId];
        };
        /**
         * 设置顶点属性数据
         * @param dataTypeId 数据类型编号
         * @param data 顶点属性数据
         */
        VertexBufferOwner.prototype.setVAData = function (dataTypeId, data) {
            var vaLen = this.getVALen(dataTypeId);
            feng3d.assert(data.length == this.numVertices * vaLen, "数据长度不对，更新数据之前需要给SubGeometry.numVertices赋值");
            this.vertexDataDic[dataTypeId] = data;
            this.context3DBufferOwner.markBufferDirty(dataTypeId);
            this.dataValidDic[dataTypeId] = true;
            this.notifyVADataChanged(dataTypeId);
        };
        /**
         * 获取顶点属性数据
         * @param dataTypeId 数据类型编号
         * @param needUpdate 是否需要更新数据
         * @return 顶点属性数据
         */
        VertexBufferOwner.prototype.getVAData = function (dataTypeId) {
            if (!this.dataValidDic[dataTypeId])
                this.updateVAdata(dataTypeId);
            this.dataValidDic[dataTypeId] = true;
            return this.vertexDataDic[dataTypeId];
        };
        /**
         * 通知数据发生变化<br/>
         * 通常会在setVAData后被调用<br/>
         * 处理某数据改变后对其他数据造成的影响<br/>
         * 比如顶点数据发生变化后法线、切线等数据就变得无效了
         * @param dataTypeId 数据类型编号
         */
        VertexBufferOwner.prototype.notifyVADataChanged = function (dataTypeId) {
        };
        /**
         * 更新顶点数据
         * @param dataTypeId 数据类型编号
         */
        VertexBufferOwner.prototype.updateVAdata = function (dataTypeId) {
        };
        Object.defineProperty(VertexBufferOwner.prototype, "vaIdList", {
            /** 顶点属性编号列表 */
            get: function () {
                return this._vaIdList;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(VertexBufferOwner.prototype, "_", {
            /**
             * Fagal编号中心
             */
            get: function () {
                return feng3d.FagalIdCenter.instance;
            },
            enumerable: true,
            configurable: true
        });
        return VertexBufferOwner;
    }(feng3d.Component));
    feng3d.VertexBufferOwner = VertexBufferOwner;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 动画数据
     * @author feng 2015-1-14
     */
    var AnimationSubGeometry = (function (_super) {
        __extends(AnimationSubGeometry, _super);
        /**
         * 创建一个动画数据
         */
        function AnimationSubGeometry() {
            _super.call(this);
        }
        return AnimationSubGeometry;
    }(feng3d.VertexBufferOwner));
    feng3d.AnimationSubGeometry = AnimationSubGeometry;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 获取几何体顶点数据时触发
     */
    //[Event(name = "getVAData", type = "me.feng3d.events.GeometryComponentEvent")]
    /**
     * 改变几何体顶点数据后触发
     */
    //[Event(name = "changedVAData", type = "me.feng3d.events.GeometryComponentEvent")]
    /**
     * 改变顶点索引数据后触发
     */
    //[Event(name = "changedIndexData", type = "me.feng3d.events.GeometryComponentEvent")]
    /**
     * 子几何体
     */
    var SubGeometry = (function (_super) {
        __extends(SubGeometry, _super);
        /**
         * 创建一个新几何体
         */
        function SubGeometry() {
            _super.call(this);
            this.initBuffers();
        }
        SubGeometry.prototype.initBuffers = function () {
            this.context3DBufferOwner.mapContext3DBuffer(this._.index, this.updateIndexBuffer);
            this.mapVABuffer(this._.position_va_3, 3);
            this.mapVABuffer(this._.uv_va_2, 2);
            this.mapVABuffer(this._.normal_va_3, 3);
            this.mapVABuffer(this._.tangent_va_3, 3);
        };
        /**
         * 更新索引数据
         * @param indexBuffer 索引缓存
         */
        SubGeometry.prototype.updateIndexBuffer = function (indexBuffer) {
            indexBuffer.update(this.indices, this.numIndices, this.numIndices);
        };
        Object.defineProperty(SubGeometry.prototype, "numTriangles", {
            /**
             * 可绘制三角形的个数
             */
            get: function () {
                return this._numTriangles;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 销毁
         */
        SubGeometry.prototype.dispose = function () {
            this._indices = null;
        };
        Object.defineProperty(SubGeometry.prototype, "indexData", {
            /**
             * 顶点索引数据
             */
            get: function () {
                if (this._indices == null)
                    this._indices = [];
                return this._indices;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SubGeometry.prototype, "numIndices", {
            /**
             * 索引数量
             */
            get: function () {
                return this._numIndices;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SubGeometry.prototype, "indices", {
            /**
             * 索引数据
             */
            get: function () {
                return this._indices;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 更新顶点索引数据
         */
        SubGeometry.prototype.updateIndexData = function (indices) {
            this._indices = indices;
            this._numIndices = indices.length;
            var numTriangles = this._numIndices / 3;
            this._numTriangles = numTriangles;
            this.context3DBufferOwner.markBufferDirty(this._.index);
            this.dispatchEvent(new feng3d.GeometryComponentEvent(feng3d.GeometryComponentEvent.CHANGED_INDEX_DATA));
        };
        SubGeometry.prototype.fromVectors = function (vertices, uvs) {
            this.updateVertexPositionData(vertices);
            this.updateUVData(uvs);
        };
        /**
         * 应用变换矩阵
         * @param transform 变换矩阵
         */
        SubGeometry.prototype.applyTransformation = function (transform) {
            var vertices = this.vertexPositionData;
            var normals = this.vertexNormalData;
            var tangents = this.vertexTangentData;
            var posStride = this.vertexPositionStride;
            var normalStride = this.vertexNormalStride;
            var tangentStride = this.vertexTangentStride;
            var len = vertices.length / posStride;
            var i, i1, i2;
            var vector = new feng3d.Vector3D();
            var bakeNormals = normals != null;
            var bakeTangents = tangents != null;
            var invTranspose;
            if (bakeNormals || bakeTangents) {
                invTranspose = transform.clone();
                invTranspose.invert();
                invTranspose.transpose();
            }
            var vi0 = 0;
            var ni0 = 0;
            var ti0 = 0;
            for (i = 0; i < len; ++i) {
                i1 = vi0 + 1;
                i2 = vi0 + 2;
                // bake position
                vector.x = vertices[vi0];
                vector.y = vertices[i1];
                vector.z = vertices[i2];
                vector = transform.transformVector(vector);
                vertices[vi0] = vector.x;
                vertices[i1] = vector.y;
                vertices[i2] = vector.z;
                vi0 += posStride;
                // bake normal
                if (bakeNormals) {
                    i1 = ni0 + 1;
                    i2 = ni0 + 2;
                    vector.x = normals[ni0];
                    vector.y = normals[i1];
                    vector.z = normals[i2];
                    vector = invTranspose.deltaTransformVector(vector);
                    vector.normalize();
                    normals[ni0] = vector.x;
                    normals[i1] = vector.y;
                    normals[i2] = vector.z;
                    ni0 += normalStride;
                }
                // bake tangent
                if (bakeTangents) {
                    i1 = ti0 + 1;
                    i2 = ti0 + 2;
                    vector.x = tangents[ti0];
                    vector.y = tangents[i1];
                    vector.z = tangents[i2];
                    vector = invTranspose.deltaTransformVector(vector);
                    vector.normalize();
                    tangents[ti0] = vector.x;
                    tangents[i1] = vector.y;
                    tangents[i2] = vector.z;
                    ti0 += tangentStride;
                }
            }
            this.context3DBufferOwner.markBufferDirty(this._.position_va_3);
            this.context3DBufferOwner.markBufferDirty(this._.normal_va_3);
            this.context3DBufferOwner.markBufferDirty(this._.tangent_va_3);
        };
        /**
         * 更新uv数据
         * @param data	uv数据
         */
        SubGeometry.prototype.updateUVData = function (data) {
            this.setVAData(this._.uv_va_2, data);
        };
        /**
         * 更新顶点数据
         */
        SubGeometry.prototype.updateVertexPositionData = function (data) {
            this.setVAData(this._.position_va_3, data);
            this.dispatchEvent(new feng3d.GeometryEvent(feng3d.GeometryEvent.SHAPE_CHANGE, this, true));
        };
        /**
         * 更新顶点法线数据
         * @param vertexNormals 顶点法线数据
         */
        SubGeometry.prototype.updateVertexNormalData = function (vertexNormals) {
            this.setVAData(this._.normal_va_3, vertexNormals);
        };
        /**
         * 更新顶点切线数据
         * @param vertexTangents 顶点切线数据
         */
        SubGeometry.prototype.updateVertexTangentData = function (vertexTangents) {
            this.setVAData(this._.tangent_va_3, vertexTangents);
        };
        Object.defineProperty(SubGeometry.prototype, "vertexPositionData", {
            /**
             * 顶点数据
             */
            get: function () {
                return this.getVAData(this._.position_va_3);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SubGeometry.prototype, "vertexNormalData", {
            /**
             * 顶点法线数据
             */
            get: function () {
                return this.getVAData(this._.normal_va_3);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SubGeometry.prototype, "vertexTangentData", {
            /**
             * 顶点切线数据
             */
            get: function () {
                return this.getVAData(this._.tangent_va_3);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SubGeometry.prototype, "UVData", {
            /**
             * uv数据
             */
            get: function () {
                return this.getVAData(this._.uv_va_2);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SubGeometry.prototype, "vertexPositionStride", {
            /**
             * 顶点坐标数据步长
             */
            get: function () {
                return this.getVALen(this._.position_va_3);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SubGeometry.prototype, "vertexTangentStride", {
            /**
             * 顶点切线步长
             */
            get: function () {
                return this.getVALen(this._.tangent_va_3);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SubGeometry.prototype, "vertexNormalStride", {
            /**
             * 顶点法线步长
             */
            get: function () {
                return this.getVALen(this._.normal_va_3);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SubGeometry.prototype, "UVStride", {
            /**
             * UV步长
             */
            get: function () {
                return this.getVALen(this._.uv_va_2);
            },
            enumerable: true,
            configurable: true
        });
        SubGeometry.prototype.notifyVADataChanged = function (dataTypeId) {
            _super.prototype.notifyVADataChanged.call(this, dataTypeId);
            this.dispatchEvent(new feng3d.GeometryComponentEvent(feng3d.GeometryComponentEvent.CHANGED_VA_DATA, dataTypeId));
        };
        SubGeometry.prototype.getVAData = function (dataTypeId) {
            this.dispatchEvent(new feng3d.GeometryComponentEvent(feng3d.GeometryComponentEvent.GET_VA_DATA, dataTypeId));
            return _super.prototype.getVAData.call(this, dataTypeId);
        };
        SubGeometry.prototype.clone = function () {
            var _this = this;
            var cls = feng3d.getDefinitionByName(feng3d.getQualifiedClassName(this));
            var _clone = new cls();
            //顶点属性编号列表
            var vaId;
            /** 顶点数据字典 */
            var sourceVertexDataDic = {};
            this.vaIdList.forEach(function (vaId) {
                sourceVertexDataDic[vaId] = _this.getVAData(vaId);
                feng3d.assert(sourceVertexDataDic[vaId].length == _this.getVALen(vaId) * _this.numVertices);
            });
            //添加索引数据
            _clone.updateIndexData(this.indices.concat());
            //更改顶点数量
            _clone.numVertices = this.numVertices;
            //添加顶点数据
            this.vaIdList.forEach(function (vaId) {
                _clone.setVAData(vaId, sourceVertexDataDic[vaId].concat());
            });
            return _clone;
        };
        Object.defineProperty(SubGeometry.prototype, "parent", {
            /**
             * 父网格
             */
            get: function () {
                return this._parent;
            },
            set: function (value) {
                this._parent = value;
            },
            enumerable: true,
            configurable: true
        });
        return SubGeometry;
    }(feng3d.VertexBufferOwner));
    feng3d.SubGeometry = SubGeometry;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 线段渲染数据缓存
     * @author feng 2014-5-9
     */
    var SegmentSubGeometry = (function (_super) {
        __extends(SegmentSubGeometry, _super);
        function SegmentSubGeometry() {
            _super.call(this);
        }
        SegmentSubGeometry.prototype.initBuffers = function () {
            _super.prototype.initBuffers.call(this);
            this.mapVABuffer(this._.segmentStart_va_3, 3);
            this.mapVABuffer(this._.segmentEnd_va_3, 3);
            this.mapVABuffer(this._.segmentThickness_va_1, 1);
            this.mapVABuffer(this._.segmentColor_va_4, 4);
        };
        Object.defineProperty(SegmentSubGeometry.prototype, "vertexPositionData", {
            get: function () {
                return this.pointData0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SegmentSubGeometry.prototype, "pointData0", {
            get: function () {
                var data = this.getVAData(this._.segmentStart_va_3);
                return data;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SegmentSubGeometry.prototype, "pointData1", {
            get: function () {
                var data = this.getVAData(this._.segmentEnd_va_3);
                return data;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SegmentSubGeometry.prototype, "thicknessData", {
            get: function () {
                var data = this.getVAData(this._.segmentThickness_va_1);
                return data;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SegmentSubGeometry.prototype, "colorData", {
            get: function () {
                var data = this.getVAData(this._.segmentColor_va_4);
                return data;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SegmentSubGeometry.prototype, "pointData0Stride", {
            get: function () {
                return 3;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SegmentSubGeometry.prototype, "pointData1Stride", {
            get: function () {
                return 3;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SegmentSubGeometry.prototype, "thicknessDataStride", {
            get: function () {
                return 1;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SegmentSubGeometry.prototype, "colorDataStride", {
            get: function () {
                return 4;
            },
            enumerable: true,
            configurable: true
        });
        SegmentSubGeometry.prototype.updatePointData0 = function (value) {
            this.setVAData(this._.segmentStart_va_3, value);
        };
        SegmentSubGeometry.prototype.updatePointData1 = function (value) {
            this.setVAData(this._.segmentEnd_va_3, value);
        };
        SegmentSubGeometry.prototype.updateThicknessData = function (value) {
            this.setVAData(this._.segmentThickness_va_1, value);
        };
        SegmentSubGeometry.prototype.updateColorData = function (value) {
            this.setVAData(this._.segmentColor_va_4, value);
        };
        return SegmentSubGeometry;
    }(feng3d.SubGeometry));
    feng3d.SegmentSubGeometry = SegmentSubGeometry;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 动画渲染参数
     * @author feng 2015-12-1
     */
    var AnimationShaderParams = (function (_super) {
        __extends(AnimationShaderParams, _super);
        /**
         * 动画渲染参数
         */
        function AnimationShaderParams() {
            _super.call(this);
        }
        AnimationShaderParams.prototype.init = function () {
            //
            this.numJoints = 0;
            this.animationType = feng3d.AnimationType.NONE;
            this.useUVAnimation = 0;
        };
        return AnimationShaderParams;
    }(feng3d.Component));
    feng3d.AnimationShaderParams = AnimationShaderParams;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 通用渲染参数
     * @author feng 2015-12-1
     */
    var CommonShaderParams = (function (_super) {
        __extends(CommonShaderParams, _super);
        /**
         * 通用渲染参数
         */
        function CommonShaderParams() {
            _super.call(this);
            this.alphaThreshold = 0;
        }
        /**
         * 初始化
         */
        CommonShaderParams.prototype.init = function () {
            this.hasDiffuseTexture = 0;
            this.needsUV = 0;
        };
        return CommonShaderParams;
    }(feng3d.Component));
    feng3d.CommonShaderParams = CommonShaderParams;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 环境渲染参数
     * @author feng 2015-12-1
     */
    var EnvShaderParams = (function (_super) {
        __extends(EnvShaderParams, _super);
        function EnvShaderParams() {
            _super.call(this);
        }
        return EnvShaderParams;
    }(feng3d.Component));
    feng3d.EnvShaderParams = EnvShaderParams;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 雾渲染参数
     * @author feng 2015-12-1
     */
    var FogShaderParams = (function (_super) {
        __extends(FogShaderParams, _super);
        /**
         * 雾渲染参数
         */
        function FogShaderParams() {
            _super.call(this);
        }
        /**
         * 初始化
         */
        FogShaderParams.prototype.init = function () {
            this.useFog = 0;
        };
        return FogShaderParams;
    }(feng3d.Component));
    feng3d.FogShaderParams = FogShaderParams;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 灯光渲染参数
     * @author feng 2015-12-1
     */
    var LightShaderParams = (function (_super) {
        __extends(LightShaderParams, _super);
        /**
         * 灯光渲染参数
         */
        function LightShaderParams() {
            _super.call(this);
            /** 是否使用灯光衰减 */
            this.useLightFallOff = true;
        }
        Object.defineProperty(LightShaderParams.prototype, "numDirectionalLights", {
            /** 方向光源数量 */
            get: function () {
                return this._numDirectionalLights;
            },
            /**
             * @private
             */
            set: function (value) {
                this._numDirectionalLights = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 初始化
         */
        LightShaderParams.prototype.init = function () {
            //
            this.numPointLights = 0;
            this.numDirectionalLights = 0;
            this.needsNormals = 0;
            this.needsViewDir = 0;
        };
        /**
         * 运行渲染程序前
         */
        LightShaderParams.prototype.preRun = function () {
            this.isFirstSpecLight = true;
            this.isFirstDiffLight = true;
        };
        Object.defineProperty(LightShaderParams.prototype, "numLights", {
            /** 灯光数量 */
            get: function () {
                return this.numPointLights + this.numDirectionalLights;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LightShaderParams.prototype, "needWorldPosition", {
            /** 是否需要世界坐标 */
            get: function () {
                return this.needsViewDir > 0 || this.numPointLights > 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LightShaderParams.prototype, "usesGlobalPosFragment", {
            /** 片段程序是否需要世界坐标 */
            get: function () {
                return this.numPointLights > 0;
            },
            enumerable: true,
            configurable: true
        });
        return LightShaderParams;
    }(feng3d.Component));
    feng3d.LightShaderParams = LightShaderParams;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 粒子渲染参数
     * @author feng 2015-12-1
     */
    var ParticleShaderParams = (function (_super) {
        __extends(ParticleShaderParams, _super);
        /**
         * 粒子渲染参数
         */
        function ParticleShaderParams() {
            _super.call(this);
        }
        /**
         * 初始化
         */
        ParticleShaderParams.prototype.init = function () {
            //
            this.changePosition = 0;
            this.changeColor = 0;
        };
        return ParticleShaderParams;
    }(feng3d.Component));
    feng3d.ParticleShaderParams = ParticleShaderParams;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 渲染参数
     * <p>? 是否需要限定组件为ShaderParamsComponent</p>
     * @author feng 2014-11-4
     */
    var ShaderParams = (function (_super) {
        __extends(ShaderParams, _super);
        /**
         * 创建一个渲染参数
         */
        function ShaderParams() {
            _super.call(this);
            this.addEventListener(feng3d.ComponentEvent.ADDED_COMPONET, this.onAddedComponet);
        }
        ShaderParams.prototype.onAddedComponet = function (event) {
            var shaderParam = event.data.child;
            if (shaderParam.hasOwnProperty("this.init")) {
                shaderParam["this.init"]();
            }
            if (shaderParam.hasOwnProperty("this.preRun")) {
                shaderParam["this.preRun"]();
            }
        };
        /**
         * 初始化渲染参数
         */
        ShaderParams.prototype.initParams = function () {
            this.init();
            this.components.forEach(function (shaderParam) {
                if (shaderParam.hasOwnProperty("this.init")) {
                    shaderParam["this.init"]();
                }
            });
        };
        /**
         * 渲染前初始化
         */
        ShaderParams.prototype.preRunParams = function () {
            this.preRun();
            this.components.forEach(function (shaderParam) {
                if (shaderParam.hasOwnProperty("this.preRun")) {
                    shaderParam["this.preRun"]();
                }
            });
        };
        /**
         * 初始化
         */
        ShaderParams.prototype.init = function () {
            this.sampleFlagsDic = {};
        };
        /**
         * 运行渲染程序前
         */
        ShaderParams.prototype.preRun = function () {
        };
        /**
         * 添加纹理取样参数
         * @param dataTypeId		纹理数据缓冲类型编号
         * @param texture			纹理代理
         * @param forceWrap			强制重复纹理参数
         */
        ShaderParams.prototype.addSampleFlags = function (dataTypeId, texture, forceWrap) {
            if (forceWrap === void 0) { forceWrap = null; }
            this.sampleFlagsDic[dataTypeId] = null;
            if (texture) {
                var flags = feng3d.TextureUtils.getFlags(this.useMipmapping, this.useSmoothTextures, this.repeatTextures, texture, forceWrap);
                this.sampleFlagsDic[dataTypeId] = flags;
            }
        };
        /**
         * 设置取样标记
         * @param dataTypeId		纹理数据缓冲类型编号
         * @param flags				纹理取样标记
         */
        ShaderParams.prototype.setSampleFlags = function (dataTypeId, flags) {
            this.sampleFlagsDic[dataTypeId] = flags;
        };
        /**
         * 获取取样标记
         * @param dataTypeId		纹理数据缓冲类型编号
         * @return					纹理取样标记
         */
        ShaderParams.prototype.getFlags = function (dataTypeId) {
            return this.sampleFlagsDic[dataTypeId];
        };
        return ShaderParams;
    }(feng3d.Component));
    feng3d.ShaderParams = ShaderParams;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 阴影渲染参数
     * @author feng 2015-12-1
     */
    var ShadowShaderParams = (function (_super) {
        __extends(ShadowShaderParams, _super);
        /**
         * 阴影渲染参数
         */
        function ShadowShaderParams() {
            _super.call(this);
        }
        /**
         * 初始化
         */
        ShadowShaderParams.prototype.init = function () {
            this.usingShadowMapMethod = 0;
            this.usePoint = 0;
            this.needsProjection = 0;
            this.useNearShadowMap = 0;
            this.needsShadowRegister = 0;
        };
        return ShadowShaderParams;
    }(feng3d.Component));
    feng3d.ShadowShaderParams = ShadowShaderParams;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 地形渲染参数
     * @author feng 2015-12-1
     */
    var TerrainShaderParams = (function (_super) {
        __extends(TerrainShaderParams, _super);
        /**
         * 地形渲染参数
         */
        function TerrainShaderParams() {
            _super.call(this);
        }
        /**
         * 初始化
         */
        TerrainShaderParams.prototype.init = function () {
            //
            this.splatNum = 0;
        };
        return TerrainShaderParams;
    }(feng3d.Component));
    feng3d.TerrainShaderParams = TerrainShaderParams;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 灯光采集器
     * @author feng 2014-9-11
     */
    var LightPickerBase = (function (_super) {
        __extends(LightPickerBase, _super);
        function LightPickerBase() {
            _super.call(this);
            this._namedAsset = new feng3d.NamedAsset(this, feng3d.AssetType.CONTAINER);
        }
        Object.defineProperty(LightPickerBase.prototype, "assetType", {
            get: function () {
                return feng3d.AssetType.LIGHT_PICKER;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LightPickerBase.prototype, "numDirectionalLights", {
            /**
             * 方向光数量
             */
            get: function () {
                return this._numDirectionalLights;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LightPickerBase.prototype, "numPointLights", {
            /**
             * 点光源数量
             */
            get: function () {
                return this._numPointLights;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LightPickerBase.prototype, "pointLights", {
            /**
             * 点光源列表
             */
            get: function () {
                return this._pointLights;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LightPickerBase.prototype, "directionalLights", {
            /**
             * 方向光列表
             */
            get: function () {
                return this._directionalLights;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LightPickerBase.prototype, "allPickedLights", {
            /**
             * A collection of all the collected lights.
             */
            get: function () {
                return this._allPickedLights;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LightPickerBase.prototype, "namedAsset", {
            get: function () {
                return this._namedAsset;
            },
            enumerable: true,
            configurable: true
        });
        return LightPickerBase;
    }(feng3d.Component));
    feng3d.LightPickerBase = LightPickerBase;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 灯光采集器
     * @author feng 2014-9-11
     */
    var StaticLightPicker = (function (_super) {
        __extends(StaticLightPicker, _super);
        function StaticLightPicker(lights) {
            _super.call(this);
            this.lights = lights;
        }
        Object.defineProperty(StaticLightPicker.prototype, "lights", {
            /**
             * 需要渲染的灯光
             */
            get: function () {
                return this._lights;
            },
            set: function (value) {
                var numPointLights = 0;
                var numDirectionalLights = 0;
                var light;
                this._lights = value;
                this._directionalLights = [];
                this._pointLights = [];
                //灯光分类
                var len = value.length;
                for (var i = 0; i < len; ++i) {
                    light = value[i];
                    if (feng3d.is(light, feng3d.PointLight)) {
                        this._pointLights[numPointLights++] = feng3d.as(light, feng3d.PointLight);
                    }
                    else if (feng3d.is(light, feng3d.DirectionalLight)) {
                        this._directionalLights[numDirectionalLights++] = feng3d.as(light, feng3d.DirectionalLight);
                    }
                }
                this._numDirectionalLights = numDirectionalLights;
                this._numPointLights = numPointLights;
                this.dispatchEvent(new feng3d.Event(feng3d.Event.CHANGE));
            },
            enumerable: true,
            configurable: true
        });
        return StaticLightPicker;
    }(feng3d.LightPickerBase));
    feng3d.StaticLightPicker = StaticLightPicker;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 渲染函数设置
     * @author feng 2014-7-1
     */
    var ShaderMethodSetup = (function (_super) {
        __extends(ShaderMethodSetup, _super);
        /**
         * 创建一个渲染函数设置
         */
        function ShaderMethodSetup() {
            _super.call(this);
            this.context3DBufferOwner = new feng3d.Context3DBufferOwner();
            this.initBuffers();
            this.uniqueMethodDic = {};
            this.methods = [];
            this.addMethod(new feng3d.BasicNormalMethod());
            this.addMethod(new feng3d.BasicAmbientMethod());
            this.addMethod(new feng3d.BasicDiffuseMethod());
            this.addMethod(new feng3d.BasicSpecularMethod());
        }
        /**
         * 初始化Context3d缓存
         */
        ShaderMethodSetup.prototype.initBuffers = function () {
        };
        Object.defineProperty(ShaderMethodSetup.prototype, "_", {
            /**
             * Fagal编号中心
             */
            get: function () {
                return feng3d.FagalIdCenter.instance;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ShaderMethodSetup.prototype, "numMethods", {
            /**
             * The number of "effect" methods added to the material.
             */
            get: function () {
                return this.methods.length;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ShaderMethodSetup.prototype, "diffuseMethod", {
            /**
             * 漫反射函数
             */
            get: function () {
                return this.uniqueMethodDic[feng3d.BasicDiffuseMethod.METHOD_TYPE];
            },
            set: function (value) {
                this.addUniqueMethod(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ShaderMethodSetup.prototype, "specularMethod", {
            /**
             * 镜面反射函数
             */
            get: function () {
                return this.uniqueMethodDic[feng3d.BasicSpecularMethod.METHOD_TYPE];
            },
            set: function (value) {
                this.addUniqueMethod(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ShaderMethodSetup.prototype, "normalMethod", {
            /**
             * 法线函数
             */
            get: function () {
                return this.uniqueMethodDic[feng3d.BasicNormalMethod.METHOD_TYPE];
            },
            set: function (value) {
                this.addUniqueMethod(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ShaderMethodSetup.prototype, "ambientMethod", {
            /**
             * 漫反射函数
             */
            get: function () {
                return this.uniqueMethodDic[feng3d.BasicAmbientMethod.METHOD_TYPE];
            },
            set: function (value) {
                this.addUniqueMethod(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ShaderMethodSetup.prototype, "shadowMethod", {
            /**
             * 阴影映射函数
             */
            get: function () {
                return this.uniqueMethodDic[feng3d.ShadowMapMethodBase.METHOD_TYPE];
            },
            set: function (value) {
                this.addUniqueMethod(value);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 通知渲染程序失效
         */
        ShaderMethodSetup.prototype.invalidateShaderProgram = function () {
            this.dispatchEvent(new feng3d.ShadingMethodEvent(feng3d.ShadingMethodEvent.SHADER_INVALIDATED));
        };
        /**
         * 渲染程序失效事件处理函数
         */
        ShaderMethodSetup.prototype.onShaderInvalidated = function (event) {
            this.invalidateShaderProgram();
        };
        /**
         * 添加渲染函数
         * @param method			渲染函数
         */
        ShaderMethodSetup.prototype.addMethod = function (method) {
            if (method.typeUnique) {
                this.addUniqueMethod(method);
            }
            else {
                this.$addMethod(method);
            }
        };
        /**
         * 移除渲染函数
         * @param method			渲染函数
         */
        ShaderMethodSetup.prototype.removeMethod = function (method) {
            if (method.typeUnique) {
                this.removeUniqueMethod(method);
            }
            else {
                this.$removeMethod(method);
            }
        };
        /**
         * 添加唯一渲染函数
         * @param method			渲染函数
         */
        ShaderMethodSetup.prototype.addUniqueMethod = function (method) {
            var oldMethod = this.uniqueMethodDic[method.methodType];
            if (oldMethod != null) {
                method.copyFrom(oldMethod);
                this.$removeMethod(oldMethod);
            }
            this.$addMethod(method);
            this.uniqueMethodDic[method.methodType] = method;
            this.invalidateShaderProgram();
        };
        /**
         * 移除唯一渲染函数
         * @param method			渲染函数
         */
        ShaderMethodSetup.prototype.removeUniqueMethod = function (method) {
            this.$removeMethod(method);
            this.uniqueMethodDic[method.methodType] = null;
        };
        /**
         * 添加函数
         * @param method			渲染函数
         */
        ShaderMethodSetup.prototype.$addMethod = function (method) {
            method.addEventListener(feng3d.ShadingMethodEvent.SHADER_INVALIDATED, this.onShaderInvalidated);
            this.context3DBufferOwner.addChildBufferOwner(method.context3DBufferOwner);
            this.methods.push(method);
            this.invalidateShaderProgram();
        };
        /**
         * 删除函数
         * @param method			渲染函数
         */
        ShaderMethodSetup.prototype.$removeMethod = function (method) {
            method.removeEventListener(feng3d.ShadingMethodEvent.SHADER_INVALIDATED, this.onShaderInvalidated);
            this.context3DBufferOwner.removeChildBufferOwner(method.context3DBufferOwner);
            var index = this.methods.indexOf(method);
            this.methods.splice(index, 1);
            this.invalidateShaderProgram();
        };
        /**
         * 设置渲染状态
         * @param renderable		可渲染对象
         * @param stage3DProxy		3D舞台代理
         * @param camera			摄像机
         */
        ShaderMethodSetup.prototype.setRenderState = function (renderable, camera) {
            for (var i = 0; i < this.methods.length; i++) {
                this.methods[i].setRenderState(renderable, camera);
            }
        };
        /**
         * 激活
         * @param shaderParams		渲染参数
         * @param stage3DProxy		3D舞台代理
         */
        ShaderMethodSetup.prototype.activate = function (shaderParams) {
            for (var i = 0; i < this.methods.length; i++) {
                this.methods[i].activate(shaderParams);
            }
        };
        /**
         * 初始化常量数据
         */
        ShaderMethodSetup.prototype.initConstants = function () {
            for (var i = 0; i < this.methods.length; i++) {
                this.methods[i].initConstants();
            }
        };
        return ShaderMethodSetup;
    }(feng3d.Component));
    feng3d.ShaderMethodSetup = ShaderMethodSetup;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 渲染函数基类
     * @author feng 2014-7-1
     */
    var ShadingMethodBase = (function (_super) {
        __extends(ShadingMethodBase, _super);
        /**
         * 创建渲染寄函数基类
         */
        function ShadingMethodBase() {
            _super.call(this);
            /**
             * 是否唯一
             * <p>值为true时一个pass只能包含一个该类型函数，否则允许多个</p>
             * @see #methodType
             */
            this.typeUnique = false;
            this.context3DBufferOwner = new feng3d.Context3DBufferOwner();
            this.initBuffers();
        }
        /**
         * 初始化Context3d缓存
         */
        ShadingMethodBase.prototype.initBuffers = function () {
        };
        Object.defineProperty(ShadingMethodBase.prototype, "_", {
            /**
             * Fagal编号中心
             */
            get: function () {
                return feng3d.FagalIdCenter.instance;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 激活渲染函数
         * @param shaderParams 		渲染参数
         */
        ShadingMethodBase.prototype.activate = function (shaderParams) {
        };
        /**
         * 设置渲染状态
         * @param renderable 		渲染对象
         * @param camera 			摄像机
         */
        ShadingMethodBase.prototype.setRenderState = function (renderable, camera) {
        };
        /**
         * 初始化常量数据
         */
        ShadingMethodBase.prototype.initConstants = function () {
        };
        /**
         * 清除编译数据
         */
        ShadingMethodBase.prototype.cleanCompilationData = function () {
        };
        /**
         * 使渲染程序失效
         */
        ShadingMethodBase.prototype.invalidateShaderProgram = function () {
            this.dispatchEvent(new feng3d.ShadingMethodEvent(feng3d.ShadingMethodEvent.SHADER_INVALIDATED));
        };
        /**
         * 拷贝渲染方法
         * @param method		被拷贝的方法
         */
        ShadingMethodBase.prototype.copyFrom = function (method) {
        };
        Object.defineProperty(ShadingMethodBase.prototype, "passes", {
            /**
             * Any passes required that render to a texture used by this method.
             */
            get: function () {
                return this._passes;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Cleans up any resources used by the current object.
         */
        ShadingMethodBase.prototype.dispose = function () {
        };
        return ShadingMethodBase;
    }(feng3d.Component));
    feng3d.ShadingMethodBase = ShadingMethodBase;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 环境光函数
     *
     * 参考《3d数学基础：图形与游戏开发》337页，15.4.6 环境光分量
     * Camb = Gamb X Mamb
     * Camb：环境光分量。
     * Gamb：整个场景的环境光值。
     * Mamb：材质的环境光分量。它总是等于漫反射分量——由纹理图定义。
     *
     * @author feng 2014-7-1
     */
    var BasicAmbientMethod = (function (_super) {
        __extends(BasicAmbientMethod, _super);
        /**
         * 创建一个基础环境光函数
         */
        function BasicAmbientMethod() {
            _super.call(this);
            this._ambientColor = 0xffffff;
            this._ambient = 1;
            this._lightAmbientR = 0;
            this._lightAmbientG = 0;
            this._lightAmbientB = 0;
            /** 环境光分量数据 */
            this.ambientColorData = [0, 0, 0, 0];
            this.methodType = BasicAmbientMethod.METHOD_TYPE;
            this.typeUnique = true;
        }
        /**
         * @inheritDoc
         */
        BasicAmbientMethod.prototype.initBuffers = function () {
            _super.prototype.initBuffers.call(this);
            this.context3DBufferOwner.mapContext3DBuffer(this._.ambientColor_fc_vector, this.updateAmbientInputBuffer);
            this.context3DBufferOwner.mapContext3DBuffer(this._.ambientTexture_fs, this.updateSpecularTextureBuffer);
        };
        BasicAmbientMethod.prototype.updateAmbientInputBuffer = function (ambientInputBuffer) {
            ambientInputBuffer.update(this.ambientColorData);
        };
        BasicAmbientMethod.prototype.updateSpecularTextureBuffer = function (fsBuffer) {
            fsBuffer.update(this.texture);
        };
        /**
         * 更新环境光数据
         */
        BasicAmbientMethod.prototype.updateAmbient = function () {
            this.ambientColorData[0] = ((this._ambientColor >> 16) & 0xff) / 0xff * this._ambient * this._lightAmbientR;
            this.ambientColorData[1] = ((this._ambientColor >> 8) & 0xff) / 0xff * this._ambient * this._lightAmbientG;
            this.ambientColorData[2] = (this._ambientColor & 0xff) / 0xff * this._ambient * this._lightAmbientB;
            this.ambientColorData[3] = 1;
        };
        /**
         * @inheritDoc
         */
        BasicAmbientMethod.prototype.setRenderState = function (renderable, camera) {
            this.updateAmbient();
        };
        Object.defineProperty(BasicAmbientMethod.prototype, "ambient", {
            /**
             * 环境光强
             */
            get: function () {
                return this._ambient;
            },
            set: function (value) {
                this._ambient = value;
                this.updateAmbient();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BasicAmbientMethod.prototype, "ambientColor", {
            /**
             * 环境光颜色
             */
            get: function () {
                return this._ambientColor;
            },
            set: function (value) {
                this._ambientColor = value;
                this.updateAmbient();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BasicAmbientMethod.prototype, "texture", {
            /**
             * The bitmapData to use to define the diffuse reflection color per texel.
             */
            get: function () {
                return this._texture;
            },
            set: function (value) {
                if ((value != null) != this._useTexture || (value && this._texture && (value.hasMipMaps != this._texture.hasMipMaps || value.format != this._texture.format))) {
                    this.invalidateShaderProgram();
                }
                this._useTexture = (value != null);
                this._texture = value;
                this.context3DBufferOwner.markBufferDirty(this._.ambientTexture_fs);
            },
            enumerable: true,
            configurable: true
        });
        BasicAmbientMethod.prototype.activate = function (shaderParams) {
            if (this.texture != null) {
                var commonShaderParams = shaderParams.getOrCreateComponentByClass(feng3d.CommonShaderParams);
                commonShaderParams.needsUV++;
                commonShaderParams.useAmbientTexture++;
                shaderParams.addSampleFlags(this._.ambientTexture_fs, this.texture);
            }
        };
        BasicAmbientMethod.prototype.copyFrom = function (method) {
            var diff = feng3d.as(method, BasicAmbientMethod);
            this.ambient = diff.ambient;
            this.ambientColor = diff.ambientColor;
        };
        BasicAmbientMethod.METHOD_TYPE = "AmbientMethod";
        return BasicAmbientMethod;
    }(feng3d.ShadingMethodBase));
    feng3d.BasicAmbientMethod = BasicAmbientMethod;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 基础法线函数
     * @author feng 2014-7-16
     */
    var BasicNormalMethod = (function (_super) {
        __extends(BasicNormalMethod, _super);
        /**
         * 创建一个基础法线函数
         */
        function BasicNormalMethod() {
            _super.call(this);
            this.methodType = BasicNormalMethod.METHOD_TYPE;
            this.typeUnique = true;
        }
        /**
         * @inheritDoc
         */
        BasicNormalMethod.prototype.initBuffers = function () {
            _super.prototype.initBuffers.call(this);
            this.context3DBufferOwner.mapContext3DBuffer(this._.normalTexture_fs, this.updateNormalTextureBuffer);
        };
        BasicNormalMethod.prototype.updateNormalTextureBuffer = function (normalTextureBuffer) {
            normalTextureBuffer.update(this._texture);
        };
        Object.defineProperty(BasicNormalMethod.prototype, "normalMap", {
            /**
             * The texture containing the normals per pixel.
             */
            get: function () {
                return this._texture;
            },
            set: function (value) {
                if ((value != null) != (this._texture != null) ||
                    (value && this._texture && (value.hasMipMaps != this._texture.hasMipMaps || value.format != this._texture.format))) {
                    this.invalidateShaderProgram();
                }
                this._texture = value;
                this.context3DBufferOwner.markBufferDirty(this._.normalTexture_fs);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BasicNormalMethod.prototype, "hasOutput", {
            /**
             * Indicates if the normal method output is not based on a texture (if not, it will usually always return true)
             * Override if subclasses are different.
             */
            get: function () {
                return (this._texture != null);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        BasicNormalMethod.prototype.copyFrom = function (method) {
            this.normalMap = feng3d.as(method, BasicNormalMethod).normalMap;
        };
        BasicNormalMethod.prototype.activate = function (shaderParams) {
            var lightShaderParams = shaderParams.getOrCreateComponentByClass(feng3d.LightShaderParams);
            lightShaderParams.hasNormalTexture = this._texture != null;
            shaderParams.addSampleFlags(this._.normalTexture_fs, this._texture);
        };
        BasicNormalMethod.METHOD_TYPE = "NormalMethod";
        return BasicNormalMethod;
    }(feng3d.ShadingMethodBase));
    feng3d.BasicNormalMethod = BasicNormalMethod;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 特效函数基类
     * @author feng 2015-8-27
     */
    var EffectMethodBase = (function (_super) {
        __extends(EffectMethodBase, _super);
        /**
         * 创建特效函数基类实例
         */
        function EffectMethodBase() {
            _super.call(this);
            this._namedAsset = new feng3d.NamedAsset(this, feng3d.AssetType.EFFECTS_METHOD);
        }
        Object.defineProperty(EffectMethodBase.prototype, "namedAsset", {
            get: function () {
                return this._namedAsset;
            },
            enumerable: true,
            configurable: true
        });
        return EffectMethodBase;
    }(feng3d.ShadingMethodBase));
    feng3d.EffectMethodBase = EffectMethodBase;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 环境映射函数
     * @author feng 2015-8-27
     */
    var EnvMapMethod = (function (_super) {
        __extends(EnvMapMethod, _super);
        /**
         * 创建EnvMapMethod实例
         * @param envMap		环境映射贴图
         * @param alpha			反射率
         */
        function EnvMapMethod(envMap, alpha) {
            if (alpha === void 0) { alpha = 1; }
            _super.call(this);
            this._envMapData = [1, 0, 0, 0];
            this._cubeTexture = envMap;
            this.alpha = alpha;
        }
        Object.defineProperty(EnvMapMethod.prototype, "mask", {
            /**
             * 用来调节反射率的纹理
             */
            get: function () {
                return this._mask;
            },
            set: function (value) {
                if ((value != null) != (this._mask != null) || (value && this._mask && (value.hasMipMaps != this._mask.hasMipMaps || value.format != this._mask.format))) {
                    this.invalidateShaderProgram();
                }
                this._mask = value;
                this.context3DBufferOwner.markBufferDirty(this._.envMapMaskTexture_fs);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EnvMapMethod.prototype, "envMap", {
            /**
             * 环境映射贴图
             */
            get: function () {
                return this._cubeTexture;
            },
            set: function (value) {
                this._cubeTexture = value;
                this.context3DBufferOwner.markBufferDirty(this._.envMapcubeTexture_fs);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EnvMapMethod.prototype, "alpha", {
            /**
             * 反射率
             */
            get: function () {
                return this._alpha;
            },
            set: function (value) {
                this._alpha = value;
                this._envMapData[0] = this._alpha;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        EnvMapMethod.prototype.initBuffers = function () {
            _super.prototype.initBuffers.call(this);
            this.context3DBufferOwner.mapContext3DBuffer(this._.envMapcubeTexture_fs, this.updateCubeTextureBuffer);
            this.context3DBufferOwner.mapContext3DBuffer(this._.envMapMaskTexture_fs, this.updateMaskTextureBuffer);
            this.context3DBufferOwner.mapContext3DBuffer(this._.envMapData_fc_vector, this.updateDataBuffer);
        };
        EnvMapMethod.prototype.updateCubeTextureBuffer = function (fsBuffer) {
            fsBuffer.update(this._cubeTexture);
        };
        EnvMapMethod.prototype.updateMaskTextureBuffer = function (fsBuffer) {
            fsBuffer.update(this._mask);
        };
        EnvMapMethod.prototype.updateDataBuffer = function (fcVectorBuffer) {
            fcVectorBuffer.update(this._envMapData);
        };
        /**
         * @inheritDoc
         */
        EnvMapMethod.prototype.activate = function (shaderParams) {
            var commonShaderParams = shaderParams.getOrCreateComponentByClass(feng3d.CommonShaderParams);
            if (this._mask != null)
                commonShaderParams.needsUV += 1;
            var lightShaderParams = shaderParams.getOrCreateComponentByClass(feng3d.LightShaderParams);
            lightShaderParams.needsNormals++;
            lightShaderParams.needsViewDir++;
            //			shaderParams.needsView = true;
            var envShaderParams = shaderParams.getOrCreateComponentByClass(feng3d.EnvShaderParams);
            envShaderParams.useEnvMapMethod++;
            if (this._mask != null)
                envShaderParams.useEnvMapMask += 1;
            shaderParams.addSampleFlags(this._.envMapcubeTexture_fs, this._cubeTexture);
            shaderParams.addSampleFlags(this._.envMapMaskTexture_fs, this._mask);
            //			var context:Context3D = stage3DProxy._context3D;
            //			vo.fragmentData[vo.fragmentConstantsIndex] = this._alpha;
            //			context.setTextureAt(vo.texturesIndex, this._cubeTexture.getTextureForStage3D(stage3DProxy));
            //			if (this._mask)
            //				context.setTextureAt(vo.texturesIndex + 1, this._mask.getTextureForStage3D(stage3DProxy));
        };
        return EnvMapMethod;
    }(feng3d.EffectMethodBase));
    feng3d.EnvMapMethod = EnvMapMethod;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 雾函数
     * @author feng 2015-8-27
     */
    var FogMethod = (function (_super) {
        __extends(FogMethod, _super);
        /**
         * 创建FogMethod实例
         * @param minDistance			出现雾效果的最近距离
         * @param maxDistance			最远距离
         * @param fogColor				雾的颜色
         */
        function FogMethod(minDistance, maxDistance, fogColor) {
            if (fogColor === void 0) { fogColor = 0x808080; }
            _super.call(this);
            this._minDistance = 0;
            this._maxDistance = 1000;
            /**
             * 雾颜色常量数据
             */
            this.fogColorData = [0, 0, 0, 1];
            /**
             * 雾通用常量数据
             */
            this.fogCommonData = [0, 0, 0, 0];
            this.minDistance = minDistance;
            this.maxDistance = maxDistance;
            this.fogColor = fogColor;
        }
        Object.defineProperty(FogMethod.prototype, "minDistance", {
            /**
             * 出现雾效果的最近距离
             */
            get: function () {
                return this._minDistance;
            },
            set: function (value) {
                this._minDistance = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FogMethod.prototype, "maxDistance", {
            /**
             * 最远距离
             */
            get: function () {
                return this._maxDistance;
            },
            set: function (value) {
                this._maxDistance = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FogMethod.prototype, "fogColor", {
            /**
             * 雾的颜色
             */
            get: function () {
                return this._fogColor;
            },
            set: function (value) {
                this._fogColor = value;
                this.fogColorData[0] = ((value >> 16) & 0xff) / 0xff;
                this.fogColorData[1] = ((value >> 8) & 0xff) / 0xff;
                this.fogColorData[2] = (value & 0xff) / 0xff;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        FogMethod.prototype.initBuffers = function () {
            _super.prototype.initBuffers.call(this);
            this.context3DBufferOwner.mapContext3DBuffer(this._.fogColor_fc_vector, this.updateFogColorBuffer);
            this.context3DBufferOwner.mapContext3DBuffer(this._.fogCommonData_fc_vector, this.updateFogCommonDataBuffer);
        };
        /**
         * 更新雾颜色常量数据
         */
        FogMethod.prototype.updateFogColorBuffer = function (fcVectorBuffer) {
            fcVectorBuffer.update(this.fogColorData);
        };
        /**
         * 更新雾通用常量数据
         */
        FogMethod.prototype.updateFogCommonDataBuffer = function (fcVectorBuffer) {
            fcVectorBuffer.update(this.fogCommonData);
        };
        /**
         * @inheritDoc
         */
        FogMethod.prototype.activate = function (shaderParams) {
            this.fogCommonData[0] = this._minDistance;
            this.fogCommonData[1] = 1 / (this._maxDistance - this._minDistance);
            var fogShaderParams = shaderParams.getOrCreateComponentByClass(feng3d.FogShaderParams);
            fogShaderParams.useFog++;
            var shadowShaderParams = shaderParams.getOrCreateComponentByClass(feng3d.ShadowShaderParams);
            shadowShaderParams.needsProjection++;
        };
        return FogMethod;
    }(feng3d.EffectMethodBase));
    feng3d.FogMethod = FogMethod;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 灯光函数
     * @author feng 2014-7-1
     */
    var LightingMethodBase = (function (_super) {
        __extends(LightingMethodBase, _super);
        function LightingMethodBase() {
            _super.apply(this, arguments);
        }
        return LightingMethodBase;
    }(feng3d.ShadingMethodBase));
    feng3d.LightingMethodBase = LightingMethodBase;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 基础漫反射函数
     * @author feng 2014-7-1
     */
    var BasicDiffuseMethod = (function (_super) {
        __extends(BasicDiffuseMethod, _super);
        /**
         * 创建一个基础漫反射函数
         */
        function BasicDiffuseMethod() {
            _super.call(this);
            this._diffuseColor = 0xffffff;
            /** 漫反射颜色数据RGBA */
            this.diffuseInputData = [0, 0, 0, 0];
            this.alphaThresholdData = [0, 0, 0, 0];
            this._alphaThreshold = 0;
            this.methodType = BasicDiffuseMethod.METHOD_TYPE;
            this.typeUnique = true;
        }
        /**
         * @inheritDoc
         */
        BasicDiffuseMethod.prototype.initBuffers = function () {
            _super.prototype.initBuffers.call(this);
            this.context3DBufferOwner.mapContext3DBuffer(this._.texture_fs, this.updateTextureBuffer);
            this.context3DBufferOwner.mapContext3DBuffer(this._.diffuseInput_fc_vector, this.updateDiffuseInputBuffer);
            this.context3DBufferOwner.mapContext3DBuffer(this._.alphaThreshold_fc_vector, this.updateAlphaThresholdBuffer);
        };
        Object.defineProperty(BasicDiffuseMethod.prototype, "diffuseColor", {
            /** 漫反射颜色 */
            get: function () {
                return this._diffuseColor;
            },
            set: function (diffuseColor) {
                this._diffuseColor = diffuseColor;
                this.updateDiffuse();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 更新漫反射值
         */
        BasicDiffuseMethod.prototype.updateDiffuse = function () {
            this.diffuseInputData[0] = ((this._diffuseColor >> 16) & 0xff) / 0xff;
            this.diffuseInputData[1] = ((this._diffuseColor >> 8) & 0xff) / 0xff;
            this.diffuseInputData[2] = (this._diffuseColor & 0xff) / 0xff;
        };
        Object.defineProperty(BasicDiffuseMethod.prototype, "diffuseAlpha", {
            /** 漫反射alpha */
            get: function () {
                return this.diffuseInputData[3];
            },
            set: function (value) {
                this.diffuseInputData[3] = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 更新纹理缓冲
         */
        BasicDiffuseMethod.prototype.updateTextureBuffer = function (textureBuffer) {
            textureBuffer.update(this.texture);
        };
        /**
         * 更新漫反射输入片段常量缓冲
         */
        BasicDiffuseMethod.prototype.updateDiffuseInputBuffer = function (diffuseInputBuffer) {
            diffuseInputBuffer.update(this.diffuseInputData);
        };
        BasicDiffuseMethod.prototype.updateAlphaThresholdBuffer = function (fcVectorBuffer) {
            fcVectorBuffer.update(this.alphaThresholdData);
        };
        Object.defineProperty(BasicDiffuseMethod.prototype, "texture", {
            /**
             * 漫反射纹理
             */
            get: function () {
                return this._texture;
            },
            set: function (value) {
                if ((value != null) != (this._texture != null) || (value && this._texture && (value.hasMipMaps != this._texture.hasMipMaps || value.format != this._texture.format))) {
                    this.invalidateShaderProgram();
                }
                this._texture = value;
                this.context3DBufferOwner.markBufferDirty(this._.texture_fs);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BasicDiffuseMethod.prototype, "alphaThreshold", {
            /**
             * The minimum alpha value for which pixels should be drawn. This is used for transparency that is either
             * invisible or entirely opaque, often used with textures for foliage, etc.
             * Recommended values are 0 to disable alpha, or 0.5 to create smooth edges. Default value is 0 (disabled).
             */
            get: function () {
                return this._alphaThreshold;
            },
            set: function (value) {
                if (value < 0)
                    value = 0;
                else if (value > 1)
                    value = 1;
                if (value == this._alphaThreshold)
                    return;
                if (value == 0 || this._alphaThreshold == 0)
                    this.invalidateShaderProgram();
                this._alphaThreshold = value;
                this.alphaThresholdData[0] = this._alphaThreshold;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        BasicDiffuseMethod.prototype.activate = function (shaderParams) {
            var commonShaderParams = shaderParams.getOrCreateComponentByClass(feng3d.CommonShaderParams);
            if (this.texture != null) {
                commonShaderParams.needsUV++;
                commonShaderParams.hasDiffuseTexture++;
                shaderParams.addSampleFlags(this._.texture_fs, this.texture);
            }
            commonShaderParams.usingDiffuseMethod += 1;
            commonShaderParams.alphaThreshold = this._alphaThreshold;
            shaderParams.diffuseModulateMethod = this._modulateMethod;
            var lightShaderParams = shaderParams.getOrCreateComponentByClass(feng3d.LightShaderParams);
            lightShaderParams.needsNormals += lightShaderParams.numLights > 0 ? 1 : 0;
            lightShaderParams.diffuseMethod = feng3d.F_DiffusePostLighting;
        };
        /**
         * @inheritDoc
         */
        BasicDiffuseMethod.prototype.copyFrom = function (method) {
            var diff = feng3d.as(method, BasicDiffuseMethod);
            this.texture = diff.texture;
            this.diffuseAlpha = diff.diffuseAlpha;
            this.diffuseColor = diff.diffuseColor;
        };
        BasicDiffuseMethod.METHOD_TYPE = "DiffuseMethod";
        return BasicDiffuseMethod;
    }(feng3d.LightingMethodBase));
    feng3d.BasicDiffuseMethod = BasicDiffuseMethod;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * CompositeDiffuseMethod provides a base class for diffuse methods that wrap a diffuse method to alter the
     * calculated diffuse reflection strength.
     */
    var CompositeDiffuseMethod = (function (_super) {
        __extends(CompositeDiffuseMethod, _super);
        /**
         * Creates a new WrapDiffuseMethod object.
         * @param modulateMethod The method which will add the code to alter the base method's strength. It needs to have the signature clampDiffuse(t : ShaderRegisterElement, regCache : ShaderRegisterCache) : string, in which t.w will contain the diffuse strength.
         * @param baseDiffuseMethod The base diffuse method on which this method's shading is based.
         */
        function CompositeDiffuseMethod(modulateMethod, baseDiffuseMethod) {
            if (modulateMethod === void 0) { modulateMethod = null; }
            if (baseDiffuseMethod === void 0) { baseDiffuseMethod = null; }
            _super.call(this);
            this._baseMethod = baseDiffuseMethod || new feng3d.BasicDiffuseMethod();
            this._baseMethod._modulateMethod = modulateMethod;
            this._baseMethod.addEventListener(feng3d.ShadingMethodEvent.SHADER_INVALIDATED, this.onShaderInvalidated);
        }
        Object.defineProperty(CompositeDiffuseMethod.prototype, "baseMethod", {
            /**
             * The base diffuse method on which this method's shading is based.
             */
            get: function () {
                return this._baseMethod;
            },
            set: function (value) {
                if (this._baseMethod == value)
                    return;
                this._baseMethod.removeEventListener(feng3d.ShadingMethodEvent.SHADER_INVALIDATED, this.onShaderInvalidated);
                this._baseMethod = value;
                this._baseMethod.addEventListener(feng3d.ShadingMethodEvent.SHADER_INVALIDATED, this.onShaderInvalidated, 0, true);
                this.invalidateShaderProgram();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        CompositeDiffuseMethod.prototype.dispose = function () {
            this._baseMethod.removeEventListener(feng3d.ShadingMethodEvent.SHADER_INVALIDATED, this.onShaderInvalidated);
            this._baseMethod.dispose();
        };
        Object.defineProperty(CompositeDiffuseMethod.prototype, "alphaThreshold", {
            /**
             * @inheritDoc
             */
            get: function () {
                return this._baseMethod.alphaThreshold;
            },
            set: function (value) {
                this._baseMethod.alphaThreshold = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CompositeDiffuseMethod.prototype, "texture", {
            /**
             * @inheritDoc
             */
            get: function () {
                return this._baseMethod.texture;
            },
            /**
             * @inheritDoc
             */
            set: function (value) {
                this._baseMethod.texture = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CompositeDiffuseMethod.prototype, "diffuseAlpha", {
            /**
             * @inheritDoc
             */
            get: function () {
                return this._baseMethod.diffuseAlpha;
            },
            /**
             * @inheritDoc
             */
            set: function (value) {
                this._baseMethod.diffuseAlpha = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CompositeDiffuseMethod.prototype, "diffuseColor", {
            /**
             * @inheritDoc
             */
            get: function () {
                return this._baseMethod.diffuseColor;
            },
            /**
             * @inheritDoc
             */
            set: function (diffuseColor) {
                this._baseMethod.diffuseColor = diffuseColor;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        CompositeDiffuseMethod.prototype.activate = function (shaderParams) {
            this._baseMethod.activate(shaderParams);
        };
        /**
         * @inheritDoc
         */
        CompositeDiffuseMethod.prototype.cleanCompilationData = function () {
            _super.prototype.cleanCompilationData.call(this);
            this._baseMethod.cleanCompilationData();
        };
        /**
         * Called when the base method's shader code is invalidated.
         */
        CompositeDiffuseMethod.prototype.onShaderInvalidated = function (event) {
            this.invalidateShaderProgram();
        };
        return CompositeDiffuseMethod;
    }(feng3d.BasicDiffuseMethod));
    feng3d.CompositeDiffuseMethod = CompositeDiffuseMethod;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * SubsurfaceScatteringDiffuseMethod provides a depth map-based diffuse shading method that mimics the scattering of
     * light inside translucent surfaces. It allows light to shine through an object and to soften the diffuse shading.
     * It can be used for candle wax, ice, skin, ...
     */
    var SubsurfaceScatteringDiffuseMethod = (function (_super) {
        __extends(SubsurfaceScatteringDiffuseMethod, _super);
        /**
         * Creates a new SubsurfaceScatteringDiffuseMethod object.
         * @param depthMapSize The size of the depth map used.
         * @param depthMapOffset The amount by which the rendered object will be inflated, to prevent depth map rounding errors.
         */
        function SubsurfaceScatteringDiffuseMethod(depthMapSize, depthMapOffset) {
            if (depthMapSize === void 0) { depthMapSize = 512; }
            if (depthMapOffset === void 0) { depthMapOffset = 15; }
            _super.call(this);
            this._translucency = 1;
            this._scatterColor = 0xffffff;
            this._scatterR = 1.0;
            this._scatterG = 1.0;
            this._scatterB = 1.0;
            this.vertexToTexData = [0.5, -0.5, 0, 1];
            this.f$ColorData = [1.0, 1.0, 1.0, 1.0];
            this.fragmentData0 = [1.0, 1.0 / 255, 1.0 / 65025, 1.0 / 16581375];
            this.fragmentData1 = [0.2, 1, 0.5, -0.1];
            this.lightProjection = new feng3d.Matrix3D();
            this._baseMethod._modulateMethod = this.scatterLight;
            this._passes = [];
            this._depthPass = new feng3d.SingleObjectDepthPass(depthMapSize, depthMapOffset);
            this._passes.push(this._depthPass);
            this._scattering = 0.2;
            this._translucency = 1;
        }
        Object.defineProperty(SubsurfaceScatteringDiffuseMethod.prototype, "depthMap", {
            get: function () {
                return this._depthMap;
            },
            set: function (value) {
                if (this._depthMap != value) {
                    this._depthMap = value;
                    this.context3DBufferOwner.markBufferDirty(this._.SSD$depthMap_fs);
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        SubsurfaceScatteringDiffuseMethod.prototype.initBuffers = function () {
            _super.prototype.initBuffers.call(this);
            this.context3DBufferOwner.mapContext3DBuffer(this._.SSD$ToTex_vc_vector, this.SSD$ToTexBuffer);
            this.context3DBufferOwner.mapContext3DBuffer(this._.SSD$f$ColorData_vc_vector, this.f$ColorDataBuffer);
            this.context3DBufferOwner.mapContext3DBuffer(this._.SSD$fragmentData0_vc_vector, this.fragmentData0Buffer);
            this.context3DBufferOwner.mapContext3DBuffer(this._.SSD$fragmentData1_vc_vector, this.fragmentData1Buffer);
            this.context3DBufferOwner.mapContext3DBuffer(this._.SSD$depthMap_fs, this.updateDepthMapBuffer);
            this.context3DBufferOwner.mapContext3DBuffer(this._.SSD$LightProjection_vc_matrix, this.updateLightProjectionBuffer);
        };
        SubsurfaceScatteringDiffuseMethod.prototype.SSD$ToTexBuffer = function (vcVectorBuffer) {
            vcVectorBuffer.update(this.vertexToTexData);
        };
        SubsurfaceScatteringDiffuseMethod.prototype.f$ColorDataBuffer = function (fcVectorBuffer) {
            fcVectorBuffer.update(this.f$ColorData);
        };
        SubsurfaceScatteringDiffuseMethod.prototype.fragmentData0Buffer = function (fcVectorBuffer) {
            fcVectorBuffer.update(this.fragmentData0);
        };
        SubsurfaceScatteringDiffuseMethod.prototype.fragmentData1Buffer = function (fcVectorBuffer) {
            fcVectorBuffer.update(this.fragmentData1);
        };
        SubsurfaceScatteringDiffuseMethod.prototype.updateDepthMapBuffer = function (textureBuffer) {
            textureBuffer.update(this.depthMap);
        };
        SubsurfaceScatteringDiffuseMethod.prototype.updateLightProjectionBuffer = function (vcMatrixBuffer) {
            vcMatrixBuffer.update(this.lightProjection, true);
        };
        SubsurfaceScatteringDiffuseMethod.prototype.cleanCompilationData = function () {
            _super.prototype.cleanCompilationData.call(this);
            this._propReg = null;
            this._lightColorReg = null;
            this._decReg = null;
            this._targetReg = null;
        };
        Object.defineProperty(SubsurfaceScatteringDiffuseMethod.prototype, "scattering", {
            /**
             * The amount by which the light scatters. It can be used to set the translucent surface's thickness. Use low
             * values for skin.
             */
            get: function () {
                return this._scattering;
            },
            set: function (value) {
                this._scattering = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SubsurfaceScatteringDiffuseMethod.prototype, "translucency", {
            /**
             * The translucency of the object.
             */
            get: function () {
                return this._translucency;
            },
            set: function (value) {
                this._translucency = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SubsurfaceScatteringDiffuseMethod.prototype, "scatterColor", {
            /**
             * The colour of the "insides" of the object, ie: the colour the light becomes after leaving the object.
             */
            get: function () {
                return this._scatterColor;
            },
            set: function (scatterColor) {
                this._scatterColor = scatterColor;
                this._scatterR = ((scatterColor >> 16) & 0xff) / 0xff;
                this._scatterG = ((scatterColor >> 8) & 0xff) / 0xff;
                this._scatterB = (scatterColor & 0xff) / 0xff;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        SubsurfaceScatteringDiffuseMethod.prototype.getVertexCode = function () {
            var vt0;
            var _ = feng3d.FagalRE.instance.space;
            var lightProjection;
            var toTexRegister = _.SSD$ToTex_vc_vector;
            var temp = _.getFreeTemp();
            var _lightProjVarying = _.SSD$LightProj_v;
            lightProjection = _.SSD$LightProjection_vc_matrix;
            _.m44(temp, vt0, lightProjection); //
            _.div(temp.xyz, temp.xyz, temp.w); //
            _.mul(temp.xy, temp.xy, toTexRegister.xy); //
            _.add(temp.xy, temp.xy, toTexRegister.xx); //
            _.mov(_lightProjVarying.xyz, temp.xyz); //
            _.mov(_lightProjVarying.w, _.position_va_3.w);
        };
        /**
         * @inheritDoc
         */
        SubsurfaceScatteringDiffuseMethod.prototype.getFragmentPreLightingCode = function () {
            var _ = feng3d.FagalRE.instance.space;
            this._decReg = _.SSD$dec_fc_vector;
            this._propReg = _.SSD$prop_fc_vector;
        };
        /**
         * @inheritDoc
         */
        SubsurfaceScatteringDiffuseMethod.prototype.getFragmentCodePerLight = function () {
            var lightColReg;
            this._isFirstLight = true;
            this._lightColorReg = lightColReg;
        };
        /**
         * @inheritDoc
         */
        SubsurfaceScatteringDiffuseMethod.prototype.getFragmentPostLightingCode = function () {
            var targetReg;
            var _ = feng3d.FagalRE.instance.space;
            var temp = _.getFreeTemp();
            var _colorReg = _.SSD$Color_fc_vector;
            _.mul(temp.xyz, this._lightColorReg.xyz, this._targetReg.w); //
            _.mul(temp.xyz, temp.xyz, _colorReg.xyz); //
            _.add(targetReg.xyz, targetReg.xyz, temp.xyz);
        };
        /**
         * @inheritDoc
         */
        SubsurfaceScatteringDiffuseMethod.prototype.activate = function (shaderParams) {
            _super.prototype.activate.call(this, shaderParams);
            this.f$ColorData[0] = this._scatterR;
            this.f$ColorData[1] = this._scatterG;
            this.f$ColorData[2] = this._scatterB;
            this.fragmentData1[0] = this._scattering;
            this.fragmentData1[1] = this._translucency;
        };
        /**
         * @inheritDoc
         */
        SubsurfaceScatteringDiffuseMethod.prototype.setRenderState = function (renderable, camera) {
            this.depthMap = this._depthPass.getDepthMap(renderable);
            var projection = this._depthPass.getProjection(renderable);
            this.lightProjection.copyFrom(projection);
        };
        /**
         * Generates the code for this method
         */
        SubsurfaceScatteringDiffuseMethod.prototype.scatterLight = function () {
            var _ = feng3d.FagalRE.instance.space;
            var shaderParams = feng3d.FagalRE.instance.context3DCache.shaderParams;
            var lightShaderParams = shaderParams.getOrCreateComponentByClass(feng3d.LightShaderParams);
            // only scatter first light
            if (!this._isFirstLight)
                return;
            this._isFirstLight = false;
            var targetReg;
            var depthReg = _.SSD$depthMap_fs;
            if (lightShaderParams.needsViewDir > 0)
                this._targetReg = _.viewDir_ft_4;
            else {
                this._targetReg = _.getFreeTemp();
            }
            var _lightProjVarying = _.SSD$LightProj_v;
            var _colorReg = _.SSD$Color_fc_vector;
            var temp = _.getFreeTemp();
            "tex " + temp + ", " + _lightProjVarying + ", " + depthReg + " <2d,nearest,clamp>\n";
            // reencode RGBA
            _.dp4(targetReg.z, temp, this._decReg);
            // currentDistanceToLight - closestDistanceToLight
            _.sub(targetReg.z, _lightProjVarying.z, targetReg.z);
            _.sub(targetReg.z, this._propReg.x, targetReg.z);
            _.mul(targetReg.z, this._propReg.y, targetReg.z);
            _.sat(targetReg.z, targetReg.z);
            // targetReg.x contains dot(lightDir, normal)
            // modulate according to incident light angle (scatter = scatter*(-.5*dot(light, normal) + .5)
            _.neg(targetReg.y, targetReg.x);
            _.mul(targetReg.y, targetReg.y, this._propReg.z);
            _.add(targetReg.y, targetReg.y, this._propReg.z);
            _.mul(this._targetReg.w, targetReg.z, targetReg.y);
            // blend diffuse: d' = (1-s)*d + s*1
            _.sub(targetReg.y, _colorReg.w, this._targetReg.w);
            _.mul(targetReg.w, targetReg.w, targetReg.y);
        };
        return SubsurfaceScatteringDiffuseMethod;
    }(feng3d.CompositeDiffuseMethod));
    feng3d.SubsurfaceScatteringDiffuseMethod = SubsurfaceScatteringDiffuseMethod;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 地形渲染函数
     * @author feng 2014-7-16
     */
    var TerrainDiffuseMethod = (function (_super) {
        __extends(TerrainDiffuseMethod, _super);
        function TerrainDiffuseMethod(splatTextures, blendingTexture, tileData) {
            _super.call(this);
            this.tileData = [0, 0, 0, 0];
            this.splats = splatTextures;
            for (var i = 0; i < this.tileData.length && i < tileData.length; i++) {
                this.tileData[i] = tileData[i];
            }
            this.blendingTexture = blendingTexture;
            this._numSplattingLayers = this.splats.length;
            if (this._numSplattingLayers > 4)
                throw new Error("More than 4 splatting layers is not supported!");
        }
        Object.defineProperty(TerrainDiffuseMethod.prototype, "splats", {
            get: function () {
                return this._splats;
            },
            set: function (value) {
                this._splats = value;
                this.context3DBufferOwner.markBufferDirty(this._.terrainTextures_fs_array);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TerrainDiffuseMethod.prototype, "blendingTexture", {
            get: function () {
                return this._blendingTexture;
            },
            set: function (value) {
                this._blendingTexture = value;
                this.context3DBufferOwner.markBufferDirty(this._.blendingtexture_fs);
            },
            enumerable: true,
            configurable: true
        });
        TerrainDiffuseMethod.prototype.initBuffers = function () {
            _super.prototype.initBuffers.call(this);
            this.context3DBufferOwner.mapContext3DBuffer(this._.blendingtexture_fs, this.updateBlendingTextureBuffer);
            this.context3DBufferOwner.mapContext3DBuffer(this._.terrainTextures_fs_array, this.updateTerrainTextureBuffer);
            this.context3DBufferOwner.mapContext3DBuffer(this._.tile_fc_vector, this.updateTileDataBuffer);
        };
        TerrainDiffuseMethod.prototype.updateTerrainTextureBuffer = function (terrainTextureBufferArr) {
            terrainTextureBufferArr.update(this.splats);
        };
        TerrainDiffuseMethod.prototype.updateTileDataBuffer = function (tileDataBuffer) {
            tileDataBuffer.update(this.tileData);
        };
        TerrainDiffuseMethod.prototype.updateBlendingTextureBuffer = function (nBlendingTextureBuffer) {
            nBlendingTextureBuffer.update(this.blendingTexture);
        };
        TerrainDiffuseMethod.prototype.activate = function (shaderParams) {
            _super.prototype.activate.call(this, shaderParams);
            //通用渲染参数
            var terrainShaderParams = shaderParams.getOrCreateComponentByClass(feng3d.TerrainShaderParams);
            terrainShaderParams.splatNum = this._numSplattingLayers;
            shaderParams.addSampleFlags(this._.texture_fs, this.texture, feng3d.Context3DWrapMode.REPEAT);
            shaderParams.addSampleFlags(this._.terrainTextures_fs_array, this.splats[0], feng3d.Context3DWrapMode.REPEAT);
            shaderParams.addSampleFlags(this._.blendingtexture_fs, this.blendingTexture);
            var lightShaderParams = shaderParams.getOrCreateComponentByClass(feng3d.LightShaderParams);
            lightShaderParams.diffuseMethod = feng3d.F_TerrainDiffusePostLighting;
        };
        return TerrainDiffuseMethod;
    }(feng3d.BasicDiffuseMethod));
    feng3d.TerrainDiffuseMethod = TerrainDiffuseMethod;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 镜面反射函数
     * @author feng 2014-5-19
     */
    var BasicSpecularMethod = (function (_super) {
        __extends(BasicSpecularMethod, _super);
        /**
         * 创建镜面反射函数
         */
        function BasicSpecularMethod() {
            _super.call(this);
            this._gloss = 50;
            this._specular = 1;
            this._specularColor = 0xffffff;
            /** 镜面反射数据 */
            this._specularData = [1, 1, 1, 50];
            this.methodType = BasicSpecularMethod.METHOD_TYPE;
            this.typeUnique = true;
        }
        Object.defineProperty(BasicSpecularMethod.prototype, "specularColor", {
            /**
             * 镜面反射颜色
             */
            get: function () {
                return this._specularColor;
            },
            set: function (value) {
                if (this._specularColor == value)
                    return;
                if (this._specularColor == 0 || value == 0)
                    this.invalidateShaderProgram();
                this._specularColor = value;
                this.updateSpecular();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BasicSpecularMethod.prototype, "texture", {
            /**
             * 镜面反射光泽图
             */
            get: function () {
                return this._texture;
            },
            set: function (value) {
                if ((value != null) != (this._texture != null) || (value && this._texture && (value.hasMipMaps != this._texture.hasMipMaps || value.format != this._texture.format))) {
                    this.invalidateShaderProgram();
                }
                this._texture = value;
                this.context3DBufferOwner.markBufferDirty(this._.specularTexture_fs);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BasicSpecularMethod.prototype, "gloss", {
            /**
             * The sharpness of the specular highlight.
             */
            get: function () {
                return this._gloss;
            },
            set: function (value) {
                this._gloss = value;
                this.updateSpecular();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BasicSpecularMethod.prototype, "specular", {
            /**
             * 镜面反射光反射强度
             */
            get: function () {
                return this._specular;
            },
            set: function (value) {
                if (value == this._specular)
                    return;
                this._specular = value;
                this.updateSpecular();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        BasicSpecularMethod.prototype.initBuffers = function () {
            _super.prototype.initBuffers.call(this);
            this.context3DBufferOwner.mapContext3DBuffer(this._.specularData_fc_vector, this.updateSpecularDataBuffer);
            this.context3DBufferOwner.mapContext3DBuffer(this._.specularTexture_fs, this.updateSpecularTextureBuffer);
        };
        BasicSpecularMethod.prototype.updateSpecularDataBuffer = function (_specularDataBuffer) {
            _specularDataBuffer.update(this._specularData);
        };
        BasicSpecularMethod.prototype.updateSpecularTextureBuffer = function (_specularTextureBuffer) {
            _specularTextureBuffer.update(this.texture);
        };
        /**
         * @inheritDoc
         */
        BasicSpecularMethod.prototype.activate = function (shaderParams) {
            var lightShaderParams = shaderParams.getOrCreateComponentByClass(feng3d.LightShaderParams);
            lightShaderParams.needsNormals += lightShaderParams.numLights > 0 ? 1 : 0;
            lightShaderParams.needsViewDir += lightShaderParams.numLights > 0 ? 1 : 0;
            lightShaderParams.usingSpecularMethod += 1;
            if (this.texture != null) {
                lightShaderParams.hasSpecularTexture++;
                var commonShaderParams = shaderParams.getOrCreateComponentByClass(feng3d.CommonShaderParams);
                commonShaderParams.needsUV++;
                shaderParams.addSampleFlags(this._.specularTexture_fs, this.texture);
            }
            shaderParams.modulateMethod = this._modulateMethod;
            shaderParams.specularModelType = feng3d.SpecularModelType.BLINN_PHONG;
        };
        BasicSpecularMethod.prototype.updateSpecular = function () {
            this._specularData[0] = ((this._specularColor >> 16) & 0xff) / 0xff * this._specular;
            this._specularData[1] = ((this._specularColor >> 8) & 0xff) / 0xff * this._specular;
            this._specularData[2] = (this._specularColor & 0xff) / 0xff * this._specular;
            this._specularData[3] = this._gloss;
        };
        BasicSpecularMethod.METHOD_TYPE = "SpecularMethod";
        return BasicSpecularMethod;
    }(feng3d.LightingMethodBase));
    feng3d.BasicSpecularMethod = BasicSpecularMethod;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * CompositeSpecularMethod provides a base class for specular methods that wrap a specular method to alter the
     * calculated specular reflection strength.
     */
    var CompositeSpecularMethod = (function (_super) {
        __extends(CompositeSpecularMethod, _super);
        /**
         * Creates a new WrapSpecularMethod object.
         * @param modulateMethod The method which will add the code to alter the base method's strength. It needs to have the signature modSpecular(t : ShaderRegisterElement, regCache : ShaderRegisterCache) : string, in which t.w will contain the specular strength and t.xyz will contain the half-vector or the reflection vector.
         * @param baseSpecularMethod The base specular method on which this method's shading is based.
         */
        function CompositeSpecularMethod(modulateMethod, baseSpecularMethod) {
            if (baseSpecularMethod === void 0) { baseSpecularMethod = null; }
            _super.call(this);
            this._baseMethod = baseSpecularMethod || new feng3d.BasicSpecularMethod();
            this._baseMethod._modulateMethod = modulateMethod;
            this._baseMethod.addEventListener(feng3d.ShadingMethodEvent.SHADER_INVALIDATED, this.onShaderInvalidated);
        }
        Object.defineProperty(CompositeSpecularMethod.prototype, "baseMethod", {
            /**
             * The base specular method on which this method's shading is based.
             */
            get: function () {
                return this._baseMethod;
            },
            set: function (value) {
                if (this._baseMethod == value)
                    return;
                this._baseMethod.removeEventListener(feng3d.ShadingMethodEvent.SHADER_INVALIDATED, this.onShaderInvalidated);
                this._baseMethod = value;
                this._baseMethod.addEventListener(feng3d.ShadingMethodEvent.SHADER_INVALIDATED, this.onShaderInvalidated, 0, true);
                this.invalidateShaderProgram();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CompositeSpecularMethod.prototype, "gloss", {
            /**
             * @inheritDoc
             */
            get: function () {
                return this._baseMethod.gloss;
            },
            set: function (value) {
                this._baseMethod.gloss = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CompositeSpecularMethod.prototype, "specular", {
            /**
             * @inheritDoc
             */
            get: function () {
                return this._baseMethod.specular;
            },
            set: function (value) {
                this._baseMethod.specular = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        CompositeSpecularMethod.prototype.dispose = function () {
            this._baseMethod.removeEventListener(feng3d.ShadingMethodEvent.SHADER_INVALIDATED, this.onShaderInvalidated);
            this._baseMethod.dispose();
        };
        Object.defineProperty(CompositeSpecularMethod.prototype, "texture", {
            /**
             * @inheritDoc
             */
            get: function () {
                return this._baseMethod.texture;
            },
            set: function (value) {
                this._baseMethod.texture = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        CompositeSpecularMethod.prototype.activate = function (shaderParams) {
            this._baseMethod.activate(shaderParams);
        };
        /**
         * @inheritDoc
         */
        CompositeSpecularMethod.prototype.cleanCompilationData = function () {
            _super.prototype.cleanCompilationData.call(this);
            this._baseMethod.cleanCompilationData();
        };
        /**
         * Called when the base method's shader code is invalidated.
         */
        CompositeSpecularMethod.prototype.onShaderInvalidated = function (event) {
            this.invalidateShaderProgram();
        };
        return CompositeSpecularMethod;
    }(feng3d.BasicSpecularMethod));
    feng3d.CompositeSpecularMethod = CompositeSpecularMethod;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * PhongSpecularMethod provides a specular method that provides Phong highlights.
     */
    var PhongSpecularMethod = (function (_super) {
        __extends(PhongSpecularMethod, _super);
        /**
         * Creates a new PhongSpecularMethod object.
         */
        function PhongSpecularMethod() {
            _super.call(this);
        }
        PhongSpecularMethod.prototype.activate = function (shaderParams) {
            _super.prototype.activate.call(this, shaderParams);
            shaderParams.specularModelType = feng3d.SpecularModelType.PHONG;
        };
        return PhongSpecularMethod;
    }(feng3d.BasicSpecularMethod));
    feng3d.PhongSpecularMethod = PhongSpecularMethod;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * FresnelSpecularMethod provides a specular shading method that causes stronger highlights on grazing view angles.
     */
    var FresnelSpecularMethod = (function (_super) {
        __extends(FresnelSpecularMethod, _super);
        /**
         * Creates a new FresnelSpecularMethod object.
         * @param basedOnSurface Defines whether the fresnel effect should be based on the view angle on the surface (if true), or on the angle between the light and the view.
         * @param baseSpecularMethod The specular method to which the fresnel equation. Defaults to BasicSpecularMethod.
         */
        function FresnelSpecularMethod(basedOnSurface) {
            if (basedOnSurface === void 0) { basedOnSurface = true; }
            // may want to offer diff speculars
            _super.call(this);
            this._fresnelPower = 5;
            this._normalReflectance = .028; // default value for skin
            this.data = [0, 0, 1, 0];
            this._incidentLight = !basedOnSurface;
        }
        Object.defineProperty(FresnelSpecularMethod.prototype, "basedOnSurface", {
            /**
             * Defines whether the fresnel effect should be based on the view angle on the surface (if true), or on the angle between the light and the view.
             */
            get: function () {
                return !this._incidentLight;
            },
            set: function (value) {
                if (this._incidentLight != value)
                    return;
                this._incidentLight = !value;
                this.invalidateShaderProgram();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FresnelSpecularMethod.prototype, "fresnelPower", {
            /**
             * The power used in the Fresnel equation. Higher values make the fresnel effect more pronounced. Defaults to 5.
             */
            get: function () {
                return this._fresnelPower;
            },
            set: function (value) {
                this._fresnelPower = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FresnelSpecularMethod.prototype, "normalReflectance", {
            /**
             * The minimum amount of reflectance, ie the reflectance when the view direction is normal to the surface or light direction.
             */
            get: function () {
                return this._normalReflectance;
            },
            set: function (value) {
                this._normalReflectance = value;
            },
            enumerable: true,
            configurable: true
        });
        FresnelSpecularMethod.prototype.initBuffers = function () {
            _super.prototype.initBuffers.call(this);
            this.context3DBufferOwner.mapContext3DBuffer(this._.fresnelSpecularData_fc_vector, this.updateSpecularDataBuffer1);
        };
        FresnelSpecularMethod.prototype.updateSpecularDataBuffer1 = function (fcVectorBuffer) {
            fcVectorBuffer.update(this.data);
        };
        /**
         * @inheritDoc
         */
        FresnelSpecularMethod.prototype.activate = function (shaderParams) {
            _super.prototype.activate.call(this, shaderParams);
            this.data[0] = this._normalReflectance;
            this.data[1] = this._fresnelPower;
            shaderParams.incidentLight = this._incidentLight;
            shaderParams.modulateMethod = feng3d.F_FresnelSpecular;
        };
        return FresnelSpecularMethod;
    }(feng3d.PhongSpecularMethod));
    feng3d.FresnelSpecularMethod = FresnelSpecularMethod;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 阴影映射函数基类
     * @author feng 2015-5-28
     */
    var ShadowMapMethodBase = (function (_super) {
        __extends(ShadowMapMethodBase, _super);
        /**
         * 创建阴影映射函数基类
         * @param castingLight		投射灯光
         */
        function ShadowMapMethodBase(castingLight) {
            _super.call(this);
            this._epsilon = .02;
            this._alpha = 1;
            this.methodType = ShadowMapMethodBase.METHOD_TYPE;
            this.typeUnique = true;
            this._namedAsset = new feng3d.NamedAsset(this, feng3d.AssetType.SHADOW_MAP_METHOD);
            this._castingLight = castingLight;
            castingLight.castsShadows = true;
            this._shadowMapper = castingLight.shadowMapper;
        }
        Object.defineProperty(ShadowMapMethodBase.prototype, "castingLight", {
            /**
             * 投射灯光
             */
            get: function () {
                return this._castingLight;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ShadowMapMethodBase.prototype, "alpha", {
            /**
             * The "transparency" of the shadows. This allows making shadows less strong.
             */
            get: function () {
                return this._alpha;
            },
            set: function (value) {
                this._alpha = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ShadowMapMethodBase.prototype, "epsilon", {
            /**
             * A small value to counter floating point precision errors when comparing values in the shadow map with the
             * calculated depth value. Increase this if shadow banding occurs, decrease it if the shadow seems to be too detached.
             */
            get: function () {
                return this._epsilon;
            },
            set: function (value) {
                this._epsilon = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        ShadowMapMethodBase.prototype.activate = function (shaderParams) {
            var shadowShaderParams = shaderParams.getOrCreateComponentByClass(feng3d.ShadowShaderParams);
            shadowShaderParams.usingShadowMapMethod += 1;
            shadowShaderParams.needsShadowRegister++;
        };
        Object.defineProperty(ShadowMapMethodBase.prototype, "namedAsset", {
            get: function () {
                return this._namedAsset;
            },
            enumerable: true,
            configurable: true
        });
        ShadowMapMethodBase.METHOD_TYPE = "ShadowMapMethod";
        return ShadowMapMethodBase;
    }(feng3d.ShadingMethodBase));
    feng3d.ShadowMapMethodBase = ShadowMapMethodBase;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 简单阴影映射函数基类
     * @author feng 2015-5-28
     */
    var SimpleShadowMapMethodBase = (function (_super) {
        __extends(SimpleShadowMapMethodBase, _super);
        /**
         * 创建简单阴影映射方法基类
         * @param castingLight			投射阴影的灯光
         */
        function SimpleShadowMapMethodBase(castingLight) {
            _super.call(this, castingLight);
            /**
             * 顶点常量数据0
             */
            this.shadowCommonsVCData0 = [0.5, -0.5, 0.0, 1.0];
            /**
             * 通用数据0
             */
            this.shadowCommonsData0 = [1.0, 1 / 255.0, 1 / 65025.0, 1 / 16581375.0];
            /**
             * 通用数据1
             */
            this.shadowCommonsData1 = [0, 0, 0, 1];
            /**
             * 通用数据2
             */
            this.shadowCommonsData2 = [0.5, 2048, 1.0 / 2048, 0];
            /**
             * 深度投影矩阵
             */
            this.depthProjection = new feng3d.Matrix3D();
            this._usePoint = feng3d.is(castingLight, feng3d.PointLight);
        }
        /**
         * @inheritDoc
         */
        SimpleShadowMapMethodBase.prototype.initBuffers = function () {
            _super.prototype.initBuffers.call(this);
            this.context3DBufferOwner.mapContext3DBuffer(this._.shadowCommondata0_vc_vector, this.updateShadowCommonVCData0Buffer);
            this.context3DBufferOwner.mapContext3DBuffer(this._.shadowCommondata0_fc_vector, this.updateShadowCommonData0Buffer);
            this.context3DBufferOwner.mapContext3DBuffer(this._.shadowCommondata1_fc_vector, this.updateShadowCommonData1Buffer);
            this.context3DBufferOwner.mapContext3DBuffer(this._.shadowCommondata2_fc_vector, this.updateShadowCommonData2Buffer);
            this.context3DBufferOwner.mapContext3DBuffer(this._.depthMap_vc_matrix, this.updateDepthProjectionMatrixBuffer);
            this.context3DBufferOwner.mapContext3DBuffer(this._.depthMap_fs, this.updateTextureBuffer);
        };
        SimpleShadowMapMethodBase.prototype.updateShadowCommonVCData0Buffer = function (vcVectorBuffer) {
            vcVectorBuffer.update(this.shadowCommonsVCData0);
        };
        SimpleShadowMapMethodBase.prototype.updateShadowCommonData0Buffer = function (fcVectorBuffer) {
            fcVectorBuffer.update(this.shadowCommonsData0);
        };
        SimpleShadowMapMethodBase.prototype.updateShadowCommonData1Buffer = function (fcVectorBuffer) {
            fcVectorBuffer.update(this.shadowCommonsData1);
        };
        SimpleShadowMapMethodBase.prototype.updateShadowCommonData2Buffer = function (fcVectorBuffer) {
            fcVectorBuffer.update(this.shadowCommonsData2);
        };
        /**
         * 更新深度投影矩阵缓冲
         * @param sceneTransformMatrixBuffer		场景变换矩阵缓冲
         */
        SimpleShadowMapMethodBase.prototype.updateDepthProjectionMatrixBuffer = function (sceneTransformMatrixBuffer) {
            sceneTransformMatrixBuffer.update(this.depthProjection, true);
        };
        /**
         * 更新深度图纹理缓冲
         */
        SimpleShadowMapMethodBase.prototype.updateTextureBuffer = function (textureBuffer) {
            textureBuffer.update(this._castingLight.shadowMapper.depthMap);
        };
        /**
         * @inheritDoc
         */
        SimpleShadowMapMethodBase.prototype.activate = function (shaderParams) {
            _super.prototype.activate.call(this, shaderParams);
            var shadowShaderParams = shaderParams.getOrCreateComponentByClass(feng3d.ShadowShaderParams);
            if (this._usePoint)
                shadowShaderParams.usePoint += 1;
            if (this._usePoint)
                this.shadowCommonsData1[0] = -Math.pow(1 / (this._castingLight.fallOff * this._epsilon), 2);
            else
                this.shadowCommonsVCData0[3] = -1 / (feng3d.as(this._shadowMapper, feng3d.DirectionalShadowMapper).depth * this._epsilon);
            this.shadowCommonsData1[1] = 1 - this._alpha;
            var size = this.castingLight.shadowMapper.depthMapSize;
            this.shadowCommonsData2[1] = size;
            this.shadowCommonsData2[2] = 1 / size;
            //通用渲染参数
            var flags = [this.castingLight.shadowMapper.depthMap.type, feng3d.Context3DTextureFilter.NEAREST, feng3d.Context3DWrapMode.CLAMP];
            shaderParams.setSampleFlags(this._.depthMap_fs, flags);
        };
        /**
         * @inheritDoc
         */
        SimpleShadowMapMethodBase.prototype.setRenderState = function (renderable, camera) {
            if (!this._usePoint) {
                this.depthProjection.copyFrom(feng3d.as(this._shadowMapper, feng3d.DirectionalShadowMapper).depthProjection);
            }
        };
        return SimpleShadowMapMethodBase;
    }(feng3d.ShadowMapMethodBase));
    feng3d.SimpleShadowMapMethodBase = SimpleShadowMapMethodBase;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 过滤的阴影映射函数
     * @author feng 2015-5-28
     */
    var FilteredShadowMapMethod = (function (_super) {
        __extends(FilteredShadowMapMethod, _super);
        /**
         * 过滤的阴影映射函数
         * @param castingLight		投射灯光
         */
        function FilteredShadowMapMethod(castingLight) {
            _super.call(this, castingLight);
        }
        return FilteredShadowMapMethod;
    }(feng3d.SimpleShadowMapMethodBase));
    feng3d.FilteredShadowMapMethod = FilteredShadowMapMethod;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 近阴影映射函数
     * @author feng 2015-5-28
     */
    var NearShadowMapMethod = (function (_super) {
        __extends(NearShadowMapMethod, _super);
        /**
         * 创建近阴影映射函数
         * @param baseMethod		基础映射函数
         * @param fadeRatio			消退比率
         */
        function NearShadowMapMethod(baseMethod, fadeRatio) {
            if (fadeRatio === void 0) { fadeRatio = .1; }
            _super.call(this, baseMethod.castingLight);
            this.secondaryFragmentConstants = [0, 0, 0, 0];
            this._baseMethod = baseMethod;
            this._fadeRatio = fadeRatio;
            this._nearShadowMapper = this._castingLight.shadowMapper;
            if (!this._nearShadowMapper)
                throw new Error("NearShadowMapMethod requires a light that has a NearDirectionalShadowMapper instance assigned to shadowMapper.");
            this._baseMethod.addEventListener(feng3d.ShadingMethodEvent.SHADER_INVALIDATED, this.onShaderInvalidated);
        }
        Object.defineProperty(NearShadowMapMethod.prototype, "baseMethod", {
            /**
             * The base shadow map method on which this method's shading is based.
             */
            get: function () {
                return this._baseMethod;
            },
            set: function (value) {
                if (this._baseMethod == value)
                    return;
                this._baseMethod.removeEventListener(feng3d.ShadingMethodEvent.SHADER_INVALIDATED, this.onShaderInvalidated);
                this._baseMethod = value;
                this._baseMethod.addEventListener(feng3d.ShadingMethodEvent.SHADER_INVALIDATED, this.onShaderInvalidated, 0, true);
                this.invalidateShaderProgram();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        NearShadowMapMethod.prototype.initBuffers = function () {
            _super.prototype.initBuffers.call(this);
            this.context3DBufferOwner.mapContext3DBuffer(this._.secondary_fc_vector, this.updateSecondaryCommonData0Buffer);
        };
        /**
         * @inheritDoc
         */
        NearShadowMapMethod.prototype.initConstants = function () {
            _super.prototype.initConstants.call(this);
            this._baseMethod.initConstants();
            this.secondaryFragmentConstants[0] = 0;
            this.secondaryFragmentConstants[1] = 0;
            this.secondaryFragmentConstants[2] = 0;
            this.secondaryFragmentConstants[3] = 1;
        };
        NearShadowMapMethod.prototype.updateSecondaryCommonData0Buffer = function (fcVectorBuffer) {
            fcVectorBuffer.update(this.secondaryFragmentConstants);
        };
        /**
         * @inheritDoc
         */
        NearShadowMapMethod.prototype.setRenderState = function (renderable, camera) {
            var near = camera.lens.near;
            var d = camera.lens.far - near;
            var maxDistance = this._nearShadowMapper.coverageRatio;
            var minDistance = maxDistance * (1 - this._fadeRatio);
            maxDistance = near + maxDistance * d;
            minDistance = near + minDistance * d;
            this.secondaryFragmentConstants[0] = minDistance;
            this.secondaryFragmentConstants[1] = 1 / (maxDistance - minDistance);
            _super.prototype.setRenderState.call(this, renderable, camera);
            this._baseMethod.setRenderState(renderable, camera);
        };
        /**
         * @inheritDoc
         */
        NearShadowMapMethod.prototype.activate = function (shaderParams) {
            _super.prototype.activate.call(this, shaderParams);
            var shadowShaderParams = shaderParams.getOrCreateComponentByClass(feng3d.ShadowShaderParams);
            shadowShaderParams.needsProjection++;
            shadowShaderParams.useNearShadowMap++;
        };
        /**
         * 处理渲染程序失效事件
         */
        NearShadowMapMethod.prototype.onShaderInvalidated = function (event) {
            this.invalidateShaderProgram();
        };
        return NearShadowMapMethod;
    }(feng3d.SimpleShadowMapMethodBase));
    feng3d.NearShadowMapMethod = NearShadowMapMethod;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 材质基类
     * @author feng 2014-4-15
     */
    var MaterialBase = (function (_super) {
        __extends(MaterialBase, _super);
        /**
         * 创建一个材质基类
         */
        function MaterialBase() {
            _super.call(this);
            this._blendMode = feng3d.BlendMode.NORMAL;
            this._mipmap = true;
            this._smooth = true;
            this._namedAsset = new feng3d.NamedAsset(this, feng3d.AssetType.MATERIAL);
            this._owners = [];
            this._passes = [];
            this._depthPass = new feng3d.DepthMapPass();
            this._planarShadowPass = new feng3d.PlanarShadowPass();
            // Default to considering pre-multiplied textures while blending
            this.alphaPremultiplied = true;
        }
        Object.defineProperty(MaterialBase.prototype, "depthPass", {
            /**
             * 深度渲染通道
             */
            get: function () {
                return this._depthPass;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialBase.prototype, "planarShadowPass", {
            /**
             * 平面阴影映射通道
             */
            get: function () {
                return this._planarShadowPass;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialBase.prototype, "bothSides", {
            /**
             * 是否双面渲染
             */
            get: function () {
                return this._bothSides;
            },
            set: function (value) {
                this._bothSides = value;
                for (var i = 0; i < this._numPasses; ++i)
                    this._passes[i].bothSides = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialBase.prototype, "requiresBlending", {
            /**
             * 是否需要混合
             */
            get: function () {
                return this._blendMode != feng3d.BlendMode.NORMAL;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        MaterialBase.prototype.getRequiresBlending = function () {
            return this.requiresBlending;
        };
        /**
         * 混合模式
         */
        MaterialBase.prototype.setBlendMode = function (value) {
            this._blendMode = value;
        };
        Object.defineProperty(MaterialBase.prototype, "blendMode", {
            /**
             * 混合模式
             */
            get: function () {
                return this._blendMode;
            },
            set: function (value) {
                this._blendMode = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialBase.prototype, "alphaPremultiplied", {
            /**
             * Indicates whether visible textures (or other pixels) used by this material have
             * already been premultiplied. Toggle this if you are seeing black halos around your
             * blended alpha edges.
             */
            get: function () {
                return this._alphaPremultiplied;
            },
            set: function (value) {
                this._alphaPremultiplied = value;
                for (var i = 0; i < this._numPasses; ++i)
                    this._passes[i].alphaPremultiplied = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialBase.prototype, "mipmap", {
            /**
             * 是否使用纹理分级细化
             */
            get: function () {
                return this._mipmap;
            },
            set: function (value) {
                this._mipmap = value;
                this._passes.forEach(function (pass) {
                    pass.mipmap = value;
                });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialBase.prototype, "repeat", {
            /**
             * 是否重复
             */
            get: function () {
                return this._repeat;
            },
            set: function (value) {
                this._repeat = value;
                this._passes.forEach(function (pass) {
                    pass.repeat = value;
                });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialBase.prototype, "smooth", {
            /**
             * 是否平滑
             */
            get: function () {
                return this._smooth;
            },
            set: function (value) {
                this._smooth = value;
                this._passes.forEach(function (pass) {
                    pass.smooth = value;
                });
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 添加通道
         * @param pass 通道
         */
        MaterialBase.prototype.addPass = function (pass) {
            this._passes.push(pass);
            this._numPasses = this._passes.length;
            pass.alphaPremultiplied = this._alphaPremultiplied;
            pass.mipmap = this._mipmap;
            pass.smooth = this._smooth;
            pass.repeat = this._repeat;
            pass.bothSides = this._bothSides;
            pass.addEventListener(feng3d.Event.CHANGE, this.onPassChange);
            this.invalidatePasses(null);
        };
        /**
         * 获取渲染通道
         * @param index		渲染通道索引
         * @return			返回指定索引处渲染通道
         */
        MaterialBase.prototype.getPass = function (index) {
            return this._passes[index];
        };
        /**
         * 处理通道变化事件
         */
        MaterialBase.prototype.onPassChange = function (event) {
        };
        /**
         * 移除通道
         * @param pass 通道
         */
        MaterialBase.prototype.removePass = function (pass) {
            this._passes.splice(this._passes.indexOf(pass), 1);
        };
        Object.defineProperty(MaterialBase.prototype, "animationSet", {
            /**
             * 动画集合
             */
            set: function (value) {
                this._passes.forEach(function (pass) {
                    pass.animationSet = value;
                });
                this.depthPass.animationSet = value;
                this.planarShadowPass.animationSet = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialBase.prototype, "lightPicker", {
            /**
             * 灯光采集器
             */
            get: function () {
                return this._lightPicker;
            },
            set: function (value) {
                if (value != this._lightPicker) {
                    this._lightPicker = value;
                    var len = this._passes.length;
                    for (var i = 0; i < len; ++i)
                        this._passes[i].lightPicker = this._lightPicker;
                }
            },
            enumerable: true,
            configurable: true
        });
        MaterialBase.prototype.setLightPicker = function (value) {
            this.lightPicker = value;
        };
        /**
         * 通道失效
         */
        MaterialBase.prototype.invalidatePasses = function (triggerPass) {
            this._passes.forEach(function (pass) {
                if (pass != triggerPass)
                    pass.invalidateShaderProgram();
            });
        };
        Object.defineProperty(MaterialBase.prototype, "numPasses", {
            /**
             * 渲染通道数量
             */
            get: function () {
                return this._numPasses;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 更新材质
         */
        MaterialBase.prototype.updateMaterial = function () {
        };
        /**
         * 清除通道渲染状态
         * @param index				通道索引
         * @param stage3DProxy		3D舞台代理
         */
        MaterialBase.prototype.deactivatePass = function (index) {
            this._passes[index].deactivate();
        };
        /**
         * 停用材质的最后一个通道
         */
        MaterialBase.prototype.deactivate = function () {
            this._passes[this._numPasses - 1].deactivate();
        };
        /**
         * 添加材质拥有者
         * @param owner		材质拥有者
         */
        MaterialBase.prototype.addOwner = function (owner) {
            this._owners.push(owner);
        };
        /**
         * 移除材质拥有者
         * @param owner		材质拥有者
         */
        MaterialBase.prototype.removeOwner = function (owner) {
            this._owners.splice(this._owners.indexOf(owner), 1);
            if (this._owners.length == 0) {
                this.invalidatePasses(null);
            }
        };
        /**
         * Cleans up resources owned by the material, including passes. Textures are not owned by the material since they
         * could be used by other materials and will not be disposed.
         */
        MaterialBase.prototype.dispose = function () {
            var i;
            for (i = 0; i < this._numPasses; ++i)
                this._passes[i].dispose();
            this._depthPass.dispose();
            this._depthPass.removeEventListener(feng3d.Event.CHANGE, this.onPassChange);
        };
        Object.defineProperty(MaterialBase.prototype, "namedAsset", {
            get: function () {
                return this._namedAsset;
            },
            enumerable: true,
            configurable: true
        });
        return MaterialBase;
    }(feng3d.Component));
    feng3d.MaterialBase = MaterialBase;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     *
     * @author feng 2014-5-19
     */
    var MultiPassMaterialBase = (function (_super) {
        __extends(MultiPassMaterialBase, _super);
        function MultiPassMaterialBase() {
            _super.call(this);
        }
        Object.defineProperty(MultiPassMaterialBase.prototype, "texture", {
            get: function () {
                return null;
            },
            set: function (value) {
            },
            enumerable: true,
            configurable: true
        });
        return MultiPassMaterialBase;
    }(feng3d.MaterialBase));
    feng3d.MultiPassMaterialBase = MultiPassMaterialBase;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     *
     * @author feng 2014-5-19
     */
    var ColorMultiPassMaterial = (function (_super) {
        __extends(ColorMultiPassMaterial, _super);
        function ColorMultiPassMaterial(color) {
            if (color === void 0) { color = 0xcccccc; }
            _super.call(this);
            this._ambientColor = 0xffffff;
            this._specularColor = 0xffffff;
            this._specular = 1;
        }
        Object.defineProperty(ColorMultiPassMaterial.prototype, "ambientColor", {
            get: function () {
                return this._ambientColor;
            },
            set: function (value) {
                this._ambientColor = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ColorMultiPassMaterial.prototype, "specularColor", {
            get: function () {
                return this._specularColor;
            },
            set: function (value) {
                this._specularColor = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ColorMultiPassMaterial.prototype, "specular", {
            get: function () {
                return this._specular;
            },
            set: function (value) {
                this._specular = value;
            },
            enumerable: true,
            configurable: true
        });
        return ColorMultiPassMaterial;
    }(feng3d.MultiPassMaterialBase));
    feng3d.ColorMultiPassMaterial = ColorMultiPassMaterial;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     *
     * @author feng 2014-5-19
     */
    var TextureMultiPassMaterial = (function (_super) {
        __extends(TextureMultiPassMaterial, _super);
        function TextureMultiPassMaterial(texture, smooth, repeat, mipmap) {
            if (texture === void 0) { texture = null; }
            if (smooth === void 0) { smooth = true; }
            if (repeat === void 0) { repeat = false; }
            if (mipmap === void 0) { mipmap = true; }
            _super.call(this);
            this._ambientColor = 0xffffff;
            this._specularMethod = new feng3d.BasicSpecularMethod();
            this._normalMethod = new feng3d.BasicNormalMethod();
            this.texture = texture;
        }
        Object.defineProperty(TextureMultiPassMaterial.prototype, "ambientColor", {
            get: function () {
                return this._ambientColor;
            },
            set: function (value) {
                this._ambientColor = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TextureMultiPassMaterial.prototype, "specularMethod", {
            get: function () {
                return this._specularMethod;
            },
            set: function (value) {
                this._specularMethod = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TextureMultiPassMaterial.prototype, "normalMap", {
            /**
             * The normal map to modulate the direction of the surface for each texel. The default normal method expects
             * tangent-space normal maps, but others could expect object-space maps.
             */
            get: function () {
                return this._normalMethod.normalMap;
            },
            set: function (value) {
                this._normalMethod.normalMap = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TextureMultiPassMaterial.prototype, "specularMap", {
            /**
             * 高光贴图
             *
             * A specular map that defines the strength of specular reflections for each texel in the red channel,
             * and the gloss factor in the green channel. You can use SpecularBitmapTexture if you want to easily set
             * specular and gloss maps from grayscale images, but correctly authored images are preferred.
             */
            get: function () {
                return this._specularMethod.texture;
            },
            set: function (value) {
                this._specularMethod.texture = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TextureMultiPassMaterial.prototype, "specular", {
            /**
             * The overall strength of the specular reflection.
             */
            get: function () {
                return this._specularMethod ? this._specularMethod.specular : 0;
            },
            set: function (value) {
                if (this._specularMethod)
                    this._specularMethod.specular = value;
            },
            enumerable: true,
            configurable: true
        });
        return TextureMultiPassMaterial;
    }(feng3d.MultiPassMaterialBase));
    feng3d.TextureMultiPassMaterial = TextureMultiPassMaterial;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 线段材质
     * @author feng 2014-4-16
     */
    var SegmentMaterial = (function (_super) {
        __extends(SegmentMaterial, _super);
        function SegmentMaterial(thickness) {
            if (thickness === void 0) { thickness = 1.25; }
            _super.call(this);
            this.bothSides = true;
            this.addPass(this._screenPass = new feng3d.SegmentPass(thickness));
        }
        return SegmentMaterial;
    }(feng3d.MaterialBase));
    feng3d.SegmentMaterial = SegmentMaterial;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 单通道纹理
     * @author feng 2014-6-5
     */
    var SinglePassMaterialBase = (function (_super) {
        __extends(SinglePassMaterialBase, _super);
        /**
         * 创建一个单通道纹理
         */
        function SinglePassMaterialBase() {
            _super.call(this);
            this.addPass(this._screenPass = new feng3d.SuperShaderPass());
        }
        Object.defineProperty(SinglePassMaterialBase.prototype, "numMethods", {
            /**
             * The number of "effect" methods added to the material.
             */
            get: function () {
                return this._screenPass.numMethods;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SinglePassMaterialBase.prototype, "blendMode", {
            /**
             * @inheritDoc
             */
            set: function (value) {
                _super.prototype.setBlendMode.call(this, value);
                this._screenPass.setBlendMode(this.blendMode == feng3d.BlendMode.NORMAL && this.requiresBlending ? feng3d.BlendMode.LAYER : this.blendMode);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SinglePassMaterialBase.prototype, "requiresBlending", {
            /**
             * @inheritDoc
             */
            get: function () {
                return _super.prototype.getRequiresBlending.call(this) || this._alphaBlending;
            },
            enumerable: true,
            configurable: true
        });
        /**
          * @inheritDoc
          */
        SinglePassMaterialBase.prototype.getRequiresBlending = function () {
            return this.requiresBlending;
        };
        Object.defineProperty(SinglePassMaterialBase.prototype, "alphaThreshold", {
            /**
             * The minimum alpha value for which pixels should be drawn. This is used for transparency that is either
             * invisible or entirely opaque, often used with textures for foliage, etc.
             * Recommended values are 0 to disable alpha, or 0.5 to create smooth edges. Default value is 0 (disabled).
             */
            get: function () {
                return this._screenPass.diffuseMethod.alphaThreshold;
            },
            set: function (value) {
                this._screenPass.diffuseMethod.alphaThreshold = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SinglePassMaterialBase.prototype, "ambientColor", {
            /**
             * 环境光反射颜色
             */
            get: function () {
                return this._screenPass.ambientMethod.ambientColor;
            },
            set: function (value) {
                this._screenPass.ambientMethod.ambientColor = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SinglePassMaterialBase.prototype, "specularColor", {
            /**
             * 镜面反射光反射颜色
             */
            get: function () {
                return this._screenPass.specularMethod.specularColor;
            },
            set: function (value) {
                this._screenPass.specularMethod.specularColor = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SinglePassMaterialBase.prototype, "specular", {
            /**
             * 镜面反射光反射强度
             */
            get: function () {
                return this._screenPass.specularMethod ? this._screenPass.specularMethod.specular : 0;
            },
            set: function (value) {
                if (this._screenPass.specularMethod)
                    this._screenPass.specularMethod.specular = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SinglePassMaterialBase.prototype, "ambient", {
            /**
             * 环境光反射强度
             */
            get: function () {
                return this._screenPass.ambientMethod.ambient;
            },
            set: function (value) {
                this._screenPass.ambientMethod.ambient = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SinglePassMaterialBase.prototype, "alphaBlending", {
            /**
             * 是否透明度混合
             */
            get: function () {
                return this._alphaBlending;
            },
            set: function (value) {
                this._alphaBlending = value;
                this._screenPass.setBlendMode(this.blendMode == feng3d.BlendMode.NORMAL && this.requiresBlending ? feng3d.BlendMode.LAYER : this.blendMode);
                //			this._screenPass.preserveAlpha = this.requiresBlending;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SinglePassMaterialBase.prototype, "diffuseMethod", {
            /**
             * 漫反射函数
             */
            get: function () {
                return this._screenPass.diffuseMethod;
            },
            set: function (value) {
                this._screenPass.diffuseMethod = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SinglePassMaterialBase.prototype, "normalMethod", {
            /**
             * The method used to generate the per-pixel normals. Defaults to BasicNormalMethod.
             */
            get: function () {
                return this._screenPass.normalMethod;
            },
            set: function (value) {
                this._screenPass.normalMethod = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SinglePassMaterialBase.prototype, "ambientMethod", {
            /**
             * 环境光函数
             */
            get: function () {
                return this._screenPass.ambientMethod;
            },
            set: function (value) {
                this._screenPass.ambientMethod = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SinglePassMaterialBase.prototype, "specularMethod", {
            /**
             * 镜面反射函数
             */
            get: function () {
                return this._screenPass.specularMethod;
            },
            set: function (value) {
                this._screenPass.specularMethod = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SinglePassMaterialBase.prototype, "normalMap", {
            /**
             * 法线贴图
             */
            get: function () {
                return this._screenPass.normalMethod.normalMap;
            },
            set: function (value) {
                this._screenPass.normalMethod.normalMap = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SinglePassMaterialBase.prototype, "specularMap", {
            /**
             * 镜面反射光泽图
             */
            get: function () {
                return this._screenPass.specularMethod.texture;
            },
            set: function (value) {
                if (this._screenPass.specularMethod)
                    this._screenPass.specularMethod.texture = value;
                else
                    throw new Error("No this.specular method was set to assign the specularGlossMap to");
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SinglePassMaterialBase.prototype, "gloss", {
            /**
             * 高光值
             */
            get: function () {
                return this._screenPass.specularMethod ? this._screenPass.specularMethod.gloss : 0;
            },
            set: function (value) {
                if (this._screenPass.specularMethod)
                    this._screenPass.specularMethod.gloss = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SinglePassMaterialBase.prototype, "shadowMethod", {
            /**
             * 阴影映射函数
             */
            get: function () {
                return this._screenPass.shadowMethod;
            },
            set: function (value) {
                this._screenPass.shadowMethod = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SinglePassMaterialBase.prototype, "lightPicker", {
            /**
             * @inheritDoc
             */
            set: function (value) {
                _super.prototype.setLightPicker.call(this, value);
                this._screenPass.lightPicker = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 添加特效函数
         * @param method		特效函数
         */
        SinglePassMaterialBase.prototype.addMethod = function (method) {
            this._screenPass.addMethod(method);
        };
        return SinglePassMaterialBase;
    }(feng3d.MaterialBase));
    feng3d.SinglePassMaterialBase = SinglePassMaterialBase;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 颜色材质
     * @author feng 2014-4-15
     */
    var ColorMaterial = (function (_super) {
        __extends(ColorMaterial, _super);
        function ColorMaterial(color, alpha) {
            if (color === void 0) { color = 0xcccccc; }
            if (alpha === void 0) { alpha = 1; }
            _super.call(this);
            this._diffuseAlpha = 1;
            this.color = color;
            this.alpha = alpha;
        }
        Object.defineProperty(ColorMaterial.prototype, "alpha", {
            /**
             * 透明度
             */
            get: function () {
                return this._screenPass.diffuseMethod.diffuseAlpha;
            },
            set: function (value) {
                if (value > 1)
                    value = 1;
                else if (value < 0)
                    value = 0;
                this._screenPass.diffuseMethod.diffuseAlpha = this._diffuseAlpha = value;
                this._screenPass.setBlendMode(this.blendMode == feng3d.BlendMode.NORMAL && this.requiresBlending ? feng3d.BlendMode.LAYER : this.blendMode);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ColorMaterial.prototype, "color", {
            /**
             * 颜色
             */
            get: function () {
                return this._screenPass.diffuseMethod.diffuseColor;
            },
            set: function (value) {
                this._screenPass.diffuseMethod.diffuseColor = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ColorMaterial.prototype, "requiresBlending", {
            get: function () {
                return _super.prototype.getRequiresBlending.call(this) || this._diffuseAlpha < 1;
            },
            enumerable: true,
            configurable: true
        });
        return ColorMaterial;
    }(feng3d.SinglePassMaterialBase));
    feng3d.ColorMaterial = ColorMaterial;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 纹理材质
     * @author feng 2014-4-15
     */
    var TextureMaterial = (function (_super) {
        __extends(TextureMaterial, _super);
        /**
         * 创建纹理材质
         * @param texture		纹理
         * @param smooth		是否平滑
         * @param repeat		是否重复
         * @param mipmap		是否使用mipmap
         */
        function TextureMaterial(texture, smooth, repeat, mipmap) {
            if (texture === void 0) { texture = null; }
            if (smooth === void 0) { smooth = true; }
            if (repeat === void 0) { repeat = false; }
            if (mipmap === void 0) { mipmap = true; }
            _super.call(this);
            this.texture = texture;
            this.smooth = smooth;
            this.repeat = repeat;
            this.mipmap = mipmap;
        }
        Object.defineProperty(TextureMaterial.prototype, "texture", {
            /**
             * 纹理
             */
            get: function () {
                return this._screenPass.diffuseMethod.texture;
            },
            set: function (value) {
                this._screenPass.diffuseMethod.texture = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TextureMaterial.prototype, "alpha", {
            /**
             * 透明度
             */
            get: function () {
                return this._alpha;
            },
            set: function (value) {
                this._alpha = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TextureMaterial.prototype, "ambientTexture", {
            /**
             * The texture object to use for the ambient colour.
             */
            get: function () {
                return this._screenPass.ambientMethod.texture;
            },
            set: function (value) {
                this._screenPass.ambientMethod.texture = value;
            },
            enumerable: true,
            configurable: true
        });
        return TextureMaterial;
    }(feng3d.SinglePassMaterialBase));
    feng3d.TextureMaterial = TextureMaterial;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * SpriteSheet材质
     * @author feng 2014-4-15
     */
    var SpriteSheetMaterial = (function (_super) {
        __extends(SpriteSheetMaterial, _super);
        /**
         * 创建SpriteSheetMaterial实例
         *
         * @param diffuses			漫反射纹理列表
         * @param normals			法线纹理列表
         * @param speculars			高光纹理列表
         * @param smooth			是否平滑
         * @param repeat			是否重复
         * @param mipmap			是否使用mipmap
         */
        function SpriteSheetMaterial(diffuses, normals, speculars, smooth, repeat, mipmap) {
            if (normals === void 0) { normals = null; }
            if (speculars === void 0) { speculars = null; }
            if (smooth === void 0) { smooth = true; }
            if (repeat === void 0) { repeat = false; }
            if (mipmap === void 0) { mipmap = true; }
            _super.call(this, diffuses[0], smooth, repeat, mipmap);
            this._diffuses = diffuses;
            this._normals = normals;
            this._speculars = speculars;
            this.initTextures();
            if (this._TBNormal)
                this.normalMap = this._TBNormal;
            if (this._TBSpecular)
                this.specularMap = this._TBSpecular;
        }
        SpriteSheetMaterial.prototype.initTextures = function () {
            if (!this._diffuses || this._diffuses.length == 0)
                throw new Error("you must pass at least one bitmapdata into diffuses param!");
            this._TBDiffuse = this._diffuses[0];
            if (this._normals && this._normals.length > 0) {
                if (this._normals.length != this._diffuses.length)
                    throw new Error("The amount of normals bitmapDatas must be same as the amount of diffuses param!");
                this._TBNormal = this._normals[0];
            }
            if (this._speculars && this._speculars.length > 0) {
                if (this._speculars.length != this._diffuses.length)
                    throw new Error("The amount of normals bitmapDatas must be same as the amount of diffuses param!");
                this._TBSpecular = this._speculars[0];
            }
            this._currentMapID = 0;
        };
        /**
         * 切换
         * @param mapID			映射编号
         * @return				是否切换成功
         */
        SpriteSheetMaterial.prototype.swap = function (mapID) {
            if (mapID === void 0) { mapID = 0; }
            if (this._currentMapID != mapID) {
                this._currentMapID = mapID;
                this._TBDiffuse = this._diffuses[mapID];
                this.texture = this._TBDiffuse;
                if (this._TBNormal)
                    this.normalMap = this._TBNormal = this._normals[mapID];
                if (this._TBSpecular)
                    this.specularMap = this._TBSpecular = this._speculars[mapID];
                return true;
            }
            return false;
        };
        return SpriteSheetMaterial;
    }(feng3d.TextureMaterial));
    feng3d.SpriteSheetMaterial = SpriteSheetMaterial;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 天空盒材质
     * @author feng 2014-7-11
     */
    var SkyBoxMaterial = (function (_super) {
        __extends(SkyBoxMaterial, _super);
        /**
         * 创建天空盒材质实例
         * @param cubeMap			立方体映射纹理
         */
        function SkyBoxMaterial(cubeMap) {
            _super.call(this);
            this._cubeMap = cubeMap;
            this.addPass(this._skyboxPass = new feng3d.SkyBoxPass());
            this._skyboxPass.cubeTexture = this._cubeMap;
        }
        Object.defineProperty(SkyBoxMaterial.prototype, "cubeMap", {
            /**
             * 立方体映射纹理
             */
            get: function () {
                return this._cubeMap;
            },
            set: function (value) {
                if (value && this._cubeMap && (value.hasMipMaps != this._cubeMap.hasMipMaps || value.format != this._cubeMap.format))
                    this.invalidatePasses(null);
                this._cubeMap = value;
                this._skyboxPass.cubeTexture = this._cubeMap;
            },
            enumerable: true,
            configurable: true
        });
        return SkyBoxMaterial;
    }(feng3d.MaterialBase));
    feng3d.SkyBoxMaterial = SkyBoxMaterial;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 纹理通道基类
     * <p>该类实现了生成与管理渲染程序功能</p>
     * @author feng 2014-4-15
     */
    var MaterialPassBase = (function (_super) {
        __extends(MaterialPassBase, _super);
        /**
         * 创建一个纹理通道基类
         */
        function MaterialPassBase() {
            _super.call(this);
            this._blendFactorSource = feng3d.Context3DBlendFactor.ONE;
            this._blendFactorDest = feng3d.Context3DBlendFactor.ZERO;
            this._depthCompareMode = feng3d.Context3DCompareMode.LESS_EQUAL;
            this._defaultCulling = feng3d.Context3DTriangleFace.BACK;
            this._writeDepth = true;
            this._smooth = true;
            this._repeat = false;
            this._mipmap = true;
            this.context3DBufferOwner = new feng3d.Context3DBufferOwner();
            this.initBuffers();
        }
        Object.defineProperty(MaterialPassBase.prototype, "_", {
            /**
             * Fagal编号中心
             */
            get: function () {
                return feng3d.FagalIdCenter.instance;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialPassBase.prototype, "material", {
            /**
             * The material to which this pass belongs.
             */
            get: function () {
                return this._material;
            },
            set: function (value) {
                this._material = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialPassBase.prototype, "shaderParams", {
            /**
             * 渲染参数
             */
            get: function () {
                return this._shaderParams = this._shaderParams || new feng3d.ShaderParams();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialPassBase.prototype, "smooth", {
            /**
             * 是否平滑
             */
            get: function () {
                return this._smooth;
            },
            set: function (value) {
                if (this._smooth == value)
                    return;
                this._smooth = value;
                this.invalidateShaderProgram();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialPassBase.prototype, "repeat", {
            /**
             * 是否重复平铺
             */
            get: function () {
                return this._repeat;
            },
            set: function (value) {
                if (this._repeat == value)
                    return;
                this._repeat = value;
                this.invalidateShaderProgram();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialPassBase.prototype, "mipmap", {
            /**
             * 贴图是否使用分级细化
             */
            get: function () {
                return this._mipmap;
            },
            set: function (value) {
                if (this._mipmap == value)
                    return;
                this._mipmap = value;
                this.invalidateShaderProgram();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialPassBase.prototype, "enableBlending", {
            /**
             * 是否开启混合模式
             */
            get: function () {
                return this._enableBlending;
            },
            set: function (value) {
                this._enableBlending = value;
                this.context3DBufferOwner.markBufferDirty(this._.blendFactors);
                this.context3DBufferOwner.markBufferDirty(this._.depthTest);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 初始化Context3d缓存
         */
        MaterialPassBase.prototype.initBuffers = function () {
            this.context3DBufferOwner.mapContext3DBuffer(this._.culling, this.updateCullingBuffer);
            this.context3DBufferOwner.mapContext3DBuffer(this._.blendFactors, this.updateBlendFactorsBuffer);
            this.context3DBufferOwner.mapContext3DBuffer(this._.depthTest, this.updateDepthTestBuffer);
            this.context3DBufferOwner.mapContext3DBuffer(this._.program, this.updateProgramBuffer);
        };
        Object.defineProperty(MaterialPassBase.prototype, "animationSet", {
            /**
             * 动画数据集合
             */
            get: function () {
                return this._animationSet;
            },
            set: function (value) {
                if (this._animationSet == value)
                    return;
                this._animationSet = value;
                this.invalidateShaderProgram();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 激活渲染通道
         * @param shaderParams		渲染参数
         * @param stage3DProxy		3D舞台代理
         * @param camera			摄像机
         */
        MaterialPassBase.prototype.activate = function (camera, target) {
            if (target === void 0) { target = null; }
            this.shaderParams.useMipmapping = this._mipmap;
            this.shaderParams.useSmoothTextures = this._smooth;
            this.shaderParams.repeatTextures = this._repeat;
            this.shaderParams.alphaPremultiplied = this._alphaPremultiplied && this._enableBlending;
            if (this._animationSet)
                this._animationSet.activate(this.shaderParams, this);
        };
        /**
         * 清除通道渲染数据
         * @param stage3DProxy		3D舞台代理
         */
        MaterialPassBase.prototype.deactivate = function () {
        };
        /**
         * 更新动画状态
         * @param renderable			渲染对象
         * @param stage3DProxy			3D舞台代理
         * @param camera				摄像机
         */
        MaterialPassBase.prototype.updateAnimationState = function (renderable, camera) {
            renderable.animator.setRenderState(renderable, camera);
        };
        /**
         * 渲染
         * @param renderable			渲染对象
         * @param stage3DProxy			3D舞台代理
         * @param camera				摄像机
         * @param renderIndex			渲染编号
         */
        MaterialPassBase.prototype.render = function (renderable, stage3DProxy, camera, renderIndex) {
            this.updateConstantData(renderable, camera);
            var context3dCache = renderable.context3dCache;
            context3dCache.addChildBufferOwner(this.context3DBufferOwner);
            //设置渲染参数
            context3dCache.shaderParams = this.shaderParams;
            if (renderable.animator)
                this.updateAnimationState(renderable, camera);
            //绘制图形
            context3dCache.render(stage3DProxy.context3D, renderIndex);
            context3dCache.removeChildBufferOwner(this.context3DBufferOwner);
        };
        /**
         * 更新常量数据
         * @param renderable			渲染对象
         * @param camera				摄像机
         */
        MaterialPassBase.prototype.updateConstantData = function (renderable, camera) {
        };
        /**
         * 标记渲染程序失效
         */
        MaterialPassBase.prototype.invalidateShaderProgram = function () {
            this.context3DBufferOwner.markBufferDirty(this._.program);
        };
        /**
         * 更新深度测试缓冲
         * @param depthTestBuffer			深度测试缓冲
         */
        MaterialPassBase.prototype.updateDepthTestBuffer = function (depthTestBuffer) {
            depthTestBuffer.update(this._writeDepth && !this.enableBlending, this._depthCompareMode);
        };
        /**
         * 更新混合因子缓冲
         * @param blendFactorsBuffer		混合因子缓冲
         */
        MaterialPassBase.prototype.updateBlendFactorsBuffer = function (blendFactorsBuffer) {
            blendFactorsBuffer.update(this._blendFactorSource, this._blendFactorDest);
        };
        /**
         * 更新剔除模式缓冲
         * @param cullingBuffer		剔除模式缓冲
         */
        MaterialPassBase.prototype.updateCullingBuffer = function (cullingBuffer) {
            cullingBuffer.update(this._bothSides ? feng3d.Context3DTriangleFace.NONE : this._defaultCulling);
        };
        /**
         * 更新（编译）渲染程序
         */
        MaterialPassBase.prototype.updateProgramBuffer = function (programBuffer) {
            var result = feng3d.FagalRE.runShader(feng3d.V_Main, feng3d.F_Main);
            //上传程序
            programBuffer.update(result.vertexCode, result.fragmentCode);
        };
        Object.defineProperty(MaterialPassBase.prototype, "lightPicker", {
            /**
             * 灯光采集器
             */
            get: function () {
                return this._lightPicker;
            },
            set: function (value) {
                if (this._lightPicker)
                    this._lightPicker.removeEventListener(feng3d.Event.CHANGE, this.onLightsChange);
                this._lightPicker = value;
                if (this._lightPicker)
                    this._lightPicker.addEventListener(feng3d.Event.CHANGE, this.onLightsChange);
                this.updateLights();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 灯光发生变化
         */
        MaterialPassBase.prototype.onLightsChange = function (event) {
            this.updateLights();
        };
        /**
         * 更新灯光渲染
         */
        MaterialPassBase.prototype.updateLights = function () {
            if (this._lightPicker) {
                this._numPointLights = this._lightPicker.numPointLights;
                this._numDirectionalLights = this._lightPicker.numDirectionalLights;
            }
            this.invalidateShaderProgram();
        };
        /**
         * 设置混合模式
         * @param value		混合模式
         */
        MaterialPassBase.prototype.setBlendMode = function (value) {
            switch (value) {
                case feng3d.BlendMode.NORMAL:
                    this._blendFactorSource = feng3d.Context3DBlendFactor.ONE;
                    this._blendFactorDest = feng3d.Context3DBlendFactor.ZERO;
                    this.enableBlending = false;
                    break;
                case feng3d.BlendMode.LAYER:
                    this._blendFactorSource = feng3d.Context3DBlendFactor.SOURCE_ALPHA;
                    this._blendFactorDest = feng3d.Context3DBlendFactor.ONE_MINUS_SOURCE_ALPHA;
                    this.enableBlending = true;
                    break;
                case feng3d.BlendMode.MULTIPLY:
                    this._blendFactorSource = feng3d.Context3DBlendFactor.ZERO;
                    this._blendFactorDest = feng3d.Context3DBlendFactor.SOURCE_COLOR;
                    this.enableBlending = true;
                    break;
                case feng3d.BlendMode.ADD:
                    this._blendFactorSource = feng3d.Context3DBlendFactor.SOURCE_ALPHA;
                    this._blendFactorDest = feng3d.Context3DBlendFactor.ONE;
                    this.enableBlending = true;
                    break;
                case feng3d.BlendMode.ALPHA:
                    this._blendFactorSource = feng3d.Context3DBlendFactor.ZERO;
                    this._blendFactorDest = feng3d.Context3DBlendFactor.SOURCE_ALPHA;
                    this.enableBlending = true;
                    break;
                case feng3d.BlendMode.SCREEN:
                    this._blendFactorSource = feng3d.Context3DBlendFactor.ONE;
                    this._blendFactorDest = feng3d.Context3DBlendFactor.ONE_MINUS_SOURCE_COLOR;
                    this.enableBlending = true;
                    break;
                default:
                    throw new ArgumentError("Unsupported blend mode!");
            }
        };
        Object.defineProperty(MaterialPassBase.prototype, "writeDepth", {
            /**
             * 是否写入到深度缓存
             */
            get: function () {
                return this._writeDepth;
            },
            set: function (value) {
                this._writeDepth = value;
                this.context3DBufferOwner.markBufferDirty(this._.depthTest);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialPassBase.prototype, "depthCompareMode", {
            /**
             * 深度比较模式
             */
            get: function () {
                return this._depthCompareMode;
            },
            set: function (value) {
                this._depthCompareMode = value;
                this.context3DBufferOwner.markBufferDirty(this._.depthTest);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialPassBase.prototype, "bothSides", {
            /**
             * 是否双面渲染
             */
            get: function () {
                return this._bothSides;
            },
            set: function (value) {
                this._bothSides = value;
                this.context3DBufferOwner.markBufferDirty(this._.culling);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 渲染中是否使用了灯光
         */
        MaterialPassBase.prototype.usesLights = function () {
            return (this._numPointLights > 0 || this._numDirectionalLights > 0);
        };
        Object.defineProperty(MaterialPassBase.prototype, "alphaPremultiplied", {
            /**
             * Indicates whether visible textures (or other pixels) used by this material have
             * already been premultiplied. Toggle this if you are seeing black halos around your
             * blended alpha edges.
             */
            get: function () {
                return this._alphaPremultiplied;
            },
            set: function (value) {
                this._alphaPremultiplied = value;
                this.invalidateShaderProgram();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Cleans up any resources used by the current object.
         * @param deep Indicates whether other resources should be cleaned up, that could potentially be shared across different instances.
         */
        MaterialPassBase.prototype.dispose = function () {
            if (this._lightPicker)
                this._lightPicker.removeEventListener(feng3d.Event.CHANGE, this.onLightsChange);
        };
        return MaterialPassBase;
    }(feng3d.Component));
    feng3d.MaterialPassBase = MaterialPassBase;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 编译通道
     * <p>用于处理复杂的渲染通道</p>
     * @author feng 2014-6-5
     */
    var CompiledPass = (function (_super) {
        __extends(CompiledPass, _super);
        /**
         * 创建一个编译通道类
         */
        function CompiledPass() {
            _super.call(this);
            /**
             * 物体投影变换矩阵（模型空间坐标-->GPU空间坐标）
             */
            this.modelViewProjection = new feng3d.Matrix3D();
            /**
             * 法线场景变换矩阵（模型空间坐标-->世界空间坐标）
             */
            this.normalSceneMatrix = new feng3d.Matrix3D();
            /**
             * 场景变换矩阵（模型空间坐标-->世界空间坐标）
             */
            this.sceneTransformMatrix = new feng3d.Matrix3D();
            /**
             * 世界投影矩阵（世界空间坐标-->投影空间坐标）
             */
            this.worldProjectionMatrix = new feng3d.Matrix3D();
            /**
             * 通用数据
             */
            this.commonsData = [0.5, 0, 1 / 255, 1];
            /**
             * 摄像机世界坐标
             */
            this.cameraPosition = [0, 0, 0, 0];
            /**
             * 是否开启灯光衰减
             */
            this._enableLightFallOff = true;
            this.init();
        }
        /**
         * 初始化
         */
        CompiledPass.prototype.init = function () {
            this._methodSetup = new feng3d.ShaderMethodSetup();
            this._methodSetup.addEventListener(feng3d.ShadingMethodEvent.SHADER_INVALIDATED, this.onShaderInvalidated);
            this.context3DBufferOwner.addChildBufferOwner(this._methodSetup.context3DBufferOwner);
        };
        /**
         * @inheritDoc
         */
        CompiledPass.prototype.initBuffers = function () {
            _super.prototype.initBuffers.call(this);
            this.context3DBufferOwner.mapContext3DBuffer(this._.commonsData_fc_vector, this.updateCommonsDataBuffer);
            this.context3DBufferOwner.mapContext3DBuffer(this._.cameraPosition_vc_vector, this.updateCameraPositionBuffer);
            this.context3DBufferOwner.mapContext3DBuffer(this._.projection_vc_matrix, this.updateProjectionBuffer);
            this.context3DBufferOwner.mapContext3DBuffer(this._.normalSceneTransform_vc_matrix, this.updateSceneNormalMatrixBuffer);
            this.context3DBufferOwner.mapContext3DBuffer(this._.sceneTransform_vc_matrix, this.updateSceneTransformMatrixBuffer);
            this.context3DBufferOwner.mapContext3DBuffer(this._.wordProjection_vc_matrix, this.updateWordProjectionMatrixBuffer);
        };
        /**
         * @inheritDoc
         */
        CompiledPass.prototype.activate = function (camera, target) {
            if (target === void 0) { target = null; }
            _super.prototype.activate.call(this, camera, target);
            var lightShaderParams = this.shaderParams.getOrCreateComponentByClass(feng3d.LightShaderParams);
            lightShaderParams.useLightFallOff = this._enableLightFallOff;
            this._methodSetup.activate(this.shaderParams);
            this._ambientLightR = this._ambientLightG = this._ambientLightB = 0;
            if (this.usesLights())
                this.updateLightConstants();
            var ambientMethod = this._methodSetup.ambientMethod;
            ambientMethod._lightAmbientR = this._ambientLightR;
            ambientMethod._lightAmbientG = this._ambientLightG;
            ambientMethod._lightAmbientB = this._ambientLightB;
        };
        /**
         * @inheritDoc
         */
        CompiledPass.prototype.updateConstantData = function (renderable, camera) {
            _super.prototype.updateConstantData.call(this, renderable, camera);
            //场景变换矩阵（物体坐标-->世界坐标）
            var sceneTransform = renderable.sourceEntity.getRenderSceneTransform(camera);
            //投影矩阵（世界坐标-->投影坐标）
            var projectionmatrix = camera.viewProjection;
            //全局变换矩阵
            this.sceneTransformMatrix.copyFrom(sceneTransform);
            //投影矩阵
            this.worldProjectionMatrix.copyFrom(projectionmatrix);
            //法线全局变换矩阵
            this.normalSceneMatrix.copyFrom(sceneTransform);
            //物体投影变换矩阵
            this.modelViewProjection.identity();
            this.modelViewProjection.append(sceneTransform);
            this.modelViewProjection.append(projectionmatrix);
            //摄像机世界坐标
            this.cameraPosition[0] = camera.scenePosition.x;
            this.cameraPosition[1] = camera.scenePosition.y;
            this.cameraPosition[2] = camera.scenePosition.z;
            this.cameraPosition[3] = 1;
            this._methodSetup.setRenderState(renderable, camera);
        };
        /**
         * 更新摄像机坐标缓冲
         * @param cameraPositionBuffer		摄像机坐标缓冲
         */
        CompiledPass.prototype.updateCameraPositionBuffer = function (cameraPositionBuffer) {
            cameraPositionBuffer.update(this.cameraPosition);
        };
        /**
         * 更新通用缓冲
         * @param commonsDataBuffer		通用缓冲
         */
        CompiledPass.prototype.updateCommonsDataBuffer = function (commonsDataBuffer) {
            commonsDataBuffer.update(this.commonsData);
        };
        /**
         * 更新投影矩阵缓冲
         * @param projectionBuffer		投影矩阵缓冲
         */
        CompiledPass.prototype.updateProjectionBuffer = function (projectionBuffer) {
            projectionBuffer.update(this.modelViewProjection, true);
        };
        /**
         * 更新摄像机投影矩阵缓冲
         * @param cameraProjectionMatrixBuffer		摄像机投影矩阵缓冲
         */
        CompiledPass.prototype.updateWordProjectionMatrixBuffer = function (worldProjectionMatrixBuffer) {
            worldProjectionMatrixBuffer.update(this.worldProjectionMatrix, true);
        };
        /**
         * 更新场景变换矩阵缓冲
         * @param sceneTransformMatrixBuffer		场景变换矩阵缓冲
         */
        CompiledPass.prototype.updateSceneTransformMatrixBuffer = function (sceneTransformMatrixBuffer) {
            sceneTransformMatrixBuffer.update(this.sceneTransformMatrix, true);
        };
        /**
         * 更新法线场景变换矩阵缓冲
         * @param normalSceneMatrixBuffer			法线场景变换矩阵缓冲
         */
        CompiledPass.prototype.updateSceneNormalMatrixBuffer = function (normalSceneMatrixBuffer) {
            normalSceneMatrixBuffer.update(this.normalSceneMatrix, true);
        };
        /**
         * @inheritDoc
         */
        CompiledPass.prototype.updateProgramBuffer = function (programBuffer) {
            this.reset();
            _super.prototype.updateProgramBuffer.call(this, programBuffer);
        };
        /**
         * 重置编译通道
         */
        CompiledPass.prototype.reset = function () {
            this.initConstantData();
        };
        /**
         * 初始化常量数据
         */
        CompiledPass.prototype.initConstantData = function () {
            this.updateMethodConstants();
        };
        /**
         * 更新函数常量数据
         */
        CompiledPass.prototype.updateMethodConstants = function () {
            this._methodSetup.initConstants();
        };
        Object.defineProperty(CompiledPass.prototype, "diffuseMethod", {
            /**
             * 漫反射方法，默认为BasicDiffuseMethod
             */
            get: function () {
                return this._methodSetup.diffuseMethod;
            },
            set: function (value) {
                this._methodSetup.diffuseMethod = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CompiledPass.prototype, "specularMethod", {
            /**
             * 镜面反射方法，默认为BasicSpecularMethod
             */
            get: function () {
                return this._methodSetup.specularMethod;
            },
            set: function (value) {
                this._methodSetup.specularMethod = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CompiledPass.prototype, "ambientMethod", {
            /**
             * 环境光方法，默认为BasicAmbientMethod
             */
            get: function () {
                return this._methodSetup.ambientMethod;
            },
            set: function (value) {
                this._methodSetup.ambientMethod = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CompiledPass.prototype, "normalMethod", {
            /**
             * 法线函数，默认为BasicNormalMethod
             */
            get: function () {
                return this._methodSetup.normalMethod;
            },
            set: function (value) {
                this._methodSetup.normalMethod = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CompiledPass.prototype, "enableLightFallOff", {
            /**
             * 是否开启灯光衰减，可以提高灯光渲染性能与真实性
             */
            get: function () {
                return this._enableLightFallOff;
            },
            set: function (value) {
                if (value != this._enableLightFallOff)
                    this.invalidateShaderProgram();
                this._enableLightFallOff = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 处理渲染失效事件
         */
        CompiledPass.prototype.onShaderInvalidated = function (event) {
            var oldPasses = this._passes;
            this._passes = [];
            if (this._methodSetup)
                this.addPassesFromMethods();
            this.invalidateShaderProgram();
        };
        /**
         * Adds any possible passes needed by the used methods.
         */
        CompiledPass.prototype.addPassesFromMethods = function () {
            if (this._methodSetup.normalMethod && this._methodSetup.normalMethod.hasOutput)
                this.addPasses(this._methodSetup.normalMethod.passes);
            if (this._methodSetup.ambientMethod)
                this.addPasses(this._methodSetup.ambientMethod.passes);
            if (this._methodSetup.shadowMethod)
                this.addPasses(this._methodSetup.shadowMethod.passes);
            if (this._methodSetup.diffuseMethod)
                this.addPasses(this._methodSetup.diffuseMethod.passes);
            if (this._methodSetup.specularMethod)
                this.addPasses(this._methodSetup.specularMethod.passes);
        };
        /**
         * Adds internal passes to the material.
         *
         * @param passes The passes to add.
         */
        CompiledPass.prototype.addPasses = function (passes) {
            if (!passes)
                return;
            var len = passes.length;
            for (var i = 0; i < len; ++i) {
                passes[i].material = this.material;
                passes[i].lightPicker = this._lightPicker;
                this._passes.push(passes[i]);
            }
        };
        /**
         * 更新灯光常数数据
         */
        CompiledPass.prototype.updateLightConstants = function () {
        };
        Object.defineProperty(CompiledPass.prototype, "shadowMethod", {
            /**
             * 阴影映射函数
             */
            get: function () {
                return this._methodSetup.shadowMethod;
            },
            set: function (value) {
                this._methodSetup.shadowMethod = value;
            },
            enumerable: true,
            configurable: true
        });
        return CompiledPass;
    }(feng3d.MaterialPassBase));
    feng3d.CompiledPass = CompiledPass;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 超级渲染通道
     * <p>提供灯光渲染相关信息</p>
     * @author feng 2014-7-1
     */
    var SuperShaderPass = (function (_super) {
        __extends(SuperShaderPass, _super);
        /**
         * 创建超级渲染通道
         */
        function SuperShaderPass() {
            _super.call(this);
            /** 方向光源场景方向数据 */
            this.dirLightSceneDirData = [];
            /** 方向光源漫反射光颜色数据 */
            this.dirLightDiffuseData = [];
            /** 方向光源镜面反射颜色数据 */
            this.dirLightSpecularData = [];
            /** 点光源场景位置数据 */
            this.pointLightScenePositionData = [];
            /** 点光源漫反射光颜色数据 */
            this.pointLightDiffuseData = [];
            /** 点光源镜面反射颜色数据 */
            this.pointLightSpecularData = [];
        }
        Object.defineProperty(SuperShaderPass.prototype, "numMethods", {
            /**
             * The number of "effect" methods added to the material.
             */
            get: function () {
                return this._methodSetup.numMethods;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        SuperShaderPass.prototype.initBuffers = function () {
            _super.prototype.initBuffers.call(this);
            this.context3DBufferOwner.mapContext3DBuffer(this._.dirLightSceneDir_fc_vector, this.updateDirLightSceneDirBuffer);
            this.context3DBufferOwner.mapContext3DBuffer(this._.dirLightDiffuse_fc_vector, this.updateDirLightDiffuseReg);
            this.context3DBufferOwner.mapContext3DBuffer(this._.dirLightSpecular_fc_vector, this.updateDirLightSpecularBuffer);
            this.context3DBufferOwner.mapContext3DBuffer(this._.pointLightScenePos_fc_vector, this.updatePointLightScenePositionBuffer);
            this.context3DBufferOwner.mapContext3DBuffer(this._.pointLightDiffuse_fc_vector, this.updatePointLightDiffuseReg);
            this.context3DBufferOwner.mapContext3DBuffer(this._.pointLightSpecular_fc_vector, this.updatePointLightSpecularBuffer);
        };
        SuperShaderPass.prototype.updateDirLightSpecularBuffer = function (dirLightSpecularBuffer) {
            dirLightSpecularBuffer.update(this.dirLightSpecularData);
        };
        SuperShaderPass.prototype.updateDirLightDiffuseReg = function (dirLightDiffuseBuffer) {
            dirLightDiffuseBuffer.update(this.dirLightDiffuseData);
        };
        SuperShaderPass.prototype.updateDirLightSceneDirBuffer = function (dirLightSceneDirBuffer) {
            dirLightSceneDirBuffer.update(this.dirLightSceneDirData);
        };
        SuperShaderPass.prototype.updatePointLightSpecularBuffer = function (pointLightSpecularBuffer) {
            pointLightSpecularBuffer.update(this.pointLightSpecularData);
        };
        SuperShaderPass.prototype.updatePointLightDiffuseReg = function (pointLightDiffuseBuffer) {
            pointLightDiffuseBuffer.update(this.pointLightDiffuseData);
        };
        SuperShaderPass.prototype.updatePointLightScenePositionBuffer = function (pointLightScenePositionBuffer) {
            pointLightScenePositionBuffer.update(this.pointLightScenePositionData);
        };
        /**
         * 添加特效函数
         * @param method		特效函数
         */
        SuperShaderPass.prototype.addMethod = function (method) {
            this._methodSetup.addMethod(method);
        };
        /**
         * @inheritDoc
         */
        SuperShaderPass.prototype.activate = function (camera, target) {
            if (target === void 0) { target = null; }
            if (this._lightPicker) {
                var lightShaderParams = this.shaderParams.getOrCreateComponentByClass(feng3d.LightShaderParams);
                lightShaderParams.numPointLights = this._lightPicker.numPointLights;
                lightShaderParams.numDirectionalLights = this._lightPicker.numDirectionalLights;
            }
            var methods = this._methodSetup.methods;
            var len = methods.length;
            for (var i = 0; i < len; ++i) {
                methods[i].activate(this.shaderParams);
            }
            _super.prototype.activate.call(this, camera);
        };
        /**
         * @inheritDoc
         */
        SuperShaderPass.prototype.updateLightConstants = function () {
            var dirLight;
            var pointLight;
            var sceneDirection;
            var scenePosition;
            var len;
            var i, k;
            var dirLights = this._lightPicker.directionalLights;
            len = dirLights.length;
            for (i = 0; i < len; ++i) {
                dirLight = dirLights[i];
                sceneDirection = dirLight.sceneDirection;
                this._ambientLightR += dirLight._ambientR;
                this._ambientLightG += dirLight._ambientG;
                this._ambientLightB += dirLight._ambientB;
                this.dirLightSceneDirData[i * 4 + 0] = -sceneDirection.x;
                this.dirLightSceneDirData[i * 4 + 1] = -sceneDirection.y;
                this.dirLightSceneDirData[i * 4 + 2] = -sceneDirection.z;
                this.dirLightSceneDirData[i * 4 + 3] = 1;
                this.dirLightDiffuseData[i * 4 + 0] = dirLight._diffuseR;
                this.dirLightDiffuseData[i * 4 + 1] = dirLight._diffuseG;
                this.dirLightDiffuseData[i * 4 + 2] = dirLight._diffuseB;
                this.dirLightDiffuseData[i * 4 + 3] = 1;
                this.dirLightSpecularData[i * 4 + 0] = dirLight._specularR;
                this.dirLightSpecularData[i * 4 + 1] = dirLight._specularG;
                this.dirLightSpecularData[i * 4 + 2] = dirLight._specularB;
                this.dirLightSpecularData[i * 4 + 3] = 1;
            }
            var pointLights = this._lightPicker.pointLights;
            len = pointLights.length;
            for (i = 0; i < len; ++i) {
                pointLight = pointLights[i];
                scenePosition = pointLight.scenePosition;
                this._ambientLightR += pointLight._ambientR;
                this._ambientLightG += pointLight._ambientG;
                this._ambientLightB += pointLight._ambientB;
                this.pointLightScenePositionData[i * 4 + 0] = scenePosition.x;
                this.pointLightScenePositionData[i * 4 + 1] = scenePosition.y;
                this.pointLightScenePositionData[i * 4 + 2] = scenePosition.z;
                this.pointLightScenePositionData[i * 4 + 3] = 1;
                this.pointLightDiffuseData[i * 4 + 0] = pointLight._diffuseR;
                this.pointLightDiffuseData[i * 4 + 1] = pointLight._diffuseG;
                this.pointLightDiffuseData[i * 4 + 2] = pointLight._diffuseB;
                this.pointLightDiffuseData[i * 4 + 3] = pointLight._radius * pointLight._radius;
                this.pointLightSpecularData[i * 4 + 0] = pointLight._specularR;
                this.pointLightSpecularData[i * 4 + 1] = pointLight._specularG;
                this.pointLightSpecularData[i * 4 + 2] = pointLight._specularB;
                this.pointLightSpecularData[i * 4 + 3] = pointLight._fallOffFactor;
            }
        };
        return SuperShaderPass;
    }(feng3d.CompiledPass));
    feng3d.SuperShaderPass = SuperShaderPass;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 深度映射通道
     * @author feng 2015-5-29
     */
    var DepthMapPass = (function (_super) {
        __extends(DepthMapPass, _super);
        /**
         * 创建深度映射通道
         */
        function DepthMapPass() {
            _super.call(this);
            /**
             * 物体投影变换矩阵（模型空间坐标-->GPU空间坐标）
             */
            this.modelViewProjection = new feng3d.Matrix3D();
            /**
             * 通用数据
             */
            this.depthCommonsData0 = [1.0, 255.0, 255.0 * 255.0, 255.0 * 255.0 * 255.0];
            /**
             * 通用数据
             */
            this.depthCommonsData1 = [1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0];
        }
        Object.defineProperty(DepthMapPass.prototype, "depthMap", {
            /**
             * 深度图纹理
             */
            get: function () {
                return this._depthMap;
            },
            set: function (value) {
                this._depthMap = value;
                this.context3DBufferOwner.markBufferDirty(this._.depthMap_oc);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        DepthMapPass.prototype.initBuffers = function () {
            _super.prototype.initBuffers.call(this);
            this.context3DBufferOwner.mapContext3DBuffer(this._.projection_vc_matrix, this.updateProjectionBuffer);
            this.context3DBufferOwner.mapContext3DBuffer(this._.depthCommonData0_fc_vector, this.updateDepthCommonData0Buffer);
            this.context3DBufferOwner.mapContext3DBuffer(this._.depthCommonData1_fc_vector, this.updateDepthCommonData1Buffer);
            this.context3DBufferOwner.mapContext3DBuffer(this._.depthMap_oc, this.updateTextureBuffer);
        };
        /**
         * 更新投影矩阵缓冲
         * @param projectionBuffer		投影矩阵缓冲
         */
        DepthMapPass.prototype.updateProjectionBuffer = function (projectionBuffer) {
            projectionBuffer.update(this.modelViewProjection, true);
        };
        /**
         * 更新深度顶点常数0 (1.0, 255.0, 65025.0, 16581375.0)
         * @param fcVectorBuffer
         */
        DepthMapPass.prototype.updateDepthCommonData0Buffer = function (fcVectorBuffer) {
            fcVectorBuffer.update(this.depthCommonsData0);
        };
        /**
         * 更新深度顶点常数1 (1.0/255.0, 1.0/255.0, 1.0/255.0, 0.0)
         * @param fcVectorBuffer
         */
        DepthMapPass.prototype.updateDepthCommonData1Buffer = function (fcVectorBuffer) {
            fcVectorBuffer.update(this.depthCommonsData1);
        };
        /**
         * 更新深度图纹理
         * @param textureBuffer
         */
        DepthMapPass.prototype.updateTextureBuffer = function (textureBuffer) {
            textureBuffer.update(this._depthMap);
        };
        /**
         * @inheritDoc
         */
        DepthMapPass.prototype.activate = function (camera, target) {
            if (target === void 0) { target = null; }
            //初始化渲染参数
            this.shaderParams.initParams();
            _super.prototype.activate.call(this, camera, target);
            this._depthMap = target;
        };
        /**
         * @inheritDoc
         */
        DepthMapPass.prototype.render = function (renderable, stage3DProxy, camera, renderIndex) {
            //场景变换矩阵（物体坐标-->世界坐标）
            var sceneTransform = renderable.sourceEntity.getRenderSceneTransform(camera);
            //投影矩阵（世界坐标-->投影坐标）
            var projectionmatrix = camera.viewProjection;
            //物体投影变换矩阵
            this.modelViewProjection.identity();
            this.modelViewProjection.append(sceneTransform);
            this.modelViewProjection.append(projectionmatrix);
            _super.prototype.render.call(this, renderable, stage3DProxy, camera, renderIndex);
        };
        /**
         * @inheritDoc
         */
        DepthMapPass.prototype.updateProgramBuffer = function (programBuffer) {
            var result = feng3d.FagalRE.runShader(feng3d.V_Main_DepthMap, feng3d.F_Main_DepthMap);
            //上传程序
            programBuffer.update(result.vertexCode, result.fragmentCode);
        };
        return DepthMapPass;
    }(feng3d.MaterialPassBase));
    feng3d.DepthMapPass = DepthMapPass;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 平面阴影映射通道
     * @author feng 2015-5-29
     */
    var PlanarShadowPass = (function (_super) {
        __extends(PlanarShadowPass, _super);
        /**
         * 创建深度映射通道
         */
        function PlanarShadowPass() {
            _super.call(this);
            /**
             * 物体投影变换矩阵（模型空间坐标-->GPU空间坐标）
             */
            this.modelViewProjection = new feng3d.Matrix3D();
            /**
             * 阴影颜色
             */
            this.shadowColorCommonsData = [0, 0, 0, 0];
            this.shadowColorCommonsData = [1, 0, 0, 1];
        }
        /**
         * @inheritDoc
         */
        PlanarShadowPass.prototype.initBuffers = function () {
            _super.prototype.initBuffers.call(this);
            this.context3DBufferOwner.mapContext3DBuffer(this._.projection_vc_matrix, this.updateProjectionBuffer);
            this.context3DBufferOwner.mapContext3DBuffer(this._.shadowColorCommonsData_fc_vector, this.updateShadowColorCommonsDataBuffer);
        };
        /**
         * 更新投影矩阵缓冲
         * @param projectionBuffer		投影矩阵缓冲
         */
        PlanarShadowPass.prototype.updateProjectionBuffer = function (projectionBuffer) {
            projectionBuffer.update(this.modelViewProjection, true);
        };
        /**
         * 更新阴影颜色常数
         * @param fcVectorBuffer
         */
        PlanarShadowPass.prototype.updateShadowColorCommonsDataBuffer = function (fcVectorBuffer) {
            fcVectorBuffer.update(this.shadowColorCommonsData);
        };
        /**
         * @inheritDoc
         */
        PlanarShadowPass.prototype.render = function (renderable, stage3DProxy, camera, renderIndex) {
            //场景变换矩阵（物体坐标-->世界坐标）
            var sceneTransform = renderable.sourceEntity.getRenderSceneTransform(camera);
            var shadowMatrix3D = this.getShadowMatrix3D();
            //投影矩阵（世界坐标-->投影坐标）
            var projectionmatrix = camera.viewProjection;
            //物体投影变换矩阵
            this.modelViewProjection.identity();
            this.modelViewProjection.append(sceneTransform);
            this.modelViewProjection.append(shadowMatrix3D);
            this.modelViewProjection.append(projectionmatrix);
            _super.prototype.render.call(this, renderable, stage3DProxy, camera, renderIndex);
        };
        /**
         * 参考《实时阴影技术》P22
         * @return 平面投影矩阵
         */
        PlanarShadowPass.prototype.getShadowMatrix3D = function () {
            var _sunVector3D = new feng3d.Vector3D(0, 10000, 0); //太阳的方向
            var l = _sunVector3D.clone();
            var n = new feng3d.Vector3D(0, 1, 0);
            var nl = n.dotProduct(l);
            var d = -PlanarShadowPass.groundY;
            var mat1 = new feng3d.Matrix3D(//
            [
                nl + d - n.x * l.x, -n.y * l.x, -n.z * l.x, -d * l.x,
                -n.x * l.y, nl + d - n.y * l.y, -n.z * l.y, -d * l.y,
                -n.x * l.y, -n.y * l.z, nl + d - n.z * l.z, -d * l.z,
                -n.x, -n.y, -n.z, nl //
            ]);
            mat1.transpose();
            return mat1;
        };
        /**
         * @inheritDoc
         */
        PlanarShadowPass.prototype.updateProgramBuffer = function (programBuffer) {
            var result = feng3d.FagalRE.runShader(feng3d.V_Main_PlanarShadow, feng3d.F_Main_PlanarShadow);
            //上传程序
            programBuffer.update(result.vertexCode, result.fragmentCode);
        };
        PlanarShadowPass.groundY = 50;
        return PlanarShadowPass;
    }(feng3d.MaterialPassBase));
    feng3d.PlanarShadowPass = PlanarShadowPass;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 线段渲染通道
     * @author feng 2014-4-16
     */
    var SegmentPass = (function (_super) {
        __extends(SegmentPass, _super);
        function SegmentPass(thickness) {
            _super.call(this);
            /**
             * 常量数据
             */
            this.constants = [0, 0, 0, 0];
            /**
             * 摄像机坐标系到投影坐标系变换矩阵（c：camera，p：projection）
             */
            this.c2pMatrix = new feng3d.Matrix3D();
            /**
             * 模型坐标系到摄像机坐标系变换矩阵（m：model，c：camera）
             */
            this.m2cMatrix = new feng3d.Matrix3D();
            this._thickness = thickness;
            this.constants[1] = 1 / 255;
        }
        /**
         * @inheritDoc
         */
        SegmentPass.prototype.initBuffers = function () {
            _super.prototype.initBuffers.call(this);
            this.context3DBufferOwner.mapContext3DBuffer(this._.segmentC2pMatrix_vc_matrix, this.updateC2pMatrixBuffer);
            this.context3DBufferOwner.mapContext3DBuffer(this._.segmentM2cMatrix_vc_matrix, this.updateM2cMatrixBuffer);
            this.context3DBufferOwner.mapContext3DBuffer(this._.segmentOne_vc_vector, this.updateOneBuffer);
            this.context3DBufferOwner.mapContext3DBuffer(this._.segmentFront_vc_vector, this.updateFrontBuffer);
            this.context3DBufferOwner.mapContext3DBuffer(this._.segmentConstants_vc_vector, this.updateConstantsBuffer);
        };
        SegmentPass.prototype.updateConstantsBuffer = function (constantsBuffer) {
            constantsBuffer.update(this.constants);
        };
        SegmentPass.prototype.updateFrontBuffer = function (frontBuffer) {
            frontBuffer.update(SegmentPass.FRONT_VECTOR);
        };
        SegmentPass.prototype.updateOneBuffer = function (oneBuffer) {
            oneBuffer.update(SegmentPass.ONE_VECTOR);
        };
        SegmentPass.prototype.updateC2pMatrixBuffer = function (c2pMatrixBuffer) {
            //设置摄像机投影矩阵
            c2pMatrixBuffer.update(this.c2pMatrix, true);
        };
        SegmentPass.prototype.updateM2cMatrixBuffer = function (m2cMatrixBuffer) {
            //设置投影矩阵
            m2cMatrixBuffer.update(this.m2cMatrix, true);
        };
        /**
         * @inheritDoc
         */
        SegmentPass.prototype.updateProgramBuffer = function (programBuffer) {
            var result = feng3d.FagalRE.runShader(feng3d.V_Segment, feng3d.F_Segment);
            //上传程序
            programBuffer.update(result.vertexCode, result.fragmentCode);
        };
        /**
         * @inheritDoc
         */
        SegmentPass.prototype.updateConstantData = function (renderable, camera) {
            _super.prototype.updateConstantData.call(this, renderable, camera);
            //线段厚度
            this.constants[0] = this._thickness / 512;
            //摄像机最近距离
            this.constants[2] = camera.lens.near;
            //
            this.m2cMatrix.copyFrom(renderable.sourceEntity.sceneTransform);
            this.m2cMatrix.append(camera.inverseSceneTransform);
            this.c2pMatrix.copyFrom(camera.lens.matrix);
        };
        /**
         * (1,1,1,1)向量
         */
        SegmentPass.ONE_VECTOR = [1, 1, 1, 1];
        /**
         * 正面向量（Z轴负方向）
         */
        SegmentPass.FRONT_VECTOR = [0, 0, -1, 0];
        return SegmentPass;
    }(feng3d.MaterialPassBase));
    feng3d.SegmentPass = SegmentPass;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * The SingleObjectDepthPass provides a material pass that renders a single object to a depth map from the point
     * of view from a light.
     */
    var SingleObjectDepthPass = (function (_super) {
        __extends(SingleObjectDepthPass, _super);
        /**
         * Creates a new SingleObjectDepthPass object.
         * @param textureSize The size of the depth map texture to render to.
         * @param polyOffset The amount by which the rendered object will be inflated, to prevent depth map rounding errors.
         *
         * todo: provide custom vertex code to assembler
         */
        function SingleObjectDepthPass(textureSize, polyOffset) {
            if (textureSize === void 0) { textureSize = 512; }
            if (polyOffset === void 0) { polyOffset = 15; }
            _super.call(this);
            this._textures = new feng3d.Map();
            this._projections = new feng3d.Map();
            this._projectionTexturesInvalid = true;
            this._polyOffset = [15, 0, 0, 0];
            /**
             * 通用数据
             */
            this.depthCommonsData0 = [1.0, 255.0, 65025.0, 16581375.0];
            /**
             * 通用数据
             */
            this.depthCommonsData1 = [1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0];
            this.objectProjectionMatrix = new feng3d.Matrix3D();
            this._textureSize = textureSize;
            this._polyOffset[0] = polyOffset;
            //			_enc = number[]([1.0, 255.0, 65025.0, 16581375.0, 1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0]);
            //			this.depthCommonsData0 = number[]([1.0, 255.0, 65025.0, 16581375.0]);
            //			this.depthCommonsData1 = number[]([1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0]);
            //			_animatableAttributes = string[](["va0", "va1"]);
            //			_animationTargetRegisters = string[](["vt0", "vt1"]);
        }
        SingleObjectDepthPass.prototype.initBuffers = function () {
            _super.prototype.initBuffers.call(this);
            this.context3DBufferOwner.mapContext3DBuffer(this._.SODP$polyOffset_vc_vector, this.updatePolyOffsetBuffer);
            this.context3DBufferOwner.mapContext3DBuffer(this._.SODP$objectProjection_vc_matrix, this.updateObjectProjectionBuffer);
            this.context3DBufferOwner.mapContext3DBuffer(this._.SODP$depthCommonsData0_fc_vector, this.updateDepthCommonsData0Buffer);
            this.context3DBufferOwner.mapContext3DBuffer(this._.SODP$depthCommonsData1_fc_vector, this.updateDepthCommonsData1Buffer);
        };
        SingleObjectDepthPass.prototype.updatePolyOffsetBuffer = function (vcVectorBuffer) {
            vcVectorBuffer.update(this._polyOffset);
        };
        SingleObjectDepthPass.prototype.updateObjectProjectionBuffer = function (vcMatrixBuffer) {
            vcMatrixBuffer.update(this.objectProjectionMatrix, true);
        };
        SingleObjectDepthPass.prototype.updateDepthCommonsData0Buffer = function (fcVectorBuffer) {
            fcVectorBuffer.update(this.depthCommonsData0);
        };
        SingleObjectDepthPass.prototype.updateDepthCommonsData1Buffer = function (fcVectorBuffer) {
            fcVectorBuffer.update(this.depthCommonsData1);
        };
        /**
         * @inheritDoc
         */
        SingleObjectDepthPass.prototype.dispose = function () {
            if (this._textures) {
                this._textures = null;
            }
        };
        /**
         * Updates the projection textures used to contain the depth renders.
         */
        SingleObjectDepthPass.prototype.updateProjectionTextures = function () {
            this._projectionTexturesInvalid = false;
        };
        /**
         * @inheritDoc
         */
        SingleObjectDepthPass.prototype.getVertexCode = function () {
            var _ = feng3d.FagalRE.instance.space;
            var vt7;
            var vt1;
            var vc4;
            var vt0;
            var vc0;
            var vt2;
            var op;
            var v0;
            // offset
            _.mul(vt7, vt1, vc4.x); //
            _.add(vt7, vt7, vt0); //
            _.mov(vt7.w, vt0.w);
            // project
            _.m44(vt2, vt7, vc0); //
            _.mov(op, vt2);
            // perspective divide
            _.div(v0, vt2, vt2.w);
        };
        /**
         * @inheritDoc
         */
        SingleObjectDepthPass.prototype.getFragmentCode = function (animationCode) {
            // encode float -> rgba
            var _ = feng3d.FagalRE.instance.space;
            var ft0;
            var fc0;
            var v0;
            var ft1;
            var fc1;
            var oc;
            _.mul(ft0, fc0, v0.z); //
            _.frc(ft0, ft0); //
            _.mul(ft1, ft0.yzww, fc1); //
            _.sub(ft0, ft0, ft1); //
            _.mov(oc, ft0);
        };
        /**
         * Gets the depth maps rendered for this object from all lights.
         * @param renderable The renderable for which to retrieve the depth maps.
         * @param stage3DProxy The Stage3DProxy object currently used for rendering.
         * @return A list of depth map textures for all supported lights.
         */
        SingleObjectDepthPass.prototype.getDepthMap = function (renderable) {
            // todo: use texture proxy?
            var target = this._textures.get(renderable) || new feng3d.RenderTexture(this._textureSize, this._textureSize);
            //			stage3DProxy.setRenderTarget(target, true);
            //			context.clear(1.0, 1.0, 1.0);
            this._textures.push(renderable, target);
            return target;
        };
        /**
         * Retrieves the depth map projection maps for all lights.
         * @param renderable The renderable for which to retrieve the projection maps.
         * @return A list of projection maps for all supported lights.
         */
        SingleObjectDepthPass.prototype.getProjection = function (renderable) {
            var light;
            var lights = this._lightPicker.allPickedLights;
            var matrix = this._projections.get(renderable) || new feng3d.Matrix3D();
            // local position = enough
            light = lights[0];
            light.getObjectProjectionMatrix(renderable, matrix);
            this.objectProjectionMatrix.copyFrom(matrix);
            this._projections.push(renderable, matrix);
            return matrix;
        };
        /**
         * @inheritDoc
         */
        SingleObjectDepthPass.prototype.activate = function (camera, target) {
            if (target === void 0) { target = null; }
            if (this._projectionTexturesInvalid)
                this.updateProjectionTextures();
            // never scale
            _super.prototype.activate.call(this, camera, target);
        };
        return SingleObjectDepthPass;
    }(feng3d.MaterialPassBase));
    feng3d.SingleObjectDepthPass = SingleObjectDepthPass;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 天空盒通道
     * @author feng 2014-7-11
     */
    var SkyBoxPass = (function (_super) {
        __extends(SkyBoxPass, _super);
        /**
         * 创建一个天空盒通道
         */
        function SkyBoxPass() {
            _super.call(this);
            this.cameraPos = [0, 0, 0, 0];
            this.scaleSkybox = [0, 0, 0, 0];
            this.modelViewProjection = new feng3d.Matrix3D();
        }
        /**
         * @inheritDoc
         */
        SkyBoxPass.prototype.initBuffers = function () {
            _super.prototype.initBuffers.call(this);
            this.context3DBufferOwner.mapContext3DBuffer(this._.skyboxTexture_fs, this.updateTextureBuffer);
            this.context3DBufferOwner.mapContext3DBuffer(this._.projection_vc_matrix, this.updateProjectionBuffer);
            this.context3DBufferOwner.mapContext3DBuffer(this._.camerapos_vc_vector, this.updateCameraPosBuffer);
            this.context3DBufferOwner.mapContext3DBuffer(this._.scaleSkybox_vc_vector, this.updateScaleSkyboxBuffer);
        };
        SkyBoxPass.prototype.updateProjectionBuffer = function (projectionBuffer) {
            projectionBuffer.update(this.modelViewProjection, true);
        };
        SkyBoxPass.prototype.updateCameraPosBuffer = function (cameraPosBuffer) {
            cameraPosBuffer.update(this.cameraPos);
        };
        SkyBoxPass.prototype.updateScaleSkyboxBuffer = function (scaleSkyboxBuffer) {
            scaleSkyboxBuffer.update(this.scaleSkybox);
        };
        SkyBoxPass.prototype.updateTextureBuffer = function (textureBuffer) {
            textureBuffer.update(this._cubeTexture);
        };
        /**
         * @inheritDoc
         */
        SkyBoxPass.prototype.updateDepthTestBuffer = function (depthTestBuffer) {
            _super.prototype.updateDepthTestBuffer.call(this, depthTestBuffer);
            depthTestBuffer.update(false, feng3d.Context3DCompareMode.LESS);
        };
        Object.defineProperty(SkyBoxPass.prototype, "cubeTexture", {
            /**
             * 立方体纹理
             */
            get: function () {
                return this._cubeTexture;
            },
            set: function (value) {
                this._cubeTexture = value;
                this.context3DBufferOwner.markBufferDirty(this._.skyboxTexture_fs);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        SkyBoxPass.prototype.updateProgramBuffer = function (programBuffer) {
            var result = feng3d.FagalRE.runShader(feng3d.V_SkyBox, feng3d.F_SkyBox);
            //上传程序
            programBuffer.update(result.vertexCode, result.fragmentCode);
        };
        /**
         * @inheritDoc
         */
        SkyBoxPass.prototype.updateConstantData = function (renderable, camera) {
            _super.prototype.updateConstantData.call(this, renderable, camera);
            this.modelViewProjection.identity();
            this.modelViewProjection.append(renderable.sourceEntity.sceneTransform);
            this.modelViewProjection.append(camera.viewProjection);
        };
        /**
         * @inheritDoc
         */
        SkyBoxPass.prototype.activate = function (camera, target) {
            if (target === void 0) { target = null; }
            _super.prototype.activate.call(this, camera, target);
            var pos = camera.scenePosition;
            this.cameraPos[0] = pos.x;
            this.cameraPos[1] = pos.y;
            this.cameraPos[2] = pos.z;
            this.cameraPos[3] = 0;
            this.scaleSkybox[0] = this.scaleSkybox[1] = this.scaleSkybox[2] = camera.lens.far / Math.sqrt(4);
            this.scaleSkybox[3] = 1;
            //通用渲染参数
            this.shaderParams.addSampleFlags(this._.skyboxTexture_fs, this._cubeTexture, feng3d.Context3DWrapMode.CLAMP);
        };
        return SkyBoxPass;
    }(feng3d.MaterialPassBase));
    feng3d.SkyBoxPass = SkyBoxPass;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 纹理代理基类
     * <p>处理纹理与stage3d的关系</p>
     * @author feng 2014-4-15
     */
    var TextureProxyBase = (function (_super) {
        __extends(TextureProxyBase, _super);
        /**
         * 创建一个纹理代理基类
         */
        function TextureProxyBase() {
            _super.call(this);
            /**
             * 纹理格式
             */
            this._format = feng3d.Context3DTextureFormat.BGRA;
            /**
             * 是否有miplevel
             */
            this._hasMipmaps = true;
            //			_namedAsset = new NamedAsset(this, AssetType.TEXTURE);
        }
        Object.defineProperty(TextureProxyBase.prototype, "hasMipMaps", {
            /**
             * 是否有miplevel
             */
            get: function () {
                return this._hasMipmaps;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TextureProxyBase.prototype, "format", {
            /**
             * 纹理格式
             * @see flash.display3D.Context3DTextureFormat
             */
            get: function () {
                return this._format;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TextureProxyBase.prototype, "width", {
            /**
             * 纹理宽度
             */
            get: function () {
                return this._width;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TextureProxyBase.prototype, "height", {
            /**
             * 纹理高度
             */
            get: function () {
                return this._height;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 设置纹理尺寸
         * @param width		纹理宽度
         * @param height	纹理高度
         */
        TextureProxyBase.prototype.setSize = function (width, height) {
            if (this._width != width || this._height != height)
                this.invalidateSize();
            this._width = width;
            this._height = height;
        };
        /**
         * 尺寸失效
         */
        TextureProxyBase.prototype.invalidateSize = function () {
        };
        /**
         * 纹理失效
         */
        TextureProxyBase.prototype.invalidateContent = function () {
        };
        return TextureProxyBase;
    }(feng3d.Component));
    feng3d.TextureProxyBase = TextureProxyBase;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 立方体纹理代理基类
     * @author feng 2014-7-12
     */
    var CubeTextureBase = (function (_super) {
        __extends(CubeTextureBase, _super);
        /**
         * 创建一个立方体纹理代理基类
         */
        function CubeTextureBase() {
            _super.call(this);
            this.type = feng3d.TextureType.TYPE_CUBE;
        }
        Object.defineProperty(CubeTextureBase.prototype, "size", {
            /**
             * 获取纹理尺寸
             */
            get: function () {
                return this._width;
            },
            enumerable: true,
            configurable: true
        });
        return CubeTextureBase;
    }(feng3d.TextureProxyBase));
    feng3d.CubeTextureBase = CubeTextureBase;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 位图立方体纹理代理
     * @author feng 2014-7-12
     */
    var BitmapCubeTexture = (function (_super) {
        __extends(BitmapCubeTexture, _super);
        /**
         * 创建位图立方体纹理代理
         * @param posX			X正方向位图
         * @param negX			X负方向位图
         * @param posY			Y正方向位图
         * @param negY			Y负方向位图
         * @param posZ			Z正方向位图
         * @param negZ			Z负方向位图
         */
        function BitmapCubeTexture(posX, negX, posY, negY, posZ, negZ) {
            _super.call(this);
            this.optimizeForRenderToTexture = false;
            this.streamingLevels = 0;
            this._bitmapDatas = [];
            this.testSize(this._bitmapDatas[0] = posX);
            this.testSize(this._bitmapDatas[1] = negX);
            this.testSize(this._bitmapDatas[2] = posY);
            this.testSize(this._bitmapDatas[3] = negY);
            this.testSize(this._bitmapDatas[4] = posZ);
            this.testSize(this._bitmapDatas[5] = negZ);
            this.setSize(posX.width, posX.height);
        }
        Object.defineProperty(BitmapCubeTexture.prototype, "bitmapDatas", {
            /**
             * 位图列表
             */
            get: function () {
                return this._bitmapDatas;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BitmapCubeTexture.prototype, "positiveX", {
            /**
             * 正X方向位图（右面位图）
             */
            get: function () {
                return this._bitmapDatas[0];
            },
            set: function (value) {
                this.testSize(value);
                this.invalidateContent();
                this.setSize(value.width, value.height);
                this._bitmapDatas[0] = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BitmapCubeTexture.prototype, "negativeX", {
            /**
             * 负X方向位图（左面位图）
             */
            get: function () {
                return this._bitmapDatas[1];
            },
            set: function (value) {
                this.testSize(value);
                this.invalidateContent();
                this.setSize(value.width, value.height);
                this._bitmapDatas[1] = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BitmapCubeTexture.prototype, "positiveY", {
            /**
             * 正Y方向位图（上面位图）
             */
            get: function () {
                return this._bitmapDatas[2];
            },
            set: function (value) {
                this.testSize(value);
                this.invalidateContent();
                this.setSize(value.width, value.height);
                this._bitmapDatas[2] = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BitmapCubeTexture.prototype, "negativeY", {
            /**
             * 负Y方向位图（下面位图）
             */
            get: function () {
                return this._bitmapDatas[3];
            },
            set: function (value) {
                this.testSize(value);
                this.invalidateContent();
                this.setSize(value.width, value.height);
                this._bitmapDatas[3] = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BitmapCubeTexture.prototype, "positiveZ", {
            /**
             * 正Z方向位图（前面位图）
             */
            get: function () {
                return this._bitmapDatas[4];
            },
            set: function (value) {
                this.testSize(value);
                this.invalidateContent();
                this.setSize(value.width, value.height);
                this._bitmapDatas[4] = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BitmapCubeTexture.prototype, "negativeZ", {
            /**
             * 负Z方向位图（后面位图）
             */
            get: function () {
                return this._bitmapDatas[5];
            },
            set: function (value) {
                this.testSize(value);
                this.invalidateContent();
                this.setSize(value.width, value.height);
                this._bitmapDatas[5] = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 检查位图尺寸
         * @param value		位图
         */
        BitmapCubeTexture.prototype.testSize = function (value) {
            if (value.width != value.height)
                throw new Error("BitmapData should have equal this.width and this.height!");
            if (!feng3d.TextureUtils.isBitmapDataValid(value))
                throw new Error("Invalid bitmapData: Width and this.height must be power of 2 and cannot exceed 2048");
        };
        return BitmapCubeTexture;
    }(feng3d.CubeTextureBase));
    feng3d.BitmapCubeTexture = BitmapCubeTexture;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 纹理基类
     * @author feng 2014-4-15
     */
    var Texture2DBase = (function (_super) {
        __extends(Texture2DBase, _super);
        function Texture2DBase() {
            _super.call(this);
            this.type = feng3d.TextureType.TYPE_2D;
        }
        return Texture2DBase;
    }(feng3d.TextureProxyBase));
    feng3d.Texture2DBase = Texture2DBase;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 位图纹理
     * @author feng 2014-3-24
     */
    var BitmapTexture = (function (_super) {
        __extends(BitmapTexture, _super);
        function BitmapTexture(bitmapData, generateMipmaps) {
            if (generateMipmaps === void 0) { generateMipmaps = true; }
            _super.call(this);
            this.bitmapData = bitmapData;
            this._generateMipmaps = generateMipmaps;
        }
        Object.defineProperty(BitmapTexture.prototype, "bitmapData", {
            get: function () {
                return this._bitmapData;
            },
            set: function (value) {
                if (value == this._bitmapData)
                    return;
                if (!feng3d.TextureUtils.isBitmapDataValid(value))
                    throw new Error("Invalid this.bitmapData: Width and this.height must be power of 2 and cannot exceed 2048");
                this.invalidateContent();
                this.setSize(value.width, value.height);
                this._bitmapData = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BitmapTexture.prototype, "generateMipmaps", {
            get: function () {
                return this._generateMipmaps;
            },
            set: function (value) {
                this._generateMipmaps = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BitmapTexture.prototype, "mipMapHolder", {
            get: function () {
                return this._mipMapHolder;
            },
            set: function (value) {
                this._mipMapHolder = value;
            },
            enumerable: true,
            configurable: true
        });
        return BitmapTexture;
    }(feng3d.Texture2DBase));
    feng3d.BitmapTexture = BitmapTexture;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 渲染纹理
     * @author feng 2015-5-28
     */
    var RenderTexture = (function (_super) {
        __extends(RenderTexture, _super);
        /**
         * 创建一个渲染纹理
         * @param width			纹理宽度
         * @param height		纹理高度
         */
        function RenderTexture(width, height) {
            _super.call(this);
            this.setSize(width, height);
        }
        return RenderTexture;
    }(feng3d.Texture2DBase));
    feng3d.RenderTexture = RenderTexture;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 全局事件适配器
     * @author feng
     */
    var GlobalDispatcher = (function (_super) {
        __extends(GlobalDispatcher, _super);
        /**
         * 创建一个全局事件适配器
         * <p>此类为单例，只能构造一次，使用时请使用GlobalDispatcher.instance获取实例</p>
         */
        function GlobalDispatcher() {
            _super.call(this);
            if (GlobalDispatcher._instance)
                throw new Error("此类不允许外部创建，请用instance属性！");
            GlobalDispatcher._instance = this;
        }
        Object.defineProperty(GlobalDispatcher, "instance", {
            /**
             * 适配器实例
             */
            get: function () {
                return GlobalDispatcher._instance || new GlobalDispatcher();
            },
            enumerable: true,
            configurable: true
        });
        return GlobalDispatcher;
    }(feng3d.EventDispatcher));
    feng3d.GlobalDispatcher = GlobalDispatcher;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 加载事件数据
     * @author feng 2015-5-27
     */
    var LoadModuleEventData = (function (_super) {
        __extends(LoadModuleEventData, _super);
        /**
         * 加载事件数据
         * @param urls		加载路径列表
         * @param data		自定义数据，可用于保存数据在加载资源后处理
         */
        function LoadModuleEventData(urls, data) {
            if (urls === void 0) { urls = null; }
            if (data === void 0) { data = null; }
            _super.call(this);
            this.urls = urls;
            this.data = data;
        }
        Object.defineProperty(LoadModuleEventData.prototype, "urls", {
            /**
             * 加载路径列表
             */
            get: function () {
                return this._urls;
            },
            /**
             * @private
             */
            set: function (value) {
                this._urls = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LoadModuleEventData.prototype, "loadTaskItems", {
            /**
             * 加载任务列表
             * <p>该函数提供给加载模块内部使用，使用者并不需要知道</p>
             */
            get: function () {
                var _loadTaskItems = [];
                _loadTaskItems.length = 0;
                this.urls.forEach(function (url) {
                    _loadTaskItems.push(new feng3d.LoadTaskItem(url));
                });
                return _loadTaskItems;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LoadModuleEventData.prototype, "taskModuleEventData", {
            /**
             * 加载任务数据
             */
            get: function () {
                if (this._taskModuleEventData == null) {
                    this._taskModuleEventData = new feng3d.TaskModuleEventDispatchTaskData();
                    this._taskModuleEventData.addEventListener(feng3d.TaskEvent.COMPLETEDITEM, this.onCompletedItem);
                    this._taskModuleEventData.addEventListener(feng3d.TaskEvent.COMPLETED, this.onCompleted);
                }
                this._taskModuleEventData.taskList = this.loadTaskItems;
                this._taskModuleEventData.taskCollectionType = feng3d.TaskCollectionType.QUEUE;
                return this._taskModuleEventData;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 处理完成加载单项事件
         */
        LoadModuleEventData.prototype.onCompletedItem = function (event) {
            var loadItemData = event.data;
            this.dispatchEvent(new feng3d.LoadUrlEvent(feng3d.LoadUrlEvent.LOAD_SINGLE_COMPLETE, loadItemData));
        };
        /**
         * 处理完成所有加载项事件
         */
        LoadModuleEventData.prototype.onCompleted = function (event) {
            this.dispatchEvent(new feng3d.LoadUrlEvent(feng3d.LoadUrlEvent.LOAD_COMPLETE));
        };
        return LoadModuleEventData;
    }(feng3d.EventDispatcher));
    feng3d.LoadModuleEventData = LoadModuleEventData;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 任务模块事件数据
     * @author feng 2015-10-29
     */
    var TaskModuleEventDispatchTaskData = (function (_super) {
        __extends(TaskModuleEventDispatchTaskData, _super);
        function TaskModuleEventDispatchTaskData(taskList, taskCollectionType, params) {
            if (taskList === void 0) { taskList = null; }
            if (taskCollectionType === void 0) { taskCollectionType = feng3d.TaskCollectionType.LIST; }
            if (params === void 0) { params = null; }
            _super.call(this);
            this.taskList = taskList;
            this.taskCollectionType = taskCollectionType;
            this.params = params;
        }
        return TaskModuleEventDispatchTaskData;
    }(feng3d.EventDispatcher));
    feng3d.TaskModuleEventDispatchTaskData = TaskModuleEventDispatchTaskData;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 任务
     * @author feng 2015-5-27
     */
    var TaskItem = (function (_super) {
        __extends(TaskItem, _super);
        /**
         * 创建一个任务单元数据
         */
        function TaskItem() {
            _super.call(this);
            /** 任务状态 */
            this._state = feng3d.TaskStateType.STATE_INIT;
            this._state = feng3d.TaskStateType.STATE_INIT;
        }
        Object.defineProperty(TaskItem.prototype, "state", {
            /**
             * 任务状态
             */
            get: function () {
                return this._state;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 执行任务
         * @param params	执行参数
         */
        TaskItem.prototype.execute = function (params) {
            if (params === void 0) { params = null; }
            this._state = feng3d.TaskStateType.STATE_EXECUTING;
        };
        /**
         * 执行完成事件
         */
        TaskItem.prototype.doComplete = function () {
            this._state = feng3d.TaskStateType.STATE_COMPLETED;
            this.dispatchEvent(new feng3d.TaskEvent(feng3d.TaskEvent.COMPLETED));
        };
        /**
         * 销毁
         */
        TaskItem.prototype.destroy = function () {
        };
        return TaskItem;
    }(feng3d.EventDispatcher));
    feng3d.TaskItem = TaskItem;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 加载单元数据
     * @author feng 2015-5-27
     */
    var LoadTaskItem = (function (_super) {
        __extends(LoadTaskItem, _super);
        /**
         * 创建一个加载单元数据
         * @param url		加载路径信息
         */
        function LoadTaskItem(url) {
            _super.call(this);
            this._url = null;
            this._type = null;
            if (typeof url == "string") {
                this._url = url;
            }
            else {
                this._type = url.type;
                this._url = url.url;
            }
        }
        Object.defineProperty(LoadTaskItem.prototype, "loadingItem", {
            /**
             * 单项资源加载器
             */
            get: function () {
                return this._loadingItem;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LoadTaskItem.prototype, "type", {
            /**
             * 资源类型
             */
            get: function () {
                return this._type;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LoadTaskItem.prototype, "url", {
            /**
             * 资源路径
             */
            get: function () {
                return this._url;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        LoadTaskItem.prototype.execute = function (param) {
            if (param === void 0) { param = null; }
            var loader = param;
            //加载资源
            if (!loader.hasItem(this._url)) {
                if (this._type) {
                    loader.add(this._url, { type: this._type });
                }
                else {
                    loader.add(this._url);
                }
            }
            this._loadingItem = loader.get(this._url);
            if (this._loadingItem.isLoaded) {
                this.doComplete();
            }
            else {
                this._loadingItem.addEventListener(feng3d.BulkLoader.COMPLETE, this.onLoadComplete);
            }
        };
        /**
         * 完成任务事件
         */
        LoadTaskItem.prototype.onLoadComplete = function (event) {
            if (event === void 0) { event = null; }
            this._loadingItem.removeEventListener(feng3d.BulkLoader.COMPLETE, this.onLoadComplete);
            this.doComplete();
        };
        return LoadTaskItem;
    }(feng3d.TaskItem));
    feng3d.LoadTaskItem = LoadTaskItem;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 任务集合，任务列表与任务队列等的基类
     * @author feng 2015-6-16
     */
    var TaskCollection = (function (_super) {
        __extends(TaskCollection, _super);
        /**
         * 创建一个任务集合
         * <p>该类为抽象类，无法直接被实例化，请使用其子类</p>
         */
        function TaskCollection() {
            _super.call(this);
            this.allItemList = [];
            this.executingItemList = [];
            this.completedItemList = [];
        }
        Object.defineProperty(TaskCollection.prototype, "isComplete", {
            /**
             * 是否已经结束任务
             */
            get: function () {
                return this.completedItemList.length == this.allItemList.length;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        TaskCollection.prototype.execute = function (params) {
            if (params === void 0) { params = null; }
            this._state = feng3d.TaskStateType.STATE_EXECUTING;
            this.waitingItemList = this.allItemList.concat();
            this.executingItemList.length = 0;
            this.completedItemList.length = 0;
            //判断是否已经完成任务
            if (this.isComplete) {
                this.doComplete();
                return;
            }
        };
        /**
         * 执行子任务
         * @param taskItem	子任务
         * @param params	执行参数
         */
        TaskCollection.prototype.executeItem = function (taskItem, params) {
            this.executingItemList.push(taskItem);
            taskItem.execute(params);
        };
        /**
         * 添加子任务
         */
        TaskCollection.prototype.addItem = function (item) {
            if (this.allItemList.indexOf(item) == -1) {
                this.allItemList.push(item);
                item.addEventListener(feng3d.TaskEvent.COMPLETED, this.onCompletedItem);
                if (this.state == feng3d.TaskStateType.STATE_EXECUTING) {
                    if (item.state == feng3d.TaskStateType.STATE_INIT || item.state == feng3d.TaskStateType.STATE_EXECUTING) {
                        this.executingItemList.push(item);
                    }
                    else if (item.state == feng3d.TaskStateType.STATE_COMPLETED) {
                        this.completedItemList.push(item);
                    }
                }
            }
        };
        /**
         * 添加任务列表
         * @param taskList		任务列表
         */
        TaskCollection.prototype.addItems = function (taskList) {
            for (var i = 0; i < taskList.length; i++) {
                this.addItem(taskList[i]);
            }
        };
        /**
         * 移除子任务
         */
        TaskCollection.prototype.removeItem = function (item) {
            var index;
            index = this.allItemList.indexOf(item);
            if (index != -1) {
                this.allItemList.splice(index, 1);
                item.removeEventListener(feng3d.TaskEvent.COMPLETED, this.onCompletedItem);
            }
            index = this.executingItemList.indexOf(item);
            if (index != -1) {
                this.executingItemList.splice(index, 1);
            }
            index = this.completedItemList.indexOf(item);
            if (index != -1) {
                this.completedItemList.splice(index, 1);
            }
        };
        /**
         * 移除所有子任务
         */
        TaskCollection.prototype.removeAllItem = function () {
            var item;
            while (this.allItemList.length > 0) {
                item = this.allItemList.pop();
                item.removeEventListener(feng3d.TaskEvent.COMPLETED, this.onCompletedItem);
                item.destroy();
            }
            this.waitingItemList.length = 0;
            this.executingItemList.length = 0;
            this.completedItemList.length = 0;
        };
        /**
         * 处理子任务完成事件
         */
        TaskCollection.prototype.onCompletedItem = function (event) {
            var taskItem = event.currentTarget;
            var index = this.executingItemList.indexOf(taskItem);
            if (index != -1) {
                this.executingItemList.splice(index, 1);
            }
            else
                throw new Error("怎么会找不到" + taskItem + "呢？");
            this.completedItemList.push(taskItem);
            this.dispatchEvent(new feng3d.TaskEvent(feng3d.TaskEvent.COMPLETEDITEM, taskItem));
            this.checkComplete();
        };
        /**
         * 检查是否完成任务
         */
        TaskCollection.prototype.checkComplete = function () {
            if (this.isComplete) {
                this.doComplete();
            }
        };
        /**
         * @inheritDoc
         */
        TaskCollection.prototype.destroy = function () {
            _super.prototype.destroy.call(this);
            this.removeAllItem();
            this.allItemList = null;
            this.waitingItemList = null;
            this.executingItemList = null;
            this.completedItemList = null;
        };
        return TaskCollection;
    }(feng3d.TaskItem));
    feng3d.TaskCollection = TaskCollection;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 任务列表
     * <p>所有子任务将会在同一时间开始执行</p>
     * @includeExample TaskListTest.as
     * @includeExample KeyDownTask.as
     *
     * @author feng 2014-7-24
     */
    var TaskList = (function (_super) {
        __extends(TaskList, _super);
        /**
         * 创建一个任务队列
         */
        function TaskList() {
            _super.call(this);
        }
        /**
         * 执行任务
         * @param params	执行参数
         */
        TaskList.prototype.execute = function (params) {
            if (params === void 0) { params = null; }
            _super.prototype.execute.call(this, params);
            //执行所有子任务
            for (var i = 0; i < this.waitingItemList.length; i++) {
                this.executeItem(this.waitingItemList[i], params);
            }
            this.waitingItemList.length = 0;
        };
        return TaskList;
    }(feng3d.TaskCollection));
    feng3d.TaskList = TaskList;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 任务队列（按先后顺序依次完成子任务，只有完成当前任务才会开始下个任务）
     * @includeExample TaskQueueTest.as
     * @includeExample KeyDownTask.as
     * @author feng 2015-6-17
     */
    var TaskQueue = (function (_super) {
        __extends(TaskQueue, _super);
        /**
         * 创建任务队列
         */
        function TaskQueue() {
            _super.call(this);
        }
        /**
         * @inheritDoc
         */
        TaskQueue.prototype.execute = function (params) {
            if (params === void 0) { params = null; }
            _super.prototype.execute.call(this, params);
            this.executeParams = params;
            this.executeNextTask();
        };
        /**
         * 执行下个任务
         */
        TaskQueue.prototype.executeNextTask = function () {
            if (this.waitingItemList.length > 0) {
                var taskItem = this.waitingItemList.shift();
                this.executeItem(taskItem, this.executeParams);
            }
        };
        /**
         * @inheritDoc
         */
        TaskQueue.prototype.onCompletedItem = function (event) {
            _super.prototype.onCompletedItem.call(this, event);
            this.executeNextTask();
        };
        return TaskQueue;
    }(feng3d.TaskCollection));
    feng3d.TaskQueue = TaskQueue;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 尝试获取可连接地址
     * @author feng 2015-12-15
     */
    var TryConnectURL = (function (_super) {
        __extends(TryConnectURL, _super);
        function TryConnectURL() {
            _super.apply(this, arguments);
        }
        TryConnectURL.prototype.tryConnect = function (urls) {
            this.connectedUrls = [];
            for (var i = 0; i < urls.length; i++) {
                this.addItem(new feng3d.TryConnectURLTaskItem(urls[i]));
            }
            this.execute();
        };
        /**
         * @inheritDoc
         */
        TryConnectURL.prototype.onCompletedItem = function (event) {
            var taskItem = event.target;
            if (taskItem.result) {
                this.connectedUrls.push(taskItem.url);
            }
            _super.prototype.onCompletedItem.call(this, event);
        };
        return TryConnectURL;
    }(feng3d.TaskQueue));
    feng3d.TryConnectURL = TryConnectURL;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 尝试获取可连接地址
     * @author feng 2015-12-15
     */
    var TryConnectURLTaskItem = (function (_super) {
        __extends(TryConnectURLTaskItem, _super);
        function TryConnectURLTaskItem(url) {
            _super.call(this);
            this.url = url;
        }
        /**
         * @inheritDoc
         */
        TryConnectURLTaskItem.prototype.execute = function (param) {
            if (param === void 0) { param = null; }
            this.tryConnect();
        };
        TryConnectURLTaskItem.prototype.tryConnect = function () {
            this.loader = new feng3d.URLLoader();
            this.addListeners();
            var request = new feng3d.URLRequest(this.url + "?version=" + Math.random());
            try {
                this.loader.load(request);
            }
            catch (error) {
                this.connectFailure();
            }
        };
        TryConnectURLTaskItem.prototype.addListeners = function () {
            this.loader.addEventListener(feng3d.Event.COMPLETE, this.connectSucceed);
            this.loader.addEventListener(feng3d.SecurityErrorEvent.SECURITY_ERROR, this.connectFailure);
            this.loader.addEventListener(feng3d.IOErrorEvent.IO_ERROR, this.ioErrorHandler);
        };
        TryConnectURLTaskItem.prototype.removeListeners = function () {
            this.loader.removeEventListener(feng3d.Event.COMPLETE, this.connectSucceed);
            this.loader.removeEventListener(feng3d.SecurityErrorEvent.SECURITY_ERROR, this.connectFailure);
            this.loader.removeEventListener(feng3d.IOErrorEvent.IO_ERROR, this.ioErrorHandler);
        };
        TryConnectURLTaskItem.prototype.connectFailure = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            this.result = false;
            this.connentEnd();
        };
        TryConnectURLTaskItem.prototype.connectSucceed = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            this.result = true;
            this.connentEnd();
        };
        TryConnectURLTaskItem.prototype.connentEnd = function () {
            this.removeListeners();
            this.loader = null;
            this.doComplete();
        };
        TryConnectURLTaskItem.prototype.ioErrorHandler = function (event) {
            if (this.loader.bytesLoaded > 0) {
                this.connectSucceed();
            }
            else {
                this.connectFailure();
            }
        };
        return TryConnectURLTaskItem;
    }(feng3d.TaskItem));
    feng3d.TryConnectURLTaskItem = TryConnectURLTaskItem;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 摄像机镜头
     * @author feng 2014-10-14
     */
    var LensBase = (function (_super) {
        __extends(LensBase, _super);
        /**
         * 创建一个摄像机镜头
         */
        function LensBase() {
            _super.call(this);
            this._scissorRect = new feng3d.Rectangle();
            this._viewPort = new feng3d.Rectangle();
            this._near = 20;
            this._far = 3000;
            this._aspectRatio = 1;
            this._matrixInvalid = true;
            this._frustumCorners = [];
            this._unprojectionInvalid = true;
            this._matrix = new feng3d.Matrix3D();
        }
        Object.defineProperty(LensBase.prototype, "frustumCorners", {
            /**
             * Retrieves the corner points of the lens frustum.
             */
            get: function () {
                return this._frustumCorners;
            },
            set: function (frustumCorners) {
                this._frustumCorners = frustumCorners;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LensBase.prototype, "matrix", {
            /**
             * 投影矩阵
             */
            get: function () {
                if (this._matrixInvalid) {
                    this.updateMatrix();
                    this._matrixInvalid = false;
                }
                return this._matrix;
            },
            set: function (value) {
                this._matrix = value;
                this.invalidateMatrix();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LensBase.prototype, "near", {
            /**
             * 最近距离
             */
            get: function () {
                return this._near;
            },
            set: function (value) {
                if (value == this._near)
                    return;
                this._near = value;
                this.invalidateMatrix();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LensBase.prototype, "far", {
            /**
             * 最远距离
             */
            get: function () {
                return this._far;
            },
            set: function (value) {
                if (value == this._far)
                    return;
                this._far = value;
                this.invalidateMatrix();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LensBase.prototype, "aspectRatio", {
            /**
             * 视窗缩放比例(width/height)，在渲染器中设置
             */
            get: function () {
                return this._aspectRatio;
            },
            set: function (value) {
                if (this._aspectRatio == value || (value * 0) != 0)
                    return;
                this._aspectRatio = value;
                this.invalidateMatrix();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 场景坐标投影到屏幕坐标
         * @param point3d 场景坐标
         * @param v 屏幕坐标（输出）
         * @return 屏幕坐标
         */
        LensBase.prototype.project = function (point3d, v) {
            if (v === void 0) { v = null; }
            if (!v)
                v = new feng3d.Vector3D();
            feng3d.Matrix3DUtils.transformVector(this.matrix, point3d, v);
            v.x = v.x / v.w;
            v.y = -v.y / v.w;
            //z is unaffected by transform
            v.z = point3d.z;
            return v;
        };
        Object.defineProperty(LensBase.prototype, "unprojectionMatrix", {
            /**
             * 投影逆矩阵
             */
            get: function () {
                if (this._unprojectionInvalid) {
                    if (this._unprojection == null)
                        this._unprojection = new feng3d.Matrix3D();
                    this._unprojection.copyFrom(this.matrix);
                    this._unprojection.invert();
                    this._unprojectionInvalid = false;
                }
                return this._unprojection;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 投影矩阵失效
         */
        LensBase.prototype.invalidateMatrix = function () {
            this._matrixInvalid = true;
            this._unprojectionInvalid = true;
            // notify the camera that the lens this.matrix is changing. this will mark the 
            // viewProjectionMatrix in the camera as invalid, and force the this.matrix to
            // be re-queried from the lens, and therefore rebuilt.
            this.dispatchEvent(new feng3d.LensEvent(feng3d.LensEvent.MATRIX_CHANGED, this));
        };
        return LensBase;
    }(feng3d.EventDispatcher));
    feng3d.LensBase = LensBase;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     *
     * @author feng 2015-5-28
     */
    var FreeMatrixLens = (function (_super) {
        __extends(FreeMatrixLens, _super);
        function FreeMatrixLens() {
            _super.call(this);
        }
        FreeMatrixLens.prototype.updateMatrix = function () {
            this._matrixInvalid = false;
        };
        /**
 * 屏幕坐标投影到摄像机空间坐标
 * @param nX 屏幕坐标X -1（左） -> 1（右）
 * @param nY 屏幕坐标Y -1（上） -> 1（下）
 * @param sZ 到屏幕的距离
 * @param v 场景坐标（输出）
 * @return 场景坐标
 */
        FreeMatrixLens.prototype.unproject = function (nX, nY, sZ, v) {
            return null;
        };
        return FreeMatrixLens;
    }(feng3d.LensBase));
    feng3d.FreeMatrixLens = FreeMatrixLens;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 透视摄像机镜头
     * @author feng 2014-10-14
     */
    var PerspectiveLens = (function (_super) {
        __extends(PerspectiveLens, _super);
        /**
         * 创建一个透视摄像机镜头
         * @param fieldOfView 视野
         * @param coordinateSystem 坐标系统类型
         */
        function PerspectiveLens(fieldOfView, coordinateSystem) {
            if (fieldOfView === void 0) { fieldOfView = 60; }
            if (coordinateSystem === void 0) { coordinateSystem = feng3d.CoordinateSystem.LEFT_HANDED; }
            _super.call(this);
            this.fieldOfView = fieldOfView;
            this.coordinateSystem = coordinateSystem;
        }
        Object.defineProperty(PerspectiveLens.prototype, "fieldOfView", {
            /**
             * 视野
             */
            get: function () {
                return this._fieldOfView;
            },
            set: function (value) {
                if (value == this._fieldOfView)
                    return;
                this._fieldOfView = value;
                this._focalLengthInv = Math.tan(this._fieldOfView * Math.PI / 360);
                this._focalLength = 1 / this._focalLengthInv;
                this.invalidateMatrix();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PerspectiveLens.prototype, "focalLength", {
            /**
             * 焦距
             */
            get: function () {
                return this._focalLength;
            },
            set: function (value) {
                if (value == this._focalLength)
                    return;
                this._focalLength = value;
                this._focalLengthInv = 1 / this._focalLength;
                this._fieldOfView = Math.atan(this._focalLengthInv) * 360 / Math.PI;
                this.invalidateMatrix();
            },
            enumerable: true,
            configurable: true
        });
        PerspectiveLens.prototype.unproject = function (nX, nY, sZ, v) {
            if (v === void 0) { v = null; }
            if (!v)
                v = new feng3d.Vector3D();
            v.x = nX;
            v.y = -nY;
            v.z = sZ;
            v.w = 1;
            v.x *= sZ;
            v.y *= sZ;
            feng3d.Matrix3DUtils.transformVector(this.unprojectionMatrix, v, v);
            //z is unaffected by transform
            v.z = sZ;
            return v;
        };
        Object.defineProperty(PerspectiveLens.prototype, "coordinateSystem", {
            /**
             * 坐标系类型
             */
            get: function () {
                return this._coordinateSystem;
            },
            set: function (value) {
                if (value == this._coordinateSystem)
                    return;
                this._coordinateSystem = value;
                this.invalidateMatrix();
            },
            enumerable: true,
            configurable: true
        });
        PerspectiveLens.prototype.updateMatrix = function () {
            var raw = feng3d.Matrix3DUtils.RAW_DATA_CONTAINER;
            this._yMax = this._near * this._focalLengthInv;
            this._xMax = this._yMax * this._aspectRatio;
            var left, right, top, bottom;
            if (this._scissorRect.x == 0 && this._scissorRect.y == 0 && this._scissorRect.width == this._viewPort.width && this._scissorRect.height == this._viewPort.height) {
                // assume unscissored frustum
                left = -this._xMax;
                right = this._xMax;
                top = -this._yMax;
                bottom = this._yMax;
                // assume unscissored frustum
                raw[0] = this._near / this._xMax;
                raw[5] = this._near / this._yMax;
                raw[10] = this._far / (this._far - this._near);
                raw[11] = 1;
                raw[1] = raw[2] = raw[3] = raw[4] = raw[6] = raw[7] = raw[8] = raw[9] = raw[12] = raw[13] = raw[15] = 0;
                raw[14] = -this._near * raw[10];
            }
            else {
                // assume scissored frustum
                var xWidth = this._xMax * (this._viewPort.width / this._scissorRect.width);
                var yHgt = this._yMax * (this._viewPort.height / this._scissorRect.height);
                var center = this._xMax * (this._scissorRect.x * 2 - this._viewPort.width) / this._scissorRect.width + this._xMax;
                var middle = -this._yMax * (this._scissorRect.y * 2 - this._viewPort.height) / this._scissorRect.height - this._yMax;
                left = center - xWidth;
                right = center + xWidth;
                top = middle - yHgt;
                bottom = middle + yHgt;
                raw[0] = 2 * this._near / (right - left);
                raw[5] = 2 * this._near / (bottom - top);
                raw[8] = (right + left) / (right - left);
                raw[9] = (bottom + top) / (bottom - top);
                raw[10] = (this._far + this._near) / (this._far - this._near);
                raw[11] = 1;
                raw[1] = raw[2] = raw[3] = raw[4] = raw[6] = raw[7] = raw[12] = raw[13] = raw[15] = 0;
                raw[14] = -2 * this._far * this._near / (this._far - this._near);
            }
            // Switch projection transform from left to right handed.
            if (this._coordinateSystem == feng3d.CoordinateSystem.RIGHT_HANDED)
                raw[5] = -raw[5];
            this._matrix.copyRawDataFrom(raw);
            var yMaxFar = this._far * this._focalLengthInv;
            var xMaxFar = yMaxFar * this._aspectRatio;
            this._frustumCorners[0] = this._frustumCorners[9] = left;
            this._frustumCorners[3] = this._frustumCorners[6] = right;
            this._frustumCorners[1] = this._frustumCorners[4] = top;
            this._frustumCorners[7] = this._frustumCorners[10] = bottom;
            this._frustumCorners[12] = this._frustumCorners[21] = -xMaxFar;
            this._frustumCorners[15] = this._frustumCorners[18] = xMaxFar;
            this._frustumCorners[13] = this._frustumCorners[16] = -yMaxFar;
            this._frustumCorners[19] = this._frustumCorners[22] = yMaxFar;
            this._frustumCorners[2] = this._frustumCorners[5] = this._frustumCorners[8] = this._frustumCorners[11] = this._near;
            this._frustumCorners[14] = this._frustumCorners[17] = this._frustumCorners[20] = this._frustumCorners[23] = this._far;
            this._matrixInvalid = false;
        };
        return PerspectiveLens;
    }(feng3d.LensBase));
    feng3d.PerspectiveLens = PerspectiveLens;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * Fagal函数追加代码事件
     */
    //[Event(name = "fagalMathEventAppend", type = "me.feng3d.events.FagalMathEvent")]
    /**
     * Fagal数学运算
     * @author feng 2015-7-22
     */
    var FagalMath = (function (_super) {
        __extends(FagalMath, _super);
        function FagalMath() {
            _super.apply(this, arguments);
        }
        /**
         * destination=abs(source1):一个寄存器的绝对值，分量形式
         */
        FagalMath.prototype.abs = function (destination, source1) {
            var code = "this.abs " + destination + ", " + source1;
            this.append(code);
        };
        /**
         * destination=source1+source2:两个寄存器相加，分量形式
         */
        FagalMath.prototype.add = function (destination, source1, source2) {
            var code = "this.add " + destination + ", " + source1 + ", " + source2;
            this.append(code);
        };
        /**
         * destination=cos(source1):一个寄存器的余弦值，分量形式
         */
        FagalMath.prototype.cos = function (destination, source1) {
            var code = "this.cos " + destination + ", " + source1;
            this.append(code);
        };
        /**
         * crs:两个寄存器间的叉积
         * <p>destination.x=source1.y*source2.z-source1.z*source2.y</p>
         * <p>destination.y=source1.z*source2.x-source1.x*source2.z</p>
         * <p>destination.z=source1.x*source2.y-source1.y*source2.x</p>
         */
        FagalMath.prototype.crs = function (destination, source1, source2) {
            var code = "this.crs " + destination + ", " + source1 + ", " + source2;
            this.append(code);
        };
        /**
         * destination=source1/source2:两个寄存器相除，分量形式
         */
        FagalMath.prototype.div = function (destination, source1, source2) {
            var code = "this.div " + destination + ", " + source1 + ", " + source2;
            this.append(code);
        };
        /**
         * dp3:两个寄存器间的点积，3分量
         * <br/>
         * destination=source1.x*source2.x+source1.y*source2.y+source1.z*source2.z
         */
        FagalMath.prototype.dp3 = function (destination, source1, source2) {
            var code = "this.dp3 " + destination + ", " + source1 + ", " + source2;
            this.append(code);
        };
        /**
         * dp4:两个寄存器间的点积，4分量
         * <br/>
         * destination=source1.x*source2.x+source1.y*source2.y+source1.z*source2.z+source1.w+source2.w
         */
        FagalMath.prototype.dp4 = function (destination, source1, source2) {
            var code = "this.dp4 " + destination + ", " + source1 + ", " + source2;
            this.append(code);
        };
        /**
         * destination=2^source1:2的source1次方，分量形式
         */
        FagalMath.prototype.exp = function (destination, source1) {
            var code = "this.exp " + destination + ", " + source1;
            this.append(code);
        };
        /**
         * destination=source1-(float)floor(source1)一个寄存器的分数部分，分量形式
         */
        FagalMath.prototype.frc = function (destination, source1) {
            var code = "this.frc " + destination + ", " + source1;
            this.append(code);
        };
        /**
         * 如果寄存器有任意一个分量小于0，则丢弃该像素不进行绘制(只适用于片段着色器)
         */
        FagalMath.prototype.kil = function (source1) {
            var code = "this.kil " + source1;
            this.append(code);
        };
        /**
         * destination=log(source1)一个寄存器以2为底的对数，分量形式
         */
        FagalMath.prototype.log = function (destination, source1) {
            var code = "this.log " + destination + ", " + source1;
            this.append(code);
        };
        /**
         * m33:由一个3*3的矩阵对一个3分量的向量进行矩阵乘法
         * <br/>
         * destination.x=(source1.x*source2[0].x)+(source1.y*source2[0].y)+(source1.z*source2[0].z)
         * <br/>
         * destination.y=(source1.x*source2[1].x)+(source1.y*source2[1].y)+(source1.z*source2[1].z)
         * <br/>
         * destination.z=(source1.x*source2[2].x)+(source1.y*source2[2].y)+(source1.z*source2[2].z)

         */
        FagalMath.prototype.m33 = function (destination, source1, source2) {
            var code = "this.m33 " + destination + ", " + source1 + ", " + source2;
            this.append(code);
        };
        /**
         * m34:由一个3*4的矩阵对一个4分量的向量进行矩阵乘法
         * <br/>
         * destination.x=(source1.x*source2[0].x)+(source1.y*source2[0].y)+(source1.z*source2[0].z)+(source1.w*source2[0].w)
         * <br/>
         * destination.y=(source1.x*source2[1].x)+(source1.y*source2[1].y)+(source1.z*source2[1].z)+(source1.w*source2[1].w)
         * <br/>destination.z=(source1.x*source2[2].x)+(source1.y*source2[2].y)+(source1.z*source2[2].z)+(source1.w*source2[2].w)

         */
        FagalMath.prototype.m34 = function (destination, source1, source2) {
            var code = "this.m34 " + destination + ", " + source1 + ", " + source2;
            this.append(code);
        };
        /**
         * m44:由一个4*4的矩阵对一个4分量的向量进行矩阵乘法
         * <br/>
         * destination.x=(source1.x*source2[0].x)+(source1.y*source2[0].y)+(source1.z*source2[0].z)+(source1.w*source2[0].w)
         * <br/>
         * destination.y=(source1.x*source2[1].x)+(source1.y*source2[1].y)+(source1.z*source2[1].z)+(source1.w*source2[1].w)
         * <br/>
         * destination.z=(source1.x*source2[2].x)+(source1.y*source2[2].y)+(source1.z*source2[2].z)+(source1.w*source2[2].w)
         * <br/>
         * destination.w=(source1.x*source2[3].x)+(source1.y*source2[3].y)+(source1.z*source2[3].z)+(source1.w*source2[3].w)
         */
        FagalMath.prototype.m44 = function (destination, source1, source2) {
            var code = "this.m44 " + destination + ", " + source1 + ", " + source2;
            this.append(code);
        };
        /**
         * max:destination=max(source1 ，source2): 两个寄存器之间的较大值，分量形式
         */
        FagalMath.prototype.max = function (destination, source1, source2) {
            var code = "this.max " + destination + ", " + source1 + ", " + source2;
            this.append(code);
        };
        /**
         * min:destination=min(source1 ， source2) : 两个寄存器之间的较小值，分量形式
         */
        FagalMath.prototype.min = function (destination, source1, source2) {
            var code = "this.min " + destination + ", " + source1 + ", " + source2;
            this.append(code);
        };
        /**
         * mov:destination=source :将数据从源寄存器复制到目标寄存器
         */
        FagalMath.prototype.mov = function (destination, source1) {
            var code = "this.mov " + destination + ", " + source1;
            this.append(code);
        };
        /**
         * destination = source1 * source2:两个寄存器相乘，分量形式
         */
        FagalMath.prototype.mul = function (destination, source1, source2) {
            var code = "this.mul " + destination + ", " + source1 + ", " + source2;
            this.append(code);
        };
        /**
         * destination=-source1:一个寄存器取反，分量形式
         */
        FagalMath.prototype.neg = function (destination, source1) {
            var code = "this.neg " + destination + ", " + source1;
            this.append(code);
        };
        /**
         * destination=normalize(source1):将一个寄存器标准化为长度1的单位向量
         */
        FagalMath.prototype.nrm = function (destination, source1) {
            var code = "this.nrm " + destination + ", " + source1;
            this.append(code);
        };
        /**
         * destination=pow(source1 ，source2):source1的source2次冥，分量形式
         */
        FagalMath.prototype.pow = function (destination, source1, source2) {
            var code = "this.pow " + destination + ", " + source1 + ", " + source2;
            this.append(code);
        };
        /**
         * destination=1/source1:一个寄存器的倒数，分量形式
         */
        FagalMath.prototype.rcp = function (destination, source1) {
            var code = "this.rcp " + destination + ", " + source1;
            this.append(code);
        };
        /**
         * destination=1/sqrt(source) 一个寄存器的平方根倒数，分量形式
         */
        FagalMath.prototype.rsq = function (destination, source1) {
            var code = "this.rsq " + destination + ", " + source1;
            this.append(code);
        };
        /**
         * destination=max(min(source1,1),0):将一个寄存器锁0-1的范围里
         */
        FagalMath.prototype.sat = function (destination, source1) {
            var code = "this.sat " + destination + ", " + source1;
            this.append(code);
        };
        /**
         * destination= source1==source2 ? 1 : 0
         */
        FagalMath.prototype.seq = function (destination, source1, source2) {
            var code = "this.seq " + destination + ", " + source1 + ", " + source2;
            this.append(code);
        };
        /**
         * destination = source1>=source2 ? 1 : 0 类似三元操作符 分量形式
         */
        FagalMath.prototype.sge = function (destination, source1, source2) {
            var code = "this.sge " + destination + ", " + source1 + ", " + source2;
            this.append(code);
        };
        /**
         * destination=sin(source1):一个寄存器的正弦值，分量形式
         */
        FagalMath.prototype.sin = function (destination, source1) {
            var code = "this.sin " + destination + ", " + source1;
            this.append(code);
        };
        /**
         * destination = source1小于source2 ? 1 : 0
         */
        FagalMath.prototype.slt = function (destination, source1, source2) {
            var code = "this.slt " + destination + ", " + source1 + ", " + source2;
            this.append(code);
        };
        /**
         * destination=source1!=source2 ? 1:0
         */
        FagalMath.prototype.sne = function (destination, source1, source2) {
            var code = "this.sne " + destination + ", " + source1 + ", " + source2;
            this.append(code);
        };
        /**
         * destination=sqrt(source):一个寄存器的平方根，分量形式
         */
        FagalMath.prototype.sqt = function (destination, source1) {
            var code = "this.sqt " + destination + ", " + source1;
            this.append(code);
        };
        /**
         * destination=source1-source2:两个寄存器相减，分量形式
         */
        FagalMath.prototype.sub = function (destination, source1, source2) {
            var code = "this.sub " + destination + ", " + source1 + ", " + source2;
            this.append(code);
        };
        /**
         * 纹理取样
         * @param	colorReg	目标寄存器
         * @param	uvReg		UV坐标
         * @param	textureReg	纹理寄存器
         * @param	flags		取样参数
         */
        FagalMath.prototype.tex = function (colorReg, uvReg, textureReg) {
            var code = "this.tex " + colorReg + ", " + uvReg + ", " + textureReg;
            //获取法线纹理采样参数
            var flags = getSampleFlags(textureReg);
            if (flags && flags.length > 0) {
                code += " <" + flags.join(",") + ">";
            }
            this.append(code);
            /**
             * 获取取样参数
             * @param textureReg 纹理寄存器
             * @return 取样参数
             */
            function getSampleFlags(textureReg) {
                //抛出 获取取样标记 事件
                var shaderParams = feng3d.FagalRE.instance.context3DCache.shaderParams;
                //提取 渲染标记
                var flags = shaderParams.getFlags(textureReg.regId);
                return flags;
            }
        };
        /**
         * 混合数据
         * <p>destination = source1 + (source2-source1) x factor</p>
         * @author feng 2015-7-4
         */
        FagalMath.prototype.blend = function (destination, source1, source2, factor) {
            this.sub(source2, source2, source1);
            this.mul(source2, source2, factor);
            this.add(destination, source1, source2);
        };
        /**
         * 添加注释
         */
        FagalMath.prototype.comment = function () {
            var remarks = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                remarks[_i - 0] = arguments[_i];
            }
            if (!feng3d.Debug.agalDebug)
                return;
            this.append(feng3d.FagalToken.COMMENT + remarks.join(" "));
        };
        /**
         * 添加代码
         */
        FagalMath.prototype.append = function (code) {
            this.dispatchEvent(new feng3d.FagalMathEvent(feng3d.FagalMathEvent.FAGALMATHEVENT_APPEND, code));
        };
        return FagalMath;
    }(feng3d.EventDispatcher));
    feng3d.FagalMath = FagalMath;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 解析基类
     * @author feng 2014-5-16
     */
    var ParserBase = (function (_super) {
        __extends(ParserBase, _super);
        function ParserBase(format) {
            _super.call(this);
            this._materialMode = 0;
            this._dataFormat = format;
            this._dependencies = [];
        }
        ParserBase.prototype.getTextData = function () {
            return feng3d.ParserUtil.toString(this._data);
        };
        ParserBase.prototype.getByteData = function () {
            return this._data;
        };
        Object.defineProperty(ParserBase.prototype, "materialMode", {
            get: function () {
                return this._materialMode;
            },
            set: function (newMaterialMode) {
                this._materialMode = newMaterialMode;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ParserBase.prototype, "dataFormat", {
            /** 数据格式 */
            get: function () {
                return this._dataFormat;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 完成资源分析（派发资源事件）
         * @param asset 完成的资源
         * @param name 资源名称
         */
        ParserBase.prototype.finalizeAsset = function (asset, name) {
            if (name === void 0) { name = null; }
            var type_event;
            var type_name;
            if (name != null)
                asset.namedAsset.name = name;
            switch (asset.namedAsset.assetType) {
                case feng3d.AssetType.LIGHT_PICKER:
                    type_name = 'lightPicker';
                    type_event = feng3d.AssetEvent.LIGHTPICKER_COMPLETE;
                    break;
                case feng3d.AssetType.LIGHT:
                    type_name = 'light';
                    type_event = feng3d.AssetEvent.LIGHT_COMPLETE;
                    break;
                case feng3d.AssetType.ANIMATOR:
                    type_name = 'animator';
                    type_event = feng3d.AssetEvent.ANIMATOR_COMPLETE;
                    break;
                case feng3d.AssetType.ANIMATION_SET:
                    type_name = 'animationSet';
                    type_event = feng3d.AssetEvent.ANIMATION_SET_COMPLETE;
                    break;
                case feng3d.AssetType.ANIMATION_STATE:
                    type_name = 'animationState';
                    type_event = feng3d.AssetEvent.ANIMATION_STATE_COMPLETE;
                    break;
                case feng3d.AssetType.ANIMATION_NODE:
                    type_name = 'animationNode';
                    type_event = feng3d.AssetEvent.ANIMATION_NODE_COMPLETE;
                    break;
                case feng3d.AssetType.STATE_TRANSITION:
                    type_name = 'stateTransition';
                    type_event = feng3d.AssetEvent.STATE_TRANSITION_COMPLETE;
                    break;
                case feng3d.AssetType.TEXTURE:
                    type_name = 'texture';
                    type_event = feng3d.AssetEvent.TEXTURE_COMPLETE;
                    break;
                case feng3d.AssetType.TEXTURE_PROJECTOR:
                    type_name = 'textureProjector';
                    type_event = feng3d.AssetEvent.TEXTURE_PROJECTOR_COMPLETE;
                    break;
                case feng3d.AssetType.CONTAINER:
                    type_name = 'container';
                    type_event = feng3d.AssetEvent.CONTAINER_COMPLETE;
                    break;
                case feng3d.AssetType.GEOMETRY:
                    type_name = 'geometry';
                    type_event = feng3d.AssetEvent.GEOMETRY_COMPLETE;
                    break;
                case feng3d.AssetType.MATERIAL:
                    type_name = 'material';
                    type_event = feng3d.AssetEvent.MATERIAL_COMPLETE;
                    break;
                case feng3d.AssetType.MESH:
                    type_name = 'mesh';
                    type_event = feng3d.AssetEvent.MESH_COMPLETE;
                    break;
                case feng3d.AssetType.SKELETON:
                    type_name = 'skeleton';
                    type_event = feng3d.AssetEvent.SKELETON_COMPLETE;
                    break;
                case feng3d.AssetType.SKELETON_POSE:
                    type_name = 'skelpose';
                    type_event = feng3d.AssetEvent.SKELETON_POSE_COMPLETE;
                    break;
                case feng3d.AssetType.ENTITY:
                    type_name = 'entity';
                    type_event = feng3d.AssetEvent.ENTITY_COMPLETE;
                    break;
                case feng3d.AssetType.SKYBOX:
                    type_name = 'skybox';
                    type_event = feng3d.AssetEvent.SKYBOX_COMPLETE;
                    break;
                case feng3d.AssetType.CAMERA:
                    type_name = 'camera';
                    type_event = feng3d.AssetEvent.CAMERA_COMPLETE;
                    break;
                case feng3d.AssetType.SEGMENT_SET:
                    type_name = 'segmentSet';
                    type_event = feng3d.AssetEvent.SEGMENT_SET_COMPLETE;
                    break;
                case feng3d.AssetType.EFFECTS_METHOD:
                    type_name = 'effectsMethod';
                    type_event = feng3d.AssetEvent.EFFECTMETHOD_COMPLETE;
                    break;
                case feng3d.AssetType.SHADOW_MAP_METHOD:
                    type_name = 'effectsMethod';
                    type_event = feng3d.AssetEvent.SHADOWMAPMETHOD_COMPLETE;
                    break;
                default:
                    throw new Error('Unhandled asset type ' + asset.namedAsset.assetType + '. Report as bug!');
            }
            //默认资源名为类型名
            if (!asset.namedAsset.name)
                asset.namedAsset.name = type_name;
            this.dispatchEvent(new feng3d.AssetEvent(feng3d.AssetEvent.ASSET_COMPLETE, asset));
            this.dispatchEvent(new feng3d.AssetEvent(type_event, asset));
        };
        ParserBase.prototype.resolveDependencyName = function (resourceDependency, asset) {
            return asset.namedAsset.name;
        };
        Object.defineProperty(ParserBase.prototype, "parsingPaused", {
            /**
             * 是否暂停解析
             */
            get: function () {
                return this._parsingPaused;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ParserBase.prototype, "parsingComplete", {
            /**
             * 是否解析完成
             */
            get: function () {
                return this._parsingComplete;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 异步解析数据
         * @param data 数据
         * @param frameLimit 帧时间限制
         */
        ParserBase.prototype.parseAsync = function (data, frameLimit) {
            if (frameLimit === void 0) { frameLimit = 30; }
            this._data = data;
            this.startParsing(frameLimit);
        };
        Object.defineProperty(ParserBase.prototype, "dependencies", {
            /**
             * A list of dependencies that need to be loaded and resolved for the object being parsed.
             */
            get: function () {
                return this._dependencies;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 是否还有时间
         */
        ParserBase.prototype.hasTime = function () {
            return ((getTimer() - this._lastFrameTime) < this._frameLimit);
        };
        /**
         * 开始解析数据
         * @param frameLimit 帧时间限制
         */
        ParserBase.prototype.startParsing = function (frameLimit) {
            this._frameLimit = frameLimit;
            this._timer = new feng3d.Timer(this._frameLimit, 0);
            this._timer.addEventListener(feng3d.TimerEvent.TIMER, this.onInterval);
            this._timer.start();
        };
        /**
         * 触发解析
         * @param event
         */
        ParserBase.prototype.onInterval = function (event) {
            if (event === void 0) { event = null; }
            this._lastFrameTime = getTimer();
            if (this.proceedParsing() && !this._parsingFailure)
                this.finishParsing();
        };
        /**
         * 暂停解析，去准备依赖项
         */
        ParserBase.prototype.pauseAndRetrieveDependencies = function () {
            //			if (this._timer)
            //				this._timer.stop();
            //			this._parsingPaused = true;
            //			this.dispatchEvent(new ParserEvent(ParserEvent.READY_FOR_DEPENDENCIES));
        };
        /**
         * 继续解析，准备好依赖项后
         */
        ParserBase.prototype.resumeParsingAfterDependencies = function () {
            this._parsingPaused = false;
            if (this._timer)
                this._timer.start();
        };
        /**
         * 完成解析
         */
        ParserBase.prototype.finishParsing = function () {
            if (this._timer) {
                this._timer.removeEventListener(feng3d.TimerEvent.TIMER, this.onInterval);
                this._timer.stop();
            }
            this._timer = null;
            this._parsingComplete = true;
            this.dispatchEvent(new feng3d.ParserEvent(feng3d.ParserEvent.PARSE_COMPLETE));
        };
        /**
         * 添加依赖项
         * @param id 编号
         * @param req url请求
         * @param retrieveAsRawData
         * @param data
         * @param suppressErrorEvents
         */
        ParserBase.prototype.addDependency = function (id, req, retrieveAsRawData, data, suppressErrorEvents) {
            if (retrieveAsRawData === void 0) { retrieveAsRawData = false; }
            if (data === void 0) { data = null; }
            if (suppressErrorEvents === void 0) { suppressErrorEvents = false; }
            this._dependencies.push(new feng3d.ResourceDependency(id, req, data, this, retrieveAsRawData, suppressErrorEvents));
        };
        ParserBase.PARSING_DONE = true;
        ParserBase.MORE_TO_PARSE = false;
        return ParserBase;
    }(feng3d.EventDispatcher));
    feng3d.ParserBase = ParserBase;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * ImageParser provides a "parser" for natively supported image types (jpg, png). While it simply loads bytes into
     * a loader object, it wraps it in a BitmapDataResource so resource management can happen consistently without
     * exception cases.
     */
    var ImageParser = (function (_super) {
        __extends(ImageParser, _super);
        /**
         * Creates a new ImageParser object.
         * @param uri The url or id of the data or file to be parsed.
         * @param extra The holder for extra contextual data that the parser might need.
         */
        function ImageParser() {
            _super.call(this, feng3d.ParserDataFormat.BINARY);
        }
        /**
         * 解决依赖
         * @param resourceDependency 依赖资源
         */
        ImageParser.prototype.resolveDependency = function (resourceDependency) {
        };
        /**
         * 解决依赖失败
         * @param resourceDependency 依赖资源
         */
        ImageParser.prototype.resolveDependencyFailure = function (resourceDependency) {
        };
        /**
         * Indicates whether or not a given file extension is supported by the parser.
         * @param extension The file extension of a potential file to be parsed.
         * @return Whether or not the given file type is supported.
         */
        ImageParser.supportsType = function (extension) {
            extension = extension.toLowerCase();
            return extension == "jpg" || extension == "jpeg" || extension == "png" || extension == "gif" || extension == "bmp" || extension == "atf";
        };
        /**
         * Tests whether a data block can be parsed by the parser.
         * @param data The data block to potentially be parsed.
         * @return Whether or not the given data is supported.
         */
        ImageParser.supportsData = function (data) {
            //shortcut if asset is IFlexAsset
            if (feng3d.is(data, feng3d.Bitmap))
                return true;
            if (feng3d.is(data, feng3d.BitmapData))
                return true;
            if (!feng3d.is(data, feng3d.ByteArray))
                return false;
            var ba = data;
            ba.position = 0;
            if (ba.readUnsignedShort() == 0xffd8)
                return true; // JPEG, maybe check for "JFIF" as well?
            ba.position = 0;
            if (ba.readShort() == 0x424D)
                return true; // BMP
            ba.position = 1;
            if (ba.readUTFBytes(3) == 'PNG')
                return true;
            ba.position = 0;
            if (ba.readUTFBytes(3) == 'GIF' && ba.readShort() == 0x3839 && ba.readByte() == 0x61)
                return true;
            ba.position = 0;
            if (ba.readUTFBytes(3) == 'ATF')
                return true;
            return false;
        };
        /**
         * @inheritDoc
         */
        ImageParser.prototype.proceedParsing = function () {
            var asset;
            if (feng3d.is(this._data, feng3d.Bitmap)) {
                asset = new feng3d.BitmapTexture(feng3d.as(this._data, feng3d.Bitmap).bitmapData);
                this.finalizeAsset(asset, this._fileName);
                return ImageParser.PARSING_DONE;
            }
            if (feng3d.is(this._data, feng3d.BitmapData)) {
                asset = new feng3d.BitmapTexture(this._data);
                this.finalizeAsset(asset, this._fileName);
                return ImageParser.PARSING_DONE;
            }
            return this._doneParsing;
        };
        return ImageParser;
    }(feng3d.ParserBase));
    feng3d.ImageParser = ImageParser;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 该类提供md5anim类型数据的解析，提供一个MD5类型的动画序列
     */
    var MD5AnimParser = (function (_super) {
        __extends(MD5AnimParser, _super);
        /**
         * 创建一个MD5动画解析类
         * @param additionalRotationAxis 附加旋转轴
         * @param additionalRotationRadians 附加旋转角度
         */
        function MD5AnimParser(additionalRotationAxis, additionalRotationRadians) {
            if (additionalRotationAxis === void 0) { additionalRotationAxis = null; }
            if (additionalRotationRadians === void 0) { additionalRotationRadians = 0; }
            _super.call(this, feng3d.ParserDataFormat.PLAIN_TEXT);
            //初始化旋转四元素
            this._rotationQuat = new feng3d.Quaternion();
            var t1 = new feng3d.Quaternion();
            var t2 = new feng3d.Quaternion();
            t1.fromAxisAngle(feng3d.Vector3D.X_AXIS, -Math.PI * .5);
            t2.fromAxisAngle(feng3d.Vector3D.Y_AXIS, -Math.PI * .5);
            this._rotationQuat.multiply(t2, t1);
            if (additionalRotationAxis) {
                this._rotationQuat.multiply(t2, t1);
                t1.fromAxisAngle(additionalRotationAxis, additionalRotationRadians);
                this._rotationQuat.multiply(t1, this._rotationQuat);
            }
        }
        /**
         * 判断是否支持解析
         * @param extension 文件类型
         * @return
         */
        MD5AnimParser.supportsType = function (extension) {
            extension = extension.toLowerCase();
            return extension == "md5anim";
        };
        /**
         * 判断是否支持该数据的解析
         * @param data 需要解析的数据
         * @return
         */
        MD5AnimParser.supportsData = function (data) {
            data = data;
            return false;
        };
        MD5AnimParser.prototype.proceedParsing = function () {
            var token;
            if (!this._startedParsing) {
                this._textData = this.getTextData();
                this._startedParsing = true;
            }
            while (this.hasTime()) {
                token = this.getNextToken();
                switch (token) {
                    case MD5AnimParser.COMMENT_TOKEN:
                        this.ignoreLine();
                        break;
                    case "":
                        // can occur at the end of a file
                        break;
                    case MD5AnimParser.VERSION_TOKEN:
                        this._version = this.getNextInt();
                        if (this._version != 10)
                            throw new Error("Unknown version number encountered!");
                        break;
                    case MD5AnimParser.COMMAND_LINE_TOKEN:
                        this.parseCMD();
                        break;
                    case MD5AnimParser.NUM_FRAMES_TOKEN:
                        this._numFrames = this.getNextInt();
                        this._bounds = [];
                        this._frameData = [];
                        break;
                    case MD5AnimParser.NUM_JOINTS_TOKEN:
                        this._numJoints = this.getNextInt();
                        this._hierarchy = [];
                        this._hierarchy.length = this._numJoints;
                        this._baseFrameData = [];
                        this._baseFrameData.length = this._numJoints;
                        break;
                    case MD5AnimParser.FRAME_RATE_TOKEN:
                        this._frameRate = this.getNextInt();
                        break;
                    case MD5AnimParser.NUM_ANIMATED_COMPONENTS_TOKEN:
                        this._numAnimatedComponents = this.getNextInt();
                        break;
                    case MD5AnimParser.HIERARCHY_TOKEN:
                        this.parseHierarchy();
                        break;
                    case MD5AnimParser.BOUNDS_TOKEN:
                        this.parseBounds();
                        break;
                    case MD5AnimParser.BASE_FRAME_TOKEN:
                        this.parseBaseFrame();
                        break;
                    case MD5AnimParser.FRAME_TOKEN:
                        this.parseFrame();
                        break;
                    default:
                        if (!this._reachedEOF)
                            this.sendUnknownKeywordError();
                }
                //解析出 骨骼动画数据
                if (this._reachedEOF) {
                    this._clip = new feng3d.SkeletonClipNode();
                    this.translateClip();
                    this.finalizeAsset(this._clip);
                    return feng3d.ParserBase.PARSING_DONE;
                }
            }
            return feng3d.ParserBase.MORE_TO_PARSE;
        };
        /**
         * 收集所有的关键帧数据
         */
        MD5AnimParser.prototype.translateClip = function () {
            for (var i = 0; i < this._numFrames; ++i)
                this._clip.addFrame(this.translatePose(this._frameData[i]), 1000 / this._frameRate);
        };
        /**
         * 将一个关键帧数据转换为SkeletonPose
         * @param frameData 帧数据
         * @return 包含帧数据的SkeletonPose对象
         */
        MD5AnimParser.prototype.translatePose = function (frameData) {
            var hierarchy;
            var pose;
            var base;
            var flags;
            var j;
            //偏移量
            var translate = new feng3d.Vector3D();
            //旋转四元素
            var orientation = new feng3d.Quaternion();
            var components = frameData.components;
            //骨骼pose数据
            var skelPose = new feng3d.SkeletonPose();
            //骨骼pose列表
            var jointPoses = skelPose.jointPoses;
            for (var i = 0; i < this._numJoints; ++i) {
                //通过原始帧数据与层级数据计算出当前骨骼pose数据
                j = 0;
                //层级数据
                hierarchy = this._hierarchy[i];
                //基础帧数据
                base = this._baseFrameData[i];
                //层级标记
                flags = hierarchy.flags;
                translate.x = base.position.x;
                translate.y = base.position.y;
                translate.z = base.position.z;
                orientation.x = base.orientation.x;
                orientation.y = base.orientation.y;
                orientation.z = base.orientation.z;
                //调整位移与角度数据
                if (flags & 1)
                    translate.x = components[hierarchy.startIndex + (j++)];
                if (flags & 2)
                    translate.y = components[hierarchy.startIndex + (j++)];
                if (flags & 4)
                    translate.z = components[hierarchy.startIndex + (j++)];
                if (flags & 8)
                    orientation.x = components[hierarchy.startIndex + (j++)];
                if (flags & 16)
                    orientation.y = components[hierarchy.startIndex + (j++)];
                if (flags & 32)
                    orientation.z = components[hierarchy.startIndex + (j++)];
                //计算四元素w值
                var w = 1 - orientation.x * orientation.x - orientation.y * orientation.y - orientation.z * orientation.z;
                orientation.w = w < 0 ? 0 : -Math.sqrt(w);
                //创建关节pose数据
                pose = new feng3d.JointPose();
                if (hierarchy.parentIndex < 0) {
                    pose.orientation.multiply(this._rotationQuat, orientation);
                    pose.translation = this._rotationQuat.rotatePoint(translate);
                }
                else {
                    pose.orientation.copyFrom(orientation);
                    pose.translation.x = translate.x;
                    pose.translation.y = translate.y;
                    pose.translation.z = translate.z;
                }
                pose.orientation.y = -pose.orientation.y;
                pose.orientation.z = -pose.orientation.z;
                pose.translation.x = -pose.translation.x;
                jointPoses[i] = pose;
            }
            return skelPose;
        };
        /**
         * 解析骨骼的层级数据
         */
        MD5AnimParser.prototype.parseHierarchy = function () {
            var ch;
            var data;
            var token = this.getNextToken();
            var i = 0;
            if (token != "{")
                this.sendUnknownKeywordError();
            do {
                if (this._reachedEOF)
                    this.sendEOFError();
                data = new HierarchyData();
                data.name = this.parseLiteralString();
                data.parentIndex = this.getNextInt();
                data.flags = this.getNextInt();
                data.startIndex = this.getNextInt();
                this._hierarchy[i++] = data;
                ch = this.getNextChar();
                if (ch == "/") {
                    this.putBack();
                    ch = this.getNextToken();
                    if (ch == MD5AnimParser.COMMENT_TOKEN)
                        this.ignoreLine();
                    ch = this.getNextChar();
                }
                if (ch != "}")
                    this.putBack();
            } while (ch != "}");
        };
        /**
         * 解析帧边界
         */
        MD5AnimParser.prototype.parseBounds = function () {
            var ch;
            var data;
            var token = this.getNextToken();
            var i = 0;
            if (token != "{")
                this.sendUnknownKeywordError();
            do {
                if (this._reachedEOF)
                    this.sendEOFError();
                data = new BoundsData();
                data.min = this.parseVector3D();
                data.max = this.parseVector3D();
                this._bounds[i++] = data;
                ch = this.getNextChar();
                if (ch == "/") {
                    this.putBack();
                    ch = this.getNextToken();
                    if (ch == MD5AnimParser.COMMENT_TOKEN)
                        this.ignoreLine();
                    ch = this.getNextChar();
                }
                if (ch != "}")
                    this.putBack();
            } while (ch != "}");
        };
        /**
         * 解析基础帧
         */
        MD5AnimParser.prototype.parseBaseFrame = function () {
            var ch;
            var data;
            var token = this.getNextToken();
            var i = 0;
            if (token != "{")
                this.sendUnknownKeywordError();
            do {
                if (this._reachedEOF)
                    this.sendEOFError();
                data = new BaseFrameData();
                data.position = this.parseVector3D();
                data.orientation = this.parseQuaternion();
                this._baseFrameData[i++] = data;
                ch = this.getNextChar();
                if (ch == "/") {
                    this.putBack();
                    ch = this.getNextToken();
                    if (ch == MD5AnimParser.COMMENT_TOKEN)
                        this.ignoreLine();
                    ch = this.getNextChar();
                }
                if (ch != "}")
                    this.putBack();
            } while (ch != "}");
        };
        /**
         * 解析帧
         */
        MD5AnimParser.prototype.parseFrame = function () {
            var ch;
            var data;
            var token;
            var frameIndex;
            frameIndex = this.getNextInt();
            token = this.getNextToken();
            if (token != "{")
                this.sendUnknownKeywordError();
            do {
                if (this._reachedEOF)
                    this.sendEOFError();
                data = new FrameData();
                data.components = [];
                data.components.length = this._numAnimatedComponents;
                for (var i = 0; i < this._numAnimatedComponents; ++i)
                    data.components[i] = this.getNextNumber();
                this._frameData[frameIndex] = data;
                ch = this.getNextChar();
                if (ch == "/") {
                    this.putBack();
                    ch = this.getNextToken();
                    if (ch == MD5AnimParser.COMMENT_TOKEN)
                        this.ignoreLine();
                    ch = this.getNextChar();
                }
                if (ch != "}")
                    this.putBack();
            } while (ch != "}");
        };
        /**
         * 返回到上个字符位置
         */
        MD5AnimParser.prototype.putBack = function () {
            this._parseIndex--;
            this._charLineIndex--;
            this._reachedEOF = this._parseIndex >= this._textData.length;
        };
        /**
         * 获取下个关键字
         */
        MD5AnimParser.prototype.getNextToken = function () {
            var ch;
            var token = "";
            while (!this._reachedEOF) {
                ch = this.getNextChar();
                if (ch == " " || ch == "\r" || ch == "\n" || ch == "\t") {
                    if (token != MD5AnimParser.COMMENT_TOKEN)
                        this.skipWhiteSpace();
                    if (token != "")
                        return token;
                }
                else
                    token += ch;
                if (token == MD5AnimParser.COMMENT_TOKEN)
                    return token;
            }
            return token;
        };
        /**
         * 跳过空白
         */
        MD5AnimParser.prototype.skipWhiteSpace = function () {
            var ch;
            do
                ch = this.getNextChar();
            while (ch == "\n" || ch == " " || ch == "\r" || ch == "\t");
            this.putBack();
        };
        /**
         * 忽略该行
         */
        MD5AnimParser.prototype.ignoreLine = function () {
            var ch;
            while (!this._reachedEOF && ch != "\n")
                ch = this.getNextChar();
        };
        /**
         * 读取下个字符
         */
        MD5AnimParser.prototype.getNextChar = function () {
            var ch = this._textData.charAt(this._parseIndex++);
            if (ch == "\n") {
                ++this._line;
                this._charLineIndex = 0;
            }
            else if (ch != "\r")
                ++this._charLineIndex;
            if (this._parseIndex == this._textData.length)
                this._reachedEOF = true;
            return ch;
        };
        /**
         * 读取下个number
         */
        MD5AnimParser.prototype.getNextInt = function () {
            var i = parseInt(this.getNextToken());
            if (isNaN(i))
                this.sendParseError("number type");
            return i;
        };
        /**
         * 读取下个number
         */
        MD5AnimParser.prototype.getNextNumber = function () {
            var f = parseFloat(this.getNextToken());
            if (isNaN(f))
                this.sendParseError("float type");
            return f;
        };
        /**
         * 解析3d向量
         */
        MD5AnimParser.prototype.parseVector3D = function () {
            var vec = new feng3d.Vector3D();
            var ch = this.getNextToken();
            if (ch != "(")
                this.sendParseError("(");
            vec.x = this.getNextNumber();
            vec.y = this.getNextNumber();
            vec.z = this.getNextNumber();
            if (this.getNextToken() != ")")
                this.sendParseError(")");
            return vec;
        };
        /**
         * 解析四元素
         */
        MD5AnimParser.prototype.parseQuaternion = function () {
            var quat = new feng3d.Quaternion();
            var ch = this.getNextToken();
            if (ch != "(")
                this.sendParseError("(");
            quat.x = this.getNextNumber();
            quat.y = this.getNextNumber();
            quat.z = this.getNextNumber();
            // quat supposed to be unit length
            var t = 1 - (quat.x * quat.x) - (quat.y * quat.y) - (quat.z * quat.z);
            quat.w = t < 0 ? 0 : -Math.sqrt(t);
            if (this.getNextToken() != ")")
                this.sendParseError(")");
            return quat;
        };
        /**
         * 解析命令行数据
         */
        MD5AnimParser.prototype.parseCMD = function () {
            // just ignore the command line property
            this.parseLiteralString();
        };
        /**
         * 解析带双引号的字符串
         */
        MD5AnimParser.prototype.parseLiteralString = function () {
            this.skipWhiteSpace();
            var ch = this.getNextChar();
            var str = "";
            if (ch != "\"")
                this.sendParseError("\"");
            do {
                if (this._reachedEOF)
                    this.sendEOFError();
                ch = this.getNextChar();
                if (ch != "\"")
                    str += ch;
            } while (ch != "\"");
            return str;
        };
        /**
         * 抛出一个文件尾过早结束文件时遇到错误
         */
        MD5AnimParser.prototype.sendEOFError = function () {
            throw new Error("Unexpected end of file");
        };
        /**
         * 遇到了一个意想不到的令牌时将抛出一个错误。
         * @param expected 发生错误的标记
         */
        MD5AnimParser.prototype.sendParseError = function (expected) {
            throw new Error("Unexpected token at line " + (this._line + 1) + ", character " + this._charLineIndex + ". " + expected + " expected, but " + this._textData.charAt(this._parseIndex - 1) + " encountered");
        };
        /**
         * 发生未知关键字错误
         */
        MD5AnimParser.prototype.sendUnknownKeywordError = function () {
            throw new Error("Unknown keyword at line " + (this._line + 1) + ", character " + this._charLineIndex + ". ");
        };
        /**
         * 解决依赖
         * @param resourceDependency 依赖资源
         */
        MD5AnimParser.prototype.resolveDependency = function (resourceDependency) {
        };
        /**
         * 解决依赖失败
         * @param resourceDependency 依赖资源
         */
        MD5AnimParser.prototype.resolveDependencyFailure = function (resourceDependency) {
        };
        //md5anim文件关键字
        MD5AnimParser.VERSION_TOKEN = "MD5Version";
        MD5AnimParser.COMMAND_LINE_TOKEN = "commandline";
        MD5AnimParser.NUM_FRAMES_TOKEN = "numFrames";
        MD5AnimParser.NUM_JOINTS_TOKEN = "numJoints";
        MD5AnimParser.FRAME_RATE_TOKEN = "frameRate";
        MD5AnimParser.NUM_ANIMATED_COMPONENTS_TOKEN = "numAnimatedComponents";
        MD5AnimParser.HIERARCHY_TOKEN = "hierarchy";
        MD5AnimParser.BOUNDS_TOKEN = "bounds";
        MD5AnimParser.BASE_FRAME_TOKEN = "baseframe";
        MD5AnimParser.FRAME_TOKEN = "frame";
        MD5AnimParser.COMMENT_TOKEN = "//";
        return MD5AnimParser;
    }(feng3d.ParserBase));
    feng3d.MD5AnimParser = MD5AnimParser;
    /**
     * 层级数据
     */
    var HierarchyData = (function () {
        function HierarchyData() {
        }
        HierarchyData.prototype.HierarchyData = function () {
        };
        return HierarchyData;
    }());
    /**
     * 包围盒信息
     */
    var BoundsData = (function () {
        function BoundsData() {
        }
        BoundsData.prototype.BoundsData = function () {
        };
        return BoundsData;
    }());
    /**
     * 基础帧数据
     */
    var BaseFrameData = (function () {
        function BaseFrameData() {
        }
        BaseFrameData.prototype.BaseFrameData = function () {
        };
        return BaseFrameData;
    }());
    /**
     * 帧数据
     */
    var FrameData = (function () {
        function FrameData() {
        }
        FrameData.prototype.FrameData = function () {
        };
        return FrameData;
    }());
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * MD5Mesh文件解析类
     */
    var MD5MeshParser = (function (_super) {
        __extends(MD5MeshParser, _super);
        /**
         * 创建一个MD5Mesh解析对象
         */
        function MD5MeshParser(additionalRotationAxis, additionalRotationRadians) {
            if (additionalRotationAxis === void 0) { additionalRotationAxis = null; }
            if (additionalRotationRadians === void 0) { additionalRotationRadians = 0; }
            _super.call(this, feng3d.ParserDataFormat.PLAIN_TEXT);
            //初始化 旋转四元素
            this._rotationQuat = new feng3d.Quaternion();
            this._rotationQuat.fromAxisAngle(feng3d.Vector3D.X_AXIS, -Math.PI * .5);
            if (additionalRotationAxis) {
                var quat = new feng3d.Quaternion();
                quat.fromAxisAngle(additionalRotationAxis, additionalRotationRadians);
                this._rotationQuat.multiply(this._rotationQuat, quat);
            }
        }
        /**
         * 判断是否支持解析
         * @param extension 文件类型
         * @return
         */
        MD5MeshParser.supportsType = function (extension) {
            extension = extension.toLowerCase();
            return extension == "md5mesh";
        };
        /**
         * 判断是否支持该数据的解析
         * @param data 需要解析的数据
         * @return
         */
        MD5MeshParser.supportsData = function (data) {
            data = data;
            return false;
        };
        MD5MeshParser.prototype.proceedParsing = function () {
            var token;
            //标记开始解析
            if (!this._startedParsing) {
                this._textData = this.getTextData();
                this._startedParsing = true;
            }
            while (this.hasTime()) {
                //获取关键字
                token = this.getNextToken();
                switch (token) {
                    case MD5MeshParser.COMMENT_TOKEN:
                        this.ignoreLine();
                        break;
                    case MD5MeshParser.VERSION_TOKEN:
                        this._version = this.getNextInt();
                        if (this._version != 10)
                            throw new Error("Unknown version number encountered!");
                        break;
                    case MD5MeshParser.COMMAND_LINE_TOKEN:
                        this.parseCMD();
                        break;
                    case MD5MeshParser.NUM_JOINTS_TOKEN:
                        this._numJoints = this.getNextInt();
                        this._bindPoses = [];
                        this._bindPoses.length = this._numJoints;
                        break;
                    case MD5MeshParser.NUM_MESHES_TOKEN:
                        this._numMeshes = this.getNextInt();
                        break;
                    case MD5MeshParser.JOINTS_TOKEN:
                        this.parseJoints();
                        break;
                    case MD5MeshParser.MESH_TOKEN:
                        this.parseMesh();
                        break;
                    default:
                        if (!this._reachedEOF)
                            this.sendUnknownKeywordError();
                }
                //解析结束后 生成引擎相关对象
                if (this._reachedEOF) {
                    this.calculateMaxJointCount();
                    this._animationSet = new feng3d.SkeletonAnimationSet(this._maxJointCount);
                    //生成引擎所需网格对象
                    var _mesh = new feng3d.Mesh(new feng3d.Geometry(), null);
                    var _geometry = _mesh.geometry;
                    for (var i = 0; i < this._meshData.length; ++i)
                        _geometry.addSubGeometry(this.translateGeom(this._meshData[i].vertexData, this._meshData[i].weightData, this._meshData[i].indices));
                    this.finalizeAsset(_geometry);
                    this.finalizeAsset(_mesh);
                    this.finalizeAsset(this._skeleton);
                    this.finalizeAsset(this._animationSet);
                    return feng3d.ParserBase.PARSING_DONE;
                }
            }
            return feng3d.ParserBase.MORE_TO_PARSE;
        };
        /**
         * 计算最大关节数量
         */
        MD5MeshParser.prototype.calculateMaxJointCount = function () {
            this._maxJointCount = 0;
            //遍历所有的网格数据
            var numMeshData = this._meshData.length;
            for (var i = 0; i < numMeshData; ++i) {
                var meshData = this._meshData[i];
                var vertexData = meshData.vertexData;
                var numVerts = vertexData.length;
                //遍历每个顶点 寻找关节关联最大数量
                for (var j = 0; j < numVerts; ++j) {
                    var zeroWeights = this.countZeroWeightJoints(vertexData[j], meshData.weightData);
                    var totalJoints = vertexData[j].countWeight - zeroWeights;
                    if (totalJoints > this._maxJointCount)
                        this._maxJointCount = totalJoints;
                }
            }
        };
        /**
         * 计算0权重关节数量
         * @param vertex 顶点数据
         * @param weights 关节权重数组
         * @return
         */
        MD5MeshParser.prototype.countZeroWeightJoints = function (vertex, weights) {
            var start = vertex.startWeight;
            var end = vertex.startWeight + vertex.countWeight;
            var count = 0;
            var weight;
            for (var i = start; i < end; ++i) {
                weight = weights[i].bias;
                if (weight == 0)
                    ++count;
            }
            return count;
        };
        /**
         * 解析关节
         */
        MD5MeshParser.prototype.parseJoints = function () {
            var ch;
            var joint;
            var pos;
            var quat;
            var i = 0;
            var token = this.getNextToken();
            if (token != "{")
                this.sendUnknownKeywordError();
            //解析骨骼数据
            this._skeleton = new feng3d.Skeleton();
            do {
                if (this._reachedEOF)
                    this.sendEOFError();
                //解析骨骼关节数据
                joint = new feng3d.SkeletonJoint();
                joint.name = this.parseLiteralString();
                joint.parentIndex = this.getNextInt();
                //关节坐标
                pos = this.parseVector3D();
                pos = this._rotationQuat.rotatePoint(pos);
                quat = this.parseQuaternion();
                // 计算bindpose下该节点(关节)的真正变换矩阵
                this._bindPoses[i] = quat.toMatrix3D();
                this._bindPoses[i].appendTranslation(pos.x, pos.y, pos.z);
                var inv = this._bindPoses[i].clone();
                inv.invert();
                joint.inverseBindPose = inv.rawData;
                //收集关节数据
                this._skeleton.joints[i++] = joint;
                ch = this.getNextChar();
                if (ch == "/") {
                    this.putBack();
                    ch = this.getNextToken();
                    if (ch == MD5MeshParser.COMMENT_TOKEN)
                        this.ignoreLine();
                    ch = this.getNextChar();
                }
                if (ch != "}")
                    this.putBack();
            } while (ch != "}");
        };
        /**
         * 返回到上个字符位置
         */
        MD5MeshParser.prototype.putBack = function () {
            this._parseIndex--;
            this._charLineIndex--;
            this._reachedEOF = this._parseIndex >= this._textData.length;
        };
        /**
         * 解析网格几何体
         */
        MD5MeshParser.prototype.parseMesh = function () {
            var token = this.getNextToken();
            var ch;
            var vertexData;
            var weights;
            var indices;
            if (token != "{")
                this.sendUnknownKeywordError();
            this._shaders = this._shaders || [];
            while (ch != "}") {
                ch = this.getNextToken();
                switch (ch) {
                    case MD5MeshParser.COMMENT_TOKEN:
                        this.ignoreLine();
                        break;
                    case MD5MeshParser.MESH_SHADER_TOKEN:
                        //材质数据
                        this._shaders.push(this.parseLiteralString());
                        break;
                    case MD5MeshParser.MESH_NUM_VERTS_TOKEN:
                        //顶点数据
                        vertexData = [];
                        vertexData.length = this.getNextInt();
                        break;
                    case MD5MeshParser.MESH_NUM_TRIS_TOKEN:
                        //根据三角形个数 创建顶点数组
                        indices = [];
                        indices.length = this.getNextInt() * 3;
                        break;
                    case MD5MeshParser.MESH_NUM_WEIGHTS_TOKEN:
                        //创建关节数据
                        weights = [];
                        weights.length = this.getNextInt();
                        break;
                    case MD5MeshParser.MESH_VERT_TOKEN:
                        //解析一个顶点数据
                        this.parseVertex(vertexData);
                        break;
                    case MD5MeshParser.MESH_TRI_TOKEN:
                        this.parseTri(indices);
                        break;
                    case MD5MeshParser.MESH_WEIGHT_TOKEN:
                        this.parseJoint(weights);
                        break;
                }
            }
            //保存网格数据
            this._meshData = this._meshData || [];
            var i = this._meshData.length;
            this._meshData[i] = new MeshData();
            this._meshData[i].vertexData = vertexData;
            this._meshData[i].weightData = weights;
            this._meshData[i].indices = indices;
        };
        /**
         * 转换网格数据为SkinnedSubGeometry实例
         * @param vertexData 网格顶点数据
         * @param weights 每个顶点的关节权重数据
         * @param indices 顶点索引数据
         * @return 包含所有几何体数据的SkinnedSubGeometry实例
         */
        MD5MeshParser.prototype.translateGeom = function (vertexData, weights, indices) {
            var len = vertexData.length;
            var v1, v2, v3;
            var vertex;
            var weight;
            var bindPose;
            var pos;
            var subGeom = new feng3d.SubGeometry();
            var skinnedsubGeom = new feng3d.SkinnedSubGeometry(this._maxJointCount);
            subGeom.addComponent(skinnedsubGeom);
            //uv数据
            var uvs = [];
            uvs.length = len * 2;
            //顶点位置数据
            var vertices = [];
            vertices.length = len * 3;
            //关节索引数据
            var jointIndices = [];
            jointIndices.length = len * this._maxJointCount;
            //关节权重数据
            var jointWeights = [];
            jointWeights.length = len * this._maxJointCount;
            var l;
            //0权重个数
            var nonZeroWeights;
            for (var i = 0; i < len; ++i) {
                vertex = vertexData[i];
                v1 = vertex.index * 3;
                v2 = v1 + 1;
                v3 = v1 + 2;
                vertices[v1] = vertices[v2] = vertices[v3] = 0;
                /**
                 * 参考 http://blog.csdn.net/summerhust/article/details/17421213
                 * VertexPos = (MJ-0 * weight[index0].pos * weight[index0].bias) + ... + (MJ-N * weight[indexN].pos * weight[indexN].bias)
                 * 变量对应  MJ-N -> bindPose; 第J个关节的变换矩阵
                 * weight[indexN].pos -> weight.pos;
                 * weight[indexN].bias -> weight.bias;
                 */
                nonZeroWeights = 0;
                for (var j = 0; j < vertex.countWeight; ++j) {
                    weight = weights[vertex.startWeight + j];
                    if (weight.bias > 0) {
                        bindPose = this._bindPoses[weight.joint];
                        pos = bindPose.transformVector(weight.pos);
                        vertices[v1] += pos.x * weight.bias;
                        vertices[v2] += pos.y * weight.bias;
                        vertices[v3] += pos.z * weight.bias;
                        // indices need to be multiplied by 3 (amount of matrix registers)
                        jointIndices[l] = weight.joint * 3;
                        jointWeights[l++] = weight.bias;
                        ++nonZeroWeights;
                    }
                }
                for (j = nonZeroWeights; j < this._maxJointCount; ++j) {
                    jointIndices[l] = 0;
                    jointWeights[l++] = 0;
                }
                v1 = vertex.index << 1;
                uvs[v1++] = vertex.u;
                uvs[v1] = vertex.v;
            }
            //更新索引数据
            subGeom.updateIndexData(indices);
            subGeom.numVertices = vertices.length / 3;
            //更新顶点坐标与uv数据
            subGeom.fromVectors(vertices, uvs);
            // cause explicit updates
            subGeom.addComponent(new feng3d.AutoDeriveVertexNormals());
            subGeom.addComponent(new feng3d.AutoDeriveVertexTangents());
            subGeom.vertexNormalData;
            subGeom.vertexTangentData;
            //更新关节索引与权重索引
            skinnedsubGeom.updateJointIndexData(jointIndices);
            skinnedsubGeom.updateJointWeightsData(jointWeights);
            return subGeom;
        };
        /**
         * 解析三角形数据
         * @param indices 索引数据
         */
        MD5MeshParser.prototype.parseTri = function (indices) {
            var index = this.getNextInt() * 3;
            indices[index] = this.getNextInt();
            indices[index + 1] = this.getNextInt();
            indices[index + 2] = this.getNextInt();
        };
        /**
         * 解析关节数据
         * @param weights 权重数据列表
         */
        MD5MeshParser.prototype.parseJoint = function (weights) {
            var weight = new WeightData();
            weight.index = this.getNextInt();
            weight.joint = this.getNextInt();
            weight.bias = this.getNextNumber();
            weight.pos = this.parseVector3D();
            weights[weight.index] = weight;
        };
        /**
         * 解析一个顶点
         * @param vertexData 顶点数据列表
         */
        MD5MeshParser.prototype.parseVertex = function (vertexData) {
            var vertex = new VertexData();
            vertex.index = this.getNextInt();
            this.parseUV(vertex);
            vertex.startWeight = this.getNextInt();
            vertex.countWeight = this.getNextInt();
            vertexData[vertex.index] = vertex;
        };
        /**
         * 解析uv坐标
         * @param vertexData 包含uv坐标的顶点数据
         */
        MD5MeshParser.prototype.parseUV = function (vertexData) {
            var ch = this.getNextToken();
            if (ch != "(")
                this.sendParseError("(");
            vertexData.u = this.getNextNumber();
            vertexData.v = this.getNextNumber();
            if (this.getNextToken() != ")")
                this.sendParseError(")");
        };
        /**
         * 获取下个关键字
         */
        MD5MeshParser.prototype.getNextToken = function () {
            var ch;
            var token = "";
            while (!this._reachedEOF) {
                ch = this.getNextChar();
                if (ch == " " || ch == "\r" || ch == "\n" || ch == "\t") {
                    if (token != MD5MeshParser.COMMENT_TOKEN)
                        this.skipWhiteSpace();
                    if (token != "")
                        return token;
                }
                else
                    token += ch;
                if (token == MD5MeshParser.COMMENT_TOKEN)
                    return token;
            }
            return token;
        };
        /**
         * 跳过空白
         */
        MD5MeshParser.prototype.skipWhiteSpace = function () {
            var ch;
            do
                ch = this.getNextChar();
            while (ch == "\n" || ch == " " || ch == "\r" || ch == "\t");
            this.putBack();
        };
        /**
         * 忽略该行
         */
        MD5MeshParser.prototype.ignoreLine = function () {
            var ch;
            while (!this._reachedEOF && ch != "\n")
                ch = this.getNextChar();
        };
        /**
         * 读取下个字符
         */
        MD5MeshParser.prototype.getNextChar = function () {
            var ch = this._textData.charAt(this._parseIndex++);
            if (ch == "\n") {
                ++this._line;
                this._charLineIndex = 0;
            }
            else if (ch != "\r")
                ++this._charLineIndex;
            if (this._parseIndex >= this._textData.length)
                this._reachedEOF = true;
            return ch;
        };
        /**
         * 读取下个number
         */
        MD5MeshParser.prototype.getNextInt = function () {
            var i = parseInt(this.getNextToken());
            if (isNaN(i))
                this.sendParseError("number type");
            return i;
        };
        /**
         * 读取下个number
         */
        MD5MeshParser.prototype.getNextNumber = function () {
            var f = parseFloat(this.getNextToken());
            if (isNaN(f))
                this.sendParseError("float type");
            return f;
        };
        /**
         * 解析3d向量
         */
        MD5MeshParser.prototype.parseVector3D = function () {
            var vec = new feng3d.Vector3D();
            var ch = this.getNextToken();
            if (ch != "(")
                this.sendParseError("(");
            vec.x = -this.getNextNumber();
            vec.y = this.getNextNumber();
            vec.z = this.getNextNumber();
            if (this.getNextToken() != ")")
                this.sendParseError(")");
            return vec;
        };
        /**
         * 解析四元素
         */
        MD5MeshParser.prototype.parseQuaternion = function () {
            var quat = new feng3d.Quaternion();
            var ch = this.getNextToken();
            if (ch != "(")
                this.sendParseError("(");
            quat.x = this.getNextNumber();
            quat.y = -this.getNextNumber();
            quat.z = -this.getNextNumber();
            // quat supposed to be unit length
            var t = 1 - quat.x * quat.x - quat.y * quat.y - quat.z * quat.z;
            quat.w = t < 0 ? 0 : -Math.sqrt(t);
            if (this.getNextToken() != ")")
                this.sendParseError(")");
            var rotQuat = new feng3d.Quaternion();
            rotQuat.multiply(this._rotationQuat, quat);
            return rotQuat;
        };
        /**
         * 解析命令行数据
         */
        MD5MeshParser.prototype.parseCMD = function () {
            //忽略命令行数据
            this.parseLiteralString();
        };
        /**
         * 解析带双引号的字符串
         */
        MD5MeshParser.prototype.parseLiteralString = function () {
            this.skipWhiteSpace();
            var ch = this.getNextChar();
            var str = "";
            if (ch != "\"")
                this.sendParseError("\"");
            do {
                if (this._reachedEOF)
                    this.sendEOFError();
                ch = this.getNextChar();
                if (ch != "\"")
                    str += ch;
            } while (ch != "\"");
            return str;
        };
        /**
         * 抛出一个文件尾过早结束文件时遇到错误
         */
        MD5MeshParser.prototype.sendEOFError = function () {
            throw new Error("Unexpected end of file");
        };
        /**
         * 遇到了一个意想不到的令牌时将抛出一个错误。
         * @param expected 发生错误的标记
         */
        MD5MeshParser.prototype.sendParseError = function (expected) {
            throw new Error("Unexpected token at line " + (this._line + 1) + ", character " + this._charLineIndex + ". " + expected + " expected, but " + this._textData.charAt(this._parseIndex - 1) + " encountered");
        };
        /**
         * 发生未知关键字错误
         */
        MD5MeshParser.prototype.sendUnknownKeywordError = function () {
            throw new Error("Unknown keyword at line " + (this._line + 1) + ", character " + this._charLineIndex + ". ");
        };
        /**
 * 解决依赖
 * @param resourceDependency 依赖资源
 */
        MD5MeshParser.prototype.resolveDependency = function (resourceDependency) {
        };
        /**
         * 解决依赖失败
         * @param resourceDependency 依赖资源
         */
        MD5MeshParser.prototype.resolveDependencyFailure = function (resourceDependency) {
        };
        MD5MeshParser.VERSION_TOKEN = "MD5Version";
        MD5MeshParser.COMMAND_LINE_TOKEN = "commandline";
        MD5MeshParser.NUM_JOINTS_TOKEN = "numJoints";
        MD5MeshParser.NUM_MESHES_TOKEN = "numMeshes";
        MD5MeshParser.COMMENT_TOKEN = "//";
        MD5MeshParser.JOINTS_TOKEN = "joints";
        MD5MeshParser.MESH_TOKEN = "mesh";
        MD5MeshParser.MESH_SHADER_TOKEN = "shader";
        MD5MeshParser.MESH_NUM_VERTS_TOKEN = "numverts";
        MD5MeshParser.MESH_VERT_TOKEN = "vert";
        MD5MeshParser.MESH_NUM_TRIS_TOKEN = "numtris";
        MD5MeshParser.MESH_TRI_TOKEN = "tri";
        MD5MeshParser.MESH_NUM_WEIGHTS_TOKEN = "numweights";
        MD5MeshParser.MESH_WEIGHT_TOKEN = "weight";
        return MD5MeshParser;
    }(feng3d.ParserBase));
    feng3d.MD5MeshParser = MD5MeshParser;
    /**
     * 顶点数据
     */
    var VertexData = (function () {
        function VertexData() {
        }
        VertexData.prototype.VertexData = function () {
        };
        return VertexData;
    }());
    /**
     * 关节权重数据
     */
    var WeightData = (function () {
        function WeightData() {
        }
        WeightData.prototype.WeightData = function () {
        };
        return WeightData;
    }());
    /**
     * 网格数据
     */
    var MeshData = (function () {
        function MeshData() {
        }
        MeshData.prototype.MeshData = function () {
        };
        return MeshData;
    }());
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * Max3DSParser provides a parser for the 3ds data type.
     */
    var Max3DSParser = (function (_super) {
        __extends(Max3DSParser, _super);
        /**
         * Creates a new <code>Max3DSParser</code> object.
         *
         * @param useSmoothingGroups Determines whether the parser looks for smoothing groups in the 3ds file or assumes uniform smoothing. Defaults to true.
         */
        function Max3DSParser(useSmoothingGroups) {
            if (useSmoothingGroups === void 0) { useSmoothingGroups = true; }
            _super.call(this, feng3d.ParserDataFormat.BINARY);
            this._useSmoothingGroups = useSmoothingGroups;
        }
        /**
         * Indicates whether or not a given file extension is supported by the parser.
         * @param extension The file extension of a potential file to be parsed.
         * @return Whether or not the given file type is supported.
         */
        Max3DSParser.supportsType = function (extension) {
            extension = extension.toLowerCase();
            return extension == "3ds";
        };
        /**
         * Tests whether a data block can be parsed by the parser.
         * @param data The data block to potentially be parsed.
         * @return Whether or not the given data is supported.
         */
        Max3DSParser.supportsData = function (data) {
            var ba = data;
            if (ba) {
                ba.position = 0;
                if (ba.readShort() == 0x4d4d)
                    return true;
            }
            return false;
        };
        /**
         * @inheritDoc
         */
        Max3DSParser.prototype.resolveDependency = function (resourceDependency) {
            if (resourceDependency.assets.length == 1) {
                var asset;
                asset = resourceDependency.assets[0];
                if (asset.namedAsset.assetType == feng3d.AssetType.TEXTURE) {
                    var tex;
                    tex = this._textures[resourceDependency.id];
                    tex.texture = feng3d.as(asset, feng3d.Texture2DBase);
                }
            }
        };
        /**
         * @inheritDoc
         */
        Max3DSParser.prototype.resolveDependencyFailure = function (resourceDependency) {
            // TODO: Implement
        };
        /**
         * @inheritDoc
         */
        Max3DSParser.prototype.startParsing = function (frameLimit) {
            _super.prototype.startParsing.call(this, frameLimit);
            this._byteData = this._data;
            this._byteData.position = 0;
            this._byteData.endian = feng3d.Endian.LITTLE_ENDIAN;
            this._textures = {};
            this._materials = {};
            this._unfinalized_objects = {};
        };
        /**
         * @inheritDoc
         */
        Max3DSParser.prototype.proceedParsing = function () {
            // TODO: With this construct, the loop will run no-op for as long
            // as there is time once file has finished reading. Consider this.a nice
            // way to stop loop when byte array is empty, without putting it in
            // the while-conditional, which will prevent finalizations from
            // happening after the last chunk.
            while (this.hasTime()) {
                // If we are currently working on an object, and the most recent chunk was
                // the last one in that object, finalize the current object.
                if (this._cur_mat && this._byteData.position >= this._cur_mat_end)
                    this.finalizeCurrentMaterial();
                else if (this._cur_obj && this._byteData.position >= this._cur_obj_end) {
                    // Can't finalize at this point, because we have to wait until the full
                    // animation section has been parsed for any potential pivot definitions
                    this._unfinalized_objects[this._cur_obj.name] = this._cur_obj;
                    this._cur_obj_end = Number.MAX_VALUE;
                    this._cur_obj = null;
                }
                if (this._byteData.bytesAvailable) {
                    var cid;
                    var len;
                    var end;
                    cid = this._byteData.readUnsignedShort();
                    len = this._byteData.readUnsignedInt();
                    end = this._byteData.position + (len - 6);
                    switch (cid) {
                        case 0x4D4D: // MAIN3DS
                        case 0x3D3D: // EDIT3DS
                        case 0xB000:
                            // This types are "container chunks" and contain only
                            // sub-chunks (no data on their own.) This means that
                            // there is nothing more to parse at this point, and 
                            // instead we should progress to the next chunk, which
                            // will be the first sub-chunk of this one.
                            continue;
                        case 0xAFFF:
                            this._cur_mat_end = end;
                            this._cur_mat = this.parseMaterial();
                            break;
                        case 0x4000:
                            this._cur_obj_end = end;
                            this._cur_obj = new ObjectVO();
                            this._cur_obj.name = this.readNulTermString();
                            this._cur_obj.materials = [];
                            this._cur_obj.materialFaces = {};
                            break;
                        case 0x4100:
                            this._cur_obj.type = feng3d.AssetType.MESH;
                            break;
                        case 0x4110:
                            this.parseVertexList();
                            break;
                        case 0x4120:
                            this.parseFaceList();
                            break;
                        case 0x4140:
                            this.parseUVList();
                            break;
                        case 0x4130:
                            this.parseFaceMaterialList();
                            break;
                        case 0x4160:
                            this._cur_obj.transform = this.readTransform();
                            break;
                        case 0xB002:
                            this.parseObjectAnimation(end);
                            break;
                        case 0x4150:
                            this.parseSmoothingGroups();
                            break;
                        default:
                            // Skip this (unknown) chunk
                            this._byteData.position += (len - 6);
                            break;
                    }
                }
            }
            // More parsing is required if the entire byte array has not yet
            // been read, or if there is this.a currently non-finalized object in
            // the pipeline.
            if (this._byteData.bytesAvailable || this._cur_obj || this._cur_mat)
                return feng3d.ParserBase.MORE_TO_PARSE;
            else {
                var name;
                // Finalize any remaining objects before ending.
                for (name in this._unfinalized_objects) {
                    var obj;
                    obj = this.constructObject(this._unfinalized_objects[name]);
                    if (obj)
                        this.finalizeAsset(obj, name);
                }
                return feng3d.ParserBase.PARSING_DONE;
            }
        };
        Max3DSParser.prototype.parseMaterial = function () {
            var mat;
            mat = new MaterialVO();
            while (this._byteData.position < this._cur_mat_end) {
                var cid;
                var len;
                var end;
                cid = this._byteData.readUnsignedShort();
                len = this._byteData.readUnsignedInt();
                end = this._byteData.position + (len - 6);
                switch (cid) {
                    case 0xA000:
                        mat.name = this.readNulTermString();
                        break;
                    case 0xA010:
                        mat.ambientColor = this.readColor();
                        break;
                    case 0xA020:
                        mat.diffuseColor = this.readColor();
                        break;
                    case 0xA030:
                        mat.specularColor = this.readColor();
                        break;
                    case 0xA081:
                        mat.twoSided = true;
                        break;
                    case 0xA200:
                        mat.colorMap = this.parseTexture(end);
                        break;
                    case 0xA204:
                        mat.specularMap = this.parseTexture(end);
                        break;
                    default:
                        this._byteData.position = end;
                        break;
                }
            }
            return mat;
        };
        Max3DSParser.prototype.parseTexture = function (end) {
            var tex;
            tex = new TextureVO();
            while (this._byteData.position < end) {
                var cid;
                var len;
                cid = this._byteData.readUnsignedShort();
                len = this._byteData.readUnsignedInt();
                switch (cid) {
                    case 0xA300:
                        tex.url = this.readNulTermString();
                        break;
                    default:
                        // Skip this unknown this.texture sub-chunk
                        this._byteData.position += (len - 6);
                        break;
                }
            }
            this._textures[tex.url] = tex;
            this.addDependency(tex.url, new feng3d.URLRequest(tex.url));
            return tex;
        };
        Max3DSParser.prototype.parseVertexList = function () {
            var i;
            var len;
            var count;
            count = this._byteData.readUnsignedShort();
            this._cur_obj.verts = [];
            this._cur_obj.verts.length = count * 3;
            i = 0;
            len = this._cur_obj.verts.length;
            while (i < len) {
                var x, y, z;
                x = this._byteData.readFloat();
                y = this._byteData.readFloat();
                z = this._byteData.readFloat();
                this._cur_obj.verts[i++] = x;
                this._cur_obj.verts[i++] = z;
                this._cur_obj.verts[i++] = y;
            }
        };
        Max3DSParser.prototype.parseFaceList = function () {
            var i;
            var len;
            var count;
            count = this._byteData.readUnsignedShort();
            this._cur_obj.indices = [];
            this._cur_obj.indices.length = count * 3;
            i = 0;
            len = this._cur_obj.indices.length;
            while (i < len) {
                var i0, i1, i2;
                i0 = this._byteData.readUnsignedShort();
                i1 = this._byteData.readUnsignedShort();
                i2 = this._byteData.readUnsignedShort();
                this._cur_obj.indices[i++] = i0;
                this._cur_obj.indices[i++] = i2;
                this._cur_obj.indices[i++] = i1;
                // Skip "face info", irrelevant in Away3D
                this._byteData.position += 2;
            }
            this._cur_obj.smoothingGroups = [];
            this._cur_obj.smoothingGroups.length = count;
        };
        Max3DSParser.prototype.parseSmoothingGroups = function () {
            var len = this._cur_obj.indices.length / 3;
            var i = 0;
            while (i < len) {
                this._cur_obj.smoothingGroups[i] = this._byteData.readUnsignedInt();
                i++;
            }
        };
        Max3DSParser.prototype.parseUVList = function () {
            var i;
            var len;
            var count;
            count = this._byteData.readUnsignedShort();
            this._cur_obj.uvs = [];
            this._cur_obj.uvs.length = count * 2;
            i = 0;
            len = this._cur_obj.uvs.length;
            while (i < len) {
                this._cur_obj.uvs[i++] = this._byteData.readFloat();
                this._cur_obj.uvs[i++] = 1.0 - this._byteData.readFloat();
            }
        };
        Max3DSParser.prototype.parseFaceMaterialList = function () {
            var mat;
            var count;
            var i;
            var faces;
            mat = this.readNulTermString();
            count = this._byteData.readUnsignedShort();
            faces = [];
            faces.length = count;
            i = 0;
            while (i < faces.length)
                faces[i++] = this._byteData.readUnsignedShort();
            this._cur_obj.materials.push(mat);
            this._cur_obj.materialFaces[mat] = faces;
        };
        Max3DSParser.prototype.parseObjectAnimation = function (end) {
            var vo;
            var obj;
            var pivot;
            var name;
            var hier;
            // Pivot defaults to origin
            pivot = new feng3d.Vector3D;
            while (this._byteData.position < end) {
                var cid;
                var len;
                cid = this._byteData.readUnsignedShort();
                len = this._byteData.readUnsignedInt();
                switch (cid) {
                    case 0xb010:
                        name = this.readNulTermString();
                        this._byteData.position += 4;
                        hier = this._byteData.readShort();
                        break;
                    case 0xb013:
                        pivot.x = this._byteData.readFloat();
                        pivot.z = this._byteData.readFloat();
                        pivot.y = this._byteData.readFloat();
                        break;
                    default:
                        this._byteData.position += (len - 6);
                        break;
                }
            }
            // If name is "$$$DUMMY" this is an empty object (e.g. this.a container)
            // and will be ignored in this version of the parser
            // TODO: Implement containers in 3DS parser.
            if (name != '$$$DUMMY' && this._unfinalized_objects.hasOwnProperty(name)) {
                vo = this._unfinalized_objects[name];
                obj = this.constructObject(vo, pivot);
                if (obj)
                    this.finalizeAsset(obj, vo.name);
                delete this._unfinalized_objects[name];
            }
        };
        Max3DSParser.prototype.constructObject = function (obj, pivot) {
            if (pivot === void 0) { pivot = null; }
            if (obj.type == feng3d.AssetType.MESH) {
                var i;
                var subs;
                var geom;
                var mat;
                var mesh;
                var mtx;
                var vertices;
                var faces;
                if (obj.materials.length > 1)
                    console.log('The Away3D 3DS parser does not support multiple this.materials per mesh at this point.');
                // Ignore empty objects
                if (!obj.indices || obj.indices.length == 0)
                    return null;
                vertices = [];
                vertices.length = obj.verts.length / 3;
                faces = [];
                faces.length = obj.indices.length / 3;
                this.prepareData(vertices, faces, obj);
                if (this._useSmoothingGroups)
                    this.applySmoothGroups(vertices, faces);
                obj.verts = [];
                obj.verts.length = vertices.length * 3;
                for (i = 0; i < vertices.length; i++) {
                    obj.verts[i * 3] = vertices[i].x;
                    obj.verts[i * 3 + 1] = vertices[i].y;
                    obj.verts[i * 3 + 2] = vertices[i].z;
                }
                obj.indices = [];
                obj.indices.length = faces.length * 3;
                for (i = 0; i < faces.length; i++) {
                    obj.indices[i * 3] = faces[i].a;
                    obj.indices[i * 3 + 1] = faces[i].b;
                    obj.indices[i * 3 + 2] = faces[i].c;
                }
                if (obj.uvs) {
                    // If the object had UVs to start with, use UVs generated by
                    // smoothing group splitting algorithm. Otherwise those UVs
                    // will be nonsense and should be skipped.
                    obj.uvs = [];
                    obj.uvs.length = vertices.length * 2;
                    for (i = 0; i < vertices.length; i++) {
                        obj.uvs[i * 2] = vertices[i].u;
                        obj.uvs[i * 2 + 1] = vertices[i].v;
                    }
                }
                geom = new feng3d.Geometry();
                // Construct sub-geometries (potentially splitting buffers)
                // and add them to geometry.
                subs = feng3d.GeomUtil.fromVectors(obj.verts, obj.indices, obj.uvs, null, null);
                for (i = 0; i < subs.length; i++)
                    geom.subGeometries.push(subs[i]);
                if (obj.materials.length > 0) {
                    var mname;
                    mname = obj.materials[0];
                    mat = this._materials[mname].material;
                }
                // Apply pivot translation to geometry if this.a pivot was
                // found while parsing the keyframe chunk earlier.
                if (pivot) {
                    if (obj.transform) {
                        // If this.a this.transform was found while parsing the
                        // object chunk, use it to find the local pivot vector
                        var dat = obj.transform.concat();
                        dat[12] = 0;
                        dat[13] = 0;
                        dat[14] = 0;
                        mtx = new feng3d.Matrix3D(dat);
                        pivot = mtx.transformVector(pivot);
                    }
                    pivot.scaleBy(-1);
                    mtx = new feng3d.Matrix3D();
                    mtx.appendTranslation(pivot.x, pivot.y, pivot.z);
                    geom.applyTransformation(mtx);
                }
                // Apply transformation to geometry if this.a transformation
                // was found while parsing the object chunk earlier.
                if (obj.transform) {
                    mtx = new feng3d.Matrix3D(obj.transform);
                    mtx.invert();
                    geom.applyTransformation(mtx);
                }
                // Final this.transform applied to geometry. Finalize the geometry,
                // which will no longer be modified after this point.
                this.finalizeAsset(geom, obj.name.concat('_geom'));
                // Build mesh and return it
                mesh = new feng3d.Mesh(geom, mat);
                mesh.transform3D.transform = new feng3d.Matrix3D(obj.transform);
                return mesh;
            }
            // If reached, unknown
            return null;
        };
        Max3DSParser.prototype.prepareData = function (vertices, faces, obj) {
            // convert raw ObjectVO's data to structured VertexVO and FaceVO
            var i;
            var j;
            var k;
            var len = obj.verts.length;
            for (i = 0, j = 0, k = 0; i < len;) {
                var v = new VertexVO;
                v.x = obj.verts[i++];
                v.y = obj.verts[i++];
                v.z = obj.verts[i++];
                if (obj.uvs) {
                    v.u = obj.uvs[j++];
                    v.v = obj.uvs[j++];
                }
                vertices[k++] = v;
            }
            len = obj.indices.length;
            for (i = 0, k = 0; i < len;) {
                var f = new FaceVO();
                f.a = obj.indices[i++];
                f.b = obj.indices[i++];
                f.c = obj.indices[i++];
                f.smoothGroup = obj.smoothingGroups[k];
                faces[k++] = f;
            }
        };
        Max3DSParser.prototype.applySmoothGroups = function (vertices, faces) {
            // clone vertices according to following rule:
            // clone if vertex's in faces from groups 1+2 and 3
            // don't clone if vertex's in faces from groups 1+2, 3 and 1+3
            var i;
            var j;
            var k;
            var l;
            var len;
            var numVerts = vertices.length;
            var numFaces = faces.length;
            // extract groups data for vertices
            var vGroups = [];
            vGroups.length = numVerts;
            for (i = 0; i < numVerts; i++)
                vGroups[i] = [];
            for (i = 0; i < numFaces; i++) {
                var face = feng3d.as(faces[i], FaceVO);
                for (j = 0; j < 3; j++) {
                    var groups = vGroups[(j == 0) ? face.a : ((j == 1) ? face.b : face.c)];
                    var group = face.smoothGroup;
                    for (k = groups.length - 1; k >= 0; k--) {
                        if ((group & groups[k]) > 0) {
                            group |= groups[k];
                            groups.splice(k, 1);
                            k = groups.length - 1;
                        }
                    }
                    groups.push(group);
                }
            }
            // clone vertices
            var vClones = [];
            vClones.length = numVerts;
            for (i = 0; i < numVerts; i++) {
                if ((len = vGroups[i].length) < 1)
                    continue;
                var clones = [];
                clones.length = len;
                vClones[i] = clones;
                clones[0] = i;
                var v0 = vertices[i];
                for (j = 1; j < len; j++) {
                    var v1 = new VertexVO;
                    v1.x = v0.x;
                    v1.y = v0.y;
                    v1.z = v0.z;
                    v1.u = v0.u;
                    v1.v = v0.v;
                    clones[j] = vertices.length;
                    vertices.push(v1);
                }
            }
            numVerts = vertices.length;
            for (i = 0; i < numFaces; i++) {
                face = feng3d.as(faces[i], FaceVO);
                group = face.smoothGroup;
                for (j = 0; j < 3; j++) {
                    k = (j == 0) ? face.a : ((j == 1) ? face.b : face.c);
                    groups = vGroups[k];
                    len = groups.length;
                    clones = vClones[k];
                    for (l = 0; l < len; l++) {
                        if (((group == 0) && (groups[l] == 0)) || ((group & groups[l]) > 0)) {
                            var index = clones[l];
                            if (group == 0) {
                                // vertex is unique if no this.smoothGroup found
                                groups.splice(l, 1);
                                clones.splice(l, 1);
                            }
                            if (j == 0)
                                face.a = index;
                            else if (j == 1)
                                face.b = index;
                            else
                                face.c = index;
                            l = len;
                        }
                    }
                }
            }
        };
        Max3DSParser.prototype.finalizeCurrentMaterial = function () {
            var mat;
            if (this.materialMode < 2) {
                if (this._cur_mat.colorMap)
                    mat = new feng3d.TextureMaterial(this._cur_mat.colorMap.texture || feng3d.DefaultMaterialManager.getDefaultTexture());
                else
                    mat = new feng3d.ColorMaterial(this._cur_mat.diffuseColor);
                feng3d.as(mat, feng3d.SinglePassMaterialBase).ambientColor = this._cur_mat.ambientColor;
                feng3d.as(mat, feng3d.SinglePassMaterialBase).specularColor = this._cur_mat.specularColor;
            }
            else {
                if (this._cur_mat.colorMap)
                    mat = new feng3d.TextureMultiPassMaterial(this._cur_mat.colorMap.texture || feng3d.DefaultMaterialManager.getDefaultTexture());
                else
                    mat = new feng3d.ColorMultiPassMaterial(this._cur_mat.diffuseColor);
            }
            mat.bothSides = this._cur_mat.twoSided;
            this.finalizeAsset(mat, this._cur_mat.name);
            this._materials[this._cur_mat.name] = this._cur_mat;
            this._cur_mat.material = mat;
            this._cur_mat = null;
        };
        Max3DSParser.prototype.readNulTermString = function () {
            var chr;
            var str = "";
            while ((chr = this._byteData.readUnsignedByte()) > 0)
                str += String.fromCharCode(chr);
            return str;
        };
        Max3DSParser.prototype.readTransform = function () {
            var data;
            data = [];
            data.length = 16;
            // X axis
            data[0] = this._byteData.readFloat(); // X
            data[2] = this._byteData.readFloat(); // Z
            data[1] = this._byteData.readFloat(); // Y
            data[3] = 0;
            // Z axis
            data[8] = this._byteData.readFloat(); // X
            data[10] = this._byteData.readFloat(); // Z
            data[9] = this._byteData.readFloat(); // Y
            data[11] = 0;
            // Y Axis
            data[4] = this._byteData.readFloat(); // X 
            data[6] = this._byteData.readFloat(); // Z
            data[5] = this._byteData.readFloat(); // Y
            data[7] = 0;
            // Translation
            data[12] = this._byteData.readFloat(); // X
            data[14] = this._byteData.readFloat(); // Z
            data[13] = this._byteData.readFloat(); // Y
            data[15] = 1;
            return data;
        };
        Max3DSParser.prototype.readColor = function () {
            var cid;
            var len;
            var r, g, b;
            cid = this._byteData.readUnsignedShort();
            len = this._byteData.readUnsignedInt();
            switch (cid) {
                case 0x0010:
                    r = this._byteData.readFloat() * 255;
                    g = this._byteData.readFloat() * 255;
                    b = this._byteData.readFloat() * 255;
                    break;
                case 0x0011:
                    r = this._byteData.readUnsignedByte();
                    g = this._byteData.readUnsignedByte();
                    b = this._byteData.readUnsignedByte();
                    break;
                default:
                    this._byteData.position += (len - 6);
                    break;
            }
            return (r << 16) | (g << 8) | b;
        };
        return Max3DSParser;
    }(feng3d.ParserBase));
    feng3d.Max3DSParser = Max3DSParser;
    var TextureVO = (function () {
        function TextureVO() {
        }
        TextureVO.prototype.TextureVO = function () {
        };
        return TextureVO;
    }());
    var MaterialVO = (function () {
        function MaterialVO() {
        }
        MaterialVO.prototype.MaterialVO = function () {
        };
        return MaterialVO;
    }());
    var ObjectVO = (function () {
        function ObjectVO() {
        }
        ObjectVO.prototype.ObjectVO = function () {
        };
        return ObjectVO;
    }());
    var VertexVO = (function () {
        function VertexVO() {
        }
        VertexVO.prototype.VertexVO = function () {
        };
        return VertexVO;
    }());
    var FaceVO = (function () {
        function FaceVO() {
        }
        FaceVO.prototype.FaceVO = function () {
        };
        return FaceVO;
    }());
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * Obj模型解析者
     */
    var OBJParser = (function (_super) {
        __extends(OBJParser, _super);
        /**
         * 创建Obj模型解析对象
         * @param scale 缩放比例
         */
        function OBJParser(scale) {
            if (scale === void 0) { scale = 1; }
            _super.call(this, feng3d.ParserDataFormat.PLAIN_TEXT);
            /** 材质库是否已加载 */
            this._mtlLibLoaded = true;
            /** 活动材质编号 */
            this._activeMaterialID = "";
            this._scale = scale;
        }
        /**
         * 判断是否支持解析
         * @param extension 文件类型
         * @return
         */
        OBJParser.supportsType = function (extension) {
            extension = extension.toLowerCase();
            return extension == "obj";
        };
        /**
         * 判断是否支持该数据的解析
         * @param data 需要解析的数据
         * @return
         */
        OBJParser.supportsData = function (data) {
            var content = feng3d.ParserUtil.toString(data);
            var hasV;
            var hasF;
            if (content) {
                hasV = content.indexOf("\nv ") != -1;
                hasF = content.indexOf("\nf ") != -1;
            }
            return hasV && hasF;
        };
        OBJParser.prototype.resolveDependency = function (resourceDependency) {
            if (resourceDependency.id == 'mtl') {
                var str = feng3d.ParserUtil.toString(resourceDependency.data);
                this.parseMtl(str);
            }
            else {
                var asset;
                if (resourceDependency.assets.length != 1)
                    return;
                asset = resourceDependency.assets[0];
                if (asset.namedAsset.assetType == feng3d.AssetType.TEXTURE) {
                    var lm = new LoadedMaterial();
                    lm.materialID = resourceDependency.id;
                    lm.texture = feng3d.as(asset, feng3d.Texture2DBase);
                    this._materialLoaded.push(lm);
                    if (this._meshes.length > 0)
                        this.applyMaterial(lm);
                }
            }
        };
        OBJParser.prototype.resolveDependencyFailure = function (resourceDependency) {
            if (resourceDependency.id == "mtl") {
                this._mtlLib = false;
                this._mtlLibLoaded = false;
            }
            else {
                var lm = new LoadedMaterial();
                lm.materialID = resourceDependency.id;
                this._materialLoaded.push(lm);
            }
            if (this._meshes.length > 0)
                this.applyMaterial(lm);
        };
        OBJParser.prototype.proceedParsing = function () {
            //单行数据
            var line;
            //换行符
            var creturn = String.fromCharCode(10);
            var trunk;
            if (!this._startedParsing) {
                this._textData = this.getTextData();
                // Merge linebreaks that are immediately preceeded by
                // the "escape" backward slash into single lines.
                this._textData = this._textData.replace(/\\[\r\n]+\s*/gm, ' ');
            }
            if (this._textData.indexOf(creturn) == -1)
                creturn = String.fromCharCode(13);
            //初始化数据
            if (!this._startedParsing) {
                this._startedParsing = true;
                this._vertices = [];
                this._vertexNormals = [];
                this._materialIDs = [];
                this._materialLoaded = [];
                this._meshes = [];
                this._uvs = [];
                this._stringLength = this._textData.length;
                this._charIndex = this._textData.indexOf(creturn, 0);
                this._oldIndex = 0;
                this._objects = [];
                this._objectIndex = 0;
            }
            //判断是否解析完毕与是否还有时间
            while (this._charIndex < this._stringLength && this.hasTime()) {
                this._charIndex = this._textData.indexOf(creturn, this._oldIndex);
                if (this._charIndex == -1)
                    this._charIndex = this._stringLength;
                //获取单行数据 整理数据格式
                line = this._textData.substring(this._oldIndex, this._charIndex);
                line = line.split('\r').join("");
                line = line.replace("  ", " ");
                trunk = line.split(" ");
                this._oldIndex = this._charIndex + 1;
                //解析该行数据
                this.parseLine(trunk);
                //处理暂停
                if (this.parsingPaused)
                    return feng3d.ParserBase.MORE_TO_PARSE;
            }
            //数据解析到文件未
            if (this._charIndex >= this._stringLength) {
                //判断是否还需要等待材质解析
                if (this._mtlLib && !this._mtlLibLoaded)
                    return feng3d.ParserBase.MORE_TO_PARSE;
                this.translate();
                this.applyMaterials();
                return feng3d.ParserBase.PARSING_DONE;
            }
            return feng3d.ParserBase.MORE_TO_PARSE;
        };
        /**
         * 解析行
         */
        OBJParser.prototype.parseLine = function (trunk) {
            switch (trunk[0]) {
                case "mtllib":
                    this._mtlLib = true;
                    this._mtlLibLoaded = false;
                    this.loadMtl(trunk[1]);
                    break;
                case "g":
                    this.createGroup(trunk);
                    break;
                case "o":
                    this.createObject(trunk);
                    break;
                case "usemtl":
                    if (this._mtlLib) {
                        if (!trunk[1])
                            trunk[1] = "def000";
                        this._materialIDs.push(trunk[1]);
                        this._activeMaterialID = trunk[1];
                        if (this._currentGroup)
                            this._currentGroup.materialID = this._activeMaterialID;
                    }
                    break;
                case "v":
                    this.parseVertex(trunk);
                    break;
                case "vt":
                    this.parseUV(trunk);
                    break;
                case "vn":
                    this.parseVertexNormal(trunk);
                    break;
                case "f":
                    this.parseFace(trunk);
            }
        };
        /**
         * 把解析出来的数据转换成引擎使用的数据结构
         */
        OBJParser.prototype.translate = function () {
            for (var objIndex = 0; objIndex < this._objects.length; ++objIndex) {
                var groups = this._objects[objIndex].groups;
                var numGroups = groups.length;
                var materialGroups;
                var numMaterialGroups;
                var geometry;
                var mesh;
                var m;
                var sm;
                var bmMaterial;
                for (var g = 0; g < numGroups; ++g) {
                    geometry = new feng3d.Geometry();
                    materialGroups = groups[g].materialGroups;
                    numMaterialGroups = materialGroups.length;
                    //添加子网格
                    for (m = 0; m < numMaterialGroups; ++m)
                        this.translateMaterialGroup(materialGroups[m], geometry);
                    if (geometry.subGeometries.length == 0)
                        continue;
                    //完成几何体资源解析
                    this.finalizeAsset(geometry, "");
                    if (this.materialMode < 2)
                        bmMaterial = new feng3d.TextureMaterial(feng3d.DefaultMaterialManager.getDefaultTexture());
                    else
                        bmMaterial = new feng3d.TextureMultiPassMaterial(feng3d.DefaultMaterialManager.getDefaultTexture());
                    //创建网格
                    mesh = new feng3d.Mesh(geometry, bmMaterial);
                    //网格命名
                    if (this._objects[objIndex].name) {
                        //使用'o'标签给网格命名
                        mesh.name = this._objects[objIndex].name;
                    }
                    else if (groups[g].name) {
                        //使用'g'标签给网格命名
                        mesh.name = groups[g].name;
                    }
                    else {
                        mesh.name = "";
                    }
                    this._meshes.push(mesh);
                    //给材质命名
                    if (groups[g].materialID != "")
                        bmMaterial.name = groups[g].materialID + "~" + mesh.name;
                    else
                        bmMaterial.name = this._lastMtlID + "~" + mesh.name;
                    //子网使用材质
                    if (mesh.subMeshes.length > 1) {
                        for (sm = 1; sm < mesh.subMeshes.length; ++sm)
                            mesh.subMeshes[sm].material = bmMaterial;
                    }
                    this.finalizeAsset(mesh);
                }
            }
        };
        /**
         * 转换材质组为子网格
         * @param materialGroup 材质组网格数据
         * @param geometry 解析出子网格的父网格
         */
        OBJParser.prototype.translateMaterialGroup = function (materialGroup, geometry) {
            var faces = materialGroup.faces;
            var face;
            var numFaces = faces.length;
            var numVerts;
            var subs;
            var vertices = [];
            var uvs = [];
            var normals = [];
            var indices = [];
            this._realIndices = [];
            this._vertexIndex = 0;
            //解析面数据
            var j;
            for (var i = 0; i < numFaces; ++i) {
                face = faces[i];
                numVerts = face.indexIds.length - 1;
                //兼容多边形(拆分成N-1个三角形)
                for (j = 1; j < numVerts; ++j) {
                    this.translateVertexData(face, j, vertices, uvs, indices, normals);
                    this.translateVertexData(face, 0, vertices, uvs, indices, normals);
                    this.translateVertexData(face, j + 1, vertices, uvs, indices, normals);
                }
            }
            //创建 子网格
            if (vertices.length > 0) {
                subs = feng3d.GeomUtil.fromVectors(vertices, indices, uvs, null, null);
                for (i = 0; i < subs.length; i++)
                    geometry.addSubGeometry(subs[i]);
            }
        };
        /**
         * 把面数据转换为顶点等数据
         * @param face
         * @param vertexIndex
         * @param vertices
         * @param uvs
         * @param indices
         * @param normals
         */
        OBJParser.prototype.translateVertexData = function (face, vertexIndex, vertices, uvs, indices, normals) {
            var index;
            var vertex;
            var vertexNormal;
            var uv;
            if (!this._realIndices[face.indexIds[vertexIndex]]) {
                index = this._vertexIndex;
                this._realIndices[face.indexIds[vertexIndex]] = ++this._vertexIndex;
                vertex = this._vertices[face.vertexIndices[vertexIndex] - 1];
                vertices.push(vertex.x * this._scale, vertex.y * this._scale, vertex.z * this._scale);
                if (face.normalIndices.length > 0) {
                    vertexNormal = this._vertexNormals[face.normalIndices[vertexIndex] - 1];
                    normals.push(vertexNormal.x, vertexNormal.y, vertexNormal.z);
                }
                if (face.uvIndices.length > 0) {
                    try {
                        uv = this._uvs[face.uvIndices[vertexIndex] - 1];
                        uvs.push(uv.u, uv.v);
                    }
                    catch (e) {
                        switch (vertexIndex) {
                            case 0:
                                uvs.push(0, 1);
                                break;
                            case 1:
                                uvs.push(.5, 0);
                                break;
                            case 2:
                                uvs.push(1, 1);
                        }
                    }
                }
            }
            else
                index = this._realIndices[face.indexIds[vertexIndex]] - 1;
            indices.push(index);
        };
        /**
         * 创建对象组
         * @param trunk 包含材料标记的数据块和它的参数
         */
        OBJParser.prototype.createObject = function (trunk) {
            this._currentGroup = null;
            this._currentMaterialGroup = null;
            this._objects.push(this._currentObject = new ObjectGroup());
            if (trunk)
                this._currentObject.name = trunk[1];
        };
        /**
         * 创建一个组
         * @param trunk 包含材料标记的数据块和它的参数
         */
        OBJParser.prototype.createGroup = function (trunk) {
            if (!this._currentObject)
                this.createObject(null);
            this._currentGroup = new Group();
            this._currentGroup.materialID = this._activeMaterialID;
            if (trunk)
                this._currentGroup.name = trunk[1];
            this._currentObject.groups.push(this._currentGroup);
            this.createMaterialGroup(null);
        };
        /**
         * 创建材质组
         * @param trunk 包含材料标记的数据块和它的参数
         */
        OBJParser.prototype.createMaterialGroup = function (trunk) {
            this._currentMaterialGroup = new MaterialGroup();
            if (trunk)
                this._currentMaterialGroup.url = trunk[1];
            this._currentGroup.materialGroups.push(this._currentMaterialGroup);
        };
        /**
         * 解析顶点坐标数据
         * @param trunk 坐标数据
         */
        OBJParser.prototype.parseVertex = function (trunk) {
            if (trunk.length > 4) {
                var nTrunk = [];
                var val;
                for (var i = 1; i < trunk.length; ++i) {
                    val = parseFloat(trunk[i]);
                    if (!isNaN(val))
                        nTrunk.push(val);
                }
                this._vertices.push(new feng3d.Vertex(nTrunk[0], nTrunk[1], -nTrunk[2]));
            }
            else
                this._vertices.push(new feng3d.Vertex(parseFloat(trunk[1]), parseFloat(trunk[2]), -parseFloat(trunk[3])));
        };
        /**
         * 解析uv
         * @param trunk uv数据
         */
        OBJParser.prototype.parseUV = function (trunk) {
            if (trunk.length > 3) {
                var nTrunk = [];
                var val;
                //获取有效数字
                for (var i = 1; i < trunk.length; ++i) {
                    val = parseFloat(trunk[i]);
                    if (!isNaN(val))
                        nTrunk.push(val);
                }
                this._uvs.push(new feng3d.UV(nTrunk[0], 1 - nTrunk[1]));
            }
            else
                this._uvs.push(new feng3d.UV(parseFloat(trunk[1]), 1 - parseFloat(trunk[2])));
        };
        /**
         * 解析顶点法线
         * @param trunk 法线数据
         */
        OBJParser.prototype.parseVertexNormal = function (trunk) {
            if (trunk.length > 4) {
                var nTrunk = [];
                var val;
                //获取有效数字
                for (var i = 1; i < trunk.length; ++i) {
                    val = parseFloat(trunk[i]);
                    if (!isNaN(val))
                        nTrunk.push(val);
                }
                this._vertexNormals.push(new feng3d.Vertex(nTrunk[0], nTrunk[1], -nTrunk[2]));
            }
            else
                this._vertexNormals.push(new feng3d.Vertex(parseFloat(trunk[1]), parseFloat(trunk[2]), -parseFloat(trunk[3])));
        };
        /**
         * 解析面
         * @param trunk 面数据
         */
        OBJParser.prototype.parseFace = function (trunk) {
            var len = trunk.length;
            var face = new FaceData();
            if (!this._currentGroup)
                this.createGroup(null);
            var indices;
            for (var i = 1; i < len; ++i) {
                if (trunk[i] == "")
                    continue;
                //解析单个面数据，分离出顶点坐标左右、uv索引、法线索引
                indices = trunk[i].split("/");
                face.vertexIndices.push(this.parseIndex(parseInt(indices[0]), this._vertices.length));
                if (indices[1] && String(indices[1]).length > 0)
                    face.uvIndices.push(this.parseIndex(parseInt(indices[1]), this._uvs.length));
                if (indices[2] && String(indices[2]).length > 0)
                    face.normalIndices.push(this.parseIndex(parseInt(indices[2]), this._vertexNormals.length));
                face.indexIds.push(trunk[i]);
            }
            this._currentMaterialGroup.faces.push(face);
        };
        /**
         * This is a hack around negative face coords
         */
        OBJParser.prototype.parseIndex = function (index, length) {
            if (index < 0)
                return index + length + 1;
            else
                return index;
        };
        /**
         * 解析材质数据
         * @param data 材质数据
         */
        OBJParser.prototype.parseMtl = function (data) {
            var materialDefinitions = data.split('newmtl');
            var lines;
            var trunk;
            var j;
            var basicSpecularMethod;
            var useSpecular;
            var useColor;
            var diffuseColor;
            var ambientColor;
            var specularColor;
            var specular;
            var alpha;
            var mapkd;
            for (var i = 0; i < materialDefinitions.length; ++i) {
                lines = materialDefinitions[i].split('\r').join("").split('\n');
                if (lines.length == 1)
                    lines = materialDefinitions[i].split(String.fromCharCode(13));
                diffuseColor = ambientColor = specularColor = 0xFFFFFF;
                specular = 0;
                useSpecular = false;
                useColor = false;
                alpha = 1;
                mapkd = "";
                for (j = 0; j < lines.length; ++j) {
                    lines[j] = lines[j].replace(/\s+$/, "");
                    if (lines[j].substring(0, 1) != "#" && (j == 0 || lines[j] != "")) {
                        trunk = lines[j].split(" ");
                        if (String(trunk[0]).charCodeAt(0) == 9 || String(trunk[0]).charCodeAt(0) == 32)
                            trunk[0] = trunk[0].substring(1, trunk[0].length);
                        if (j == 0) {
                            this._lastMtlID = trunk.join("");
                            this._lastMtlID = (this._lastMtlID == "") ? "def000" : this._lastMtlID;
                        }
                        else {
                            switch (trunk[0]) {
                                case "Ka":
                                    if (trunk[1] && !isNaN(Number(trunk[1])) && trunk[2] && !isNaN(Number(trunk[2])) && trunk[3] && !isNaN(Number(trunk[3])))
                                        ambientColor = trunk[1] * 255 << 16 | trunk[2] * 255 << 8 | trunk[3] * 255;
                                    break;
                                case "Ks":
                                    if (trunk[1] && !isNaN(Number(trunk[1])) && trunk[2] && !isNaN(Number(trunk[2])) && trunk[3] && !isNaN(Number(trunk[3]))) {
                                        specularColor = trunk[1] * 255 << 16 | trunk[2] * 255 << 8 | trunk[3] * 255;
                                        useSpecular = true;
                                    }
                                    break;
                                case "Ns":
                                    if (trunk[1] && !isNaN(Number(trunk[1])))
                                        specular = Number(trunk[1]) * 0.001;
                                    if (specular == 0)
                                        useSpecular = false;
                                    break;
                                case "Kd":
                                    if (trunk[1] && !isNaN(Number(trunk[1])) && trunk[2] && !isNaN(Number(trunk[2])) && trunk[3] && !isNaN(Number(trunk[3]))) {
                                        diffuseColor = trunk[1] * 255 << 16 | trunk[2] * 255 << 8 | trunk[3] * 255;
                                        useColor = true;
                                    }
                                    break;
                                case "tr":
                                case "d":
                                    if (trunk[1] && !isNaN(Number(trunk[1])))
                                        alpha = Number(trunk[1]);
                                    break;
                                case "map_Kd":
                                    mapkd = this.parseMapKdString(trunk);
                                    mapkd = mapkd.replace(/\\/g, "/");
                            }
                        }
                    }
                }
                if (mapkd != "") {
                    if (useSpecular) {
                        basicSpecularMethod = new feng3d.BasicSpecularMethod();
                        basicSpecularMethod.specularColor = specularColor;
                        basicSpecularMethod.specular = specular;
                        var specularData = new SpecularData();
                        specularData.alpha = alpha;
                        specularData.basicSpecularMethod = basicSpecularMethod;
                        specularData.materialID = this._lastMtlID;
                        if (!this._materialSpecularData)
                            this._materialSpecularData = [];
                        this._materialSpecularData.push(specularData);
                    }
                    //添加材质依赖性
                    this.addDependency(this._lastMtlID, new feng3d.URLRequest(mapkd));
                }
                else if (useColor && !isNaN(diffuseColor)) {
                    var lm = new LoadedMaterial();
                    lm.materialID = this._lastMtlID;
                    if (alpha == 0)
                        console.log("Warning: an alpha value of 0 was found in mtl color tag (Tr or d) ref:" + this._lastMtlID + ", mesh(es) using it will be invisible!");
                    if (this.materialMode < 2) {
                        var cm = new feng3d.ColorMaterial(diffuseColor);
                        cm.alpha = alpha;
                        cm.ambientColor = ambientColor;
                        cm.repeat = true;
                        if (useSpecular) {
                            cm.specularColor = specularColor;
                            cm.specular = specular;
                        }
                    }
                    else {
                        var cmm = new feng3d.ColorMultiPassMaterial(diffuseColor);
                        cmm.ambientColor = ambientColor;
                        cmm.repeat = true;
                        if (useSpecular) {
                            cmm.specularColor = specularColor;
                            cmm.specular = specular;
                        }
                    }
                    lm.cm = cm;
                    this._materialLoaded.push(lm);
                    if (this._meshes.length > 0)
                        this.applyMaterial(lm);
                }
            }
            this._mtlLibLoaded = true;
        };
        OBJParser.prototype.parseMapKdString = function (trunk) {
            var url = "";
            var i;
            var breakflag;
            for (i = 1; i < trunk.length;) {
                switch (trunk[i]) {
                    case "-blendu":
                    case "-blendv":
                    case "-cc":
                    case "-clamp":
                    case "-texres":
                        i += 2; //Skip ahead 1 attribute
                        break;
                    case "-mm":
                        i += 3; //Skip ahead 2 attributes
                        break;
                    case "-o":
                    case "-s":
                    case "-t":
                        i += 4; //Skip ahead 3 attributes
                        continue;
                    default:
                        breakflag = true;
                        break;
                }
                if (breakflag)
                    break;
            }
            //Reconstruct URL/filename
            for (i; i < trunk.length; i++) {
                url += trunk[i];
                url += " ";
            }
            //Remove the extraneous space and/or newline from the right side
            url = url.replace(/\s+$/, "");
            return url;
        };
        /**
         * 加载材质
         * @param mtlurl 材质地址
         */
        OBJParser.prototype.loadMtl = function (mtlurl) {
            //添加 材质 资源依赖，暂停解析
            this.addDependency('mtl', new feng3d.URLRequest(mtlurl), true);
            this.pauseAndRetrieveDependencies();
        };
        /**
         * 应用材质
         * @param lm 加载到的材质
         */
        OBJParser.prototype.applyMaterial = function (lm) {
            var decomposeID;
            var mesh;
            var mat;
            var j;
            var specularData;
            for (var i = 0; i < this._meshes.length; ++i) {
                mesh = this._meshes[i];
                decomposeID = mesh.material.name.split("~");
                if (decomposeID[0] == lm.materialID) {
                    if (lm.cm) {
                        if (mesh.material)
                            mesh.material = null;
                        mesh.material = lm.cm;
                    }
                    else if (lm.texture) {
                        if (this.materialMode < 2) {
                            var textMat = feng3d.as(mesh.material, feng3d.TextureMaterial);
                            textMat.texture = lm.texture;
                            textMat.ambientColor = lm.ambientColor;
                            textMat.alpha = lm.alpha;
                            textMat.repeat = true;
                            if (lm.specularMethod) {
                                // By setting the this.specularMethod property to null before assigning
                                // the actual method instance, we avoid having the properties of
                                // the new method being overridden with the settings from the old
                                // one, which is default behavior of the setter.
                                textMat.specularMethod = null;
                                textMat.specularMethod = lm.specularMethod;
                            }
                            else if (this._materialSpecularData) {
                                for (j = 0; j < this._materialSpecularData.length; ++j) {
                                    specularData = this._materialSpecularData[j];
                                    if (specularData.materialID == lm.materialID) {
                                        textMat.specularMethod = null; // Prevent property overwrite (see above)
                                        textMat.specularMethod = specularData.basicSpecularMethod;
                                        textMat.ambientColor = specularData.ambientColor;
                                        textMat.alpha = specularData.alpha;
                                        break;
                                    }
                                }
                            }
                        }
                        else {
                            var multMat = feng3d.as(mesh.material, feng3d.TextureMultiPassMaterial);
                            multMat.texture = lm.texture;
                            multMat.ambientColor = lm.ambientColor;
                            multMat.repeat = true;
                            if (lm.specularMethod) {
                                // By setting the this.specularMethod property to null before assigning
                                // the actual method instance, we avoid having the properties of
                                // the new method being overridden with the settings from the old
                                // one, which is default behavior of the setter.
                                multMat.specularMethod = null;
                                multMat.specularMethod = lm.specularMethod;
                            }
                            else if (this._materialSpecularData) {
                                for (j = 0; j < this._materialSpecularData.length; ++j) {
                                    specularData = this._materialSpecularData[j];
                                    if (specularData.materialID == lm.materialID) {
                                        multMat.specularMethod = null; // Prevent property overwrite (see above)
                                        multMat.specularMethod = specularData.basicSpecularMethod;
                                        multMat.ambientColor = specularData.ambientColor;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    mesh.material.name = decomposeID[1] ? decomposeID[1] : decomposeID[0];
                    this._meshes.splice(i, 1);
                    --i;
                }
            }
            if (lm.cm || mat)
                this.finalizeAsset(lm.cm || mat);
        };
        /**
         * 应用材质
         */
        OBJParser.prototype.applyMaterials = function () {
            if (this._materialLoaded.length == 0)
                return;
            for (var i = 0; i < this._materialLoaded.length; ++i)
                this.applyMaterial(this._materialLoaded[i]);
        };
        return OBJParser;
    }(feng3d.ParserBase));
    feng3d.OBJParser = OBJParser;
    var ObjectGroup = (function () {
        function ObjectGroup() {
            /** 组列表（子网格列表） */
            this.groups = [];
        }
        ObjectGroup.prototype.ObjectGroup = function () {
        };
        return ObjectGroup;
    }());
    var Group = (function () {
        function Group() {
            this.materialGroups = [];
        }
        Group.prototype.Group = function () {
        };
        return Group;
    }());
    /**
     * 材质组
     */
    var MaterialGroup = (function () {
        function MaterialGroup() {
            this.faces = [];
        }
        MaterialGroup.prototype.MaterialGroup = function () {
        };
        return MaterialGroup;
    }());
    var SpecularData = (function () {
        function SpecularData() {
            this.ambientColor = 0xFFFFFF;
            this.alpha = 1;
        }
        SpecularData.prototype.SpecularData = function () {
        };
        return SpecularData;
    }());
    /**
     * 加载的材质
     */
    var LoadedMaterial = (function () {
        function LoadedMaterial() {
            this.ambientColor = 0xFFFFFF;
            this.alpha = 1;
        }
        LoadedMaterial.prototype.LoadedMaterial = function () {
        };
        return LoadedMaterial;
    }());
    /**
     * 面数据
     */
    var FaceData = (function () {
        function FaceData() {
            /** 顶点坐标索引数组 */
            this.vertexIndices = [];
            /** 顶点uv索引数组 */
            this.uvIndices = [];
            /** 顶点法线索引数组 */
            this.normalIndices = [];
            /** 顶点Id(原本该值存放了顶点索引、uv索引、发现索引，已经被解析为上面3个数组，剩下的就当做ID使用) */
            this.indexIds = []; // 
        }
        FaceData.prototype.FaceData = function () {
        };
        return FaceData;
    }());
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 加载模块类
     * @author feng 2014-7-25
     */
    var Load = (function () {
        function Load() {
        }
        /**
         * 初始化加载模块
         */
        Load.init = function () {
            Load.loadManager || (Load.loadManager = new feng3d.LoadManager());
            feng3d.assert(feng3d.Task.isInit, "加载模块依赖任务模块，请先初始化任务模块");
        };
        Object.defineProperty(Load, "loader", {
            /**
             * 加载器
             */
            get: function () {
                return Load.loadManager.loader;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 根据类名获取类定义
         * @param className			类名
         * @return					类定义
         */
        Load.getDefinitionByName = function (className) {
            this.loader.items.forEach(function (loadingItem) {
                var imageItem = loadingItem;
                if (imageItem && imageItem.content) {
                    if (imageItem.getDefinitionByName(className))
                        return imageItem.getDefinitionByName(className);
                }
            });
        };
        /**
         * 根据类名获取实例
         * @param className		类名
         * @return 				实例
         */
        Load.getInstance = function (className) {
            var cls = feng3d.getDefinitionByName(className);
            if (cls)
                return new cls();
            return null;
        };
        return Load;
    }());
    feng3d.Load = Load;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 任务集合类型
     * @author feng 2015-10-29
     */
    var TaskCollectionType = (function () {
        function TaskCollectionType() {
        }
        /**
         * 列表
         * <p>所有任务全部执行</p>
         */
        TaskCollectionType.LIST = "list";
        /**
         * 队列
         * <p>按照队列中的顺序一个一个依次执行</p>
         */
        TaskCollectionType.QUEUE = "queue";
        return TaskCollectionType;
    }());
    feng3d.TaskCollectionType = TaskCollectionType;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 任务模块类
     * @includeExample TaskModuleTest.as
     *
     * @author feng 2015-5-27
     */
    var Task = (function () {
        function Task() {
        }
        Object.defineProperty(Task, "isInit", {
            /**
             * 模块是否初始化
             */
            get: function () {
                return Task._isInit;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 初始化模块
         */
        Task.init = function () {
            Task.taskManager || (Task.taskManager = new feng3d.TaskManager());
            Task._isInit = true;
        };
        Task._isInit = false;
        return Task;
    }());
    feng3d.Task = Task;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 任务状态
     * @author feng 2015-6-16
     */
    var TaskStateType = (function () {
        function TaskStateType() {
        }
        /** 初始状态 */
        TaskStateType.STATE_INIT = 0;
        /** 任务正在执行 */
        TaskStateType.STATE_EXECUTING = 1;
        /** 任务已完成 */
        TaskStateType.STATE_COMPLETED = 2;
        return TaskStateType;
    }());
    feng3d.TaskStateType = TaskStateType;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 类工具
     * @author feng 2015-4-27
     */
    var ClassUtils = (function () {
        function ClassUtils() {
        }
        /**
         * 获取类定义
         * @param obj
         * @return
         */
        ClassUtils.getClass = function (obj) {
            if (typeof obj === "string") {
                try {
                    return feng3d.getDefinitionByName(obj);
                }
                catch (error) {
                    return null;
                }
            }
            var cla = obj;
            var className = feng3d.getQualifiedClassName(obj);
            if (className == "null" || className == "void") {
                return null;
            }
            if (cla == null) {
                cla = feng3d.getDefinitionByName(className);
            }
            return cla;
        };
        /**
         * 获取类实例
         * @param obj
         * @return
         */
        ClassUtils.getInstance = function (obj) {
            if (typeof obj === "function") {
                return new obj();
            }
            if (typeof obj == "string") {
                var cla = this.getClass(obj);
                return new cla;
            }
            return obj;
        };
        /**
         * 构造实例
         * @param cla						类定义
         * @param params					构造参数
         * @return							构造出的实例
         */
        ClassUtils.structureInstance = function (cla, params) {
            if (params == null) {
                return new cla();
            }
            var paramNum = params.length;
            switch (paramNum) {
                case 0:
                    return new cla();
                case 1:
                    return new cla(params[0]);
                case 2:
                    return new cla(params[0], params[1]);
                case 3:
                    return new cla(params[0], params[1], params[2]);
                case 4:
                    return new cla(params[0], params[1], params[2], params[3]);
                case 5:
                    return new cla(params[0], params[1], params[2], params[3], params[4]);
                case 6:
                    return new cla(params[0], params[1], params[2], params[3], params[4], params[5]);
                case 7:
                    return new cla(params[0], params[1], params[2], params[3], params[4], params[5], params[6]);
                case 8:
                    return new cla(params[0], params[1], params[2], params[3], params[4], params[5], params[6], params[7]);
                case 9:
                    return new cla(params[0], params[1], params[2], params[3], params[4], params[5], params[6], params[7], params[8]);
                case 10:
                    return new cla(params[0], params[1], params[2], params[3], params[4], params[5], params[6], params[7], params[8], params[9]);
                default:
                    throw new Error("不支持" + paramNum + "个参数的类构造");
            }
        };
        /**
         * 构造实例
         * @param space						运行空间
         * @param funcName					函数名称
         * @param params					函数参数
         * @return							函数返回值
         */
        ClassUtils.call = function (space, funcName, params) {
            var func = space[funcName];
            var result = func.apply(null, params);
            return result;
        };
        /**
         * 编码参数
         * @param params		参数数组
         */
        ClassUtils.encodeParams = function (params) {
            for (var i = 0; i < params.length; i++) {
                var item = params[i];
                var paramType = feng3d.getQualifiedClassName(item);
                params[i] = { paramType: paramType, paramValue: item };
            }
        };
        /**
         * 解码参数
         * @param params		参数数组
         */
        ClassUtils.decodeParams = function (params) {
            for (var i = 0; i < params.length; i++) {
                var item = params[i];
                if (item.hasOwnProperty("paramType") && item.hasOwnProperty("paramValue")) {
                    var obj;
                    if (item.paramType == "flash.geom::Matrix3D") {
                        obj = new feng3d.Matrix3D(item.paramValue.rawData);
                    }
                    else {
                        obj = ClassUtils.getInstance(item.paramType);
                        if (this.isBaseType(item.paramValue)) {
                            obj = item.paramValue;
                        }
                        else {
                            this.copyValue(obj, item.paramValue);
                        }
                    }
                    params[i] = obj;
                }
            }
        };
        /**
         * 拷贝数据
         * @param obj			需要赋值的对象
         * @param value			拥有数据的对象
         */
        ClassUtils.copyValue = function (obj, value) {
            for (var key in value) {
                var attrValue = value[key];
                var attrType = feng3d.getQualifiedClassName(attrValue);
                var baseType = this.isBaseType(value[key]);
                if (baseType) {
                    obj[key] = value[key];
                }
                else {
                    this.copyValue(obj[key], value[key]);
                }
            }
        };
        /**
         * 判断对象是否为基础类型
         * @param obj			对象
         * @return				true为基础类型，false为复杂类型
         */
        ClassUtils.isBaseType = function (obj) {
            var type = feng3d.getQualifiedClassName(obj);
            var index = ClassUtils.BASETYPES.indexOf(type);
            return index != -1;
        };
        /**
         * 获取对象默认名称
         * @param obj				对象
         * @return					对象默认名称
         */
        ClassUtils.getDefaultName = function (obj) {
            return feng3d.getQualifiedClassName(obj).split("::").pop();
        };
        /**
         * 判断两个对象的完全限定类名是否相同
         * @param obj1			对象1
         * @param obj2			对象2
         * @return
         */
        ClassUtils.isSameClass = function (obj1, obj2) {
            var className1 = feng3d.getQualifiedClassName(obj1);
            var className2 = feng3d.getQualifiedClassName(obj2);
            return className1 == className2;
        };
        /**
         * 基础类型列表
         */
        ClassUtils.BASETYPES = ["int", "boolean", "Number", "uint", "string", "null"];
        return ClassUtils;
    }());
    feng3d.ClassUtils = ClassUtils;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 格式化输出字符串
     * @param format		需要格式化的字符串
     * @param ...args		传入一个或多个需要替换的参数
     *
     * @example
     * <pre>
        trace(formatString("[{0} type=\"{1}\" bubbles={2}  cancelable={3}]", "MouseEvent", "click", true, false));

         // trace output
         [MouseEvent type="click" bubbles=true  cancelable=false]
     * </pre>
     * @author feng 2014-5-7
     */
    function formatString(format) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        for (var i = 0; i < args.length; ++i)
            format = format.replace(new RegExp("\\{" + i + "\\}", "g"), args[i]);
        return format;
    }
    feng3d.formatString = formatString;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 动画状态基类
     * @author feng 2015-9-18
     */
    var AnimationStateBase = (function () {
        /**
         * 创建动画状态基类
         * @param animator				动画
         * @param animationNode			动画节点
         */
        function AnimationStateBase(animator, animationNode) {
            this._rootDelta = new feng3d.Vector3D();
            this._positionDeltaDirty = true;
            this._animator = animator;
            this._animationNode = animationNode;
        }
        Object.defineProperty(AnimationStateBase.prototype, "positionDelta", {
            /**
             * @inheritDoc
             */
            get: function () {
                if (this._positionDeltaDirty)
                    this.updatePositionDelta();
                return this._rootDelta;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        AnimationStateBase.prototype.offset = function (startTime) {
            this._startTime = startTime;
            this._positionDeltaDirty = true;
        };
        /**
         * @inheritDoc
         */
        AnimationStateBase.prototype.update = function (time) {
            if (this._time == time - this._startTime)
                return;
            this.updateTime(time);
        };
        /**
         * @inheritDoc
         */
        AnimationStateBase.prototype.phase = function (value) {
        };
        /**
         * 更新时间
         * @param time		当前时间
         */
        AnimationStateBase.prototype.updateTime = function (time) {
            this._time = time - this._startTime;
            this._positionDeltaDirty = true;
        };
        /**
         * 位置偏移
         */
        AnimationStateBase.prototype.updatePositionDelta = function () {
        };
        return AnimationStateBase;
    }());
    feng3d.AnimationStateBase = AnimationStateBase;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 动画剪辑状态
     * @author feng 2015-9-18
     */
    var AnimationClipState = (function (_super) {
        __extends(AnimationClipState, _super);
        /**
         * 创建一个帧动画状态
         * @param animator				动画
         * @param animationClipNode		帧动画节点
         */
        function AnimationClipState(animator, animationClipNode) {
            _super.call(this, animator, animationClipNode);
            this._framesDirty = true;
            this._animationClipNode = animationClipNode;
        }
        Object.defineProperty(AnimationClipState.prototype, "blendWeight", {
            /**
             * 混合权重	(0[当前帧],1[下一帧])
             * @see #currentFrame
             * @see #nextFrame
             */
            get: function () {
                if (this._framesDirty)
                    this.updateFrames();
                return this._blendWeight;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AnimationClipState.prototype, "currentFrame", {
            /**
             * 当前帧
             */
            get: function () {
                if (this._framesDirty)
                    this.updateFrames();
                return this._currentFrame;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AnimationClipState.prototype, "nextFrame", {
            /**
             * 下一帧
             */
            get: function () {
                if (this._framesDirty)
                    this.updateFrames();
                return this._nextFrame;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        AnimationClipState.prototype.update = function (time) {
            if (!this._animationClipNode.looping) {
                if (time > this._startTime + this._animationClipNode.totalDuration)
                    time = this._startTime + this._animationClipNode.totalDuration;
                else if (time < this._startTime)
                    time = this._startTime;
            }
            if (this._time == time - this._startTime)
                return;
            this.updateTime(time);
        };
        /**
         * @inheritDoc
         */
        AnimationClipState.prototype.phase = function (value) {
            var time = value * this._animationClipNode.totalDuration + this._startTime;
            if (this._time == time - this._startTime)
                return;
            this.updateTime(time);
        };
        /**
         * @inheritDoc
         */
        AnimationClipState.prototype.updateTime = function (time) {
            this._framesDirty = true;
            this._timeDir = (time - this._startTime > this._time) ? 1 : -1;
            _super.prototype.updateTime.call(this, time);
        };
        /**
         * 更新帧，计算当前帧、下一帧与混合权重
         *
         * @see #currentFrame
         * @see #nextFrame
         * @see #blendWeight
         */
        AnimationClipState.prototype.updateFrames = function () {
            this._framesDirty = false;
            var looping = this._animationClipNode.looping;
            var totalDuration = this._animationClipNode.totalDuration;
            var lastFrame = this._animationClipNode.lastFrame;
            var time = this._time;
            //trace("time", time, totalDuration)
            if (looping && (time >= totalDuration || time < 0)) {
                time %= totalDuration;
                if (time < 0)
                    time += totalDuration;
            }
            if (!looping && time >= totalDuration) {
                this.notifyPlaybackComplete();
                this._currentFrame = lastFrame;
                this._nextFrame = lastFrame;
                this._blendWeight = 0;
            }
            else if (!looping && time <= 0) {
                this._currentFrame = 0;
                this._nextFrame = 0;
                this._blendWeight = 0;
            }
            else if (this._animationClipNode.fixedFrameRate) {
                var t = time / totalDuration * lastFrame;
                this._currentFrame = t;
                this._blendWeight = t - this._currentFrame;
                this._nextFrame = this._currentFrame + 1;
            }
            else {
                this._currentFrame = 0;
                this._nextFrame = 0;
                var dur = 0, frameTime;
                var durations = this._animationClipNode.durations;
                do {
                    frameTime = dur;
                    dur += durations[this.nextFrame];
                    this._currentFrame = this._nextFrame++;
                } while (time > dur);
                if (this._currentFrame == lastFrame) {
                    this._currentFrame = 0;
                    this._nextFrame = 1;
                }
                this._blendWeight = (time - frameTime) / durations[this._currentFrame];
            }
        };
        /**
         * 通知播放完成
         */
        AnimationClipState.prototype.notifyPlaybackComplete = function () {
            this._animationClipNode.dispatchEvent(new feng3d.AnimationStateEvent(feng3d.AnimationStateEvent.PLAYBACK_COMPLETE, this._animator, this, this._animationClipNode));
        };
        return AnimationClipState;
    }(feng3d.AnimationStateBase));
    feng3d.AnimationClipState = AnimationClipState;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 骨骼剪辑状态
     * @author feng 2015-9-18
     */
    var SkeletonClipState = (function (_super) {
        __extends(SkeletonClipState, _super);
        /**
         * 创建骨骼剪辑状态实例
         * @param animator				动画
         * @param skeletonClipNode		骨骼剪辑节点
         */
        function SkeletonClipState(animator, skeletonClipNode) {
            _super.call(this, animator, skeletonClipNode);
            this._rootPos = new feng3d.Vector3D();
            this._skeletonPose = new feng3d.SkeletonPose();
            this._skeletonPoseDirty = true;
            this._skeletonClipNode = skeletonClipNode;
            this._frames = this._skeletonClipNode.frames;
        }
        Object.defineProperty(SkeletonClipState.prototype, "currentPose", {
            /**
             * 当前骨骼姿势
             */
            get: function () {
                if (this._framesDirty)
                    this.updateFrames();
                return this._currentPose;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SkeletonClipState.prototype, "nextPose", {
            /**
             * 下个姿势
             */
            get: function () {
                if (this._framesDirty)
                    this.updateFrames();
                return this._nextPose;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        SkeletonClipState.prototype.getSkeletonPose = function (skeleton) {
            if (this._skeletonPoseDirty)
                this.updateSkeletonPose(skeleton);
            return this._skeletonPose;
        };
        /**
         * @inheritDoc
         */
        SkeletonClipState.prototype.updateTime = function (time) {
            this._skeletonPoseDirty = true;
            _super.prototype.updateTime.call(this, time);
        };
        /**
         * @inheritDoc
         */
        SkeletonClipState.prototype.updateFrames = function () {
            _super.prototype.updateFrames.call(this);
            this._currentPose = this._frames[this._currentFrame];
            if (this._skeletonClipNode.looping && this._nextFrame >= this._skeletonClipNode.lastFrame) {
                this._nextPose = this._frames[0];
                this._animator.dispatchCycleEvent();
            }
            else
                this._nextPose = this._frames[this._nextFrame];
        };
        /**
         * 更新骨骼姿势
         * @param skeleton 骨骼
         */
        SkeletonClipState.prototype.updateSkeletonPose = function (skeleton) {
            this._skeletonPoseDirty = false;
            if (!this._skeletonClipNode.totalDuration)
                return;
            if (this._framesDirty)
                this.updateFrames();
            var currentPose = this._currentPose.jointPoses;
            var nextPose = this._nextPose.jointPoses;
            var numJoints = skeleton.numJoints;
            var p1, p2;
            var pose1, pose2;
            var showPoses = this._skeletonPose.jointPoses;
            var showPose;
            var tr;
            //调整当前显示关节姿势数量
            if (showPoses.length != numJoints)
                showPoses.length = numJoints;
            if ((numJoints != currentPose.length) || (numJoints != nextPose.length))
                throw new Error("joint counts don't match!");
            for (var i = 0; i < numJoints; ++i) {
                showPose = showPoses[i];
                if (showPose == null)
                    showPose = showPoses[i] = new feng3d.JointPose();
                pose1 = currentPose[i];
                pose2 = nextPose[i];
                p1 = pose1.translation;
                p2 = pose2.translation;
                //根据前后两个关节姿势计算出当前显示关节姿势
                showPose.orientation.lerp(pose1.orientation, pose2.orientation, this._blendWeight);
                //计算显示的关节位置
                if (i > 0) {
                    tr = showPose.translation;
                    tr.x = p1.x + this._blendWeight * (p2.x - p1.x);
                    tr.y = p1.y + this._blendWeight * (p2.y - p1.y);
                    tr.z = p1.z + this._blendWeight * (p2.z - p1.z);
                }
            }
        };
        /**
         * @inheritDoc
         */
        SkeletonClipState.prototype.updatePositionDelta = function () {
            this._positionDeltaDirty = false;
            if (this._framesDirty)
                this.updateFrames();
            var p1, p2, p3;
            var totalDelta = this._skeletonClipNode.totalDelta;
            //跳过最后，重置位置
            if ((this._timeDir > 0 && this._nextFrame < this._oldFrame) || (this._timeDir < 0 && this._nextFrame > this._oldFrame)) {
                this._rootPos.x -= totalDelta.x * this._timeDir;
                this._rootPos.y -= totalDelta.y * this._timeDir;
                this._rootPos.z -= totalDelta.z * this._timeDir;
            }
            /** 保存骨骼根节点原位置 */
            var dx = this._rootPos.x;
            var dy = this._rootPos.y;
            var dz = this._rootPos.z;
            //计算骨骼根节点位置
            if (this._skeletonClipNode.stitchFinalFrame && this._nextFrame == this._skeletonClipNode.lastFrame) {
                p1 = this._frames[0].jointPoses[0].translation;
                p2 = this._frames[1].jointPoses[0].translation;
                p3 = this._currentPose.jointPoses[0].translation;
                this._rootPos.x = p3.x + p1.x + this._blendWeight * (p2.x - p1.x);
                this._rootPos.y = p3.y + p1.y + this._blendWeight * (p2.y - p1.y);
                this._rootPos.z = p3.z + p1.z + this._blendWeight * (p2.z - p1.z);
            }
            else {
                p1 = this._currentPose.jointPoses[0].translation;
                p2 = this._frames[this._nextFrame].jointPoses[0].translation; //cover the instances where we wrap the pose but still want the final frame translation values
                this._rootPos.x = p1.x + this._blendWeight * (p2.x - p1.x);
                this._rootPos.y = p1.y + this._blendWeight * (p2.y - p1.y);
                this._rootPos.z = p1.z + this._blendWeight * (p2.z - p1.z);
            }
            //计算骨骼根节点偏移量
            this._rootDelta.x = this._rootPos.x - dx;
            this._rootDelta.y = this._rootPos.y - dy;
            this._rootDelta.z = this._rootPos.z - dz;
            //保存旧帧编号
            this._oldFrame = this._nextFrame;
        };
        return SkeletonClipState;
    }(feng3d.AnimationClipState));
    feng3d.SkeletonClipState = SkeletonClipState;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * sprite动画状态
     * @author feng 2015-9-18
     */
    var SpriteSheetAnimationState = (function (_super) {
        __extends(SpriteSheetAnimationState, _super);
        /**
         * 创建sprite动画状态实例
         * @param animator			动画
         * @param clipNode			动画剪辑节点
         */
        function SpriteSheetAnimationState(animator, clipNode) {
            _super.call(this, animator, clipNode);
            this._currentFrameID = 0;
            this._clipNode = clipNode;
            this._frames = this._clipNode.frames;
        }
        Object.defineProperty(SpriteSheetAnimationState.prototype, "reverse", {
            /**
             * 是否反向播放
             */
            set: function (b) {
                this._reverse = b;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SpriteSheetAnimationState.prototype, "backAndForth", {
            /**
             * 改变播放方向
             */
            set: function (b) {
                if (b)
                    this._reverse = false;
                this._backAndForth = b;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SpriteSheetAnimationState.prototype, "currentFrameData", {
            /**
             * @inheritDoc
             */
            get: function () {
                if (this._framesDirty)
                    this.updateFrames();
                return this._frames[this._currentFrameID];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SpriteSheetAnimationState.prototype, "currentFrameNumber", {
            /**
             * 当前帧数
             */
            get: function () {
                return this._currentFrameID;
            },
            set: function (frameNumber) {
                this._currentFrameID = (frameNumber > this._frames.length - 1) ? this._frames.length - 1 : frameNumber;
                this._forcedFrame = true;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SpriteSheetAnimationState.prototype, "totalFrames", {
            /**
             * 总帧数
             */
            get: function () {
                return (!this._frames) ? 0 : this._frames.length;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        SpriteSheetAnimationState.prototype.updateFrames = function () {
            if (this._forcedFrame) {
                this._forcedFrame = false;
                return;
            }
            _super.prototype.updateFrames.call(this);
            if (this._reverse) {
                if (this._currentFrameID - 1 > -1)
                    this._currentFrameID--;
                else {
                    if (this._clipNode.looping) {
                        if (this._backAndForth) {
                            this._reverse = false;
                            this._currentFrameID++;
                        }
                        else
                            this._currentFrameID = this._frames.length - 1;
                    }
                    this._animator.dispatchCycleEvent();
                }
            }
            else {
                if (this._currentFrameID < this._frames.length - 1)
                    this._currentFrameID++;
                else {
                    if (this._clipNode.looping) {
                        if (this._backAndForth) {
                            this._reverse = true;
                            this._currentFrameID--;
                        }
                        else
                            this._currentFrameID = 0;
                    }
                    (this._animator).dispatchCycleEvent();
                }
            }
        };
        return SpriteSheetAnimationState;
    }(feng3d.AnimationClipState));
    feng3d.SpriteSheetAnimationState = SpriteSheetAnimationState;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * UV动画剪辑状态
     * @author feng 2015-9-18
     */
    var UVClipState = (function (_super) {
        __extends(UVClipState, _super);
        /**
         * 创建UVClipState实例
         * @param animator				动画
         * @param uvClipNode			UV动画剪辑节点
         */
        function UVClipState(animator, uvClipNode) {
            _super.call(this, animator, uvClipNode);
            this._uvClipNode = uvClipNode;
            this._frames = this._uvClipNode.frames;
        }
        Object.defineProperty(UVClipState.prototype, "currentUVFrame", {
            /**
             * @inheritDoc
             */
            get: function () {
                if (this._framesDirty)
                    this.updateFrames();
                return this._currentUVFrame;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UVClipState.prototype, "nextUVFrame", {
            /**
             * @inheritDoc
             */
            get: function () {
                if (this._framesDirty)
                    this.updateFrames();
                return this._nextUVFrame;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        UVClipState.prototype.updateFrames = function () {
            _super.prototype.updateFrames.call(this);
            if (this._frames.length > 0) {
                if (this._frames.length == 2 && this._currentFrame == 0) {
                    this._currentUVFrame = this._frames[1];
                    this._nextUVFrame = this._frames[0];
                }
                else {
                    this._currentUVFrame = this._frames[this._currentFrame];
                    if (this._uvClipNode.looping && this._nextFrame >= this._uvClipNode.lastFrame)
                        this._nextUVFrame = this._frames[0];
                    else
                        this._nextUVFrame = this._frames[this._nextFrame];
                }
            }
        };
        return UVClipState;
    }(feng3d.AnimationClipState));
    feng3d.UVClipState = UVClipState;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 顶点动画剪辑状态
     * @author feng 2015-9-18
     */
    var VertexClipState = (function (_super) {
        __extends(VertexClipState, _super);
        /**
         * 创建VertexClipState实例
         * @param animator				动画
         * @param vertexClipNode		顶点动画节点
         */
        function VertexClipState(animator, vertexClipNode) {
            _super.call(this, animator, vertexClipNode);
            this._vertexClipNode = vertexClipNode;
            this._frames = this._vertexClipNode.frames;
        }
        Object.defineProperty(VertexClipState.prototype, "currentGeometry", {
            /**
             * @inheritDoc
             */
            get: function () {
                if (this._framesDirty)
                    this.updateFrames();
                return this._currentGeometry;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(VertexClipState.prototype, "nextGeometry", {
            /**
             * @inheritDoc
             */
            get: function () {
                if (this._framesDirty)
                    this.updateFrames();
                return this._nextGeometry;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        VertexClipState.prototype.updateFrames = function () {
            _super.prototype.updateFrames.call(this);
            this._currentGeometry = this._frames[this._currentFrame];
            if (this._vertexClipNode.looping && this._nextFrame >= this._vertexClipNode.lastFrame) {
                this._nextGeometry = this._frames[0];
                this._animator.dispatchCycleEvent();
            }
            else
                this._nextGeometry = this._frames[this._nextFrame];
        };
        return VertexClipState;
    }(feng3d.AnimationClipState));
    feng3d.VertexClipState = VertexClipState;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 粒子状态基类
     * @author feng 2014-5-20
     */
    var ParticleStateBase = (function (_super) {
        __extends(ParticleStateBase, _super);
        /**
         * 创建粒子状态基类
         * @param animator				粒子动画
         * @param particleNode			粒子节点
         * @param needUpdateTime		是否需要更新时间
         */
        function ParticleStateBase(animator, particleNode, needUpdateTime) {
            if (needUpdateTime === void 0) { needUpdateTime = false; }
            _super.call(this, animator, particleNode);
            this._dynamicProperties = [];
            this._dynamicPropertiesDirty = {};
            this._particleNode = particleNode;
            this._needUpdateTime = needUpdateTime;
        }
        Object.defineProperty(ParticleStateBase.prototype, "needUpdateTime", {
            /**
             * 是否需要更新时间
             */
            get: function () {
                return this._needUpdateTime;
            },
            enumerable: true,
            configurable: true
        });
        return ParticleStateBase;
    }(feng3d.AnimationStateBase));
    feng3d.ParticleStateBase = ParticleStateBase;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 骨骼线性插值状态接口
     * @author feng 2015-9-18
     */
    var SkeletonBinaryLERPState = (function (_super) {
        __extends(SkeletonBinaryLERPState, _super);
        /**
         * 创建SkeletonBinaryLERPState实例
         * @param animator						动画
         * @param skeletonAnimationNode			骨骼动画节点
         */
        function SkeletonBinaryLERPState(animator, skeletonAnimationNode) {
            _super.call(this, animator, skeletonAnimationNode);
            this._blendWeight = 0;
            this._skeletonPose = new feng3d.SkeletonPose();
            this._skeletonPoseDirty = true;
            this._skeletonAnimationNode = skeletonAnimationNode;
            this._inputA = animator.getAnimationState(this._skeletonAnimationNode.inputA);
            this._inputB = animator.getAnimationState(this._skeletonAnimationNode.inputB);
        }
        Object.defineProperty(SkeletonBinaryLERPState.prototype, "blendWeight", {
            /**
             * 混合权重	(0[inputA],1[inputB])
             */
            get: function () {
                return this._blendWeight;
            },
            set: function (value) {
                this._blendWeight = value;
                this._positionDeltaDirty = true;
                this._skeletonPoseDirty = true;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        SkeletonBinaryLERPState.prototype.phase = function (value) {
            this._skeletonPoseDirty = true;
            this._positionDeltaDirty = true;
            this._inputA.phase(value);
            this._inputB.phase(value);
        };
        /**
         * @inheritDoc
         */
        SkeletonBinaryLERPState.prototype.updateTime = function (time) {
            this._skeletonPoseDirty = true;
            this._inputA.update(time);
            this._inputB.update(time);
            _super.prototype.updateTime.call(this, time);
        };
        /**
         * @inheritDoc
         */
        SkeletonBinaryLERPState.prototype.getSkeletonPose = function (skeleton) {
            if (this._skeletonPoseDirty)
                this.updateSkeletonPose(skeleton);
            return this._skeletonPose;
        };
        /**
         * @inheritDoc
         */
        SkeletonBinaryLERPState.prototype.updatePositionDelta = function () {
            this._positionDeltaDirty = false;
            var deltA = this._inputA.positionDelta;
            var deltB = this._inputB.positionDelta;
            this._rootDelta.x = deltA.x + this._blendWeight * (deltB.x - deltA.x);
            this._rootDelta.y = deltA.y + this._blendWeight * (deltB.y - deltA.y);
            this._rootDelta.z = deltA.z + this._blendWeight * (deltB.z - deltA.z);
        };
        /**
         * 更新骨骼姿势
         * @param skeleton		骨骼
         */
        SkeletonBinaryLERPState.prototype.updateSkeletonPose = function (skeleton) {
            this._skeletonPoseDirty = false;
            var endPose;
            var endPoses = this._skeletonPose.jointPoses;
            var poses1 = this._inputA.getSkeletonPose(skeleton).jointPoses;
            var poses2 = this._inputB.getSkeletonPose(skeleton).jointPoses;
            var pose1, pose2;
            var p1, p2;
            var tr;
            var numJoints = skeleton.numJoints;
            // :s
            if (endPoses.length != numJoints)
                endPoses.length = numJoints;
            for (var i = 0; i < numJoints; ++i) {
                endPose = endPoses[i];
                if (endPose == null)
                    endPose = endPoses[i] = new feng3d.JointPose();
                pose1 = poses1[i];
                pose2 = poses2[i];
                p1 = pose1.translation;
                p2 = pose2.translation;
                endPose.orientation.lerp(pose1.orientation, pose2.orientation, this._blendWeight);
                tr = endPose.translation;
                tr.x = p1.x + this._blendWeight * (p2.x - p1.x);
                tr.y = p1.y + this._blendWeight * (p2.y - p1.y);
                tr.z = p1.z + this._blendWeight * (p2.z - p1.z);
            }
        };
        return SkeletonBinaryLERPState;
    }(feng3d.AnimationStateBase));
    feng3d.SkeletonBinaryLERPState = SkeletonBinaryLERPState;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 淡入淡出变换状态
     * @author feng 2015-9-18
     */
    var CrossfadeTransitionState = (function (_super) {
        __extends(CrossfadeTransitionState, _super);
        /**
         * 创建淡入淡出变换状态实例
         * @param animator						动画
         * @param skeletonAnimationNode			骨骼动画节点
         */
        function CrossfadeTransitionState(animator, skeletonAnimationNode) {
            _super.call(this, animator, skeletonAnimationNode);
            this._skeletonAnimationNode1 = skeletonAnimationNode;
        }
        /**
         * @inheritDoc
         */
        CrossfadeTransitionState.prototype.updateTime = function (time) {
            this.blendWeight = Math.abs(time - this._skeletonAnimationNode1.startBlend) / (1000 * this._skeletonAnimationNode1.blendSpeed);
            if (this.blendWeight >= 1) {
                this.blendWeight = 1;
                if (this._animationStateTransitionComplete == null)
                    this._animationStateTransitionComplete = new feng3d.AnimationStateEvent(feng3d.AnimationStateEvent.TRANSITION_COMPLETE, this._animator, this, this._skeletonAnimationNode1);
                this._skeletonAnimationNode1.dispatchEvent(this._animationStateTransitionComplete);
            }
            _super.prototype.updateTime.call(this, time);
        };
        return CrossfadeTransitionState;
    }(feng3d.SkeletonBinaryLERPState));
    feng3d.CrossfadeTransitionState = CrossfadeTransitionState;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * ...
     */
    var ParticleAnimationData = (function () {
        function ParticleAnimationData(index, startTime, duration, delay, particle) {
            this.index = index;
            this.startTime = startTime;
            this.totalTime = duration + delay;
            this.duration = duration;
            this.delay = delay;
            this.startVertexIndex = particle.startVertexIndex;
            this.numVertices = particle.numVertices;
        }
        return ParticleAnimationData;
    }());
    feng3d.ParticleAnimationData = ParticleAnimationData;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 粒子属性
     * @author feng 2014-11-13
     */
    var ParticleProperties = (function () {
        function ParticleProperties() {
        }
        return ParticleProperties;
    }());
    feng3d.ParticleProperties = ParticleProperties;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 粒子属性模型
     * @author feng 2014-11-13
     */
    var ParticlePropertiesMode = (function () {
        function ParticlePropertiesMode() {
        }
        /**
         * 全局粒子属性，数据将上传至常量寄存器中
         */
        ParticlePropertiesMode.GLOBAL = 0;
        /**
         * 本地静态粒子属性，数据将上传顶点属性寄存器
         */
        ParticlePropertiesMode.LOCAL_STATIC = 1;
        return ParticlePropertiesMode;
    }());
    feng3d.ParticlePropertiesMode = ParticlePropertiesMode;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 关节pose
     * @author feng 2014-5-20
     */
    var JointPose = (function () {
        function JointPose() {
            /** 旋转信息 */
            this.orientation = new feng3d.Quaternion();
            /** 位移信息 */
            this.translation = new feng3d.Vector3D();
        }
        /**
         * Converts the transformation to a Matrix3D representation.
         *
         * @param target An optional target matrix to store the transformation. If not provided, it will create a new instance.
         * @return The transformation matrix of the pose.
         */
        JointPose.prototype.toMatrix3D = function (target) {
            if (target === void 0) { target = null; }
            if (target == null)
                target = new feng3d.Matrix3D();
            this.orientation.toMatrix3D(target);
            target.appendTranslation(this.translation.x, this.translation.y, this.translation.z);
            return target;
        };
        return JointPose;
    }());
    feng3d.JointPose = JointPose;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 骨骼关节数据
     * @author feng 2014-5-20
     */
    var SkeletonJoint = (function () {
        function SkeletonJoint() {
            /** 父关节索引 （-1说明本身是总父节点，这个序号其实就是行号了，譬如上面”origin“节点的序号就是0，无父节点； "body"节点序号是1，父节点序号是0，也就是说父节点是”origin“）*/
            this.parentIndex = -1;
        }
        return SkeletonJoint;
    }());
    feng3d.SkeletonJoint = SkeletonJoint;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * sprite动画帧
     * @author feng 2015-9-18
     * @see me.feng3d.animators.uv.UVAnimationFrame
     */
    var SpriteSheetAnimationFrame = (function () {
        /**
         * 创建<code>SpriteSheetAnimationFrame</code>实例
         *
         * @param offsetU			U元素偏移
         * @param offsetV			V元素偏移
         * @param scaleU			U元素缩放
         * @param scaleV			V元素缩放
         * @param mapID				映射编号
         */
        function SpriteSheetAnimationFrame(offsetU, offsetV, scaleU, scaleV, mapID) {
            if (offsetU === void 0) { offsetU = 0; }
            if (offsetV === void 0) { offsetV = 0; }
            if (scaleU === void 0) { scaleU = 1; }
            if (scaleV === void 0) { scaleV = 1; }
            if (mapID === void 0) { mapID = 0; }
            this.offsetU = offsetU;
            this.offsetV = offsetV;
            this.scaleU = scaleU;
            this.scaleV = scaleV;
            this.mapID = mapID;
        }
        return SpriteSheetAnimationFrame;
    }());
    feng3d.SpriteSheetAnimationFrame = SpriteSheetAnimationFrame;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 淡入淡出变换
     * @author feng 2015-9-18
     */
    var CrossfadeTransition = (function () {
        /**
         * 创建淡入淡出变换实例
         * @param blendSpeed			混合速度
         */
        function CrossfadeTransition(blendSpeed) {
            this.blendSpeed = 0.5;
            this.blendSpeed = blendSpeed;
        }
        /**
         * @inheritDoc
         */
        CrossfadeTransition.prototype.getAnimationNode = function (animator, startNode, endNode, startBlend) {
            var crossFadeTransitionNode = new feng3d.CrossfadeTransitionNode();
            crossFadeTransitionNode.inputA = startNode;
            crossFadeTransitionNode.inputB = endNode;
            crossFadeTransitionNode.blendSpeed = this.blendSpeed;
            crossFadeTransitionNode.startBlend = startBlend;
            return crossFadeTransitionNode;
        };
        return CrossfadeTransition;
    }());
    feng3d.CrossfadeTransition = CrossfadeTransition;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * UV动画帧
     * @author feng 2015-9-18
     * @see me.feng3d.animators.spriteSheet.SpriteSheetAnimationFrame
     */
    var UVAnimationFrame = (function () {
        /**
         * 创建<code>UVAnimationFrame</code>实例
         *
         * @param offsetU			U元素偏移
         * @param offsetV			V元素偏移
         * @param scaleU			U元素缩放
         * @param scaleV			V元素缩放
         * @param rotation			旋转角度（度数）
         */
        function UVAnimationFrame(offsetU, offsetV, scaleU, scaleV, rotation) {
            if (offsetU === void 0) { offsetU = 0; }
            if (offsetV === void 0) { offsetV = 0; }
            if (scaleU === void 0) { scaleU = 1; }
            if (scaleV === void 0) { scaleV = 1; }
            if (rotation === void 0) { rotation = 0; }
            this.offsetU = offsetU;
            this.offsetV = offsetV;
            this.scaleU = scaleU;
            this.scaleV = scaleV;
            this.rotation = rotation;
        }
        return UVAnimationFrame;
    }());
    feng3d.UVAnimationFrame = UVAnimationFrame;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 包围盒基类
     * @author feng 2014-4-27
     */
    var BoundingVolumeBase = (function () {
        /**
         * 创建包围盒
         */
        function BoundingVolumeBase() {
            this._aabbPointsDirty = true;
            this._min = new feng3d.Vector3D();
            this._max = new feng3d.Vector3D();
        }
        Object.defineProperty(BoundingVolumeBase.prototype, "max", {
            /**
             * The maximum extreme of the bounds
             */
            get: function () {
                return this._max;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BoundingVolumeBase.prototype, "min", {
            /**
             * The minimum extreme of the bounds
             */
            get: function () {
                return this._min;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BoundingVolumeBase.prototype, "boundingRenderable", {
            /**
             * 渲染实体
             */
            get: function () {
                if (!this._boundingRenderable) {
                    this._boundingRenderable = this.createBoundingRenderable();
                    this.updateBoundingRenderable();
                }
                return this._boundingRenderable;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 销毁渲染实体
         */
        BoundingVolumeBase.prototype.disposeRenderable = function () {
            this._boundingRenderable = null;
        };
        /**
         * 根据几何结构更新边界
         */
        BoundingVolumeBase.prototype.fromGeometry = function (geometry) {
            var subGeoms = geometry.subGeometries;
            var numSubGeoms = subGeoms.length;
            var minX, minY, minZ;
            var maxX, maxY, maxZ;
            if (numSubGeoms > 0) {
                var subGeom = subGeoms[0];
                var vertices = subGeom.vertexPositionData;
                var i = 0;
                minX = maxX = vertices[i];
                minY = maxY = vertices[i + 1];
                minZ = maxZ = vertices[i + 2];
                var j = 0;
                while (j < numSubGeoms) {
                    subGeom = subGeoms[j++];
                    vertices = subGeom.vertexPositionData;
                    var vertexDataLen = vertices.length;
                    i = 0;
                    var stride = subGeom.vertexPositionStride;
                    while (i < vertexDataLen) {
                        var v = vertices[i];
                        if (v < minX)
                            minX = v;
                        else if (v > maxX)
                            maxX = v;
                        v = vertices[i + 1];
                        if (v < minY)
                            minY = v;
                        else if (v > maxY)
                            maxY = v;
                        v = vertices[i + 2];
                        if (v < minZ)
                            minZ = v;
                        else if (v > maxZ)
                            maxZ = v;
                        i += stride;
                    }
                }
                this.fromExtremes(minX, minY, minZ, maxX, maxY, maxZ);
            }
            else
                this.fromExtremes(0, 0, 0, 0, 0, 0);
        };
        /**
         * 根据所给极值设置边界
         * @param minX 边界最小X坐标
         * @param minY 边界最小Y坐标
         * @param minZ 边界最小Z坐标
         * @param maxX 边界最大X坐标
         * @param maxY 边界最大Y坐标
         * @param maxZ 边界最大Z坐标
         */
        BoundingVolumeBase.prototype.fromExtremes = function (minX, minY, minZ, maxX, maxY, maxZ) {
            this._min.x = minX;
            this._min.y = minY;
            this._min.z = minZ;
            this._max.x = maxX;
            this._max.y = maxY;
            this._max.z = maxZ;
            if (this._boundingRenderable)
                this.updateBoundingRenderable();
        };
        /**
         * 检测射线是否与边界交叉
         * @param ray3D						射线
         * @param targetNormal				交叉点法线值
         * @return							射线起点到交点距离
         */
        BoundingVolumeBase.prototype.rayIntersection = function (ray3D, targetNormal) {
            return -1;
        };
        /**
         * 检测是否包含指定点
         * @param position 		被检测点
         * @return				true：包含指定点
         */
        BoundingVolumeBase.prototype.containsPoint = function (position) {
            return false;
        };
        /**
         * 从给出的球体设置边界
         * @param center 		球心坐标
         * @param radius 		球体半径
         */
        BoundingVolumeBase.prototype.fromSphere = function (center, radius) {
            this.fromExtremes(center.x - radius, center.y - radius, center.z - radius, center.x + radius, center.y + radius, center.z + radius);
        };
        return BoundingVolumeBase;
    }());
    feng3d.BoundingVolumeBase = BoundingVolumeBase;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 轴对其包围盒
     * @author feng 2014-4-27
     */
    var AxisAlignedBoundingBox = (function (_super) {
        __extends(AxisAlignedBoundingBox, _super);
        /**
         * 创建轴对其包围盒
         */
        function AxisAlignedBoundingBox() {
            _super.call(this);
            this._centerX = 0;
            this._centerY = 0;
            this._centerZ = 0;
            this._halfExtentsX = 0;
            this._halfExtentsY = 0;
            this._halfExtentsZ = 0;
        }
        /**
         * 创建渲染边界
         */
        AxisAlignedBoundingBox.prototype.createBoundingRenderable = function () {
            return new feng3d.WireframeCube(1, 1, 1, 0xffffff, 0.5);
        };
        /**
         * 测试轴对其包围盒是否出现在摄像机视锥体内
         * @param planes 		视锥体面向量
         * @return 				true：出现在视锥体内
         * @see me.feng3d.cameras.Camera3D.updateFrustum()
         */
        AxisAlignedBoundingBox.prototype.isInFrustum = function (planes, numPlanes) {
            for (var i = 0; i < numPlanes; ++i) {
                var plane = planes[i];
                var a = plane.a;
                var b = plane.b;
                var c = plane.c;
                //最可能出现在平面内的点，即距离最可能大于0的点 (如果这个点都不在平面内的话，其他的点肯定会不在平面内)
                var flippedExtentX = a < 0 ? -this._halfExtentsX : this._halfExtentsX;
                var flippedExtentY = b < 0 ? -this._halfExtentsY : this._halfExtentsY;
                var flippedExtentZ = c < 0 ? -this._halfExtentsZ : this._halfExtentsZ;
                var projDist = a * (this._centerX + flippedExtentX) + b * (this._centerY + flippedExtentY) + c * (this._centerZ + flippedExtentZ) - plane.d;
                //小于0表示包围盒8个点都在平面内，同时就表面不存在点在视锥体内。注：视锥体6个平面朝内
                if (projDist < 0)
                    return false;
            }
            return true;
        };
        /**
         * @inheritDoc
         */
        AxisAlignedBoundingBox.prototype.updateBoundingRenderable = function () {
            var transform3D = this._boundingRenderable.transform3D;
            transform3D.scaleX = Math.max(this._halfExtentsX * 2, 0.001);
            transform3D.scaleY = Math.max(this._halfExtentsY * 2, 0.001);
            transform3D.scaleZ = Math.max(this._halfExtentsZ * 2, 0.001);
            transform3D.x = this._centerX;
            transform3D.y = this._centerY;
            transform3D.z = this._centerZ;
        };
        /**
         * @inheritDoc
         */
        AxisAlignedBoundingBox.prototype.fromExtremes = function (minX, minY, minZ, maxX, maxY, maxZ) {
            this._centerX = (maxX + minX) * .5;
            this._centerY = (maxY + minY) * .5;
            this._centerZ = (maxZ + minZ) * .5;
            this._halfExtentsX = (maxX - minX) * .5;
            this._halfExtentsY = (maxY - minY) * .5;
            this._halfExtentsZ = (maxZ - minZ) * .5;
            _super.prototype.fromExtremes.call(this, minX, minY, minZ, maxX, maxY, maxZ);
        };
        /**
         * @inheritDoc
         */
        AxisAlignedBoundingBox.prototype.rayIntersection = function (ray3D, targetNormal) {
            var position = ray3D.position;
            var direction = ray3D.direction;
            if (this.containsPoint(position))
                return 0;
            var px = position.x - this._centerX, py = position.y - this._centerY, pz = position.z - this._centerZ;
            var vx = direction.x, vy = direction.y, vz = direction.z;
            var ix, iy, iz;
            var rayEntryDistance;
            // ray-plane tests
            var intersects;
            if (vx < 0) {
                rayEntryDistance = (this._halfExtentsX - px) / vx;
                if (rayEntryDistance > 0) {
                    iy = py + rayEntryDistance * vy;
                    iz = pz + rayEntryDistance * vz;
                    if (iy > -this._halfExtentsY && iy < this._halfExtentsY && iz > -this._halfExtentsZ && iz < this._halfExtentsZ) {
                        targetNormal.x = 1;
                        targetNormal.y = 0;
                        targetNormal.z = 0;
                        intersects = true;
                    }
                }
            }
            if (!intersects && vx > 0) {
                rayEntryDistance = (-this._halfExtentsX - px) / vx;
                if (rayEntryDistance > 0) {
                    iy = py + rayEntryDistance * vy;
                    iz = pz + rayEntryDistance * vz;
                    if (iy > -this._halfExtentsY && iy < this._halfExtentsY && iz > -this._halfExtentsZ && iz < this._halfExtentsZ) {
                        targetNormal.x = -1;
                        targetNormal.y = 0;
                        targetNormal.z = 0;
                        intersects = true;
                    }
                }
            }
            if (!intersects && vy < 0) {
                rayEntryDistance = (this._halfExtentsY - py) / vy;
                if (rayEntryDistance > 0) {
                    ix = px + rayEntryDistance * vx;
                    iz = pz + rayEntryDistance * vz;
                    if (ix > -this._halfExtentsX && ix < this._halfExtentsX && iz > -this._halfExtentsZ && iz < this._halfExtentsZ) {
                        targetNormal.x = 0;
                        targetNormal.y = 1;
                        targetNormal.z = 0;
                        intersects = true;
                    }
                }
            }
            if (!intersects && vy > 0) {
                rayEntryDistance = (-this._halfExtentsY - py) / vy;
                if (rayEntryDistance > 0) {
                    ix = px + rayEntryDistance * vx;
                    iz = pz + rayEntryDistance * vz;
                    if (ix > -this._halfExtentsX && ix < this._halfExtentsX && iz > -this._halfExtentsZ && iz < this._halfExtentsZ) {
                        targetNormal.x = 0;
                        targetNormal.y = -1;
                        targetNormal.z = 0;
                        intersects = true;
                    }
                }
            }
            if (!intersects && vz < 0) {
                rayEntryDistance = (this._halfExtentsZ - pz) / vz;
                if (rayEntryDistance > 0) {
                    ix = px + rayEntryDistance * vx;
                    iy = py + rayEntryDistance * vy;
                    if (iy > -this._halfExtentsY && iy < this._halfExtentsY && ix > -this._halfExtentsX && ix < this._halfExtentsX) {
                        targetNormal.x = 0;
                        targetNormal.y = 0;
                        targetNormal.z = 1;
                        intersects = true;
                    }
                }
            }
            if (!intersects && vz > 0) {
                rayEntryDistance = (-this._halfExtentsZ - pz) / vz;
                if (rayEntryDistance > 0) {
                    ix = px + rayEntryDistance * vx;
                    iy = py + rayEntryDistance * vy;
                    if (iy > -this._halfExtentsY && iy < this._halfExtentsY && ix > -this._halfExtentsX && ix < this._halfExtentsX) {
                        targetNormal.x = 0;
                        targetNormal.y = 0;
                        targetNormal.z = -1;
                        intersects = true;
                    }
                }
            }
            return intersects ? rayEntryDistance : -1;
        };
        /**
         * @inheritDoc
         */
        AxisAlignedBoundingBox.prototype.containsPoint = function (position) {
            var px = position.x - this._centerX, py = position.y - this._centerY, pz = position.z - this._centerZ;
            return px <= this._halfExtentsX && px >= -this._halfExtentsX && py <= this._halfExtentsY && py >= -this._halfExtentsY && pz <= this._halfExtentsZ && pz >= -this._halfExtentsZ;
        };
        /**
         * 对包围盒进行变换
         * @param bounds		包围盒
         * @param matrix		变换矩阵
         * @see http://www.cppblog.com/lovedday/archive/2008/02/23/43122.html
         */
        AxisAlignedBoundingBox.prototype.transformFrom = function (bounds, matrix) {
            var aabb = feng3d.as(bounds, AxisAlignedBoundingBox);
            var cx = aabb._centerX;
            var cy = aabb._centerY;
            var cz = aabb._centerZ;
            var raw = feng3d.Matrix3DUtils.RAW_DATA_CONTAINER;
            matrix.copyRawDataTo(raw);
            var m11 = raw[0], m12 = raw[4], m13 = raw[8], m14 = raw[12];
            var m21 = raw[1], m22 = raw[5], m23 = raw[9], m24 = raw[13];
            var m31 = raw[2], m32 = raw[6], m33 = raw[10], m34 = raw[14];
            this._centerX = cx * m11 + cy * m12 + cz * m13 + m14;
            this._centerY = cx * m21 + cy * m22 + cz * m23 + m24;
            this._centerZ = cx * m31 + cy * m32 + cz * m33 + m34;
            if (m11 < 0)
                m11 = -m11;
            if (m12 < 0)
                m12 = -m12;
            if (m13 < 0)
                m13 = -m13;
            if (m21 < 0)
                m21 = -m21;
            if (m22 < 0)
                m22 = -m22;
            if (m23 < 0)
                m23 = -m23;
            if (m31 < 0)
                m31 = -m31;
            if (m32 < 0)
                m32 = -m32;
            if (m33 < 0)
                m33 = -m33;
            var hx = aabb._halfExtentsX;
            var hy = aabb._halfExtentsY;
            var hz = aabb._halfExtentsZ;
            this._halfExtentsX = hx * m11 + hy * m12 + hz * m13;
            this._halfExtentsY = hx * m21 + hy * m22 + hz * m23;
            this._halfExtentsZ = hx * m31 + hy * m32 + hz * m33;
            this._min.x = this._centerX - this._halfExtentsX;
            this._min.y = this._centerY - this._halfExtentsY;
            this._min.z = this._centerZ - this._halfExtentsZ;
            this._max.x = this._centerX + this._halfExtentsX;
            this._max.y = this._centerY + this._halfExtentsY;
            this._max.z = this._centerZ + this._halfExtentsZ;
            this._aabbPointsDirty = true;
        };
        return AxisAlignedBoundingBox;
    }(feng3d.BoundingVolumeBase));
    feng3d.AxisAlignedBoundingBox = AxisAlignedBoundingBox;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 无空间包围盒，用于表示一直处于视锥体内或之外
     * <p>用于某些一直处于视锥体的实体，例如方向光源、天空盒等</p>
     * @author feng 2015-3-21
     */
    var NullBounds = (function (_super) {
        __extends(NullBounds, _super);
        /**
         * 构建空无空间包围盒
         * @param alwaysIn				是否总在视锥体内
         * @param renderable			渲染实体
         */
        function NullBounds(alwaysIn, renderable) {
            if (alwaysIn === void 0) { alwaysIn = true; }
            if (renderable === void 0) { renderable = null; }
            _super.call(this);
            this._alwaysIn = alwaysIn;
            this._renderable = renderable;
            this._max.x = this._max.y = this._max.z = Number.POSITIVE_INFINITY;
            this._min.x = this._min.y = this._min.z = this._alwaysIn ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;
        }
        /**
         * 更新边界渲染实体
         */
        NullBounds.prototype.updateBoundingRenderable = function () {
        };
        /**
         * @inheritDoc
         */
        NullBounds.prototype.createBoundingRenderable = function () {
            return this._renderable || new feng3d.WireframeSphere(100, 16, 12, 0xffffff, 0.5);
        };
        /**
         * @inheritDoc
         */
        NullBounds.prototype.isInFrustum = function (planes, numPlanes) {
            planes = planes;
            numPlanes = numPlanes;
            return this._alwaysIn;
        };
        /**
         * @inheritDoc
         */
        NullBounds.prototype.fromGeometry = function (geometry) {
        };
        /**
         * @inheritDoc
         */
        NullBounds.prototype.fromExtremes = function (minX, minY, minZ, maxX, maxY, maxZ) {
        };
        /**
         * @inheritDoc
         */
        NullBounds.prototype.transformFrom = function (bounds, matrix) {
            matrix = matrix;
            this._alwaysIn = feng3d.as(bounds, NullBounds)._alwaysIn;
        };
        return NullBounds;
    }(feng3d.BoundingVolumeBase));
    feng3d.NullBounds = NullBounds;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 坐标系统类型
     * @author feng 2014-10-14
     */
    var CoordinateSystem = (function () {
        function CoordinateSystem() {
        }
        /**
         * 默认坐标系统，左手坐标系统
         */
        CoordinateSystem.LEFT_HANDED = 0;
        /**
         * 右手坐标系统
         */
        CoordinateSystem.RIGHT_HANDED = 1;
        return CoordinateSystem;
    }());
    feng3d.CoordinateSystem = CoordinateSystem;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 3D缓冲编号配置
     * @author feng 2015-7-21
     */
    var Context3DBufferIDConfig = (function () {
        function Context3DBufferIDConfig() {
        }
        /**
         * 缓冲编号配置
         */
        Context3DBufferIDConfig.bufferIdConfigs = [
            //----------------------------------------------------------
            ["normal_va_3", "法线数据"],
            ["tangent_va_3", "切线数据"],
            ["camerapos_vc_vector", " 摄像机位置静态数据 "],
            ["sceneTransform_vc_matrix", " 场景变换矩阵(模型空间转场景空间) "],
            ["normalSceneTransform_vc_matrix", " 法线场景变换矩阵(模型空间转场景空间) "],
            ["wordProjection_vc_matrix", " 世界投影矩阵(世界坐标转context3D的2D坐标) "],
            ["normal_ft_4", " 法线临时片段寄存器 "],
            ["globalPosition_vt_4", " 顶点世界坐标 "],
            ["cameraPosition_vc_vector", " 摄像机世界坐标 "],
            ["normal_v", " 法线变量寄存器 "],
            ["tangent_v", " 切线变量寄存器 "],
            ["bitangent_v", " 双切线变量寄存器 "],
            ["viewDir_v", " 视线变量寄存器 "],
            ["globalPos_v", " 世界坐标变量 "],
            ["viewDir_ft_4", " 视线方向片段临时数据 "],
            ["tangent_ft_4", " 切线片段临时寄存器 "],
            ["biTangent_ft_4", " 双切线片段临时寄存器 "],
            ["normalTexture_fs", " 法线纹理寄存器 "],
            ["normalTexData_ft_4", " 法线纹理数据临时寄存器 "],
            ["specularTexData_ft_4", " 光泽纹理数据片段临时寄存器 "],
            ["finalColor_ft_4", " 最终颜色寄存器（输出到oc寄存器的颜色） "],
            //---------------------------- 常用寄存器数据类型 ------------------------------
            ["index", "索引数据"],
            ["position_va_3", "顶点坐标数据"],
            ["color_va_3", "顶点颜色数据"],
            ["color_v", "颜色变量寄存器"],
            ["uv_va_2", "uv数据"],
            ["projection_vc_matrix", "顶点程序投影矩阵静态数据"],
            ["uv_v", "uv变量数据"],
            ["texture_fs", "片段程序的纹理"],
            ["skyboxTexture_fs", "天空盒立方体纹理"],
            ["color_fc_vector", "颜色静态数据"],
            ["program", "渲染程序"],
            ["culling", "三角形剔除模式"],
            ["blendFactors", "颜色混合"],
            ["depthTest", "深度测试模式"],
            ["commonsData_fc_vector", "公用数据片段常量数据"],
            ["_op", "顶点输出寄存器"],
            ["_oc", "片段输出寄存器"],
            //---------------------------- 常用寄存器数据类型 ------------------------------
            ["animated_va_3", "骨骼动画计算完成后的顶点坐标数据"],
            ["position0_va_3", "顶点动画第0个坐标数据"],
            ["position1_va_3", "顶点动画第1个坐标数据"],
            ["animatedPosition_vt_4", "动画后的顶点坐标数据"],
            ["jointindex_va_x", "关节索引数据"],
            ["jointweights_va_x", "关节权重数据"],
            ["weights_vc_vector", "顶点程序权重向量静态数据"],
            ["globalmatrices_vc_vector", "骨骼全局变换矩阵静态数据"],
            //---------------------------- 灯光相关寄存器数据类型 ------------------------------
            ["ambientColor_fc_vector", "环境颜色数据"],
            ["ambientTexture_fs", "环境纹理数据"],
            ["diffuseInput_fc_vector", "漫反射输入静态数据"],
            ["alphaThreshold_fc_vector", "漫反射透明度阀值数据"],
            ["dirLightSceneDir_fc_vector", "方向光源场景方向"],
            ["dirLightDiffuse_fc_vector", "方向光源漫反射光颜色"],
            ["dirLightSpecular_fc_vector", "方向光源镜面反射颜色"],
            ["pointLightScenePos_fc_vector", "点光源场景位置"],
            ["pointLightDiffuse_fc_vector", "点光源漫反射光颜色"],
            ["pointLightSpecular_fc_vector", "点光源镜面反射颜色"],
            ["specularData_fc_vector", "材质镜面反射光数据"],
            ["specularColor_ft_4", "镜面反射光临时片段寄存器"],
            ["mDiff_ft", "材质的漫反射颜色"],
            ["ambient_ft", "环境光因子临时变量"],
            ["totalDiffuseLightColor_ft_4", "总漫反射颜色寄存器"],
            ["totalSpecularLightColor_ft_4", "总镜面反射颜色寄存器"],
            ["specularTexture_fs", "光泽纹理寄存器"],
            //---------------------------- 阴影相关寄存器数据类型 ------------------------------
            ["depthMap_oc", "深度映射纹理(该纹理由片段着色器输出)"],
            ["depthMap_fs", "深度映射纹理"],
            ["depthMap_vc_matrix", "深度映射矩阵"],
            ["depthCommonData0_fc_vector", "深度顶点常数0 (1.0, 255.0, 65025.0, 16581375.0)"],
            ["depthCommonData1_fc_vector", "深度顶点常数1 (1.0/255.0, 1.0/255.0, 1.0/255.0, 0.0)"],
            ["positionProjected_v", "投影后的顶点坐标 变量数据"],
            ["depthMapCoord_v", "深度映射uv坐标 变量数据"],
            ["shadowCommondata0_vc_vector", "阴影函数顶点常数0 (0.5,-0.5,0,1) 用于深度值转换为uv值"],
            ["shadowCommondata0_fc_vector", "阴影函数片段常数0 (1.0,1.0/255,1.0/255/255,1.0/255/255/255) 用于颜色值转换为深度值"],
            ["shadowCommondata1_fc_vector", "阴影函数片段常数1"],
            ["shadowCommondata2_fc_vector", "阴影函数片段常数2 保存有深度图尺寸"],
            ["secondary_fc_vector", "用于计算阴影相对于观察者距离不同而作衰减"],
            ["shadowValue_ft_4", "阴影值临时变量寄存器"],
            ["shadowColorCommonsData_fc_vector", "平面阴影颜色片段常数"],
            //---------------------------- 天空盒相关寄存器数据类型 ------------------------------
            ["scaleSkybox_vc_vector", "天空盒缩放静态数据"],
            //---------------------------- 地形相关寄存器数据类型 ------------------------------
            ["blendingtexture_fs", "混合纹理"],
            ["terrainTextures_fs_array", "地形纹理数组"],
            ["tile_fc_vector", "地形常量"],
            //---------------------------- 粒子相关寄存器数据类型 ------------------------------
            ["particleCommon_vc_vector", "粒子常数数据[0,1,2,0]"],
            ["particleBillboard_vc_matrix", "广告牌旋转矩阵"],
            ["particleScale_vc_vector", "粒子缩放常数数据"],
            ["particleTime_va_4", "粒子时间数据"],
            ["particleTime_vc_vector", "粒子时间常量数据"],
            ["particleVelocity_va_3", "粒子速度数据"],
            ["particleVelocity_vc_vector", "粒子速度常数数据"],
            ["particleStartColorMultiplier_vc_vector", "粒子颜色乘数因子起始值，用于计算粒子颜色乘数因子"],
            ["particleDeltaColorMultiplier_vc_vector", "粒子颜色乘数因子增量值，用于计算粒子颜色乘数因子"],
            ["particleStartColorOffset_vc_vector", "粒子颜色偏移起始值，用于计算粒子颜色偏移值"],
            ["particleDeltaColorOffset_vc_vector", "粒子颜色偏移增量值，用于计算粒子颜色偏移值"],
            ["particleColorMultiplier_v", "粒子颜色乘数因子，用于乘以纹理上的颜色值"],
            ["particleColorOffset_v", "粒子颜色乘数因子，用于乘以纹理上的颜色值"],
            ["particlePositionTemp_vt_4", "粒子顶点坐标数据"],
            ["particleColorOffset_vt_4", "粒子颜色偏移值，在片段渲染的最终颜色值上偏移"],
            ["particleColorMultiplier_vt_4", "粒子颜色乘数因子，用于乘以纹理上的颜色值"],
            ["inCycleTime_vt_4", "粒子周期内时间临时寄存器"],
            //---------------------------- 线段相关寄存器数据类型 ------------------------------
            ["segmentStart_va_3", "线段起点坐标数据"],
            ["segmentEnd_va_3", "线段终点坐标数据"],
            ["segmentThickness_va_1", "线段厚度数据"],
            ["segmentColor_va_4", "线段颜色数据"],
            ["segmentC2pMatrix_vc_matrix", "摄像机坐标系到投影坐标系变换矩阵静态数据"],
            ["segmentM2cMatrix_vc_matrix", "模型坐标系到摄像机坐标系变换矩阵静态数据"],
            ["segmentOne_vc_vector", "常数1"],
            ["segmentFront_vc_vector", "常数前向量"],
            ["segmentConstants_vc_vector", "常量数据"],
            //---------------------------- 烟雾相关寄存器数据类型 ------------------------------
            ["fogColor_fc_vector", "雾颜色常量数据"],
            ["fogCommonData_fc_vector", "雾通用常量数据"],
            //---------------------------- uv动画相关寄存器数据类型 ------------------------------
            ["uvAnimatorTranslate_vc_vector", "uv偏移值（uv动画）"],
            ["uvAnimatorMatrix2d_vc_vector", "uv变换矩阵（uv动画）"],
            ["spriteSheetVectorFrame_vc_vector", "常量数据（spriteSheet动画）"],
            //---------------------------- EnvMap相关寄存器数据类型 ------------------------------
            ["envMapcubeTexture_fs", "立方体纹理（EnvMap）"],
            ["envMapMaskTexture_fs", "遮罩纹理（EnvMap）"],
            ["envMapData_fc_vector", "片段数据（EnvMap）"],
            //----------------------------  ------------------------------
            ["fresnelSpecularData_fc_vector", "片段数据（FresnelSpecular）"],
            //----------------------------  ------------------------------
            ["SSD$ToTex_vc_vector", "SubsurfaceScatteringDiffuseMethod"],
            ["SSD$f$ColorData_vc_vector", "SubsurfaceScatteringDiffuseMethod"],
            ["SSD$fragmentData0_vc_vector", "SubsurfaceScatteringDiffuseMethod"],
            ["SSD$fragmentData1_vc_vector", "SubsurfaceScatteringDiffuseMethod"],
            ["SSD$depthMap_fs", "SubsurfaceScatteringDiffuseMethod"],
            ["SSD$LightProjection_vc_matrix", "SubsurfaceScatteringDiffuseMethod"],
            //----------------------------  ------------------------------
            ["SODP$polyOffset_vc_vector", "SingleObjectDepthPass"],
            ["SODP$objectProjection_vc_matrix", "SingleObjectDepthPass"],
            ["SODP$depthCommonsData0_fc_vector", "SingleObjectDepthPass"],
            ["SODP$depthCommonsData1_fc_vector", "SingleObjectDepthPass"],
        ];
        return Context3DBufferIDConfig;
    }());
    feng3d.Context3DBufferIDConfig = Context3DBufferIDConfig;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 3D视图
     * @author feng 2014-3-17
     */
    var View3D = (function (_super) {
        __extends(View3D, _super);
        /**
         * 创建一个3D视图
         * @param scene 				场景
         * @param camera 				摄像机
         * @param renderer				渲染器
         * @param forceSoftware			是否强行使用软件渲染
         * @param profile				指定 Flash Player 支持低级别 GPU 的范围
         */
        function View3D(scene, camera, renderer, forceSoftware, profile) {
            if (scene === void 0) { scene = null; }
            if (camera === void 0) { camera = null; }
            if (renderer === void 0) { renderer = null; }
            if (forceSoftware === void 0) { forceSoftware = false; }
            if (profile === void 0) { profile = feng3d.Context3DProfile.STANDARD; }
            _super.call(this);
            this._width = 0;
            this._height = 0;
            this._localPos = new feng3d.Point();
            this._globalPos = new feng3d.Point();
            this._backBufferInvalid = true;
            this._backgroundColor = 0x000000;
            this._backgroundAlpha = 1;
            this._scissorRectDirty = true;
            this._viewportDirty = true;
            this._shareContext = false;
            this._scene = scene || new feng3d.Scene3D();
            this._camera = camera || new feng3d.Camera3D();
            this._renderer = renderer || new feng3d.DefaultRenderer();
            this._forceSoftware = forceSoftware;
            this._profile = profile;
            this._entityCollector = this._renderer.createEntityCollector();
            this._entityCollector.camera = this._camera;
            this.initHitField();
            this._mouse3DManager = new feng3d.Mouse3DManager();
            this._mouse3DManager.enableMouseListeners(this);
            this.addEventListener(feng3d.Event.ADDED_TO_STAGE, this.onAddedToStage, 0, true);
            this.addEventListener(feng3d.Event.ADDED, this.onAdded, 0, true);
            this.addEventListener(feng3d.Event.REMOVED_FROM_STAGE, this.onRemoveFromeStage, 0, true);
            this._camera.partition = this._scene.partition;
        }
        Object.defineProperty(View3D.prototype, "x", {
            set: function (value) {
                if (this.x == value)
                    return;
                this._localPos.x = this.x = value;
                this._globalPos.x = this.parent ? this.parent.localToGlobal(this._localPos).x : value;
                this._globalPosDirty = true;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(View3D.prototype, "y", {
            set: function (value) {
                if (this.y == value)
                    return;
                this._localPos.y = value;
                this._globalPos.y = this.parent ? this.parent.localToGlobal(this._localPos).y : value;
                this._globalPosDirty = true;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(View3D.prototype, "visible", {
            set: function (value) {
                var _visible = value;
                if (this._stage3DProxy && !this._shareContext)
                    this._stage3DProxy.visible = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(View3D.prototype, "antiAlias", {
            /**
             * The amount of anti-aliasing to be used.
             */
            get: function () {
                return this._antiAlias;
            },
            set: function (value) {
                this._antiAlias = value;
                this._backBufferInvalid = true;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(View3D.prototype, "camera", {
            /**
             * 摄像机
             */
            get: function () {
                return this._camera;
            },
            set: function (value) {
                this._camera.removeEventListener(feng3d.CameraEvent.LENS_CHANGED, this.onLensChanged);
                this._camera = value;
                this._entityCollector.camera = this._camera;
                if (this._scene)
                    this._camera.partition = this._scene.partition;
                this._camera.addEventListener(feng3d.CameraEvent.LENS_CHANGED, this.onLensChanged);
                this._scissorRectDirty = true;
                this._viewportDirty = true;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 处理镜头改变事件
         */
        View3D.prototype.onLensChanged = function (event) {
            this._scissorRectDirty = true;
            this._viewportDirty = true;
        };
        /**
         * 处理添加到舞台事件
         */
        View3D.prototype.onAddedToStage = function (event) {
            this._addedToStage = true;
            if (!this._stage3DProxy) {
                this._stage3DProxy = feng3d.Stage3DManager.getInstance(this.stage).getFreeStage3DProxy(this._forceSoftware, this._profile);
                //				this._stage3DProxy.addEventListener(Stage3DEvent.VIEWPORT_UPDATED, onViewportUpdated);
                this._stage3DProxy.addEventListener(feng3d.Stage3DEvent.CONTEXT3D_RECREATED, this.onContext3DRecreated);
            }
            this._stage3DProxy.visible = true;
            if (this._width == 0)
                this.width = this.stage.stageWidth;
            if (this._height == 0)
                this.height = this.stage.stageHeight;
        };
        /**
         * 添加事件
         * @param event
         */
        View3D.prototype.onAdded = function (event) {
            this._parentIsStage = (this.parent == this.stage);
            this._globalPos = this.parent.localToGlobal(this._localPos);
            this._globalPosDirty = true;
        };
        /**
         * 处理3D环境被重建事件
         */
        View3D.prototype.onContext3DRecreated = function (event) {
            //			_depthTextureInvalid = true;
        };
        /**
         * 处理从舞台移除事件
         */
        View3D.prototype.onRemoveFromeStage = function (event) {
            this._stage3DProxy.visible = false;
        };
        /**
         * 初始化点击区域
         */
        View3D.prototype.initHitField = function () {
            this._hitField = new feng3d.Sprite();
            this._hitField.alpha = 0;
            this._hitField.doubleClickEnabled = true;
            this._hitField.graphics.beginFill(0x000000);
            this._hitField.graphics.drawRect(0, 0, 100, 100);
            this.addChild(this._hitField);
        };
        /**
         * 添加源码地址
         * @param url
         */
        View3D.prototype.addSourceURL = function (url) {
        };
        /**
         * 渲染3D视图
         */
        View3D.prototype.render = function () {
            //当3D环境被系统释放，不能进行渲染
            if (!this.stage3DProxy.recoverFromDisposal()) {
                this._backBufferInvalid = true;
                return;
            }
            //重置渲染设置
            if (this._backBufferInvalid)
                this.updateBackBuffer();
            if (!this._parentIsStage) {
                var globalPos = this.parent.localToGlobal(this._localPos);
                if (this._globalPos.x != globalPos.x || this._globalPos.y != globalPos.y) {
                    this._globalPos = globalPos;
                    this._globalPosDirty = true;
                }
            }
            if (this._globalPosDirty)
                this.updateGlobalPos();
            this._entityCollector.clear();
            //收集渲染实体
            this._scene.traversePartitions(this._entityCollector);
            this._renderer.shareContext = this._shareContext;
            //渲染收集的实体对象
            this._renderer.render(this.stage3DProxy, this._entityCollector);
            //收集场景显示对象
            this._scene.collectMouseCollisionEntitys();
            if (!this._shareContext) {
                this.stage3DProxy.present();
                //获取鼠标射线
                var mouseRay3D = this.getMouseRay3D();
                //更新鼠标碰撞
                this._mouse3DManager.fireMouseEvents(mouseRay3D, this._scene.mouseCollisionEntitys);
            }
            // register that a view has been rendered
            this.stage3DProxy.bufferClear = false;
        };
        Object.defineProperty(View3D.prototype, "scene", {
            /** 3d场景 */
            get: function () {
                return this._scene;
            },
            /**
             * @private
             */
            set: function (value) {
                this._scene = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(View3D.prototype, "stage3DProxy", {
            /**
             * 3D舞台代理
             */
            get: function () {
                return this._stage3DProxy;
            },
            set: function (value) {
                this._stage3DProxy = value;
                this._stage3DProxy = this.stage3DProxy;
                this._globalPosDirty = true;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(View3D.prototype, "width", {
            /**
             * 宽度
             */
            get: function () {
                return this._width;
            },
            set: function (value) {
                //限制软件渲染时最大宽度
                if (this._stage3DProxy && this._stage3DProxy.usesSoftwareRendering && value > 2048)
                    value = 2048;
                if (this._width == value)
                    return;
                this._hitField.width = value;
                this._width = value;
                this._aspectRatio = this._width / this._height;
                this._camera.lens.aspectRatio = this._aspectRatio;
                this._backBufferInvalid = true;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(View3D.prototype, "height", {
            /**
             * 高度
             */
            get: function () {
                return this._height;
            },
            set: function (value) {
                //限制软件渲染时最大高度
                if (this._stage3DProxy && this._stage3DProxy.usesSoftwareRendering && value > 2048)
                    value = 2048;
                if (this._height == value)
                    return;
                this._hitField.height = value;
                this._height = value;
                this._aspectRatio = this._width / this._height;
                this._camera.lens.aspectRatio = this._aspectRatio;
                this._backBufferInvalid = true;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(View3D.prototype, "renderedFacesCount", {
            /**
             * 渲染面数
             */
            get: function () {
                return 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(View3D.prototype, "shareContext", {
            /**
             * Defers control of Context3D clear() and present() calls to Stage3DProxy, enabling multiple Stage3D frameworks
             * to share the same Context3D object.
             */
            get: function () {
                return this._shareContext;
            },
            set: function (value) {
                if (this._shareContext == value)
                    return;
                this._shareContext = value;
                this._globalPosDirty = true;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 更新背景缓冲大小
         */
        View3D.prototype.updateBackBuffer = function () {
            if (this._stage3DProxy.context3D && !this._shareContext) {
                if (this._width && this._height) {
                    if (this._stage3DProxy.usesSoftwareRendering) {
                        if (this._width > 2048)
                            this._width = 2048;
                        if (this._height > 2048)
                            this._height = 2048;
                    }
                    this._stage3DProxy.configureBackBuffer(this._width, this._height, this._antiAlias);
                    this._backBufferInvalid = false;
                }
                else {
                    this.width = this.stage.stageWidth;
                    this.height = this.stage.stageHeight;
                }
            }
        };
        /**
         * 更新全局坐标
         */
        View3D.prototype.updateGlobalPos = function () {
            this._globalPosDirty = false;
            if (!this._stage3DProxy)
                return;
            this._stage3DProxy.x = this._globalPos.x;
            this._stage3DProxy.y = this._globalPos.y;
        };
        Object.defineProperty(View3D.prototype, "backgroundColor", {
            /**
             * 背景颜色
             */
            set: function (value) {
                this._backgroundColor = value;
                this._renderer.backgroundColor = this._backgroundColor;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 投影坐标（世界坐标转换为3D视图坐标）
         * @param point3d 世界坐标
         * @return 屏幕的绝对坐标
         */
        View3D.prototype.project = function (point3d) {
            var v = this._camera.project(point3d);
            v.x = (v.x + 1.0) * this._width / 2.0;
            v.y = (v.y + 1.0) * this._height / 2.0;
            return v;
        };
        /**
         * 屏幕坐标投影到场景坐标
         * @param nX 屏幕坐标X ([0-width])
         * @param nY 屏幕坐标Y ([0-height])
         * @param sZ 到屏幕的距离
         * @param v 场景坐标（输出）
         * @return 场景坐标
         */
        View3D.prototype.unproject = function (sX, sY, sZ, v) {
            if (v === void 0) { v = null; }
            var gpuPos = this.screenToGpuPosition(new feng3d.Point(sX, sY));
            return this._camera.unproject(gpuPos.x, gpuPos.y, sZ, v);
        };
        /**
         * 屏幕坐标转GPU坐标
         * @param screenPos 屏幕坐标 (x:[0-width],y:[0-height])
         * @return GPU坐标 (x:[-1,1],y:[-1-1])
         */
        View3D.prototype.screenToGpuPosition = function (screenPos) {
            var gpuPos = new feng3d.Point();
            gpuPos.x = (screenPos.x * 2 - this._width) / this._stage3DProxy.width;
            gpuPos.y = (screenPos.y * 2 - this._height) / this._stage3DProxy.height;
            return gpuPos;
        };
        /**
         * 获取鼠标射线（与鼠标重叠的摄像机射线）
         */
        View3D.prototype.getMouseRay3D = function () {
            return this.getRay3D(this.mouseX, this.mouseY);
        };
        /**
         * 获取与坐标重叠的射线
         * @param x view3D上的X坐标
         * @param y view3D上的X坐标
         * @return
         */
        View3D.prototype.getRay3D = function (x, y) {
            //摄像机坐标
            var rayPosition = this.unproject(x, y, 0, View3D.tempRayPosition);
            //摄像机前方1处坐标
            var rayDirection = this.unproject(x, y, 1, View3D.tempRayDirection);
            //射线方向
            rayDirection.x = rayDirection.x - rayPosition.x;
            rayDirection.y = rayDirection.y - rayPosition.y;
            rayDirection.z = rayDirection.z - rayPosition.z;
            rayDirection.normalize();
            //定义射线
            var ray3D = new feng3d.Ray3D(rayPosition, rayDirection);
            return ray3D;
        };
        Object.defineProperty(View3D.prototype, "renderer", {
            /**
             * 渲染器
             */
            get: function () {
                return this._renderer;
            },
            set: function (value) {
                this._renderer.dispose();
                this._renderer = value;
                this._entityCollector = this._renderer.createEntityCollector();
                this._entityCollector.camera = this._camera;
                this._renderer.backgroundColor = this._backgroundColor;
                this._renderer.backgroundAlpha = this._backgroundAlpha;
                this._renderer.viewWidth = this._width;
                this._renderer.viewHeight = this._height;
                this._backBufferInvalid = true;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 射线坐标临时变量
         */
        View3D.tempRayPosition = new feng3d.Vector3D();
        /**
         * 射线方向临时变量
         */
        View3D.tempRayDirection = new feng3d.Vector3D();
        return View3D;
    }(feng3d.Sprite));
    feng3d.View3D = View3D;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 控制器
     * @author feng 2014-10-10
     */
    var ControllerBase = (function () {
        /**
         * 创建控制器
         * @param targetObject 被控制对象
         */
        function ControllerBase(targetObject) {
            if (targetObject === void 0) { targetObject = null; }
            this._autoUpdate = true;
            this.targetObject = targetObject;
        }
        Object.defineProperty(ControllerBase.prototype, "targetObject", {
            /**
             * 被控制对象
             */
            get: function () {
                return this._targetObject;
            },
            set: function (val) {
                if (this._targetObject == val)
                    return;
                if (this._targetObject && this._autoUpdate)
                    this._targetObject._controller = null;
                this._targetObject = val;
                if (this._targetObject && this._autoUpdate)
                    this._targetObject._controller = this;
                this.notifyUpdate();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 通知被控制对象更新
         */
        ControllerBase.prototype.notifyUpdate = function () {
            this.update();
            //
            if (this._targetObject && this._targetObject.implicitPartition && this._autoUpdate)
                this._targetObject.implicitPartition.markForUpdate(this._targetObject);
        };
        return ControllerBase;
    }());
    feng3d.ControllerBase = ControllerBase;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 注视点控制器
     * @author feng 2014-10-10
     */
    var LookAtController = (function (_super) {
        __extends(LookAtController, _super);
        /**
         * 创建注视点控制器
         * @param targetObject 控制对象
         * @param lookAtObject 被注视对象
         */
        function LookAtController(targetObject, lookAtObject) {
            if (targetObject === void 0) { targetObject = null; }
            if (lookAtObject === void 0) { lookAtObject = null; }
            _super.call(this, targetObject);
            this._upAxis = feng3d.Vector3D.Y_AXIS;
            this._pos = new feng3d.Vector3D();
            if (lookAtObject)
                this.lookAtObject = lookAtObject;
            else
                this.lookAtPosition = new feng3d.Vector3D();
        }
        Object.defineProperty(LookAtController.prototype, "upAxis", {
            /**
             * 目标对象的上朝向
             */
            get: function () {
                return this._upAxis;
            },
            set: function (upAxis) {
                this._upAxis = upAxis;
                this.notifyUpdate();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LookAtController.prototype, "lookAtPosition", {
            /**
             * 被注视目标所在位置
             */
            get: function () {
                return this._lookAtPosition;
            },
            set: function (val) {
                if (this._lookAtObject) {
                    this._lookAtObject.removeEventListener(feng3d.Transform3DEvent.SCENETRANSFORM_CHANGED, this.onLookAtObjectChanged);
                    this._lookAtObject = null;
                }
                this._lookAtPosition = val;
                this.notifyUpdate();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LookAtController.prototype, "lookAtObject", {
            /**
             * 被注视目标
             */
            get: function () {
                return this._lookAtObject;
            },
            set: function (val) {
                if (this._lookAtPosition)
                    this._lookAtPosition = null;
                if (this._lookAtObject == val)
                    return;
                if (this._lookAtObject)
                    this._lookAtObject.removeEventListener(feng3d.Transform3DEvent.SCENETRANSFORM_CHANGED, this.onLookAtObjectChanged);
                this._lookAtObject = val;
                if (this._lookAtObject)
                    this._lookAtObject.addEventListener(feng3d.Transform3DEvent.SCENETRANSFORM_CHANGED, this.onLookAtObjectChanged);
                this.notifyUpdate();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 处理注视目标变化事件
         */
        LookAtController.prototype.onLookAtObjectChanged = function (event) {
            this.notifyUpdate();
        };
        /**
         * @inheritDoc
         */
        LookAtController.prototype.update = function () {
            if (this._targetObject) {
                if (this._lookAtPosition) {
                    this._targetObject.transform3D.lookAt(this._lookAtPosition, this._upAxis);
                }
                else if (this._lookAtObject) {
                    if (this._targetObject.parent && this._lookAtObject.parent) {
                        if (this._targetObject.parent != this._lookAtObject.parent) {
                            this._pos.x = this._lookAtObject.scenePosition.x;
                            this._pos.y = this._lookAtObject.scenePosition.y;
                            this._pos.z = this._lookAtObject.scenePosition.z;
                            //
                            feng3d.Matrix3DUtils.transformVector(this._targetObject.parent.inverseSceneTransform, this._pos, this._pos);
                        }
                        else {
                            feng3d.Matrix3DUtils.getTranslation(this._lookAtObject.transform3D.transform, this._pos);
                        }
                    }
                    else if (this._lookAtObject.scene) {
                        this._pos.x = this._lookAtObject.scenePosition.x;
                        this._pos.y = this._lookAtObject.scenePosition.y;
                        this._pos.z = this._lookAtObject.scenePosition.z;
                    }
                    else {
                        feng3d.Matrix3DUtils.getTranslation(this._lookAtObject.transform3D.transform, this._pos);
                    }
                    this._targetObject.transform3D.lookAt(this._pos, this._upAxis);
                }
            }
        };
        return LookAtController;
    }(feng3d.ControllerBase));
    feng3d.LookAtController = LookAtController;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 盘旋控制器
     * @author feng 2014-10-10
     */
    var HoverController = (function (_super) {
        __extends(HoverController, _super);
        /**
         * 创建盘旋控制器
         * @param targetObject 控制对象
         * @param lookAtObject 被注视对象
         * @param panAngle 摄像机以Y轴旋转的角度
         * @param tiltAngle 摄像机以X轴旋转的角度
         * @param distance 与注视对象的距离
         * @param minTiltAngle 以X轴旋转的最小角度。
         * @param maxTiltAngle 以X轴旋转的最大角度。
         * @param minPanAngle 以Y轴旋转的最小角度。
         * @param maxPanAngle 以Y轴旋转的最大角度。
         * @param yFactor
         * @param wrapPanAngle 是否把角度约束在0到360度
         */
        function HoverController(targetObject, lookAtObject, panAngle, tiltAngle, distance, minTiltAngle, maxTiltAngle, minPanAngle, maxPanAngle, yFactor, wrapPanAngle) {
            if (targetObject === void 0) { targetObject = null; }
            if (lookAtObject === void 0) { lookAtObject = null; }
            if (panAngle === void 0) { panAngle = 0; }
            if (tiltAngle === void 0) { tiltAngle = 90; }
            if (distance === void 0) { distance = 1000; }
            if (minTiltAngle === void 0) { minTiltAngle = -90; }
            if (maxTiltAngle === void 0) { maxTiltAngle = 90; }
            if (minPanAngle === void 0) { minPanAngle = NaN; }
            if (maxPanAngle === void 0) { maxPanAngle = NaN; }
            if (yFactor === void 0) { yFactor = 2; }
            if (wrapPanAngle === void 0) { wrapPanAngle = false; }
            _super.call(this, targetObject, lookAtObject);
            this._currentPanAngle = 0;
            this._currentTiltAngle = 90;
            this._origin = new feng3d.Vector3D(0.0, 0.0, 0.0);
            this._panAngle = 0;
            this._tiltAngle = 90;
            this._distance = 1000;
            this._minPanAngle = -Infinity;
            this._maxPanAngle = Infinity;
            this._minTiltAngle = -90;
            this._maxTiltAngle = 90;
            this._yFactor = 2;
            this._wrapPanAngle = false;
            this._pos1 = new feng3d.Vector3D();
            this.distance = distance;
            this.panAngle = panAngle;
            this.tiltAngle = tiltAngle;
            this.minPanAngle = minPanAngle || -Infinity;
            this.maxPanAngle = maxPanAngle || Infinity;
            this.minTiltAngle = minTiltAngle;
            this.maxTiltAngle = maxTiltAngle;
            this.yFactor = yFactor;
            this.wrapPanAngle = wrapPanAngle;
            //values passed in contrustor are applied immediately
            this._currentPanAngle = this._panAngle;
            this._currentTiltAngle = this._tiltAngle;
        }
        Object.defineProperty(HoverController.prototype, "distance", {
            /**
             * 与注视目标的距离
             */
            get: function () {
                return this._distance;
            },
            set: function (val) {
                if (this._distance == val)
                    return;
                this._distance = val;
                this.notifyUpdate();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HoverController.prototype, "minPanAngle", {
            /**
             * 最小摆动角度
             */
            get: function () {
                return this._minPanAngle;
            },
            set: function (val) {
                if (this._minPanAngle == val)
                    return;
                this._minPanAngle = val;
                this.panAngle = Math.max(this._minPanAngle, Math.min(this._maxPanAngle, this._panAngle));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HoverController.prototype, "maxPanAngle", {
            /**
             * 最大摆动角度
             */
            get: function () {
                return this._maxPanAngle;
            },
            set: function (val) {
                if (this._maxPanAngle == val)
                    return;
                this._maxPanAngle = val;
                this.panAngle = Math.max(this._minPanAngle, Math.min(this._maxPanAngle, this._panAngle));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HoverController.prototype, "tiltAngle", {
            /**
             * 倾斜角度
             */
            get: function () {
                return this._tiltAngle;
            },
            set: function (val) {
                val = Math.max(this._minTiltAngle, Math.min(this._maxTiltAngle, val));
                if (this._tiltAngle == val)
                    return;
                this._tiltAngle = val;
                this.notifyUpdate();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HoverController.prototype, "minTiltAngle", {
            /**
             * 最小倾斜角度
             */
            get: function () {
                return this._minTiltAngle;
            },
            set: function (val) {
                if (this._minTiltAngle == val)
                    return;
                this._minTiltAngle = val;
                this.tiltAngle = Math.max(this._minTiltAngle, Math.min(this._maxTiltAngle, this._tiltAngle));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HoverController.prototype, "maxTiltAngle", {
            /**
             * 最大倾斜角度
             */
            get: function () {
                return this._maxTiltAngle;
            },
            set: function (val) {
                if (this._maxTiltAngle == val)
                    return;
                this._maxTiltAngle = val;
                this.tiltAngle = Math.max(this._minTiltAngle, Math.min(this._maxTiltAngle, this._tiltAngle));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HoverController.prototype, "yFactor", {
            /**
             * y因子，用于体现摄像机水平与垂直旋转的差异
             * @see #distance
             */
            get: function () {
                return this._yFactor;
            },
            set: function (val) {
                if (this._yFactor == val)
                    return;
                this._yFactor = val;
                this.notifyUpdate();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HoverController.prototype, "wrapPanAngle", {
            /**
             * 是否把角度约束在0到360度
             */
            get: function () {
                return this._wrapPanAngle;
            },
            set: function (val) {
                if (this._wrapPanAngle == val)
                    return;
                this._wrapPanAngle = val;
                this.notifyUpdate();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HoverController.prototype, "panAngle", {
            /**
             * 摆动角度
             */
            get: function () {
                return this._panAngle;
            },
            set: function (val) {
                val = Math.max(this._minPanAngle, Math.min(this._maxPanAngle, val));
                if (this._panAngle == val)
                    return;
                this._panAngle = val;
                this.notifyUpdate();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 更新当前倾斜与摆动角度
         * @see    #tiltAngle
         * @see    #panAngle
         * @see    #steps
         */
        HoverController.prototype.update = function () {
            if (this._tiltAngle != this._currentTiltAngle || this._panAngle != this._currentPanAngle) {
                if (this._wrapPanAngle) {
                    if (this._panAngle < 0) {
                        this._currentPanAngle += this._panAngle % 360 + 360 - this._panAngle;
                        this._panAngle = this._panAngle % 360 + 360;
                    }
                    else {
                        this._currentPanAngle += this._panAngle % 360 - this._panAngle;
                        this._panAngle = this._panAngle % 360;
                    }
                    while (this._panAngle - this._currentPanAngle < -180)
                        this._currentPanAngle -= 360;
                    while (this._panAngle - this._currentPanAngle > 180)
                        this._currentPanAngle += 360;
                }
                this._currentPanAngle = this._panAngle;
                this._currentTiltAngle = this._tiltAngle;
                //snap coords if angle differences are close
                if ((Math.abs(this.tiltAngle - this._currentTiltAngle) < 0.01) && (Math.abs(this._panAngle - this._currentPanAngle) < 0.01)) {
                    this._currentTiltAngle = this._tiltAngle;
                    this._currentPanAngle = this._panAngle;
                }
            }
            if (!this._targetObject)
                return;
            if (this._lookAtPosition) {
                this._pos1.x = this._lookAtPosition.x;
                this._pos1.y = this._lookAtPosition.y;
                this._pos1.z = this._lookAtPosition.z;
            }
            else if (this._lookAtObject) {
                if (this._targetObject.parent && this._lookAtObject.parent) {
                    if (this._targetObject.parent != this._lookAtObject.parent) {
                        this._pos1.x = this._lookAtObject.scenePosition.x;
                        this._pos1.y = this._lookAtObject.scenePosition.y;
                        this._pos1.z = this._lookAtObject.scenePosition.z;
                        feng3d.Matrix3DUtils.transformVector(this._targetObject.parent.inverseSceneTransform, this._pos1, this._pos1);
                    }
                    else {
                        feng3d.Matrix3DUtils.getTranslation(this._lookAtObject.transform3D.transform, this._pos1);
                    }
                }
                else if (this._lookAtObject.scene) {
                    this._pos1.x = this._lookAtObject.scenePosition.x;
                    this._pos1.y = this._lookAtObject.scenePosition.y;
                    this._pos1.z = this._lookAtObject.scenePosition.z;
                }
                else {
                    feng3d.Matrix3DUtils.getTranslation(this._lookAtObject.transform3D.transform, this._pos1);
                }
            }
            else {
                this._pos1.x = this._origin.x;
                this._pos1.y = this._origin.y;
                this._pos1.z = this._origin.z;
            }
            this._targetObject.transform3D.x = this._pos1.x + this._distance * Math.sin(this._currentPanAngle * feng3d.MathConsts.DEGREES_TO_RADIANS) * Math.cos(this._currentTiltAngle * feng3d.MathConsts.DEGREES_TO_RADIANS);
            this._targetObject.transform3D.z = this._pos1.z + this._distance * Math.cos(this._currentPanAngle * feng3d.MathConsts.DEGREES_TO_RADIANS) * Math.cos(this._currentTiltAngle * feng3d.MathConsts.DEGREES_TO_RADIANS);
            this._targetObject.transform3D.y = this._pos1.y + this._distance * Math.sin(this._currentTiltAngle * feng3d.MathConsts.DEGREES_TO_RADIANS) * this._yFactor;
            _super.prototype.update.call(this);
        };
        return HoverController;
    }(feng3d.LookAtController));
    feng3d.HoverController = HoverController;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * Face value object.
     */
    var Face = (function () {
        /**
         * Creates a new <code>Face</code> value object.
         *
         * @param    vertices        [optional] 9 entries long Vector.&lt;number&gt; representing the x, y and z of v0, v1, and v2 of a face
         * @param    uvs            [optional] 6 entries long Vector.&lt;number&gt; representing the u and v of uv0, uv1, and uv2 of a face
         */
        function Face(vertices, uvs) {
            if (vertices === void 0) { vertices = null; }
            if (uvs === void 0) { uvs = null; }
            this._vertices = vertices;
            if (this._vertices == null)
                this._vertices = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0];
            this._uvs = uvs;
            if (this._uvs == null)
                this._uvs = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0];
        }
        //uvs
        /**
         * To set uv values for either uv0, uv1 or uv2.
         * @param    index        The id of the uv (0, 1 or 2)
         * @param    u            The horizontal coordinate of the texture value.
         * @param    v            The vertical coordinate of the texture value.
         */
        Face.prototype.setUVat = function (index, u, v) {
            var ind = (index * 2);
            this._uvs[ind] = u;
            this._uvs[ind + 1] = v;
        };
        Object.defineProperty(Face.prototype, "faceIndex", {
            /**
             * @return            Returns the tmp index set for this Face object
             */
            get: function () {
                return this._faceIndex;
            },
            /**
             * To store a temp index of a face during a loop
             * @param    ind        The index
             */
            set: function (ind) {
                this._faceIndex = ind;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Face.prototype, "uv0Index", {
            /**
             * @return return the index set for uv0 in this Face value object
             */
            get: function () {
                return this._uv0Index;
            },
            //uv0
            /**
             * the index set for uv0 in this Face value object
             * @param    ind        The index
             */
            set: function (ind) {
                this._uv0Index = ind;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * uv0 u and v values
         * @param    u        The u value
         * @param    v        The v value
         */
        Face.prototype.setUv0Value = function (u, v) {
            this._uvs[0] = u;
            this._uvs[1] = v;
        };
        Object.defineProperty(Face.prototype, "uv0u", {
            /**
             * @return return the u value of the uv0 of this Face value object
             */
            get: function () {
                return this._uvs[0];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Face.prototype, "uv0v", {
            /**
             * @return return the v value of the uv0 of this Face value object
             */
            get: function () {
                return this._uvs[1];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Face.prototype, "uv1Index", {
            /**
             * @return Returns the index set for uv1 in this Face value object
             */
            get: function () {
                return this._uv1Index;
            },
            //uv1
            /**
             * the index set for uv1 in this Face value object
             * @param    ind        The index
             */
            set: function (ind) {
                this._uv1Index = ind;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * uv1 u and v values
         * @param    u        The u value
         * @param    v        The v value
         */
        Face.prototype.setUv1Value = function (u, v) {
            this._uvs[2] = u;
            this._uvs[3] = v;
        };
        Object.defineProperty(Face.prototype, "uv1u", {
            /**
             * @return Returns the u value of the uv1 of this Face value object
             */
            get: function () {
                return this._uvs[2];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Face.prototype, "uv1v", {
            /**
             * @return Returns the v value of the uv1 of this Face value object
             */
            get: function () {
                return this._uvs[3];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Face.prototype, "uv2Index", {
            /**
             * @return return the index set for uv2 in this Face value object
             */
            get: function () {
                return this._uv2Index;
            },
            //uv2
            /**
             * the index set for uv2 in this Face value object
             * @param    ind        The index
             */
            set: function (ind) {
                this._uv2Index = ind;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * uv2 u and v values
         * @param    u        The u value
         * @param    v        The v value
         */
        Face.prototype.setUv2Value = function (u, v) {
            this._uvs[4] = u;
            this._uvs[5] = v;
        };
        Object.defineProperty(Face.prototype, "uv2u", {
            /**
             * @return return the u value of the uv2 of this Face value object
             */
            get: function () {
                return this._uvs[4];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Face.prototype, "uv2v", {
            /**
             * @return return the v value of the uv2 of this Face value object
             */
            get: function () {
                return this._uvs[5];
            },
            enumerable: true,
            configurable: true
        });
        //vertices
        /**
         * To set uv values for either v0, v1 or v2.
         * @param    index        The id of the uv (0, 1 or 2)
         * @param    x            The x value of the vertex.
         * @param    y            The y value of the vertex.
         * @param    z            The z value of the vertex.
         */
        Face.prototype.setVertexAt = function (index, x, y, z) {
            var ind = (index * 3);
            this._vertices[ind] = x;
            this._vertices[ind + 1] = y;
            this._vertices[ind + 2] = z;
        };
        Object.defineProperty(Face.prototype, "v0Index", {
            /**
             * @return Returns the index value of the v0 stored in the Face value object
             */
            get: function () {
                return this._v0Index;
            },
            //v0
            /**
             * set the index value for v0
             * @param    ind            The index value to store
             */
            set: function (ind) {
                this._v0Index = ind;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Face.prototype, "v0", {
            /**
             * @return Returns a number[] representing the v0 stored in the Face value object
             */
            get: function () {
                return [this._vertices[0], this._vertices[1], this._vertices[2]];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Face.prototype, "v0x", {
            /**
             * @return Returns the x value of the v0 stored in the Face value object
             */
            get: function () {
                return this._vertices[0];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Face.prototype, "v0y", {
            /**
             * @return Returns the y value of the v0 stored in the Face value object
             */
            get: function () {
                return this._vertices[1];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Face.prototype, "v0z", {
            /**
             * @return Returns the z value of the v0 stored in the Face value object
             */
            get: function () {
                return this._vertices[2];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Face.prototype, "v1Index", {
            /**
             * @return Returns the index value of the v1 stored in the Face value object
             */
            get: function () {
                return this._v1Index;
            },
            //v1
            /**
             * set the index value for v1
             * @param    ind            The index value to store
             */
            set: function (ind) {
                this._v1Index = ind;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Face.prototype, "v1", {
            /**
             * @return Returns a number[] representing the v1 stored in the Face value object
             */
            get: function () {
                return [this._vertices[3], this._vertices[4], this._vertices[5]];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Face.prototype, "v1x", {
            /**
             * @return Returns the x value of the v1 stored in the Face value object
             */
            get: function () {
                return this._vertices[3];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Face.prototype, "v1y", {
            /**
             * @return Returns the y value of the v1 stored in the Face value object
             */
            get: function () {
                return this._vertices[4];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Face.prototype, "v1z", {
            /**
             * @return Returns the z value of the v1 stored in the Face value object
             */
            get: function () {
                return this._vertices[5];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Face.prototype, "v2Index", {
            /**
             * @return return the index value of the v2 stored in the Face value object
             */
            get: function () {
                return this._v2Index;
            },
            //v2
            /**
             * set the index value for v2
             * @param    ind            The index value to store
             */
            set: function (ind) {
                this._v2Index = ind;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Face.prototype, "v2", {
            /**
             * @return Returns a number[] representing the v2 stored in the Face value object
             */
            get: function () {
                return [this._vertices[6], this._vertices[7], this._vertices[8]];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Face.prototype, "v2x", {
            /**
             * @return Returns the x value of the v2 stored in the Face value object
             */
            get: function () {
                return this._vertices[6];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Face.prototype, "v2y", {
            /**
             * @return Returns the y value of the v2 stored in the Face value object
             */
            get: function () {
                return this._vertices[7];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Face.prototype, "v2z", {
            /**
             * @return Returns the z value of the v2 stored in the Face value object
             */
            get: function () {
                return this._vertices[8];
            },
            enumerable: true,
            configurable: true
        });
        /**
         * returns a new Face value Object
         */
        Face.prototype.clone = function () {
            var nVertices = [this._vertices[0], this._vertices[1], this._vertices[2],
                this._vertices[3], this._vertices[4], this._vertices[5],
                this._vertices[6], this._vertices[7], this._vertices[8]];
            var nUvs = [this._uvs[0], this._uvs[1],
                this._uvs[2], this._uvs[3],
                this._uvs[4], this._uvs[5]];
            return new Face(nVertices, nUvs);
        };
        /**
         * Returns the first two barycentric coordinates for a point on (or outside) the triangle. The third coordinate is 1 - x - y
         * @param point The point for which to calculate the new target
         * @param target An optional Point object to store the calculation in order to prevent creation of a new object
         */
        Face.prototype.getBarycentricCoords = function (point, target) {
            if (target === void 0) { target = null; }
            var v0x = this._vertices[0];
            var v0y = this._vertices[1];
            var v0z = this._vertices[2];
            var dx0 = point.x - v0x;
            var dy0 = point.y - v0y;
            var dz0 = point.z - v0z;
            var dx1 = this._vertices[3] - v0x;
            var dy1 = this._vertices[4] - v0y;
            var dz1 = this._vertices[5] - v0z;
            var dx2 = this._vertices[6] - v0x;
            var dy2 = this._vertices[7] - v0y;
            var dz2 = this._vertices[8] - v0z;
            var dot01 = dx1 * dx0 + dy1 * dy0 + dz1 * dz0;
            var dot02 = dx2 * dx0 + dy2 * dy0 + dz2 * dz0;
            var dot11 = dx1 * dx1 + dy1 * dy1 + dz1 * dz1;
            var dot22 = dx2 * dx2 + dy2 * dy2 + dz2 * dz2;
            var dot12 = dx2 * dx1 + dy2 * dy1 + dz2 * dz1;
            var invDenom = 1 / (dot22 * dot11 - dot12 * dot12);
            if (target == null)
                target = new feng3d.Point();
            target.x = (dot22 * dot01 - dot12 * dot02) * invDenom;
            target.y = (dot11 * dot02 - dot12 * dot01) * invDenom;
            return target;
        };
        /**
         * Tests whether a given point is inside the triangle
         * @param point The point to test against
         * @param maxDistanceToPlane The minimum distance to the plane for the point to be considered on the triangle. This is usually used to allow for rounding error, but can also be used to perform a volumetric test.
         */
        Face.prototype.containsPoint = function (point, maxDistanceToPlane) {
            if (maxDistanceToPlane === void 0) { maxDistanceToPlane = .007; }
            if (!this.planeContains(point, maxDistanceToPlane))
                return false;
            this.getBarycentricCoords(point, Face._calcPoint);
            var s = Face._calcPoint.x;
            var t = Face._calcPoint.y;
            return s >= 0.0 && t >= 0.0 && (s + t) <= 1.0;
        };
        Face.prototype.planeContains = function (point, epsilon) {
            if (epsilon === void 0) { epsilon = .007; }
            var v0x = this._vertices[0];
            var v0y = this._vertices[1];
            var v0z = this._vertices[2];
            var d1x = this._vertices[3] - v0x;
            var d1y = this._vertices[4] - v0y;
            var d1z = this._vertices[5] - v0z;
            var d2x = this._vertices[6] - v0x;
            var d2y = this._vertices[7] - v0y;
            var d2z = this._vertices[8] - v0z;
            var a = d1y * d2z - d1z * d2y;
            var b = d1z * d2x - d1x * d2z;
            var c = d1x * d2y - d1y * d2x;
            var len = 1 / Math.sqrt(a * a + b * b + c * c);
            a *= len;
            b *= len;
            c *= len;
            var dist = a * (point.x - v0x) + b * (point.y - v0y) + c * (point.z - v0z);
            return dist > -epsilon && dist < epsilon;
        };
        /**
         * Returns the target coordinates for a point on a triangle
         * @param v0 The triangle's first vertex
         * @param v1 The triangle's second vertex
         * @param v2 The triangle's third vertex
         * @param uv0 The UV coord associated with the triangle's first vertex
         * @param uv1 The UV coord associated with the triangle's second vertex
         * @param uv2 The UV coord associated with the triangle's third vertex
         * @param point The point for which to calculate the new target
         * @param target An optional UV object to store the calculation in order to prevent creation of a new object
         */
        Face.prototype.getUVAtPoint = function (point, target) {
            if (target === void 0) { target = null; }
            this.getBarycentricCoords(point, Face._calcPoint);
            var s = Face._calcPoint.x;
            var t = Face._calcPoint.y;
            if (s >= 0.0 && t >= 0.0 && (s + t) <= 1.0) {
                var u0 = this._uvs[0];
                var v0 = this._uvs[1];
                if (target == null)
                    target = new feng3d.UV();
                target.u = u0 + t * (this._uvs[4] - u0) + s * (this._uvs[2] - u0);
                target.v = v0 + t * (this._uvs[5] - v0) + s * (this._uvs[3] - v0);
                return target;
            }
            else
                return null;
        };
        Face._calcPoint = new feng3d.Point();
        return Face;
    }());
    feng3d.Face = Face;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 单个粒子数据
     * @author feng 2014-12-9
     */
    var ParticleData = (function () {
        function ParticleData() {
        }
        return ParticleData;
    }());
    feng3d.ParticleData = ParticleData;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * Texture coordinates value object.
     */
    var UV = (function () {
        /**
         * Creates a new <code>UV</code> object.
         *
         * @param    u        [optional]    The horizontal coordinate of the texture value. Defaults to 0.
         * @param    v        [optional]    The vertical coordinate of the texture value. Defaults to 0.
         */
        function UV(u, v) {
            if (u === void 0) { u = 0; }
            if (v === void 0) { v = 0; }
            this._u = u;
            this._v = v;
        }
        Object.defineProperty(UV.prototype, "v", {
            /**
             * Defines the vertical coordinate of the texture value.
             */
            get: function () {
                return this._v;
            },
            set: function (value) {
                this._v = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UV.prototype, "u", {
            /**
             * Defines the horizontal coordinate of the texture value.
             */
            get: function () {
                return this._u;
            },
            set: function (value) {
                this._u = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * returns a new UV value Object
         */
        UV.prototype.clone = function () {
            return new UV(this._u, this._v);
        };
        /**
         * returns the value object as a string for trace/debug purpose
         */
        UV.prototype.toString = function () {
            return this._u + "," + this._v;
        };
        return UV;
    }());
    feng3d.UV = UV;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 顶点
     */
    var Vertex = (function () {
        /**
         *
         * @param x X轴坐标
         * @param y Y轴坐标
         * @param z Z轴坐标
         * @param index 顶点索引
         */
        function Vertex(x, y, z, index) {
            if (x === void 0) { x = 0; }
            if (y === void 0) { y = 0; }
            if (z === void 0) { z = 0; }
            if (index === void 0) { index = 0; }
            this._x = x;
            this._y = y;
            this._z = z;
            this._index = index;
        }
        Object.defineProperty(Vertex.prototype, "index", {
            get: function () {
                return this._index;
            },
            /**
             * To define/store the index of value object
             * @param    ind        The index
             */
            set: function (ind) {
                this._index = ind;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Vertex.prototype, "x", {
            get: function () {
                return this._x;
            },
            set: function (value) {
                this._x = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Vertex.prototype, "y", {
            get: function () {
                return this._y;
            },
            set: function (value) {
                this._y = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Vertex.prototype, "z", {
            get: function () {
                return this._z;
            },
            set: function (value) {
                this._z = value;
            },
            enumerable: true,
            configurable: true
        });
        Vertex.prototype.clone = function () {
            return new Vertex(this._x, this._y, this._z);
        };
        Vertex.prototype.toString = function () {
            return this._x + "," + this._y + "," + this._z;
        };
        return Vertex;
    }());
    feng3d.Vertex = Vertex;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 3D环境缓冲编号集合
     * @author feng 2015-7-21
     */
    var Context3DBufferID = (function () {
        /**
         * 创建3D环境缓冲编号集合
         */
        function Context3DBufferID() {
        }
        Object.defineProperty(Context3DBufferID, "instance", {
            get: function () {
                if (Context3DBufferID._instance == null)
                    Context3DBufferID._instance = new Context3DBufferID();
                return Context3DBufferID._instance;
            },
            enumerable: true,
            configurable: true
        });
        return Context3DBufferID;
    }());
    feng3d.Context3DBufferID = Context3DBufferID;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     *
     * @author feng 2014-8-26
     */
    var IndexBufferItem = (function () {
        function IndexBufferItem(context3D, numIndices) {
            /** 是否无效 */
            this.invalid = true;
            this.context3D = context3D;
            this.indexBuffer3D = context3D.createIndexBuffer(numIndices);
            this.invalid = true;
        }
        IndexBufferItem.prototype.uploadFromVector = function (data, startOffset, count) {
            this.indexBuffer3D.uploadFromVector(data, startOffset, count);
            this.invalid = false;
        };
        IndexBufferItem.prototype.drawTriangles = function (firstIndex, numTriangles) {
            if (firstIndex === void 0) { firstIndex = 0; }
            if (numTriangles === void 0) { numTriangles = -1; }
            this.context3D.drawTriangles(this.indexBuffer3D, firstIndex, numTriangles);
        };
        return IndexBufferItem;
    }());
    feng3d.IndexBufferItem = IndexBufferItem;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 顶点VA数据缓冲
     * @author feng 2014-8-28
     */
    var VADataBuffer = (function () {
        /**
         * 创建顶点VA数据缓冲
         */
        function VADataBuffer() {
            /** 缓存字典 可在多个寄存器共享数据缓存时使用同一个 */
            this.bufferItemDic = new feng3d.Map();
            /** 是否无效 */
            this.invalid = true;
            /** 缓存是否无效 */
            this.bufferInvalid = true;
        }
        /**
         * 获取顶点缓冲项
         * @param context3D		3d环境
         * @return 				顶点缓冲项
         */
        VADataBuffer.prototype.getBufferItem = function (context3D) {
            var vertexBufferItem;
            //处理 缓存无效标记
            if (this.bufferInvalid) {
                this.bufferInvalid = false;
                this.invalid = false;
            }
            //处理 数据无效标记
            if (this.invalid) {
                for (var key in this.bufferItemDic) {
                    if (this.bufferItemDic.hasOwnProperty(key)) {
                        vertexBufferItem = this.bufferItemDic[key];
                        vertexBufferItem.invalid = true;
                    }
                }
                this.invalid = false;
            }
            vertexBufferItem = this.bufferItemDic.get(context3D);
            if (vertexBufferItem == null) {
                vertexBufferItem = new feng3d.VertexBufferItem(context3D, this.numVertices, this.data32PerVertex);
                this.bufferItemDic.push(context3D, vertexBufferItem);
            }
            if (vertexBufferItem.invalid) {
                vertexBufferItem.uploadFromVector(this.data, 0, this.numVertices);
            }
            return vertexBufferItem;
        };
        /**
         * 更新数据
         * @param data 				顶点数据
         * @param numVertices 		要在缓存区中存储的顶点数量。单个缓存区中的最大顶点数为 65535。
         * @param data32PerVertex 	与每个顶点关联的 32 位（4 字节）数据值的数量。每个顶点的 32 位数据元素数量最多为 64 个（或 256 个字节）。请注意，顶点着色器程序在任何给定时间只能访问 8 个属性寄存器。使用 SetVertextBufferAt() 在顶点缓存区内选择属性。
         */
        VADataBuffer.prototype.update = function (data, numVertices, data32PerVertex) {
            if (!data || numVertices == 0)
                throw new Error("顶点缓存不接收空数组");
            this.invalid = true;
            if (!this.data || this.data.length != data.length) {
                this.bufferInvalid = true;
            }
            this.data = data;
            this.numVertices = numVertices;
            this.data32PerVertex = data32PerVertex;
        };
        return VADataBuffer;
    }());
    feng3d.VADataBuffer = VADataBuffer;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 顶点缓冲项
     * @author feng 2014-8-26
     */
    var VertexBufferItem = (function () {
        /**
         * 创建顶点缓冲项
         * @param context3D
         * @param numVertices			要在缓冲区中存储的顶点数量。单个缓冲区中的最大顶点数为 65535。
         * @param data32PerVertex		与每个顶点关联的 32 位（4 字节）数据值的数量。每个顶点的 32 位数据元素数量最多为 64 个（或 256 个字节）。请注意，顶点着色器程序在任何给定时间只能访问 8 个属性寄存器。使用 SetVertextBufferAt() 在顶点缓冲区内选择属性。
         */
        function VertexBufferItem(context3D, numVertices, data32PerVertex) {
            /** 是否无效 */
            this.invalid = true;
            this.context3D = context3D;
            this.vertexBuffer3D = context3D.createVertexBuffer(numVertices, data32PerVertex);
            this.invalid = true;
        }
        /**
         * 从矢量数组上载一组顶点的数据到渲染上下文。
         * @param data					位值的矢量。单个顶点由许多按顺序存储在矢量中的值组成。顶点中的值数量在创建缓冲区时使用 Context3D createVertexBuffer3D() 方法的 data32PerVertex 参数指定。矢量的长度必须为每个顶点的值数量乘以顶点数量。
         * @param startVertex			要加载的第一个顶点的索引。startVertex 的非零值可用于加载顶点数据的子区域。
         * @param numVertices			data 表示的顶点数量。
         */
        VertexBufferItem.prototype.uploadFromVector = function (data, startVertex, numVertices) {
            this.vertexBuffer3D.uploadFromVector(data, startVertex, numVertices);
            this.invalid = false;
        };
        /**
         * 指定与单个着色器程序输入相对应的顶点数据组件。
         * <p>使用 setVertexBufferAt 方法来标识 VertexBuffer3D 缓冲区中每个顶点定义的哪些数据组件属于顶点程序的哪些输入。顶点程序的开发人员会确定每个顶点需要的数据量。该数据从 1 个或多个 VertexBuffer3D 流映射到顶点着色器程序的属性寄存器中。</p>
         * <p>顶点着色器所使用数据的最小单位为 32 位数据。距顶点流的偏移量以 32 位的倍数指定。</p>
         * 举例来说，编程人员可以使用以下数据定义每个顶点：
         * <pre>
         * position:	x    float32
         * 		y    float32
         * 		z    float32
         * color:	r    unsigned byte
         *		g    unsigned byte
         *		b    unsigned byte
         *		a    unsigned byte
         * </pre>
         * 假定在 VertexBuffer3D 对象中定义了名为 buffer 的对象，则可使用以下代码将其分配给顶点着色器：
         * <pre>
         * setVertexBufferAt( 0, buffer, 0, Context3DVertexBufferFormat.FLOAT_3 );   // attribute #0 will contain the position information
         * setVertexBufferAt( 1, buffer, 3, Context3DVertexBufferFormat.BYTES_4 );    // attribute #1 will contain the color information
         * </pre>
         *
         * @param index				顶点着色器中的属性寄存器的索引（0 到 7）。
         * @param bufferOffset		单个顶点的起始数据偏移量，从此处开始读取此属性。在上例中，位置数据的偏移量为 0，因为它是第一个属性；颜色的偏移量为 3，因为颜色属性跟在 3 个 32 位位置值之后。以 32 位为单位指定偏移量。
         * @param format			来自<code>Context3DVertexBufferFormat</code>类的值，指定此属性的数据类型。
         */
        VertexBufferItem.prototype.setVertexBufferAt = function (index, bufferOffset, format) {
            this.context3D.setVertexBufferAt(index, this.vertexBuffer3D, bufferOffset, format);
        };
        return VertexBufferItem;
    }());
    feng3d.VertexBufferItem = VertexBufferItem;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * Context3D可执行的数据缓存
     * @author feng 2014-6-9
     */
    var Context3DBuffer = (function () {
        /**
         * 创建一个Context3D可执行的数据缓存
         * @param dataTypeId 		数据缓存编号
         * @param updateFunc 		更新回调函数
         */
        function Context3DBuffer(dataTypeId, updateFunc) {
            /** 数据脏了 */
            this._dataDirty = true;
            this._dataTypeId = dataTypeId;
            this._updateFunc = updateFunc;
        }
        /**
         * 使缓存无效
         */
        Context3DBuffer.prototype.invalid = function () {
            this._dataDirty = true;
        };
        /**
         * 运行更新回调函数
         */
        Context3DBuffer.prototype.doUpdateFunc = function () {
            if (this._updateFunc != null && this._dataDirty) {
                this._updateFunc(this);
                this._dataDirty = false;
            }
        };
        Object.defineProperty(Context3DBuffer.prototype, "dataTypeId", {
            /**
             * 缓存类型编号
             */
            get: function () {
                return this._dataTypeId;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 字符串描述
         */
        Context3DBuffer.prototype.toString = function () {
            return feng3d.formatString("[{0} dataType=\"{1}\"]", feng3d.getQualifiedClassName(this).split("::").pop(), this._dataTypeId);
        };
        return Context3DBuffer;
    }());
    feng3d.Context3DBuffer = Context3DBuffer;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 混合因素缓存
     * @author feng 2014-8-28
     */
    var BlendFactorsBuffer = (function (_super) {
        __extends(BlendFactorsBuffer, _super);
        /**
         * 创建混合因素缓存
         * @param dataTypeId	数据缓存编号
         * @param updateFunc	更新回调函数
         */
        function BlendFactorsBuffer(dataTypeId, updateFunc) {
            _super.call(this, dataTypeId, updateFunc);
        }
        /**
         * 更新混合因素缓存
         * @param sourceFactor 用于与源颜色相乘的系数。默认为 Context3DBlendFactor.ONE。
         * @param destinationFactor 用于与目标颜色相乘的系数。默认为 Context3DBlendFactor.ZERO。
         * @see flash.display3D.Context3D
         * @see flash.display3D.Context3D.setBlendFactors
         */
        BlendFactorsBuffer.prototype.update = function (sourceFactor, destinationFactor) {
            this.sourceFactor = sourceFactor;
            this.destinationFactor = destinationFactor;
        };
        /**
         * 执行混合因素缓存
         * @param context3D		3d环境
         */
        BlendFactorsBuffer.prototype.doBuffer = function (context3D) {
            this.doUpdateFunc();
            context3D.setBlendFactors(this.sourceFactor, this.destinationFactor);
        };
        return BlendFactorsBuffer;
    }(feng3d.Context3DBuffer));
    feng3d.BlendFactorsBuffer = BlendFactorsBuffer;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 三角形剔除模式缓存
     * @author feng 2014-8-14
     */
    var CullingBuffer = (function (_super) {
        __extends(CullingBuffer, _super);
        /**
         * 创建一个三角形剔除模式缓存
         * @param dataTypeId 		数据缓存编号
         * @param updateFunc 		更新回调函数
         */
        function CullingBuffer(dataTypeId, updateFunc) {
            _super.call(this, dataTypeId, updateFunc);
        }
        /**
         * @inheritDoc
         */
        CullingBuffer.prototype.doBuffer = function (context3D) {
            this.doUpdateFunc();
            context3D.setCulling(this.triangleFaceToCull);
        };
        /**
         * 更新
         * @param triangleFaceToCull
         */
        CullingBuffer.prototype.update = function (triangleFaceToCull) {
            this.triangleFaceToCull = triangleFaceToCull;
        };
        return CullingBuffer;
    }(feng3d.Context3DBuffer));
    feng3d.CullingBuffer = CullingBuffer;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 深度测试缓存
     * @author feng 2014-8-28
     */
    var DepthTestBuffer = (function (_super) {
        __extends(DepthTestBuffer, _super);
        /**
         * 创建一个深度测试缓存
         * @param dataTypeId 		数据缓存编号
         * @param updateFunc 		更新回调函数
         */
        function DepthTestBuffer(dataTypeId, updateFunc) {
            _super.call(this, dataTypeId, updateFunc);
        }
        /**
         * @inheritDoc
         */
        DepthTestBuffer.prototype.doBuffer = function (context3D) {
            this.doUpdateFunc();
            context3D.setDepthTest(this.depthMask, this.passCompareMode);
        };
        /**
         * 更新
         * @param depthMask
         * @param passCompareMode
         */
        DepthTestBuffer.prototype.update = function (depthMask, passCompareMode) {
            this.depthMask = depthMask;
            this.passCompareMode = passCompareMode;
        };
        return DepthTestBuffer;
    }(feng3d.Context3DBuffer));
    feng3d.DepthTestBuffer = DepthTestBuffer;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 索引缓存
     * @author feng 2014-8-21
     */
    var IndexBuffer = (function (_super) {
        __extends(IndexBuffer, _super);
        /**
         * 创建一个索引缓存
         * @param dataTypeId 		数据缓存编号
         * @param updateFunc 		更新回调函数
         */
        function IndexBuffer(dataTypeId, updateFunc) {
            _super.call(this, dataTypeId, updateFunc);
            this._bufferItemDic = new feng3d.Map();
            this.firstIndex = 0;
            this.numTriangles = -1;
            /** 是否无效 */
            this.dicInvalid = true;
            /** 缓存无效 */
            this.bufferInvalid = true;
        }
        /**
         * @inheritDoc
         */
        IndexBuffer.prototype.doBuffer = function (context3D) {
            this.doUpdateFunc();
            var indexBufferItem;
            //处理 缓存无效标记
            if (this.bufferInvalid) {
                this.bufferInvalid = false;
                this.dicInvalid = false;
            }
            //处理 数据无效标记
            if (this.dicInvalid) {
                for (var key in this._bufferItemDic) {
                    if (this._bufferItemDic.hasOwnProperty(key)) {
                        indexBufferItem = this._bufferItemDic[key];
                        indexBufferItem.invalid = true;
                    }
                }
                this.dicInvalid = false;
            }
            indexBufferItem = this._bufferItemDic.get(context3D);
            if (indexBufferItem == null) {
                indexBufferItem = new feng3d.IndexBufferItem(context3D, this.numIndices);
                this._bufferItemDic.push(context3D, indexBufferItem);
            }
            if (indexBufferItem.invalid) {
                indexBufferItem.uploadFromVector(this.data, this._startOffset, this.count);
            }
            indexBufferItem.drawTriangles(this.firstIndex, this.numTriangles);
        };
        /**
         * 销毁数据
         */
        IndexBuffer.prototype.dispose = function () {
            this.data = null;
            this._bufferItemDic = null;
        };
        /**
         * 更新数据
         * @param data 顶点索引的矢量。仅使用每个索引值的低 16 位。矢量的长度必须大于或等于 count。
         * @param numIndices 要在缓存区中存储的顶点数量。单个缓存区中的最大索引数为 524287。
         * @param count data 中索引的数量。
         */
        IndexBuffer.prototype.update = function (data, numIndices, count, firstIndex, numTriangles) {
            if (firstIndex === void 0) { firstIndex = 0; }
            if (numTriangles === void 0) { numTriangles = -1; }
            if (!data)
                throw new Error("顶点索引不接收空数组");
            this.dicInvalid = true;
            if (!this.data || this.data.length != data.length) {
                this.bufferInvalid = true;
            }
            this.data = data;
            this.numIndices = numIndices;
            this.count = count;
            this.firstIndex = firstIndex;
            this.numTriangles = numTriangles;
        };
        return IndexBuffer;
    }(feng3d.Context3DBuffer));
    feng3d.IndexBuffer = IndexBuffer;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 渲染程序缓存
     * @author feng 2014-8-14
     */
    var ProgramBuffer = (function (_super) {
        __extends(ProgramBuffer, _super);
        /**
         * 创建一个渲染程序缓存
         * @param dataTypeId 		数据缓存编号
         * @param updateFunc 		更新回调函数
         */
        function ProgramBuffer(dataTypeId, updateFunc) {
            _super.call(this, dataTypeId, updateFunc);
            this.bufferItemDic = new feng3d.Map();
            /** 是否无效 */
            this.bufferInvalid = true;
        }
        /**
         * @inheritDoc
         */
        ProgramBuffer.prototype.doUpdateFunc = function () {
            if (this._updateFunc != null && this._dataDirty) {
                feng3d.ShaderRegisterCache.invalid();
                this._updateFunc(this);
                this._dataDirty = false;
                this.dataRegisterDic = feng3d.ShaderRegisterCache.instance.dataRegisterDic;
            }
        };
        ProgramBuffer.prototype.doBuffer = function (context3D) {
            var _this = this;
            this.doUpdateFunc();
            var program3D;
            if (this.bufferInvalid) {
                this.bufferItemDic.getKeys().forEach(function (key) {
                    var contextTemp = key;
                    feng3d.AGALProgram3DCache.getInstance(contextTemp).freeProgram3D(_this.bufferItemDic.get(contextTemp));
                });
                this.bufferItemDic.clear();
                this.bufferInvalid = false;
            }
            var oldProgram3D = this.bufferItemDic.get(context3D);
            program3D = feng3d.AGALProgram3DCache.getInstance(context3D).getProgram3D(oldProgram3D, this.vertexCode, this.fragmentCode);
            this.bufferItemDic.push(context3D, program3D);
            context3D.setProgram(program3D);
        };
        ProgramBuffer.prototype.update = function (vertexCode, fragmentCode) {
            this.bufferInvalid = true;
            this.vertexCode = vertexCode;
            this.fragmentCode = fragmentCode;
        };
        return ProgramBuffer;
    }(feng3d.Context3DBuffer));
    feng3d.ProgramBuffer = ProgramBuffer;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * Context3D关联寄存器的数据缓存
     * @author feng 2014-8-14
     */
    var RegisterBuffer = (function (_super) {
        __extends(RegisterBuffer, _super);
        /**
         * 创建寄存器数据缓存
         * @param dataTypeId 		数据编号
         * @param updateFunc 		数据更新回调函数
         */
        function RegisterBuffer(dataTypeId, updateFunc) {
            _super.call(this, dataTypeId, updateFunc);
            /** 需要寄存器的个数 */
            this.numRegisters = 1;
        }
        return RegisterBuffer;
    }(feng3d.Context3DBuffer));
    feng3d.RegisterBuffer = RegisterBuffer;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 3d环境常量数据缓存
     * @author feng 2014-8-20
     */
    var ConstantsBuffer = (function (_super) {
        __extends(ConstantsBuffer, _super);
        /**
         * 创建3d环境常量数据缓存
         * @param dataTypeId 		数据编号
         * @param updateFunc 		数据更新回调函数
         */
        function ConstantsBuffer(dataTypeId, updateFunc) {
            _super.call(this, dataTypeId, updateFunc);
        }
        return ConstantsBuffer;
    }(feng3d.RegisterBuffer));
    feng3d.ConstantsBuffer = ConstantsBuffer;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * Context3D 片段字节数组常量数据缓存
     * @author feng 2014-8-20
     */
    var FCByteArrayBuffer = (function (_super) {
        __extends(FCByteArrayBuffer, _super);
        /**
         * 创建一个片段字节数组常量数据缓存
         * @param dataTypeId		数据编号
         * @param updateFunc		数据更新回调函数
         */
        function FCByteArrayBuffer(dataTypeId, updateFunc) {
            _super.call(this, dataTypeId, updateFunc);
        }
        /**
         * @inheritDoc
         */
        FCByteArrayBuffer.prototype.doBuffer = function (context3D) {
            this.doUpdateFunc();
            context3D.setProgramConstantsFromByteArray(feng3d.Context3DProgramType.FRAGMENT, this.firstRegister, 1, this.data, this.data.position);
        };
        return FCByteArrayBuffer;
    }(feng3d.ConstantsBuffer));
    feng3d.FCByteArrayBuffer = FCByteArrayBuffer;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * Context3D 片段矩阵常量数据缓存
     * @author feng 2014-8-20
     */
    var FCMatrixBuffer = (function (_super) {
        __extends(FCMatrixBuffer, _super);
        /**
         * 创建片段矩阵常量数据缓存
         * @param dataTypeId 		数据编号
         * @param updateFunc 		数据更新回调函数
         */
        function FCMatrixBuffer(dataTypeId, updateFunc) {
            _super.call(this, dataTypeId, updateFunc);
        }
        /**
         * @inheritDoc
         */
        FCMatrixBuffer.prototype.doBuffer = function (context3D) {
            this.doUpdateFunc();
            context3D.setProgramConstantsFromMatrix(feng3d.Context3DProgramType.FRAGMENT, this.firstRegister, this.matrix, false);
        };
        /**
         * 更新
         * @param matrix
         * @param transposedMatrix
         */
        FCMatrixBuffer.prototype.update = function (matrix, transposedMatrix) {
            if (transposedMatrix === void 0) { transposedMatrix = false; }
            this.matrix = matrix;
            this.transposedMatrix = transposedMatrix;
        };
        return FCMatrixBuffer;
    }(feng3d.ConstantsBuffer));
    feng3d.FCMatrixBuffer = FCMatrixBuffer;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * Context3D 片段向量常量数据缓存
     * @author feng 2014-8-20
     */
    var FCVectorBuffer = (function (_super) {
        __extends(FCVectorBuffer, _super);
        /**
         * 创建片段向量常量数据缓存
         * @param dataTypeId 		数据编号
         * @param updateFunc 		数据更新回调函数
         */
        function FCVectorBuffer(dataTypeId, updateFunc) {
            _super.call(this, dataTypeId, updateFunc);
        }
        /**
         * @inheritDoc
         */
        FCVectorBuffer.prototype.doBuffer = function (context3D) {
            this.doUpdateFunc();
            context3D.setProgramConstantsFromVector(feng3d.Context3DProgramType.FRAGMENT, this.firstRegister, this.data, this.numRegisters);
        };
        /**
         * 更新数据
         * @param data
         * @param numRegisters
         *
         */
        FCVectorBuffer.prototype.update = function (data, numRegisters) {
            if (numRegisters === void 0) { numRegisters = -1; }
            feng3d.assert(data.length % 4 == 0, "常量数据个数必须为4的倍数！");
            this.data = data;
            this.numRegisters = numRegisters;
        };
        return FCVectorBuffer;
    }(feng3d.ConstantsBuffer));
    feng3d.FCVectorBuffer = FCVectorBuffer;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * Context3D 顶点字节数组常量数据缓存
     * @author feng 2014-8-20
     */
    var VCByteArrayBuffer = (function (_super) {
        __extends(VCByteArrayBuffer, _super);
        /**
         * 创建一个顶点字节数组常量数据缓存
         * @param dataTypeId		数据编号
         * @param updateFunc		数据更新回调函数
         */
        function VCByteArrayBuffer(dataTypeId, updateFunc) {
            _super.call(this, dataTypeId, updateFunc);
        }
        /**
         * @inheritDoc
         */
        VCByteArrayBuffer.prototype.doBuffer = function (context3D) {
            this.doUpdateFunc();
            context3D.setProgramConstantsFromByteArray(feng3d.Context3DProgramType.VERTEX, this.firstRegister, 1, this.data, this.data.position);
        };
        return VCByteArrayBuffer;
    }(feng3d.ConstantsBuffer));
    feng3d.VCByteArrayBuffer = VCByteArrayBuffer;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * Context3D 顶点矩阵常量数据缓存
     * @author feng 2014-8-20
     */
    var VCMatrixBuffer = (function (_super) {
        __extends(VCMatrixBuffer, _super);
        /**
         * 创建顶点矩阵常量数据缓存
         * @param dataTypeId 		数据编号
         * @param updateFunc 		数据更新回调函数
         */
        function VCMatrixBuffer(dataTypeId, updateFunc) {
            _super.call(this, dataTypeId, updateFunc);
        }
        /**
         * @inheritDoc
         */
        VCMatrixBuffer.prototype.doBuffer = function (context3D) {
            this.doUpdateFunc();
            context3D.setProgramConstantsFromMatrix(feng3d.Context3DProgramType.VERTEX, this.firstRegister, this.matrix, this.transposedMatrix);
        };
        /**
         * 更新数据
         * @param matrix					静态矩阵数据
         * @param transposedMatrix			如果为 true，则将按颠倒顺序将矩阵条目复制到寄存器中。默认值为 false。
         */
        VCMatrixBuffer.prototype.update = function (matrix, transposedMatrix) {
            if (transposedMatrix === void 0) { transposedMatrix = false; }
            this.matrix = matrix;
            this.transposedMatrix = transposedMatrix;
        };
        return VCMatrixBuffer;
    }(feng3d.ConstantsBuffer));
    feng3d.VCMatrixBuffer = VCMatrixBuffer;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * Context3D 顶点向量常量数据缓存
     * @author feng 2014-8-20
     */
    var VCVectorBuffer = (function (_super) {
        __extends(VCVectorBuffer, _super);
        /**
         * 创建一个顶点向量常量数据缓存
         * @param dataTypeId		数据编号
         * @param updateFunc		数据更新回调函数
         */
        function VCVectorBuffer(dataTypeId, updateFunc) {
            _super.call(this, dataTypeId, updateFunc);
        }
        /**
         * @inheritDoc
         */
        VCVectorBuffer.prototype.doBuffer = function (context3D) {
            this.doUpdateFunc();
            context3D.setProgramConstantsFromVector(feng3d.Context3DProgramType.VERTEX, this.firstRegister, this.data, this.numRegisters);
        };
        /**
         * 更新顶点常量数据
         * @param data				静态向量数据
         * @param numRegisters		需要寄存器的个数
         */
        VCVectorBuffer.prototype.update = function (data, numRegisters) {
            if (numRegisters === void 0) { numRegisters = -1; }
            feng3d.assert(data.length % 4 == 0, "常量数据个数必须为4的倍数！");
            this.data = data;
            this.numRegisters = numRegisters;
        };
        return VCVectorBuffer;
    }(feng3d.ConstantsBuffer));
    feng3d.VCVectorBuffer = VCVectorBuffer;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 纹理数组缓存（解决类似地形多纹理混合）
     * @author feng 2014-11-6
     */
    var FSArrayBuffer = (function (_super) {
        __extends(FSArrayBuffer, _super);
        /**
         * 创建纹理数组缓存
         * @param dataTypeId 数据编号
         * @param updateFunc 数据更新回调函数
         * @param textureFlags	取样参数回调函数
         */
        function FSArrayBuffer(dataTypeId, updateFunc) {
            _super.call(this, dataTypeId, updateFunc);
        }
        /**
         * @inheritDoc
         */
        FSArrayBuffer.prototype.doBuffer = function (context3D) {
            this.doUpdateFunc();
            for (var i = 0; i < this.textures.length; i++) {
                //从纹理缓存中获取纹理
                var textureBase = feng3d.TextureCenter.getTexture(context3D, this.textures[i]);
                context3D.setTextureAt(this.firstRegister + i, textureBase);
            }
        };
        /**
         * 更新纹理
         * @param textures		纹理数组
         */
        FSArrayBuffer.prototype.update = function (textures) {
            this.textures = textures;
        };
        return FSArrayBuffer;
    }(feng3d.RegisterBuffer));
    feng3d.FSArrayBuffer = FSArrayBuffer;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 纹理缓存
     * @author feng 2014-8-14
     */
    var FSBuffer = (function (_super) {
        __extends(FSBuffer, _super);
        /**
         * 创建纹理数据缓存
         * @param dataTypeId 	数据编号
         * @param updateFunc 	数据更新回调函数
         * @param textureFlags	取样参数回调函数
         */
        function FSBuffer(dataTypeId, updateFunc) {
            _super.call(this, dataTypeId, updateFunc);
        }
        /**
         * @inheritDoc
         */
        FSBuffer.prototype.doBuffer = function (context3D) {
            this.doUpdateFunc();
            //从纹理缓存中获取纹理
            var textureBase = feng3d.TextureCenter.getTexture(context3D, this.texture);
            context3D.setTextureAt(this.firstRegister, textureBase);
        };
        /**
         * 更新纹理数据
         * @param texture
         */
        FSBuffer.prototype.update = function (texture) {
            this.texture = texture;
        };
        return FSBuffer;
    }(feng3d.RegisterBuffer));
    feng3d.FSBuffer = FSBuffer;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 输出纹理缓冲
     * @author feng 2015-6-3
     */
    var OCBuffer = (function (_super) {
        __extends(OCBuffer, _super);
        /**
         * 创建一个输出纹理缓冲
         * @param dataTypeId 		数据缓存编号
         * @param updateFunc 		更新回调函数
         */
        function OCBuffer(dataTypeId, updateFunc) {
            _super.call(this, dataTypeId, updateFunc);
            this.enableDepthAndStencil = true;
            this.surfaceSelector = 0;
            this._antiAlias = 0;
        }
        /**
         * @inheritDoc
         */
        OCBuffer.prototype.doBuffer = function (context3D) {
            this.doUpdateFunc();
            //从纹理缓存中获取纹理
            var textureBase = feng3d.TextureCenter.getTexture(context3D, this.texture);
            context3D.setRenderToTexture(textureBase, true, 0, 0, this.firstRegister);
        };
        /**
         * 更新纹理数据
         * @param texture
         */
        OCBuffer.prototype.update = function (texture) {
            this.texture = texture;
        };
        return OCBuffer;
    }(feng3d.RegisterBuffer));
    feng3d.OCBuffer = OCBuffer;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 顶点数据缓冲
     * @author feng 2014-8-14
     */
    var VABuffer = (function (_super) {
        __extends(VABuffer, _super);
        /**
         * 创建顶点数据缓存
         * @param dataTypeId 数据编号
         * @param updateFunc 数据更新回调函数
         */
        function VABuffer(dataTypeId, updateFunc) {
            _super.call(this, dataTypeId, updateFunc);
            /** 顶点数据缓存(真正的数据缓存) */
            this.dataBuffer = new feng3d.VADataBuffer();
        }
        Object.defineProperty(VABuffer.prototype, "format", {
            /**
             * 来自 Context3DVertexBufferFormat 类的值，指定此属性的数据类型。
             */
            get: function () {
                return this._format;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        VABuffer.prototype.doBuffer = function (context3D) {
            this.doUpdateFunc();
            var vertexBufferItem = this.dataBuffer.getBufferItem(context3D);
            vertexBufferItem.setVertexBufferAt(this.firstRegister, 0, this.format);
        };
        /**
         * 更新数据
         * @param data 				顶点数据
         * @param numVertices 		要在缓存区中存储的顶点数量。单个缓存区中的最大顶点数为 65535。
         * @param data32PerVertex 	与每个顶点关联的 32 位（4 字节）数据值的数量。每个顶点的 32 位数据元素数量最多为 64 个（或 256 个字节）。请注意，顶点着色器程序在任何给定时间只能访问 8 个属性寄存器。使用 SetVertextBufferAt() 在顶点缓存区内选择属性。
         */
        VABuffer.prototype.update = function (data, numVertices, data32PerVertex) {
            feng3d.assert(1 <= data32PerVertex && data32PerVertex <= 4);
            this._format = VABuffer.bufferFormats[data32PerVertex];
            this.dataBuffer.update(data, numVertices, data32PerVertex);
        };
        /**
         * 顶点数据缓冲格式数组
         */
        VABuffer.bufferFormats = [null, feng3d.Context3DVertexBufferFormat.FLOAT_1, feng3d.Context3DVertexBufferFormat.FLOAT_2, feng3d.Context3DVertexBufferFormat.FLOAT_3, feng3d.Context3DVertexBufferFormat.FLOAT_4];
        return VABuffer;
    }(feng3d.RegisterBuffer));
    feng3d.VABuffer = VABuffer;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    feng3d._bId = feng3d.Context3DBufferID.instance;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 3d缓存类型
     * @author feng 2014-8-20
     */
    var Context3DBufferType = (function () {
        function Context3DBufferType() {
        }
        return Context3DBufferType;
    }());
    feng3d.Context3DBufferType = Context3DBufferType;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * AGAL程序缓冲
     * @author feng 2014-8-20
     */
    var AGALProgram3DCache = (function () {
        /**
         * 创建AGAL程序缓冲
         * @param context3D			3D环境
         */
        function AGALProgram3DCache(context3D) {
            /**
             * 程序使用计数
             */
            this._usages = new feng3d.Map();
            /**
             * 程序与字符串字典
             */
            this._keys = new feng3d.Map();
            if (AGALProgram3DCache._instanceDic.get(context3D))
                throw new Error("已经存在对应的实例，请使用GetInstance方法获取。");
            AGALProgram3DCache._instanceDic.push(context3D, this);
            this._context3D = context3D;
            this._program3Ds = {};
        }
        /**
         * 获取AGAL程序缓冲实例
         * @param context3D			3D环境
         * @return					AGAL程序缓冲实例
         */
        AGALProgram3DCache.getInstance = function (context3D) {
            var cache = AGALProgram3DCache._instanceDic.get(context3D);
            if (cache == null) {
                AGALProgram3DCache._instanceDic.push(context3D, new AGALProgram3DCache(context3D));
            }
            return cache;
        };
        /**
         * 销毁
         */
        AGALProgram3DCache.prototype.dispose = function () {
            for (var key in this._program3Ds) {
                if (this._program3Ds.hasOwnProperty(key)) {
                    this.destroyProgram(key);
                }
            }
            this._keys = null;
            this._program3Ds = null;
            this._usages = null;
        };
        /**
         * 获取渲染程序
         * @param oldProgram3D			原来的渲染程序
         * @param vertexCode			顶点渲染代码
         * @param fragmentCode			片段渲染代码
         * @return						渲染程序
         */
        AGALProgram3DCache.prototype.getProgram3D = function (oldProgram3D, vertexCode, fragmentCode) {
            var key = this.getKey(vertexCode, fragmentCode);
            var program = this._program3Ds[key];
            if (program == null) {
                program = this._context3D.createProgram();
                var vertexByteCode = this.getVertexByteCode(vertexCode);
                var fragmentByteCode = this.getFragmentByteCode(fragmentCode);
                program.upload(vertexByteCode, fragmentByteCode);
                this._program3Ds[key] = program;
                this._keys.push(program, key);
                this._usages.push(program, 0);
            }
            if (oldProgram3D != program) {
                if (oldProgram3D)
                    this.freeProgram3D(oldProgram3D);
                this._usages.push(program, this._usages.get(program) + 1);
            }
            return program;
        };
        /**
         * 获取片段渲染二进制
         * @param fragmentCode		片段渲染代码
         * @return					片段渲染二进制
         */
        AGALProgram3DCache.prototype.getFragmentByteCode = function (fragmentCode) {
            var noCommentCode = this.filterComment(fragmentCode);
            return AGALProgram3DCache.shaderByteCodeDic[fragmentCode] = AGALProgram3DCache.shaderByteCodeDic[fragmentCode] || new feng3d.AGALMiniAssembler(feng3d.Debug.agalDebug).assemble(feng3d.Context3DProgramType.FRAGMENT, noCommentCode);
        };
        /**
         * 获取顶点渲染二进制
         * @param vertexCode		顶点渲染代码
         * @return 					顶点渲染二进制
         */
        AGALProgram3DCache.prototype.getVertexByteCode = function (vertexCode) {
            var noCommentCode = this.filterComment(vertexCode);
            return AGALProgram3DCache.shaderByteCodeDic[vertexCode] = AGALProgram3DCache.shaderByteCodeDic[vertexCode] || new feng3d.AGALMiniAssembler(feng3d.Debug.agalDebug).assemble(feng3d.Context3DProgramType.VERTEX, noCommentCode);
        };
        /**
         * 过滤代码中的注释
         * @param code			渲染代码
         * @return				没有注释的渲染代码
         */
        AGALProgram3DCache.prototype.filterComment = function (code) {
            //			return code;
            var codes = code.split(feng3d.FagalToken.BREAK);
            var line;
            var newCode = "";
            for (var i = 0; i < codes.length; i++) {
                line = codes[i];
                if (line.length > 0 && line.substr(0, feng3d.FagalToken.COMMENT.length) != feng3d.FagalToken.COMMENT) {
                    if (newCode.length > 0 && newCode.substr(-feng3d.FagalToken.BREAK.length) != feng3d.FagalToken.BREAK)
                        newCode += feng3d.FagalToken.BREAK;
                    newCode += line;
                }
            }
            return newCode;
        };
        /**
         * 释放渲染程序
         * @param program3D		被释放的渲染程序
         */
        AGALProgram3DCache.prototype.freeProgram3D = function (program3D) {
            this._usages.push(program3D, this._usages.get(program3D) - 1);
            if (this._usages.get(program3D) == 0)
                this.destroyProgram(this._keys.get(program3D));
        };
        /**
         * 销毁渲染程序
         * @param key		渲染代码
         */
        AGALProgram3DCache.prototype.destroyProgram = function (key) {
            this._program3Ds[key].dispose();
            this._program3Ds[key] = null;
            delete this._program3Ds[key];
        };
        /**
         * 获取渲染代码键值
         * @param vertexCode			顶点渲染代码
         * @param fragmentCode			片段渲染代码
         * @return						渲染代码键值
         */
        AGALProgram3DCache.prototype.getKey = function (vertexCode, fragmentCode) {
            return vertexCode + "---" + fragmentCode;
        };
        /**
         * 实例字典
         */
        AGALProgram3DCache._instanceDic = new feng3d.Map();
        /**
         * 字符串与二进制字典
         */
        AGALProgram3DCache.shaderByteCodeDic = {};
        return AGALProgram3DCache;
    }());
    feng3d.AGALProgram3DCache = AGALProgram3DCache;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 3D环境缓冲收集器
     * @author feng 2015-7-18
     */
    var Context3DBufferCollector = (function () {
        /**
         * 创建3D环境缓冲收集器
         * @bufferOwner		缓冲拥有者
         */
        function Context3DBufferCollector() {
            /** 所有数据缓存 */
            this.bufferDic = {};
        }
        Object.defineProperty(Context3DBufferCollector.prototype, "rootBufferOwner", {
            /**
             * 根3D环境缓冲拥有者
             */
            get: function () {
                if (this._rootBufferOwner == null) {
                    this._rootBufferOwner = new feng3d.Context3DBufferOwner();
                    //添加事件
                    this._rootBufferOwner.addEventListener(feng3d.Context3DBufferOwnerEvent.ADD_CONTEXT3DBUFFER, this.onAddContext3DBuffer);
                    this._rootBufferOwner.addEventListener(feng3d.Context3DBufferOwnerEvent.REMOVE_CONTEXT3DBUFFER, this.onRemoveContext3DBuffer);
                    this._rootBufferOwner.addEventListener(feng3d.Context3DBufferOwnerEvent.ADDCHILD_CONTEXT3DBUFFEROWNER, this.onAddChildContext3DBufferOwner);
                    this._rootBufferOwner.addEventListener(feng3d.Context3DBufferOwnerEvent.REMOVECHILD_CONTEXT3DBUFFEROWNER, this.onRemoveChildContext3DBufferOwner);
                }
                return this._rootBufferOwner;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 添加子项缓存拥有者
         * @param childBufferOwner
         */
        Context3DBufferCollector.prototype.addChildBufferOwner = function (childBufferOwner) {
            this.rootBufferOwner.addChildBufferOwner(childBufferOwner);
        };
        /**
         * 移除子项缓存拥有者
         * @param childBufferOwner
         */
        Context3DBufferCollector.prototype.removeChildBufferOwner = function (childBufferOwner) {
            this.rootBufferOwner.removeChildBufferOwner(childBufferOwner);
        };
        /**
         * 添加数据缓存
         * @param context3DDataBuffer 数据缓存
         */
        Context3DBufferCollector.prototype.addDataBuffer = function (context3DDataBuffer) {
            var dataTypeId = context3DDataBuffer.dataTypeId;
            if (this.bufferDic[dataTypeId])
                console.log("重复提交数据" + context3DDataBuffer);
            this.bufferDic[dataTypeId] = context3DDataBuffer;
        };
        /**
         * 移除数据缓存
         * @param dataTypeId 数据缓存类型编号
         */
        Context3DBufferCollector.prototype.removeDataBuffer = function (context3DDataBuffer) {
            var dataTypeId = context3DDataBuffer.dataTypeId;
            if (this.bufferDic[dataTypeId] != context3DDataBuffer)
                throw new Error("移除数据缓存错误");
            delete this.bufferDic[dataTypeId];
        };
        /**
         * 处理添加缓冲拥有者事件
         */
        Context3DBufferCollector.prototype.onAddChildContext3DBufferOwner = function (event) {
            this.addContext3DBufferOwer(event.data);
        };
        /**
         * 处理移除缓冲拥有者事件
         */
        Context3DBufferCollector.prototype.onRemoveChildContext3DBufferOwner = function (event) {
            this.removeContext3DBufferOwer(event.data);
        };
        /**
         * 处理添加缓冲事件
         */
        Context3DBufferCollector.prototype.onAddContext3DBuffer = function (event) {
            this.addDataBuffer(event.data);
        };
        /**
         * 处理移除缓冲事件
         */
        Context3DBufferCollector.prototype.onRemoveContext3DBuffer = function (event) {
            this.removeDataBuffer(event.data);
        };
        /**
         * 添加缓冲拥有者
         * @param bufferOwer		缓冲拥有者
         */
        Context3DBufferCollector.prototype.addContext3DBufferOwer = function (bufferOwer) {
            var allBufferList = bufferOwer.getAllBufferList();
            for (var i = 0; i < allBufferList.length; i++) {
                this.addDataBuffer(allBufferList[i]);
            }
        };
        /**
         * 移除缓冲拥有者
         * @param bufferOwer		缓冲拥有者
         */
        Context3DBufferCollector.prototype.removeContext3DBufferOwer = function (bufferOwer) {
            var allBufferList = bufferOwer.getAllBufferList();
            for (var i = 0; i < allBufferList.length; i++) {
                this.removeDataBuffer(allBufferList[i]);
            }
        };
        /**
         * 销毁
         */
        Context3DBufferCollector.prototype.dispose = function () {
            //移除事件
            if (this._rootBufferOwner != null) {
                this._rootBufferOwner.removeEventListener(feng3d.Context3DBufferOwnerEvent.ADD_CONTEXT3DBUFFER, this.onAddContext3DBuffer);
                this._rootBufferOwner.removeEventListener(feng3d.Context3DBufferOwnerEvent.REMOVE_CONTEXT3DBUFFER, this.onRemoveContext3DBuffer);
                this._rootBufferOwner.removeEventListener(feng3d.Context3DBufferOwnerEvent.ADDCHILD_CONTEXT3DBUFFEROWNER, this.onAddChildContext3DBufferOwner);
                this._rootBufferOwner.removeEventListener(feng3d.Context3DBufferOwnerEvent.REMOVECHILD_CONTEXT3DBUFFEROWNER, this.onRemoveChildContext3DBufferOwner);
            }
            this._rootBufferOwner = null;
        };
        return Context3DBufferCollector;
    }());
    feng3d.Context3DBufferCollector = Context3DBufferCollector;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 3D环境缓存类(方便调试与管理渲染操作)
     * @author feng 2014-6-6
     */
    var Context3DCache = (function (_super) {
        __extends(Context3DCache, _super);
        /**
         * 创建3D环境缓存类
         */
        function Context3DCache() {
            _super.call(this);
            /** 寄存器数据缓存 */
            this.regBufferDic = {};
            /** 其他数据缓存 */
            this.otherBufferDic = {};
        }
        /**
         * @inheritDoc
         */
        Context3DCache.prototype.addDataBuffer = function (context3DDataBuffer) {
            _super.prototype.addDataBuffer.call(this, context3DDataBuffer);
            var dataTypeId = context3DDataBuffer.dataTypeId;
            if (feng3d.is(context3DDataBuffer, feng3d.RegisterBuffer))
                this.regBufferDic[dataTypeId] = context3DDataBuffer;
            else if (feng3d.is(context3DDataBuffer, feng3d.ProgramBuffer))
                this.programBuffer = context3DDataBuffer;
            else if (feng3d.is(context3DDataBuffer, feng3d.IndexBuffer))
                this.indexBuffer = context3DDataBuffer;
            else
                this.otherBufferDic[dataTypeId] = context3DDataBuffer;
        };
        /**
         * @inheritDoc
         */
        Context3DCache.prototype.removeDataBuffer = function (context3DDataBuffer) {
            _super.prototype.removeDataBuffer.call(this, context3DDataBuffer);
            var dataTypeId = context3DDataBuffer.dataTypeId;
            delete this.regBufferDic[dataTypeId];
            delete this.otherBufferDic[dataTypeId];
            if (feng3d.is(context3DDataBuffer, feng3d.ProgramBuffer)) {
                this.programBuffer = null;
            }
        };
        /**
         * 使用Context3D缓存绘制
         * <p>过程：渲染程序缓存（标记使用的寄存器数据缓存）-->寄存器数据缓存(标记使用的数据)-->其他缓存-->绘制三角形</p>
         * @param context3D				3d环境
         * @param renderIndex			渲染编号
         */
        Context3DCache.prototype.render = function (context3D, renderIndex) {
            if (renderIndex === void 0) { renderIndex = 0; }
            //更新渲染程序（标记使用寄存器）
            this.fagalRE.context3DCache = this;
            this.programBuffer.doBuffer(context3D);
            this.fagalRE.context3DCache = null;
            this.dataRegisterDic = this.programBuffer.dataRegisterDic;
            //处理 其他数据缓存
            for (var key in this.otherBufferDic) {
                if (this.otherBufferDic.hasOwnProperty(key)) {
                    var context3DDataBuffer = this.otherBufferDic[key];
                    context3DDataBuffer.doBuffer(context3D);
                }
            }
            //处理 需要执行的寄存器数据缓存
            for (var key in this.runRegBufferList) {
                if (this.runRegBufferList.hasOwnProperty(key)) {
                    var registerBuffer = this.runRegBufferList[key];
                    registerBuffer.doBuffer(context3D);
                }
            }
            if (this.ocBuffer != null) {
                this.ocBuffer.doBuffer(context3D);
                if (renderIndex == 0) {
                    context3D.clear(1, 1, 1);
                }
            }
            //执行索引数据缓存
            this.indexBuffer.doBuffer(context3D);
            if (this.ocBuffer != null) {
                context3D.setRenderToBackBuffer();
            }
            //清理缓存
            this.clearContext3D(context3D);
        };
        Object.defineProperty(Context3DCache.prototype, "dataRegisterDic", {
            /**
             * 使用到的数据寄存器
             */
            get: function () {
                return this._dataRegisterDic;
            },
            /**
             * @private
             */
            set: function (value) {
                if (this._dataRegisterDic != value) {
                    this._dataRegisterDic = value;
                    this.mapRegister();
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 清理3D环境
         */
        Context3DCache.prototype.clearContext3D = function (context3D) {
            for (var i = 0; i < 8; ++i) {
                context3D.setVertexBufferAt(i, null);
                context3D.setTextureAt(i, null);
            }
        };
        /**
         * 映射寄存器
         */
        Context3DCache.prototype.mapRegister = function () {
            this.ocBuffer = null;
            this.runRegBufferList = [];
            for (var key in this.dataRegisterDic) {
                if (this.dataRegisterDic.hasOwnProperty(key)) {
                    var register = this.dataRegisterDic[key];
                    var registerBuffer = this.regBufferDic[register.dataTypeId];
                    //输入数据寄存器必须有对应的数据缓存
                    if (feng3d.RegisterType.isInputDataRegister(register.regType)) {
                        if (registerBuffer == null) {
                            throw new Error("缺少【" + register.dataTypeId + "】寄存器数据缓存");
                        }
                    }
                    if (registerBuffer != null) {
                        if (feng3d.is(registerBuffer, feng3d.OCBuffer)) {
                            this.ocBuffer = registerBuffer;
                        }
                        else {
                            registerBuffer.firstRegister = register.index;
                            this.runRegBufferList.push(registerBuffer);
                        }
                    }
                }
            }
            this.runRegBufferList.sort(function (a, b) {
                "dataTypeId";
                return 0;
            });
        };
        Object.defineProperty(Context3DCache.prototype, "fagalRE", {
            /**
             * Fagal函数运行环境
             */
            get: function () {
                return feng3d.FagalRE.instance;
            },
            enumerable: true,
            configurable: true
        });
        return Context3DCache;
    }(feng3d.Context3DBufferCollector));
    feng3d.Context3DCache = Context3DCache;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 3d环境缓存类型管理者
     * @author feng 2014-9-3
     */
    var Context3DBufferTypeManager = (function () {
        /**
         * 创建3d环境缓存类型管理者
         */
        function Context3DBufferTypeManager() {
            if (Context3DBufferTypeManager._instance)
                throw new Error("单例模式");
            Context3DBufferTypeManager._instance = this;
            this.bufferTypeDic = {};
            this.typeClassDic = {};
        }
        Object.defineProperty(Context3DBufferTypeManager, "instance", {
            /**
             * 3d环境缓存类型管理者实例
             */
            get: function () {
                return Context3DBufferTypeManager._instance || new Context3DBufferTypeManager();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 获取或创建3d缓存类型
         * @param typeId 		3d缓存类型编号
         * @return				3d缓存类型实例
         */
        Context3DBufferTypeManager.getBufferType = function (typeId) {
            return Context3DBufferTypeManager.instance.getBufferType(typeId);
        };
        /**
         * 获取3d缓存类定义
         * @param typeId 		3d缓存类型编号
         * @return				3d缓存类定义
         */
        Context3DBufferTypeManager.getBufferClass = function (typeId) {
            return Context3DBufferTypeManager.instance.getBufferClass(typeId);
        };
        /**
         * 获取或创建3d缓存类型
         * @param typeId 		3d缓存类型编号
         * @return				3d缓存类型实例
         */
        Context3DBufferTypeManager.prototype.getBufferType = function (typeId) {
            var bufferType = this.bufferTypeDic[typeId];
            if (bufferType)
                return bufferType;
            this.bufferTypeDic[typeId] = bufferType = new feng3d.Context3DBufferType();
            var types = typeId.split("_");
            bufferType.registerType = types[1];
            bufferType.dataType = types[2];
            return bufferType;
        };
        /**
         * 获取3d缓存类定义
         * @param typeId 		3d缓存类型编号
         * @return				3d缓存类定义
         */
        Context3DBufferTypeManager.prototype.getBufferClass = function (typeId) {
            var cls = this.typeClassDic[typeId];
            if (cls == null) {
                for (var i = 0; i < Context3DBufferTypeManager.config.length; i++) {
                    var result = typeId.match(feng3d.as(Context3DBufferTypeManager.config[i][0], String));
                    if (result != null && result.input == result[0]) {
                        return Context3DBufferTypeManager.config[i][1];
                    }
                }
            }
            throw new Error("无法为" + typeId + "匹配到3d缓存类");
        };
        Context3DBufferTypeManager.NAME_REGEXP = "[a-zA-Z0-9$]";
        Context3DBufferTypeManager.config = [
            ["blendFactors", feng3d.BlendFactorsBuffer],
            ["culling", feng3d.CullingBuffer],
            ["depthTest", feng3d.DepthTestBuffer],
            ["(" + Context3DBufferTypeManager.NAME_REGEXP + "+)?_fc_bytes", feng3d.FCByteArrayBuffer],
            ["(" + Context3DBufferTypeManager.NAME_REGEXP + "+)?_fc_matrix", feng3d.FCMatrixBuffer],
            ["(" + Context3DBufferTypeManager.NAME_REGEXP + "+)?_fc_vector", feng3d.FCVectorBuffer],
            ["(" + Context3DBufferTypeManager.NAME_REGEXP + "+)?_fs_array", feng3d.FSArrayBuffer],
            ["(" + Context3DBufferTypeManager.NAME_REGEXP + "+)?_fs", feng3d.FSBuffer],
            ["index", feng3d.IndexBuffer],
            ["(" + Context3DBufferTypeManager.NAME_REGEXP + "+)?_oc", feng3d.OCBuffer],
            ["program", feng3d.ProgramBuffer],
            ["(" + Context3DBufferTypeManager.NAME_REGEXP + "+)?_va_([1-4x])", feng3d.VABuffer],
            ["(" + Context3DBufferTypeManager.NAME_REGEXP + "+)?_vc_bytes", feng3d.VCByteArrayBuffer],
            ["(" + Context3DBufferTypeManager.NAME_REGEXP + "+)?_vc_matrix", feng3d.VCMatrixBuffer],
            ["(" + Context3DBufferTypeManager.NAME_REGEXP + "+)?_vc_vector", feng3d.VCVectorBuffer],
        ];
        return Context3DBufferTypeManager;
    }());
    feng3d.Context3DBufferTypeManager = Context3DBufferTypeManager;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 寄存器数据类型
     * @author feng 2014-8-20
     */
    var RgisterDataType = (function () {
        function RgisterDataType() {
        }
        /** 字节数组(ByteArray) */
        RgisterDataType.BYTEARRAY = "byteArray";
        /** 向量(Vector) */
        RgisterDataType.VECTOR = "vector";
        /** 矩阵（Matrix3D ） */
        RgisterDataType.MATRIX = "matrix";
        /**
         * 寄存器数组
         */
        RgisterDataType.ARRAY = "array";
        return RgisterDataType;
    }());
    feng3d.RgisterDataType = RgisterDataType;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 纹理缓存中心
     * @author feng 2014-8-14
     */
    var TextureCenter = (function () {
        /**
         * 创建一个纹理缓存中心
         */
        function TextureCenter() {
        }
        /**
         * 获取纹理
         * @param context3D		3D环境
         * @param texture		纹理代理
         * @return				纹理
         */
        TextureCenter.getTexture = function (context3D, texture) {
            //冲缓存中取纹理
            var textureBase = TextureCenter.$getTexture(context3D, texture);
            if (textureBase)
                return textureBase;
            //创建位图纹理
            var bitmapTexture = texture;
            if (bitmapTexture)
                return TextureCenter.createTexture(context3D, bitmapTexture);
            //创建立方体纹理
            var bitmapCubeTexture = texture;
            if (bitmapCubeTexture)
                return TextureCenter.createCubeTexture(context3D, bitmapCubeTexture);
            var renderTexture = texture;
            if (renderTexture)
                return TextureCenter.createRenderTexture(context3D, renderTexture);
            return null;
        };
        /**
         * 获取纹理
         * @param context3D		3D环境
         * @param texture		纹理代理
         * @return				纹理
         */
        TextureCenter.$getTexture = function (context3D, texture) {
            if (TextureCenter.textureDic.get(texture) == null || TextureCenter.textureDic.get(texture).get(context3D) == null) {
                return null;
            }
            return TextureCenter.textureDic.get(texture).get(context3D);
        };
        /**
         * 创建纹理
         * @param context3D				3D环境
         * @param bitmapTexture			位图纹理代理
         * @return						纹理
         */
        TextureCenter.createTexture = function (context3D, bitmapTexture) {
            var texture = context3D.createTexture(bitmapTexture.width, bitmapTexture.height, bitmapTexture.format, true);
            if (bitmapTexture.generateMipmaps)
                feng3d.MipmapGenerator.generateMipMaps(bitmapTexture.bitmapData, texture, bitmapTexture.mipMapHolder, true);
            else
                texture.uploadFromBitmapData(bitmapTexture.bitmapData, 0);
            TextureCenter.saveTextureBuffer(bitmapTexture, context3D, texture);
            return texture;
        };
        /**
         * 创建纹理
         * @param context3D				3D环境
         * @param renderTexture			渲染纹理代理
         * @return						纹理
         */
        TextureCenter.createRenderTexture = function (context3D, renderTexture) {
            var texture = context3D.createTexture(renderTexture.width, renderTexture.height, renderTexture.format, true);
            var bmp = new feng3d.BitmapData(renderTexture.width, renderTexture.height, false, 0xff0000);
            feng3d.MipmapGenerator.generateMipMaps(bmp, texture);
            bmp.dispose();
            TextureCenter.saveTextureBuffer(renderTexture, context3D, texture);
            return texture;
        };
        /**
         * 创建立方体纹理
         * @param context3D				3D环境
         * @param bitmapTexture			位图立方体纹理代理
         * @return						立方体纹理
         */
        TextureCenter.createCubeTexture = function (context3D, bitmapTexture) {
            var texture = context3D["createCubeTexture"](bitmapTexture.size, bitmapTexture.format, bitmapTexture.optimizeForRenderToTexture, bitmapTexture.streamingLevels);
            var _bitmapDatas = bitmapTexture.bitmapDatas;
            for (var i = 0; i < 6; ++i)
                feng3d.MipmapGenerator.generateMipMaps(_bitmapDatas[i], texture, null, _bitmapDatas[i].transparent, i);
            TextureCenter.saveTextureBuffer(bitmapTexture, context3D, texture);
            return texture;
        };
        /**
         * 保存纹理缓存
         * @param texture				纹理代理
         * @param context3D				3D环境
         * @param textureBase			纹理
         */
        TextureCenter.saveTextureBuffer = function (texture, context3D, textureBase) {
            var textureDic1 = TextureCenter.textureDic.get(texture);
            if (textureDic1 == null) {
                textureDic1 = new feng3d.Map();
                TextureCenter.textureDic.push(texture, textureDic1);
            }
            textureDic1.push(context3D, textureBase);
        };
        /** 纹理字典 */
        TextureCenter.textureDic = new feng3d.Map();
        return TextureCenter;
    }());
    feng3d.TextureCenter = TextureCenter;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 实体列表元素池
     * @author feng 2015-3-6
     */
    var EntityListItemPool = (function () {
        /**
         * 创建一个实体列表元素池
         */
        function EntityListItemPool() {
        }
        /**
         * 释放所有
         */
        EntityListItemPool.prototype.freeAll = function () {
            this._index = 0;
        };
        return EntityListItemPool;
    }());
    feng3d.EntityListItemPool = EntityListItemPool;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 可渲染元素链表（元素）
     * @author feng 2015-3-6
     */
    var RenderableListItem = (function () {
        /**
         * 创建一个可渲染列表
         */
        function RenderableListItem() {
        }
        return RenderableListItem;
    }());
    feng3d.RenderableListItem = RenderableListItem;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 可渲染列表元素池
     * @author feng 2015-3-6
     */
    var RenderableListItemPool = (function () {
        /**
         * 创建可渲染列表元素池
         */
        function RenderableListItemPool() {
            this._pool = [];
        }
        /**
         * 获取 可渲染列表元
         */
        RenderableListItemPool.prototype.getItem = function () {
            if (this._index == this._poolSize) {
                var item = new feng3d.RenderableListItem();
                this._pool[this._index++] = item;
                ++this._poolSize;
                return item;
            }
            else
                return this._pool[this._index++];
        };
        /**
         * 释放所有
         */
        RenderableListItemPool.prototype.freeAll = function () {
            this._index = 0;
        };
        return RenderableListItemPool;
    }());
    feng3d.RenderableListItemPool = RenderableListItemPool;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 鼠标事件管理
     * @author feng 2014-4-29
     */
    var Mouse3DManager = (function () {
        function Mouse3DManager() {
            /** 射线采集器(采集射线穿过场景中物体的列表) */
            this._mousePicker = new feng3d.RaycastPicker(false);
            /** 收集的鼠标事件列表 */
            this.mouseEventList = [];
            /** 是否开启鼠标事件检测 */
            this.mouseEventOpen = false;
            if (Mouse3DManager.eventMap == null) {
                Mouse3DManager.eventMap = {};
                Mouse3DManager.eventMap[feng3d.MouseEvent.CLICK] = feng3d.MouseEvent3D.CLICK;
                Mouse3DManager.eventMap[feng3d.MouseEvent.DOUBLE_CLICK] = feng3d.MouseEvent3D.DOUBLE_CLICK;
                Mouse3DManager.eventMap[feng3d.MouseEvent.MOUSE_DOWN] = feng3d.MouseEvent3D.MOUSE_DOWN;
                Mouse3DManager.eventMap[feng3d.MouseEvent.MOUSE_MOVE] = feng3d.MouseEvent3D.MOUSE_MOVE;
                Mouse3DManager.eventMap[feng3d.MouseEvent.MOUSE_OUT] = feng3d.MouseEvent3D.MOUSE_OUT;
                Mouse3DManager.eventMap[feng3d.MouseEvent.MOUSE_OVER] = feng3d.MouseEvent3D.MOUSE_OVER;
                Mouse3DManager.eventMap[feng3d.MouseEvent.MOUSE_UP] = feng3d.MouseEvent3D.MOUSE_UP;
                Mouse3DManager.eventMap[feng3d.MouseEvent.MOUSE_WHEEL] = feng3d.MouseEvent3D.MOUSE_WHEEL;
            }
        }
        /**
         * 开启鼠标事件
         */
        Mouse3DManager.prototype.enableMouseListeners = function (view) {
            view.addEventListener(feng3d.MouseEvent.MOUSE_OVER, this.onMouseOver);
            view.addEventListener(feng3d.MouseEvent.MOUSE_OUT, this.onMouseOut);
        };
        Mouse3DManager.prototype.onMouseOver = function (event) {
            var view = event.currentTarget;
            for (var eventType in Mouse3DManager.eventMap) {
                if (Mouse3DManager.eventMap.hasOwnProperty(eventType)) {
                    view.addEventListener(eventType, this.onMouseEvent);
                }
            }
            this.mouseEventList.length = 0;
            this.mouseEventOpen = true;
        };
        Mouse3DManager.prototype.onMouseOut = function (event) {
            var view = event.currentTarget;
            for (var eventType in Mouse3DManager.eventMap) {
                if (Mouse3DManager.eventMap.hasOwnProperty(eventType)) {
                    view.removeEventListener(eventType, this.onMouseEvent);
                }
            }
            this.mouseEventOpen = false;
        };
        /**
         * 收集玩家触发的鼠标事件
         */
        Mouse3DManager.prototype.onMouseEvent = function (event) {
            this.mouseEventList.push(event.type);
        };
        /**
         * 处理玩家触发的鼠标事件
         */
        Mouse3DManager.prototype.fireMouseEvents = function (mouseRay3D, mouseCollisionEntitys) {
            //玩家未触发鼠标事件时，直接返回
            if (!this.mouseEventOpen) {
                return;
            }
            var mouseEvent3DList = [];
            //计算得到鼠标射线相交的物体
            this._collidingObject = this._mousePicker.getViewCollision(mouseRay3D, mouseCollisionEntitys);
            //处理3d对象的Over与Out事件
            var mouseEventType;
            var mouseEvent3D;
            if (this._collidingObject != this._previousCollidingObject) {
                if (this._previousCollidingObject) {
                    mouseEvent3D = this.createMouseEvent3D(feng3d.MouseEvent.MOUSE_OUT, this._previousCollidingObject);
                    mouseEvent3DList.push(mouseEvent3D);
                }
                if (this._collidingObject) {
                    mouseEvent3D = this.createMouseEvent3D(feng3d.MouseEvent.MOUSE_OVER, this._collidingObject);
                    mouseEvent3DList.push(mouseEvent3D);
                }
            }
            //遍历收集的鼠标事件
            while (this._collidingObject && this.mouseEventList.length > 0) {
                mouseEventType = this.mouseEventList.pop();
                //处理鼠标事件
                mouseEvent3D = this.createMouseEvent3D(mouseEventType, this._collidingObject);
                mouseEvent3DList.push(mouseEvent3D);
            }
            this.dispatchAllEvent(mouseEvent3DList);
            this.mouseEventList.length = 0;
            mouseEvent3DList.length = 0;
            this._previousCollidingObject = this._collidingObject;
        };
        /**
         * 抛出所有3D鼠标事件
         * @param mouseEvent3DList
         */
        Mouse3DManager.prototype.dispatchAllEvent = function (mouseEvent3DList) {
            var mouseEvent3D;
            var dispatcher;
            while (mouseEvent3DList.length > 0) {
                mouseEvent3D = mouseEvent3DList.pop();
                if (mouseEvent3D && mouseEvent3D.object) {
                    dispatcher = mouseEvent3D.object;
                    if (dispatcher) {
                        dispatcher.dispatchEvent(mouseEvent3D);
                    }
                }
            }
        };
        /**
         * 创建3D鼠标事件
         * @param sourceEvent 2d鼠标事件
         * @param collider 碰撞信息
         * @return 3D鼠标事件
         */
        Mouse3DManager.prototype.createMouseEvent3D = function (sourceEventType, collider) {
            if (collider === void 0) { collider = null; }
            var mouseEvent3DType = Mouse3DManager.eventMap[sourceEventType];
            if (mouseEvent3DType == null)
                return null;
            var mouseEvent3D = new feng3d.MouseEvent3D(mouseEvent3DType);
            mouseEvent3D.object = collider.firstEntity;
            mouseEvent3D.collider = collider;
            return mouseEvent3D;
        };
        return Mouse3DManager;
    }());
    feng3d.Mouse3DManager = Mouse3DManager;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * The Stage3DManager class provides a multiton object that handles management for Stage3D objects. Stage3D objects
     * should not be requested directly, but are exposed by a Stage3DProxy.
     *
     * @see away3d.core.managers.Stage3DProxy
     */
    var Stage3DManager = (function () {
        /**
         * Creates a new Stage3DManager class.
         * @param stage The Stage object that contains the Stage3D objects to be managed.
         * @private
         */
        function Stage3DManager(stage, stage3DManagerSingletonEnforcer) {
            if (!stage3DManagerSingletonEnforcer)
                throw new Error("This class is a multiton and cannot be instantiated manually. Use Stage3DManager.getInstance instead.");
            this._stage = stage;
            if (!Stage3DManager._stageProxies) {
                Stage3DManager._stageProxies = [];
                Stage3DManager._stageProxies.length = this._stage.stage3Ds.length;
            }
        }
        /**
         * Gets a Stage3DManager instance for the given Stage object.
         * @param stage The Stage object that contains the Stage3D objects to be managed.
         * @return The Stage3DManager instance for the given Stage object.
         */
        Stage3DManager.getInstance = function (stage) {
            var stage3DManager = Stage3DManager._instances.get(stage);
            if (stage3DManager == null) {
                stage3DManager = new Stage3DManager(stage, new Stage3DManagerSingletonEnforcer());
                Stage3DManager._instances.push(stage, stage3DManager);
            }
            return stage3DManager;
        };
        /**
         * Requests the Stage3DProxy for the given index.
         * @param index The index of the requested Stage3D.
         * @param forceSoftware Whether to force software mode even if hardware acceleration is available.
         * @param profile The compatibility profile, an enumeration of Context3DProfile
         * @return The Stage3DProxy for the given index.
         */
        Stage3DManager.prototype.getStage3DProxy = function (index, forceSoftware, profile) {
            if (forceSoftware === void 0) { forceSoftware = false; }
            if (profile === void 0) { profile = "baseline"; }
            if (!Stage3DManager._stageProxies[index]) {
                Stage3DManager._numStageProxies++;
                Stage3DManager._stageProxies[index] = new feng3d.Stage3DProxy(index, this._stage.stage3Ds[index], this, forceSoftware, profile);
            }
            return Stage3DManager._stageProxies[index];
        };
        /**
         * Removes a Stage3DProxy from the manager.
         * @param stage3DProxy
         * @private
         */
        Stage3DManager.prototype.removeStage3DProxy = function (stage3DProxy) {
            Stage3DManager._numStageProxies--;
            Stage3DManager._stageProxies[stage3DProxy.stage3DIndex] = null;
        };
        /**
         * Get the next available stage3DProxy. An error is thrown if there are no Stage3DProxies available
         * @param forceSoftware Whether to force software mode even if hardware acceleration is available.
         * @param profile The compatibility profile, an enumeration of Context3DProfile
         * @return The allocated stage3DProxy
         */
        Stage3DManager.prototype.getFreeStage3DProxy = function (forceSoftware, profile) {
            if (forceSoftware === void 0) { forceSoftware = false; }
            if (profile === void 0) { profile = feng3d.Context3DProfile.STANDARD; }
            var i;
            var len = Stage3DManager._stageProxies.length;
            while (i < len) {
                if (!Stage3DManager._stageProxies[i]) {
                    this.getStage3DProxy(i, forceSoftware, profile);
                    Stage3DManager._stageProxies[i].width = this._stage.stageWidth;
                    Stage3DManager._stageProxies[i].height = this._stage.stageHeight;
                    return Stage3DManager._stageProxies[i];
                }
                ++i;
            }
            throw new Error("Too many Stage3D instances used!");
        };
        Object.defineProperty(Stage3DManager.prototype, "hasFreeStage3DProxy", {
            /**
             * Checks if a new stage3DProxy can be created and managed by the class.
             * @return true if there is one slot free for a new stage3DProxy
             */
            get: function () {
                return Stage3DManager._numStageProxies < Stage3DManager._stageProxies.length ? true : false;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Stage3DManager.prototype, "numProxySlotsFree", {
            /**
             * Returns the amount of stage3DProxy objects that can be created and managed by the class
             * @return the amount of free slots
             */
            get: function () {
                return Stage3DManager._stageProxies.length - Stage3DManager._numStageProxies;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Stage3DManager.prototype, "numProxySlotsUsed", {
            /**
             * Returns the amount of Stage3DProxy objects currently managed by the class.
             * @return the amount of slots used
             */
            get: function () {
                return Stage3DManager._numStageProxies;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Stage3DManager.prototype, "numProxySlotsTotal", {
            /**
             * Returns the maximum amount of Stage3DProxy objects that can be managed by the class
             * @return the maximum amount of Stage3DProxy objects that can be managed by the class
             */
            get: function () {
                return Stage3DManager._stageProxies.length;
            },
            enumerable: true,
            configurable: true
        });
        Stage3DManager._instances = new feng3d.Map();
        Stage3DManager._numStageProxies = 0;
        return Stage3DManager;
    }());
    feng3d.Stage3DManager = Stage3DManager;
    var Stage3DManagerSingletonEnforcer = (function () {
        function Stage3DManagerSingletonEnforcer() {
        }
        return Stage3DManagerSingletonEnforcer;
    }());
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 分区节点基类
     * @author feng 2015-3-8
     */
    var NodeBase = (function () {
        /**
         * 创建一个分区节点基类
         */
        function NodeBase() {
            this._childNodes = [];
        }
        Object.defineProperty(NodeBase.prototype, "parent", {
            /**
             * 父分区节点
             */
            get: function () {
                return this._parent;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NodeBase.prototype, "showDebugBounds", {
            /**
             * 是否显示调试边界
             */
            get: function () {
                return this._debugPrimitive != null;
            },
            /**
             * @private
             */
            set: function (value) {
                if ((this._debugPrimitive != null) == value)
                    return;
                if (value)
                    this._debugPrimitive = this.createDebugBounds();
                else {
                    //				_debugPrimitive.dispose();
                    this._debugPrimitive = null;
                }
                for (var i = 0; i < this._numChildNodes; ++i)
                    this._childNodes[i].showDebugBounds = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 添加节点
         * @param node	节点
         */
        NodeBase.prototype.addNode = function (node) {
            node._parent = this;
            this._numEntities += node._numEntities;
            this._childNodes[this._numChildNodes++] = node;
            node.showDebugBounds = this._debugPrimitive != null;
            var numEntities = node._numEntities;
            node = this;
            do
                node._numEntities += numEntities;
            while ((node = node._parent) != null);
        };
        /**
         * 移除节点
         * @param node 节点
         */
        NodeBase.prototype.removeNode = function (node) {
            var index = this._childNodes.indexOf(node);
            this._childNodes[index] = this._childNodes[--this._numChildNodes];
            this._childNodes.pop();
            var numEntities = node._numEntities;
            node = this;
            do
                node._numEntities -= numEntities;
            while ((node = node._parent) != null);
        };
        /**
         * 为给定实体查找分区节点
         * @param entity		实体
         * @return 				实体所在分区节点
         */
        NodeBase.prototype.findPartitionForEntity = function (entity) {
            entity = entity;
            return this;
        };
        /**
         * 接受横越者
         * @param traverser		访问节点的横越者
         */
        NodeBase.prototype.acceptTraverser = function (traverser) {
            if (this._numEntities == 0 && !this._debugPrimitive)
                return;
            if (traverser.enterNode(this)) {
                var i;
                while (i < this._numChildNodes)
                    this._childNodes[i++].acceptTraverser(traverser);
                if (this._debugPrimitive)
                    traverser.applyRenderable(this._debugPrimitive);
            }
        };
        /**
         * 创建调试边界
         */
        NodeBase.prototype.createDebugBounds = function () {
            return null;
        };
        /**
         * 更新多个实体
         * @param value 数量
         */
        NodeBase.prototype.updateNumEntities = function (value) {
            var diff = value - this._numEntities;
            var node = this;
            do
                node._numEntities += diff;
            while ((node = node._parent) != null);
        };
        /**
         * 测试是否出现在摄像机视锥体内
         * @param planes		视锥体面向量
         * @param numPlanes		面数
         * @return 				true：在视锥体内
         */
        NodeBase.prototype.isInFrustum = function (planes, numPlanes) {
            return true;
        };
        return NodeBase;
    }());
    feng3d.NodeBase = NodeBase;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 实体分区节点
     * @author feng 2015-3-8
     */
    var EntityNode = (function (_super) {
        __extends(EntityNode, _super);
        /**
         * 创建一个实体分区节点
         * @param entity		实体
         */
        function EntityNode(entity) {
            _super.call(this);
            this._entity = entity;
            this._numEntities = 1;
        }
        /**
         * 从父节点中移除
         */
        EntityNode.prototype.removeFromParent = function () {
            if (this._parent)
                this._parent.removeNode(this);
            this._parent = null;
        };
        Object.defineProperty(EntityNode.prototype, "entity", {
            /**
             * 实体
             */
            get: function () {
                return this._entity;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        EntityNode.prototype.isInFrustum = function (planes, numPlanes) {
            if (!this._entity.sceneVisible)
                return false;
            return this._entity.worldBounds.isInFrustum(planes, numPlanes);
        };
        return EntityNode;
    }(feng3d.NodeBase));
    feng3d.EntityNode = EntityNode;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 摄像机分区节点
     * @author feng 2015-3-21
     */
    var CameraNode = (function (_super) {
        __extends(CameraNode, _super);
        /**
         * 创建一个摄像机分区节点
         * @param camera		摄像机
         */
        function CameraNode(camera) {
            _super.call(this, camera);
        }
        /**
         * @inheritDoc
         */
        CameraNode.prototype.acceptTraverser = function (traverser) {
        };
        return CameraNode;
    }(feng3d.EntityNode));
    feng3d.CameraNode = CameraNode;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 方向光分区节点
     * @author feng 2015-3-21
     */
    var DirectionalLightNode = (function (_super) {
        __extends(DirectionalLightNode, _super);
        /**
         * 创建一个方向光分区节点
         * @param light 		方向光
         */
        function DirectionalLightNode(light) {
            _super.call(this, light);
            this._light = light;
        }
        Object.defineProperty(DirectionalLightNode.prototype, "light", {
            /**
             * 方向光
             */
            get: function () {
                return this._light;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        DirectionalLightNode.prototype.acceptTraverser = function (traverser) {
            if (traverser.enterNode(this)) {
                _super.prototype.acceptTraverser.call(this, traverser);
                traverser.applyDirectionalLight(this._light);
            }
        };
        return DirectionalLightNode;
    }(feng3d.EntityNode));
    feng3d.DirectionalLightNode = DirectionalLightNode;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 网格分区节点
     * @author feng 2015-3-8
     */
    var MeshNode = (function (_super) {
        __extends(MeshNode, _super);
        /**
         * 创建一个网格分区节点
         * @param mesh		网格
         */
        function MeshNode(mesh) {
            _super.call(this, mesh);
            this._mesh = mesh;
        }
        /**
         * @inheritDoc
         */
        MeshNode.prototype.acceptTraverser = function (traverser) {
            if (traverser.enterNode(this)) {
                _super.prototype.acceptTraverser.call(this, traverser);
                var subs = this._mesh.subMeshes;
                var i;
                var len = subs.length;
                while (i < len)
                    traverser.applyRenderable(subs[i++].renderableBase);
            }
        };
        return MeshNode;
    }(feng3d.EntityNode));
    feng3d.MeshNode = MeshNode;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 点光源分区节点
     * @author feng 2015-3-23
     */
    var PointLightNode = (function (_super) {
        __extends(PointLightNode, _super);
        /**
         * 创建一个点光源分区节点
         * @param light		点光源
         */
        function PointLightNode(light) {
            _super.call(this, light);
            this._light = light;
        }
        Object.defineProperty(PointLightNode.prototype, "light", {
            /**
             * 点光源
             */
            get: function () {
                return this._light;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        PointLightNode.prototype.acceptTraverser = function (traverser) {
            if (traverser.enterNode(this)) {
                _super.prototype.acceptTraverser.call(this, traverser);
                traverser.applyPointLight(this._light);
            }
        };
        return PointLightNode;
    }(feng3d.EntityNode));
    feng3d.PointLightNode = PointLightNode;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * RenderableNode is a space partitioning leaf node that contains any Entity that is itself a IRenderable
     * object. This excludes Mesh (since the renderable objects are its SubMesh children).
     */
    var RenderableNode = (function (_super) {
        __extends(RenderableNode, _super);
        /**
         * Creates a new RenderableNode object.
         * @param mesh The mesh to be contained in the node.
         */
        function RenderableNode(renderable) {
            _super.call(this, feng3d.as(renderable, feng3d.Entity));
            this._renderable = renderable; // also keep a stronger typed reference
        }
        /**
         * @inheritDoc
         */
        RenderableNode.prototype.acceptTraverser = function (traverser) {
            if (traverser.enterNode(this)) {
                _super.prototype.acceptTraverser.call(this, traverser);
                traverser.applyRenderable(this._renderable);
            }
        };
        return RenderableNode;
    }(feng3d.EntityNode));
    feng3d.RenderableNode = RenderableNode;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 天空盒分区节点
     * @author feng 2015-3-8
     */
    var SkyBoxNode = (function (_super) {
        __extends(SkyBoxNode, _super);
        /**
         * 创建SkyBoxNode实例
         * @param skyBox		天空盒实例
         */
        function SkyBoxNode(skyBox) {
            _super.call(this, skyBox);
            this._skyBox = skyBox;
        }
        /**
         * @inheritDoc
         */
        SkyBoxNode.prototype.acceptTraverser = function (traverser) {
            if (traverser.enterNode(this)) {
                _super.prototype.acceptTraverser.call(this, traverser);
                traverser.applySkyBox(this._skyBox);
            }
        };
        /**
         * @inheritDoc
         */
        SkyBoxNode.prototype.isInFrustum = function (planes, numPlanes) {
            planes = planes;
            numPlanes = numPlanes;
            return true;
        };
        return SkyBoxNode;
    }(feng3d.EntityNode));
    feng3d.SkyBoxNode = SkyBoxNode;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 空分区节点
     * @author feng 2015-3-9
     */
    var NullNode = (function (_super) {
        __extends(NullNode, _super);
        /**
         * 创建一个空分区节点
         */
        function NullNode() {
            _super.call(this);
        }
        return NullNode;
    }(feng3d.NodeBase));
    feng3d.NullNode = NullNode;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 3D空间分区
     * <p>用于把3D空间分区，便于搜索出有必要渲染的对象，从而优化性能</p>
     * @author feng 2015-3-5
     */
    var Partition3D = (function () {
        /**
         * 创建一个3D空间分区
         * @param rootNode	根节点
         */
        function Partition3D(rootNode) {
            this._rootNode = rootNode || new feng3d.NullNode();
        }
        /**
         * 发送一个横越者穿过分区
         * @param traverser		横越者
         */
        Partition3D.prototype.traverse = function (traverser) {
            if (this._updatesMade)
                this.updateEntities();
            //更新收集标记
            ++feng3d.PartitionTraverser._collectionMark;
            //接受一个穿越者来收集实体
            this._rootNode.acceptTraverser(traverser);
        };
        /**
         * 从分区树种移除实体
         * @param entity 被移除实体
         */
        Partition3D.prototype.removeEntity = function (entity) {
            var node = entity.getEntityPartitionNode();
            var t;
            //从父节点中移除
            node.removeFromParent();
            //链表中移除节点
            if (node == this._updateQueue)
                this._updateQueue = node._updateQueueNext;
            else {
                t = this._updateQueue;
                while (t && t._updateQueueNext != node)
                    t = t._updateQueueNext;
                //连接删除节点的前节点与后节点
                if (t)
                    t._updateQueueNext = node._updateQueueNext;
            }
            //清空删除节点的next指针
            node._updateQueueNext = null;
            if (!this._updateQueue)
                this._updatesMade = false;
        };
        /**
         * 标记为待更新节点，把新节点添加到待更新节点链表表头
         * @param entity	更新的实体
         */
        Partition3D.prototype.markForUpdate = function (entity) {
            var node = entity.getEntityPartitionNode();
            //链表中添加节点到表头
            var t = this._updateQueue;
            //判断节点是否已经存在链表中
            while (t) {
                if (node == t)
                    return;
                t = t._updateQueueNext;
            }
            //把表头添加到新节点的next指针
            node._updateQueueNext = this._updateQueue;
            //把新节点设置为表头
            this._updateQueue = node;
            this._updatesMade = true;
        };
        /**
         * 更新待更新节点中的实体
         */
        Partition3D.prototype.updateEntities = function () {
            var node = this._updateQueue;
            var targetNode;
            var t;
            //为了重新标记实体，清除更新队列
            this._updateQueue = null;
            this._updatesMade = false;
            do {
                targetNode = this._rootNode.findPartitionForEntity(node.entity);
                // 更新 待更新链表中节点的父节点
                if (node.parent != targetNode) {
                    if (node)
                        node.removeFromParent();
                    targetNode.addNode(node);
                }
                //获取链表中下个节点
                t = node._updateQueueNext;
                node._updateQueueNext = null;
                //调用节点实体的内部更新
                node.entity.internalUpdate();
            } while ((node = t) != null);
        };
        return Partition3D;
    }());
    feng3d.Partition3D = Partition3D;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     *
     * @author feng 2014-4-30
     */
    var PickingColliderBase = (function () {
        function PickingColliderBase() {
        }
        /**
         * 获取碰撞法线
         * @param indexData 顶点索引数据
         * @param vertexData 顶点数据
         * @param triangleIndex 三角形索引
         * @param normal 碰撞法线
         * @return 碰撞法线
         *
         */
        PickingColliderBase.prototype.getCollisionNormal = function (indexData, vertexData, triangleIndex, normal) {
            if (normal === void 0) { normal = null; }
            var i0 = indexData[triangleIndex] * 3;
            var i1 = indexData[triangleIndex + 1] * 3;
            var i2 = indexData[triangleIndex + 2] * 3;
            var side0x = vertexData[i1] - vertexData[i0];
            var side0y = vertexData[i1 + 1] - vertexData[i0 + 1];
            var side0z = vertexData[i1 + 2] - vertexData[i0 + 2];
            var side1x = vertexData[i2] - vertexData[i0];
            var side1y = vertexData[i2 + 1] - vertexData[i0 + 1];
            var side1z = vertexData[i2 + 2] - vertexData[i0 + 2];
            if (!normal)
                normal = new feng3d.Vector3D();
            normal.x = side0y * side1z - side0z * side1y;
            normal.y = side0z * side1x - side0x * side1z;
            normal.z = side0x * side1y - side0y * side1x;
            normal.w = 1;
            normal.normalize();
            return normal;
        };
        /**
         * 获取碰撞uv
         * @param indexData 顶点数据
         * @param uvData uv数据
         * @param triangleIndex 三角形所有
         * @param v
         * @param w
         * @param u
         * @param uvOffset
         * @param uvStride
         * @param uv uv坐标
         * @return 碰撞uv
         */
        PickingColliderBase.prototype.getCollisionUV = function (indexData, uvData, triangleIndex, v, w, u, uvOffset, uvStride, uv) {
            if (uv === void 0) { uv = null; }
            var uIndex = indexData[triangleIndex] * uvStride + uvOffset;
            var uv0x = uvData[uIndex];
            var uv0y = uvData[uIndex + 1];
            uIndex = indexData[triangleIndex + 1] * uvStride + uvOffset;
            var uv1x = uvData[uIndex];
            var uv1y = uvData[uIndex + 1];
            uIndex = indexData[triangleIndex + 2] * uvStride + uvOffset;
            var uv2x = uvData[uIndex];
            var uv2y = uvData[uIndex + 1];
            if (!uv)
                uv = new feng3d.Point();
            uv.x = u * uv0x + v * uv1x + w * uv2x;
            uv.y = u * uv0y + v * uv1y + w * uv2y;
            return uv;
        };
        /**
         * 设置碰撞射线
         */
        PickingColliderBase.prototype.setLocalRay = function (ray3D) {
            this.ray3D = ray3D;
        };
        return PickingColliderBase;
    }());
    feng3d.PickingColliderBase = PickingColliderBase;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 使用纯AS3计算与实体相交
     */
    var AS3PickingCollider = (function (_super) {
        __extends(AS3PickingCollider, _super);
        /**
         * 创建一个AS碰撞检测器
         * @param findClosestCollision 是否查找最短距离碰撞
         */
        function AS3PickingCollider(findClosestCollision) {
            if (findClosestCollision === void 0) { findClosestCollision = false; }
            _super.call(this);
            this._findClosestCollision = findClosestCollision;
        }
        AS3PickingCollider.prototype.testSubMeshCollision = function (subMesh, pickingCollisionVO, shortestCollisionDistance, bothSides) {
            if (bothSides === void 0) { bothSides = true; }
            var t;
            var i0, i1, i2;
            var rx, ry, rz;
            var nx, ny, nz;
            var cx, cy, cz;
            var coeff, u, v, w;
            var p0x, p0y, p0z;
            var p1x, p1y, p1z;
            var p2x, p2y, p2z;
            var s0x, s0y, s0z;
            var s1x, s1y, s1z;
            var nl, nDotV, D, disToPlane;
            var Q1Q2, Q1Q1, Q2Q2, RQ1, RQ2;
            var subGeom = subMesh.subGeometry;
            var indexData = subGeom.indexData;
            var vertexData = subGeom.vertexPositionData;
            var uvData = subGeom.UVData;
            var collisionTriangleIndex = -1;
            var vertexStride = subGeom.vertexPositionStride;
            var vertexOffset = 0;
            var uvStride = subGeom.UVStride;
            var numIndices = indexData.length;
            //遍历每个三角形 检测碰撞
            for (var index = 0; index < numIndices; index += 3) {
                //三角形三个顶点索引
                i0 = vertexOffset + indexData[index] * vertexStride;
                i1 = vertexOffset + indexData[index + 1] * vertexStride;
                i2 = vertexOffset + indexData[index + 2] * vertexStride;
                //三角形三个顶点数据
                p0x = vertexData[i0];
                p0y = vertexData[i0 + 1];
                p0z = vertexData[i0 + 2];
                p1x = vertexData[i1];
                p1y = vertexData[i1 + 1];
                p1z = vertexData[i1 + 2];
                p2x = vertexData[i2];
                p2y = vertexData[i2 + 1];
                p2z = vertexData[i2 + 2];
                //计算出三角面的法线
                s0x = p1x - p0x; // s0 = p1 - p0
                s0y = p1y - p0y;
                s0z = p1z - p0z;
                s1x = p2x - p0x; // s1 = p2 - p0
                s1y = p2y - p0y;
                s1z = p2z - p0z;
                nx = s0y * s1z - s0z * s1y; // n = s0 x s1
                ny = s0z * s1x - s0x * s1z;
                nz = s0x * s1y - s0y * s1x;
                nl = 1 / Math.sqrt(nx * nx + ny * ny + nz * nz); // normalize n
                nx *= nl;
                ny *= nl;
                nz *= nl;
                //初始化射线数据
                var rayPosition = this.ray3D.position;
                var rayDirection = this.ray3D.direction;
                //计算射线与法线的点积，不等于零表示射线所在直线与三角面相交
                nDotV = nx * rayDirection.x + ny * +rayDirection.y + nz * rayDirection.z; // rayDirection . normal
                //判断射线是否与三角面相交
                if ((!bothSides && nDotV < 0.0) || (bothSides && nDotV != 0.0)) {
                    //计算平面方程D值，参考Plane3D
                    D = -(nx * p0x + ny * p0y + nz * p0z);
                    //射线点到平面的距离
                    disToPlane = -(nx * rayPosition.x + ny * rayPosition.y + nz * rayPosition.z + D);
                    t = disToPlane / nDotV;
                    //得到交点
                    cx = rayPosition.x + t * rayDirection.x;
                    cy = rayPosition.y + t * rayDirection.y;
                    cz = rayPosition.z + t * rayDirection.z;
                    //判断交点是否在三角形内( using barycentric coordinates )
                    Q1Q2 = s0x * s1x + s0y * s1y + s0z * s1z;
                    Q1Q1 = s0x * s0x + s0y * s0y + s0z * s0z;
                    Q2Q2 = s1x * s1x + s1y * s1y + s1z * s1z;
                    rx = cx - p0x;
                    ry = cy - p0y;
                    rz = cz - p0z;
                    RQ1 = rx * s0x + ry * s0y + rz * s0z;
                    RQ2 = rx * s1x + ry * s1y + rz * s1z;
                    coeff = 1 / (Q1Q1 * Q2Q2 - Q1Q2 * Q1Q2);
                    v = coeff * (Q2Q2 * RQ1 - Q1Q2 * RQ2);
                    w = coeff * (-Q1Q2 * RQ1 + Q1Q1 * RQ2);
                    if (v < 0)
                        continue;
                    if (w < 0)
                        continue;
                    u = 1 - v - w;
                    //u v w都大于0表示点在三角形内 射线的坐标t大于0表示射线朝向三角面
                    if (!(u < 0) && t > 0 && t < shortestCollisionDistance) {
                        shortestCollisionDistance = t;
                        collisionTriangleIndex = index / 3;
                        pickingCollisionVO.rayEntryDistance = t;
                        pickingCollisionVO.localPosition = new feng3d.Vector3D(cx, cy, cz);
                        pickingCollisionVO.localNormal = new feng3d.Vector3D(nx, ny, nz);
                        pickingCollisionVO.uv = this.getCollisionUV(indexData, uvData, index, v, w, u, 0, uvStride);
                        pickingCollisionVO.index = index;
                        //是否继续寻找最优解
                        if (!this._findClosestCollision)
                            return true;
                    }
                }
            }
            if (collisionTriangleIndex >= 0)
                return true;
            return false;
        };
        return AS3PickingCollider;
    }(feng3d.PickingColliderBase));
    feng3d.AS3PickingCollider = AS3PickingCollider;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 定义检测相交的工具类
     * @author feng 2014-4-30
     */
    var PickingColliderType = (function () {
        function PickingColliderType() {
        }
        /**
         * Default null collider that forces picker to only use entity bounds for hit calculations on an Entity
         */
        PickingColliderType.BOUNDS_ONLY = null;
        /**
         * 使用纯AS3计算与实体相交
         */
        PickingColliderType.AS3_BEST_HIT = new feng3d.AS3PickingCollider(true);
        return PickingColliderType;
    }());
    feng3d.PickingColliderType = PickingColliderType;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 采集的碰撞数据
     * @author feng 2014-4-29
     */
    var PickingCollisionVO = (function () {
        /**
         * 创建射线拾取碰撞数据
         * @param entity
         */
        function PickingCollisionVO(entity) {
            /**
             * 本地坐标系射线
             */
            this.localRay = new feng3d.Ray3D();
            /**
             * 场景中碰撞射线
             */
            this.ray3D = new feng3d.Ray3D();
            this.firstEntity = entity;
        }
        Object.defineProperty(PickingCollisionVO.prototype, "scenePosition", {
            /**
             * 实体上碰撞世界坐标
             */
            get: function () {
                return feng3d.Matrix3DUtils.transformVector(this.firstEntity.sceneTransform, this.localPosition);
            },
            enumerable: true,
            configurable: true
        });
        return PickingCollisionVO;
    }());
    feng3d.PickingCollisionVO = PickingCollisionVO;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 光线投射采集
     * @author feng 2014-4-29
     */
    var RaycastPicker = (function () {
        /**
         *
         * @param findClosestCollision 是否需要寻找最接近的
         */
        function RaycastPicker(findClosestCollision) {
            this._findClosestCollision = findClosestCollision;
        }
        /**
         * 获取射线穿过的实体
         * @param ray3D 射线
         * @param entitys 实体列表
         * @return
         */
        RaycastPicker.prototype.getViewCollision = function (ray3D, entitys) {
            var _this = this;
            this._entities = [];
            if (entitys.length == 0)
                return null;
            entitys.forEach(function (entity) {
                if (entity.isIntersectingRay(ray3D))
                    _this._entities.push(entity);
            });
            if (this._entities.length == 0)
                return null;
            return this.getPickingCollisionVO();
        };
        /**
         *获取射线穿过的实体
         */
        RaycastPicker.prototype.getPickingCollisionVO = function () {
            // Sort entities from closest to furthest.
            this._entities = this._entities.sort(this.sortOnNearT);
            // ---------------------------------------------------------------------
            // Evaluate triangle collisions when needed.
            // Replaces collision data provided by bounds collider with more precise data.
            // ---------------------------------------------------------------------
            var shortestCollisionDistance = Number.MAX_VALUE;
            var bestCollisionVO;
            var pickingCollisionVO;
            var entity;
            var i;
            for (i = 0; i < this._entities.length; ++i) {
                entity = this._entities[i];
                pickingCollisionVO = entity._pickingCollisionVO;
                if (entity.pickingCollider) {
                    // If a collision exists, update the collision data and stop all checks.
                    if ((bestCollisionVO == null || pickingCollisionVO.rayEntryDistance < bestCollisionVO.rayEntryDistance) && entity.collidesBefore(shortestCollisionDistance, this._findClosestCollision)) {
                        shortestCollisionDistance = pickingCollisionVO.rayEntryDistance;
                        bestCollisionVO = pickingCollisionVO;
                        if (!this._findClosestCollision) {
                            this.updateLocalPosition(pickingCollisionVO);
                            return pickingCollisionVO;
                        }
                    }
                }
                else if (bestCollisionVO == null || pickingCollisionVO.rayEntryDistance < bestCollisionVO.rayEntryDistance) {
                    // Note: a bounds collision with a ray origin inside its bounds is ONLY ever used
                    // to enable the detection of a corresponsding triangle collision.
                    // Therefore, bounds collisions with a ray origin inside its bounds can be ignored
                    // if it has been established that there is NO triangle collider to test
                    if (!pickingCollisionVO.rayOriginIsInsideBounds) {
                        this.updateLocalPosition(pickingCollisionVO);
                        return pickingCollisionVO;
                    }
                }
            }
            return bestCollisionVO;
        };
        /**
         * 按与射线原点距离排序
         */
        RaycastPicker.prototype.sortOnNearT = function (entity1, entity2) {
            return entity1.pickingCollisionVO.rayEntryDistance > entity2.pickingCollisionVO.rayEntryDistance ? 1 : -1;
        };
        /**
         * 更新碰撞本地坐标
         * @param pickingCollisionVO
         */
        RaycastPicker.prototype.updateLocalPosition = function (pickingCollisionVO) {
            pickingCollisionVO.localPosition = pickingCollisionVO.localRay.getPoint(pickingCollisionVO.rayEntryDistance);
        };
        return RaycastPicker;
    }());
    feng3d.RaycastPicker = RaycastPicker;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    //[Event(name = "enterFrame", type = "flash.events.Event")]
    //[Event(name = "exitFrame", type = "flash.events.Event")]
    /**
     * 3D舞台代理
     */
    var Stage3DProxy = (function (_super) {
        __extends(Stage3DProxy, _super);
        /**
         * 创建一个3D舞台代理
         * @param stage3DIndex		被代理3D舞台编号
         * @param stage3D			被代理的3D舞台
         * @param stage3DManager	3D舞台管理类
         * @param forceSoftware		是否强制软件渲染
         * @param profile
         */
        function Stage3DProxy(stage3DIndex, stage3D, stage3DManager, forceSoftware, profile) {
            if (forceSoftware === void 0) { forceSoftware = false; }
            if (profile === void 0) { profile = "baseline"; }
            _super.call(this);
            this._frameEventDriver = new feng3d.Shape();
            this._stage3DIndex = -1;
            this._backBufferEnableDepthAndStencil = true;
            this._stage3DIndex = stage3DIndex;
            this._stage3D = stage3D;
            this._stage3D.x = 0;
            this._stage3D.y = 0;
            this._stage3D.visible = true;
            this._stage3DManager = stage3DManager;
            this._viewPort = new feng3d.Rectangle();
            this._stage3D.addEventListener(feng3d.Event.CONTEXT3D_CREATE, this.onContext3DUpdate, 1000, false);
            this.requestContext(forceSoftware, profile);
        }
        Object.defineProperty(Stage3DProxy.prototype, "color", {
            /**
             * The background color of the Stage3D.
             */
            get: function () {
                return this._color;
            },
            set: function (color) {
                this._color = color;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 通知视窗发生变化
         */
        Stage3DProxy.prototype.notifyViewportUpdated = function () {
            if (this._viewportDirty)
                return;
            this._viewportDirty = true;
            if (!this.hasEventListener(feng3d.Stage3DEvent.VIEWPORT_UPDATED))
                return;
            this._viewportUpdated = new feng3d.Stage3DEvent(feng3d.Stage3DEvent.VIEWPORT_UPDATED);
            this.dispatchEvent(this._viewportUpdated);
        };
        /**
         * 通知进入帧事件
         */
        Stage3DProxy.prototype.notifyEnterFrame = function () {
            if (!this.hasEventListener(feng3d.Event.ENTER_FRAME))
                return;
            if (!this._enterFrame)
                this._enterFrame = new feng3d.Event(feng3d.Event.ENTER_FRAME);
            this.dispatchEvent(this._enterFrame);
        };
        /**
         * 通知退出帧事件
         */
        Stage3DProxy.prototype.notifyExitFrame = function () {
            if (!this.hasEventListener(feng3d.Event.EXIT_FRAME))
                return;
            if (!this._exitFrame)
                this._exitFrame = new feng3d.Event(feng3d.Event.EXIT_FRAME);
            this.dispatchEvent(this._exitFrame);
        };
        /**
         * 释放3D舞台代理，同时释放3D舞台中的3D环境
         */
        Stage3DProxy.prototype.dispose = function () {
            this._stage3DManager.removeStage3DProxy(this);
            this._stage3D.removeEventListener(feng3d.Event.CONTEXT3D_CREATE, this.onContext3DUpdate);
            this.freeContext3D();
            this._stage3D = null;
            this._stage3DManager = null;
            this._stage3DIndex = -1;
        };
        /**
         * 设置渲染缓冲区的视口尺寸和其他属性
         * @param backBufferWidth		缓冲区的宽度，以像素为单位。
         * @param backBufferHeight		缓冲区的高度，以像素为单位。
         * @param antiAlias				一个整数值，指定所请求的消除锯齿品质。该值与消除锯齿时使用的子实例的数量相关联。使用更多子实例要求执行更多的计算，尽管相对性能影响取决于特定的渲染硬件。消除锯齿的类型和是否执行消除锯齿操作取决于设备和渲染模式。软件渲染上下文完全不支持消除锯齿。
         */
        Stage3DProxy.prototype.configureBackBuffer = function (backBufferWidth, backBufferHeight, antiAlias) {
            if (backBufferWidth < 50)
                backBufferWidth = 50;
            if (backBufferHeight < 50)
                backBufferHeight = 50;
            var oldWidth = this._backBufferWidth;
            var oldHeight = this._backBufferHeight;
            this._backBufferWidth = this._viewPort.width = backBufferWidth;
            this._backBufferHeight = this._viewPort.height = backBufferHeight;
            if (oldWidth != this._backBufferWidth || oldHeight != this._backBufferHeight)
                this.notifyViewportUpdated();
            this._antiAlias = antiAlias;
            if (this._context3D)
                this._context3D.configureBackBuffer(backBufferWidth, backBufferHeight, antiAlias, this._backBufferEnableDepthAndStencil);
        };
        /**
         * 清除与重置缓冲区
         */
        Stage3DProxy.prototype.clear = function () {
            if (!this._context3D)
                return;
            if (this._backBufferDirty) {
                this.configureBackBuffer(this._backBufferWidth, this._backBufferHeight, this._antiAlias);
                this._backBufferDirty = false;
            }
            this._context3D.clear(//
            ((this._color >> 16) & 0xff) / 255.0, //
            ((this._color >> 8) & 0xff) / 255.0, //
            (this._color & 0xff) / 255.0, //
            ((this._color >> 24) & 0xff) / 255.0);
            this._bufferClear = true;
        };
        /**
         * 显示渲染缓冲
         */
        Stage3DProxy.prototype.present = function () {
            if (!this._context3D)
                return;
            this._context3D.present();
        };
        /**
         * 添加事件侦听
         * @param type							事件的类型
         * @param listener						处理事件的侦听器函数
         * @param useCapture					确定侦听器是运行于捕获阶段还是运行于目标和冒泡阶段
         * @param priority						事件侦听器的优先级。优先级由一个带符号的 32 位整数指定。数字越大，优先级越高。优先级为 n 的所有侦听器会在优先级为 n -1 的侦听器之前得到处理。如果两个或更多个侦听器共享相同的优先级，则按照它们的添加顺序进行处理。默认优先级为 0。
         * @param useWeakReference				确定对侦听器的引用是强引用，还是弱引用。强引用（默认值）可防止您的侦听器被当作垃圾回收。弱引用则没有此作用。
         */
        Stage3DProxy.prototype.addEventListener = function (type, listener, priority, useWeakReference) {
            if (priority === void 0) { priority = 0; }
            if (useWeakReference === void 0) { useWeakReference = false; }
            _super.prototype.addEventListener.call(this, type, listener, priority, useWeakReference);
            if ((type == feng3d.Event.ENTER_FRAME || type == feng3d.Event.EXIT_FRAME) && !this._frameEventDriver.hasEventListener(feng3d.Event.ENTER_FRAME))
                this._frameEventDriver.addEventListener(feng3d.Event.ENTER_FRAME, this.onEnterFrame, priority, useWeakReference);
        };
        /**
         * 移除事件侦听
         * @param type				事件的类型
         * @param listener			要删除的侦听器函数
         * @param useCapture		指出是为捕获阶段还是为目标和冒泡阶段注册了侦听器。如果为捕获阶段以及目标和冒泡阶段注册了侦听器，则需要对 removeEventListener() 进行两次调用才能将这两个侦听器删除，一次调用将 useCapture() 设置为 true，另一次调用将 useCapture() 设置为 false。
         */
        Stage3DProxy.prototype.removeEventListener = function (type, listener) {
            _super.prototype.removeEventListener.call(this, type, listener);
            // Remove the main rendering listener if no EnterFrame listeners remain
            if (!this.hasEventListener(feng3d.Event.ENTER_FRAME) && !this.hasEventListener(feng3d.Event.EXIT_FRAME) && this._frameEventDriver.hasEventListener(feng3d.Event.ENTER_FRAME))
                this._frameEventDriver.removeEventListener(feng3d.Event.ENTER_FRAME, this.onEnterFrame);
        };
        Object.defineProperty(Stage3DProxy.prototype, "scissorRect", {
            /**
             * 裁剪矩形
             */
            get: function () {
                return this._scissorRect;
            },
            set: function (value) {
                this._scissorRect = value;
                this._context3D.setScissorRectangle(this._scissorRect);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Stage3DProxy.prototype, "stage3DIndex", {
            /**
             * 3D舞台编号
             */
            get: function () {
                return this._stage3DIndex;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Stage3DProxy.prototype, "stage3D", {
            /**
             * 3D舞台
             */
            get: function () {
                return this._stage3D;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Stage3DProxy.prototype, "context3D", {
            /**
             * 3D环境
             */
            get: function () {
                return this._context3D;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Stage3DProxy.prototype, "driverInfo", {
            /**
             * 驱动信息
             */
            get: function () {
                return this._context3D ? this._context3D.driverInfo : null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Stage3DProxy.prototype, "usesSoftwareRendering", {
            /**
             * 是否在软件模式渲染
             */
            get: function () {
                return this._usesSoftwareRendering;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Stage3DProxy.prototype, "x", {
            /**
             * 3D舞台X坐标
             */
            get: function () {
                return this._stage3D.x;
            },
            set: function (value) {
                if (this._viewPort.x == value)
                    return;
                this._stage3D.x = this._viewPort.x = value;
                this.notifyViewportUpdated();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Stage3DProxy.prototype, "y", {
            /**
             * 3D舞台Y坐标
             */
            get: function () {
                return this._stage3D.y;
            },
            set: function (value) {
                if (this._viewPort.y == value)
                    return;
                this._stage3D.y = this._viewPort.y = value;
                this.notifyViewportUpdated();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Stage3DProxy.prototype, "width", {
            /**
             * 3D舞台宽度
             */
            get: function () {
                return this._backBufferWidth;
            },
            set: function (width) {
                if (this._viewPort.width == width)
                    return;
                if (width < 50)
                    width = 50;
                this._backBufferWidth = this._viewPort.width = width;
                this._backBufferDirty = true;
                this.notifyViewportUpdated();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Stage3DProxy.prototype, "height", {
            /**
             * 3D舞台高度
             */
            get: function () {
                return this._backBufferHeight;
            },
            set: function (height) {
                if (this._viewPort.height == height)
                    return;
                if (height < 50)
                    height = 50;
                this._backBufferHeight = this._viewPort.height = height;
                this._backBufferDirty = true;
                this.notifyViewportUpdated();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Stage3DProxy.prototype, "antiAlias", {
            /**
             * 抗锯齿值
             */
            get: function () {
                return this._antiAlias;
            },
            set: function (antiAlias) {
                this._antiAlias = antiAlias;
                this._backBufferDirty = true;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Stage3DProxy.prototype, "viewPort", {
            /**
             * 视窗矩形
             */
            get: function () {
                this._viewportDirty = false;
                return this._viewPort;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Stage3DProxy.prototype, "visible", {
            /**
             * 是否可见
             */
            get: function () {
                return this._stage3D.visible;
            },
            set: function (value) {
                this._stage3D.visible = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Stage3DProxy.prototype, "bufferClear", {
            /**
             * 缓冲区清理状态
             */
            get: function () {
                return this._bufferClear;
            },
            set: function (newBufferClear) {
                this._bufferClear = newBufferClear;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 释放3D环境
         */
        Stage3DProxy.prototype.freeContext3D = function () {
            if (this._context3D) {
                this._context3D.dispose();
                this.dispatchEvent(new feng3d.Stage3DEvent(feng3d.Stage3DEvent.CONTEXT3D_DISPOSED));
            }
            this._context3D = null;
        };
        /**
         * 处理3D环境变化事件
         */
        Stage3DProxy.prototype.onContext3DUpdate = function (event) {
            if (this._stage3D.context3D) {
                var hadContext = (this._context3D != null);
                this._context3D = this._stage3D.context3D;
                this._context3D.enableErrorChecking = feng3d.Debug.agalDebug;
                this._usesSoftwareRendering = (this._context3D.driverInfo.indexOf('Software') == 0);
                // Only configure back buffer if this.width and this.height have been set,
                // which they may not have been if View3D.render() has yet to be
                // invoked for the first time.
                if (this._backBufferWidth && this._backBufferHeight)
                    this._context3D.configureBackBuffer(this._backBufferWidth, this._backBufferHeight, this._antiAlias, this._backBufferEnableDepthAndStencil);
                // Dispatch the appropriate event depending on whether context was
                // created for the first time or recreated after a device loss.
                this.dispatchEvent(new feng3d.Stage3DEvent(hadContext ? feng3d.Stage3DEvent.CONTEXT3D_RECREATED : feng3d.Stage3DEvent.CONTEXT3D_CREATED));
            }
            else
                throw new Error("Rendering context lost!");
        };
        /**
         * 请求3D环境
         */
        Stage3DProxy.prototype.requestContext = function (forceSoftware, profile) {
            if (forceSoftware === void 0) { forceSoftware = false; }
            if (profile === void 0) { profile = feng3d.Context3DProfile.STANDARD; }
            // If forcing software, we can be certain that the
            // returned Context3D will be running software mode.
            // If not, we can't be sure and should stick to the
            // old value (will likely be same if re-requesting.)
            this._usesSoftwareRendering = this._usesSoftwareRendering || forceSoftware;
            this._profile = profile;
            // ugly stuff for backward compatibility
            var renderMode = forceSoftware ? feng3d.Context3DRenderMode.SOFTWARE : feng3d.Context3DRenderMode.AUTO;
            if (profile == "baseline")
                this._stage3D.requestContext3D(renderMode);
            else {
                try {
                    this._stage3D.requestContext3D(renderMode, profile);
                }
                catch (error) {
                    throw "An error occurred creating a context using the given profile. Profiles are not supported for the SDK this was compiled with.";
                }
            }
            this._contextRequested = true;
        };
        /**
         * 处理进入帧事件
         */
        Stage3DProxy.prototype.onEnterFrame = function (event) {
            if (!this._context3D)
                return;
            this.clear();
            this.notifyEnterFrame();
            this.present();
            this.notifyExitFrame();
        };
        /**
         *	判断3D环境是否可用
         */
        Stage3DProxy.prototype.recoverFromDisposal = function () {
            if (!this._context3D)
                return false;
            if (this._context3D.driverInfo == "Disposed") {
                this._context3D = null;
                this.dispatchEvent(new feng3d.Stage3DEvent(feng3d.Stage3DEvent.CONTEXT3D_DISPOSED));
                return false;
            }
            return true;
        };
        return Stage3DProxy;
    }(feng3d.EventDispatcher));
    feng3d.Stage3DProxy = Stage3DProxy;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 寄存器(链表)
     * @author feng 2014-6-9
     */
    var Register = (function () {
        /**
         * 创建一个寄存器
         * @param regId			寄存器id
         */
        function Register(regId) {
            this._index = -1;
            this._regId = regId;
            this.init();
        }
        Object.defineProperty(Register.prototype, "valueString", {
            get: function () {
                if (this._regType != feng3d.RegisterType.OP && this._regType != feng3d.RegisterType.OC)
                    return this._regType + this._index;
                return this._regType;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Register.prototype, "nameString", {
            get: function () {
                return this.regId;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Register.prototype, "index", {
            /**
             * 寄存器编号
             */
            get: function () {
                return this._index;
            },
            set: function (value) {
                this._index = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Register.prototype, "regId", {
            /** 寄存器id */
            get: function () {
                return this._regId;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Register.prototype, "regType", {
            get: function () {
                return this._regType;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 初始化
         */
        Register.prototype.init = function () {
            var bufferType = feng3d.Context3DBufferTypeManager.getBufferType(this._regId);
            this._regType = bufferType.registerType;
            this._index = -1;
        };
        /**
         * @inheritDoc
         */
        Register.prototype.toString = function () {
            if (Register.TO_STRING == Register.NAME)
                return this.nameString;
            return this.valueString;
        };
        /**
         * 寄存器分量
         * @param component 分量编号
         * @return 寄存器分量
         */
        Register.prototype.c = function (component) {
            return new feng3d.RegisterComponent(this, Register.COMPONENTS[component]);
        };
        /**
         * 获取寄存器分量
         * @param name 分量名称
         * @return
         */
        Register.prototype.getProperty = function (name) {
            var components = name;
            if (components.length == 0)
                throw new Error("无效寄存器分量: " + this + "." + components);
            if (components.length > 4)
                throw new Error("无效寄存器分量: " + this + "." + components);
            for (var i = 0; i < components.length; i++) {
                if (!feng3d.RegisterComponent.valid(components.substr(i, 1)))
                    throw new Error("无效寄存器分量: " + this + "." + components);
            }
            if (components.length == 1) {
                return new feng3d.RegisterComponent(this, components.toLowerCase());
            }
            return new feng3d.RegisterComponentSelection(this, components.toLowerCase());
        };
        /**
         * @inheritDoc
         */
        Register.prototype.callProperty = function (name) {
            var parameters = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                parameters[_i - 1] = arguments[_i];
            }
            return null;
        };
        Object.defineProperty(Register.prototype, "desc", {
            /**
             * @inheritDoc
             */
            get: function () {
                var str = this.regId + ":";
                if (this.index != -1) {
                    str += this.valueString;
                }
                if (this.description && this.description.length > 0)
                    return str += "[" + this.description + "]";
                return str;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Register.prototype, "regLen", {
            /**
             * @inheritDoc
             */
            get: function () {
                return 1;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 清理寄存器值
         */
        Register.prototype.clear = function () {
            this.index = -1;
        };
        /**
         * 输出寄存器名称
         */
        Register.NAME = "name";
        /**
         * 输出寄存器值
         */
        Register.VALUE = "value";
        /**
         * 寄存器输出方式
         */
        Register.TO_STRING = Register.NAME;
        /**
         * 寄存器中元素数组
         */
        Register.COMPONENTS = ["x", "y", "z", "w"];
        return Register;
    }());
    feng3d.Register = Register;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 寄存器数组
     * @author feng 2014-11-4
     */
    var RegisterArray = (function (_super) {
        __extends(RegisterArray, _super);
        /**
         * 创建一个寄存器数组
         * @param regId		寄存器id
         */
        function RegisterArray(regId) {
            _super.call(this, regId);
            this._regs = [];
            this._regs.length = 1;
        }
        Object.defineProperty(RegisterArray.prototype, "first", {
            /**
             * 第一个寄存器
             */
            get: function () {
                return this.getReg(0);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RegisterArray.prototype, "last", {
            /**
             * 最后一个寄存器
             */
            get: function () {
                return this.getReg(this._regs.length - 1);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 获取寄存器链表中的元素
         * @param $index 链表中的位置
         * @return 寄存器
         */
        RegisterArray.prototype.getReg = function ($index) {
            if (this._regs.length < $index + 1) {
                this._regs.length = $index + 1;
            }
            if (!this._regs[$index]) {
                var reg = new feng3d.RegisterArrayItem(this, $index);
                this._regs[$index] = reg;
            }
            return this._regs[$index];
        };
        /**
         * 获取寄存器数组中的寄存器
         * @param args 索引信息
         * @return
         */
        RegisterArray.prototype.getReg1 = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var index = 0;
            var complexArgs = [];
            for (var i = 0; i < args.length; i++) {
                if (feng3d.is(args[i], Number)) {
                    index += args[i];
                }
                else {
                    complexArgs.push(args[i]);
                }
            }
            if (complexArgs.length == 0)
                return this.getReg(index);
            return new feng3d.RegisterArrayComplexItem(this, complexArgs, index);
        };
        Object.defineProperty(RegisterArray.prototype, "regLen", {
            /**
             * @inheritDoc
             */
            get: function () {
                return this._regs.length;
            },
            set: function (value) {
                this._regs.length = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        RegisterArray.prototype.clear = function () {
            this.regLen = 1;
            _super.prototype.clear.call(this);
        };
        return RegisterArray;
    }(feng3d.Register));
    feng3d.RegisterArray = RegisterArray;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 寄存器矩阵
     * @author feng 2014-11-4
     */
    var RegisterMatrix = (function (_super) {
        __extends(RegisterMatrix, _super);
        /**
         *
         * @param regId
         */
        function RegisterMatrix(regId) {
            _super.call(this, regId);
            this.regLen = 4;
        }
        /**
         * @inheritDoc
         */
        RegisterMatrix.prototype.clear = function () {
            this.regLen = 4;
            this.index = -1;
        };
        return RegisterMatrix;
    }(feng3d.RegisterArray));
    feng3d.RegisterMatrix = RegisterMatrix;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 寄存器数组元素
     * @author feng 2014-11-3
     */
    var RegisterArrayItem = (function (_super) {
        __extends(RegisterArrayItem, _super);
        /**
         * 创建一个寄存器数组元素
         * @param registerArray			所属寄存器数组
         * @param arrayIndex			所在寄存器数组中的索引
         */
        function RegisterArrayItem(registerArray, arrayIndex) {
            _super.call(this, registerArray.regId);
            this._registerArray = registerArray;
            this._arrayIndex = arrayIndex;
        }
        RegisterArrayItem.prototype.toString = function () {
            if (feng3d.Register.TO_STRING == feng3d.Register.NAME)
                return this.regId + "[" + this._arrayIndex + "]";
            if (this._regType != feng3d.RegisterType.OP && this._regType != feng3d.RegisterType.OC)
                return this.regType + (this._arrayIndex + this._registerArray.index);
            return this._regType;
        };
        return RegisterArrayItem;
    }(feng3d.Register));
    feng3d.RegisterArrayItem = RegisterArrayItem;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 寄存器数组复杂元素
     * @author feng 2014-11-3
     */
    var RegisterArrayComplexItem = (function (_super) {
        __extends(RegisterArrayComplexItem, _super);
        /**
         * 创建一个寄存器数组复杂元素
         * @param registerArray			所属寄存器数组
         * @param complexArgs			复杂参数（用来计算所在寄存器数组中的索引值）
         * @param arrayIndex			起始索引值
         */
        function RegisterArrayComplexItem(registerArray, complexArgs, startIndex) {
            _super.call(this, registerArray, startIndex);
            this._complexArgs = complexArgs;
        }
        Object.defineProperty(RegisterArrayComplexItem.prototype, "complexArgs", {
            /**
             * 复杂参数（用来计算所在寄存器数组中的索引值）
             */
            get: function () {
                return this._complexArgs;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        RegisterArrayComplexItem.prototype.toString = function () {
            var _numStr = this._complexArgs.join("+");
            if (feng3d.Register.TO_STRING == feng3d.Register.NAME)
                return this.regId + "[" + _numStr + "+" + this._arrayIndex + "]";
            if (this._regType != feng3d.RegisterType.OP && this._regType != feng3d.RegisterType.OC)
                return this.regType + "[" + _numStr + "+" + (this._arrayIndex + this._registerArray.index) + "]";
            return this._regType;
        };
        return RegisterArrayComplexItem;
    }(feng3d.RegisterArrayItem));
    feng3d.RegisterArrayComplexItem = RegisterArrayComplexItem;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 寄存器池
     * @author feng 2014-6-9
     */
    var RegisterPool = (function () {
        /**
         * 创建寄存器池
         * @param regType 寄存器类型
         * @param regCount 寄存器总数
         */
        function RegisterPool(regType, regCount) {
            this._regType = regType;
            this._regCount = regCount;
            this.init();
        }
        Object.defineProperty(RegisterPool.prototype, "regCount", {
            /**
             * 寄存器总数
             */
            get: function () {
                return this._regCount;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RegisterPool.prototype, "regType", {
            /**
             * 寄存器类型
             */
            get: function () {
                return this._regType;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 初始化
         */
        RegisterPool.prototype.init = function () {
            this.usedRegisters = [];
        };
        /**
         * 获取寄存器
         * @param num 寄存器个数
         */
        RegisterPool.prototype.requestFreeRegisters = function (num) {
            var index = this.find(num);
            if (index == -1)
                throw new Error(this._regType + "寄存器不够用!");
            var reg = new feng3d.RegisterValue();
            reg.regType = this._regType;
            reg.index = index;
            reg.length = num;
            for (var i = 0; i < num; i++) {
                this.usedRegisters[index + i] = true;
            }
            return reg;
        };
        /**
         * 移除使用寄存器
         * @param register 寄存器
         */
        RegisterPool.prototype.removeUsage = function (register) {
            //只允许临时寄存器移除寄存器
            if (feng3d.RegisterType.isTemp(register.regType)) {
                for (var i = 0; i < register.regLen; i++) {
                    this.usedRegisters[register.index + i] = false;
                }
            }
        };
        /**
         * 销毁
         */
        RegisterPool.prototype.dispose = function () {
            this.usedRegisters = null;
        };
        /**
         * 重置
         */
        RegisterPool.prototype.reset = function () {
            this.usedRegisters = [];
        };
        /**
         * 寻找连续可用寄存器编号
         * @param num 个数
         * @return 如果找到返回非负值，未找到返回-1
         */
        RegisterPool.prototype.find = function (num) {
            if (num === void 0) { num = 1; }
            var cNum = 0;
            for (var i = 0; i < this._regCount; i++) {
                if (!this.usedRegisters[i])
                    cNum++;
                else
                    cNum = 0;
                if (cNum == num)
                    return i - cNum + 1;
            }
            return -1;
        };
        return RegisterPool;
    }());
    feng3d.RegisterPool = RegisterPool;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 寄存器类型
     * @author feng 2014-6-9
     */
    var RegisterType = (function () {
        function RegisterType() {
        }
        /**
         * 是否常量
         * @param regType		寄存器类型
         */
        RegisterType.isConst = function (regType) {
            return regType == RegisterType.VC || regType == RegisterType.FC;
        };
        /**
         * 是否临时变量
         * @param regType		寄存器类型
         */
        RegisterType.isTemp = function (regType) {
            return regType == RegisterType.VT || regType == RegisterType.FT;
        };
        /**
         * 是否只读
         * @param regType		寄存器类型
         * @return
         */
        RegisterType.isReadOnly = function (regType) {
            switch (regType) {
                case RegisterType.VA:
                    return true;
                case RegisterType.VC:
                    return true;
                case RegisterType.VT:
                    return false;
                case RegisterType.OP:
                    return false;
                case RegisterType.V:
                    return false;
                case RegisterType.FS:
                    return true;
                case RegisterType.FC:
                    return true;
                case RegisterType.FT:
                    return false;
                case RegisterType.OC:
                    return false;
            }
            throw new Error("错误寄存器类型");
        };
        /**
         * 是否可以在顶点寄存器中出现
         * @param regType		寄存器类型
         * @return
         */
        RegisterType.inVertex = function (regType) {
            switch (regType) {
                case RegisterType.VA:
                    return true;
                case RegisterType.VC:
                    return true;
                case RegisterType.VT:
                    return true;
                case RegisterType.OP:
                    return true;
                case RegisterType.V:
                    return true;
                case RegisterType.FS:
                    return false;
                case RegisterType.FC:
                    return false;
                case RegisterType.FT:
                    return false;
                case RegisterType.OC:
                    return false;
            }
            throw new Error("错误寄存器类型");
        };
        /**
         * 是否可以在片段寄存器中出现
         * @param regType		寄存器类型
         * @return
         */
        RegisterType.inFragment = function (regType) {
            switch (regType) {
                case RegisterType.VA:
                    return false;
                case RegisterType.VC:
                    return false;
                case RegisterType.VT:
                    return false;
                case RegisterType.OP:
                    return false;
                case RegisterType.V:
                    return true;
                case RegisterType.FS:
                    return true;
                case RegisterType.FC:
                    return true;
                case RegisterType.FT:
                    return true;
                case RegisterType.OC:
                    return true;
            }
            throw new Error("错误寄存器类型");
        };
        /**
         * 是否为输入数据寄存器
         * @param regType		寄存器类型
         * @return
         */
        RegisterType.isInputDataRegister = function (regType) {
            switch (regType) {
                case RegisterType.VA:
                    return true;
                case RegisterType.VC:
                    return true;
                case RegisterType.VT:
                    return false;
                case RegisterType.OP:
                    return false;
                case RegisterType.V:
                    return false;
                case RegisterType.FS:
                    return true;
                case RegisterType.FC:
                    return true;
                case RegisterType.FT:
                    return false;
                case RegisterType.OC:
                    return false;
            }
            throw new Error("错误寄存器类型");
        };
        /** 顶点属性寄存器 */
        RegisterType.VA = "va";
        /** 顶点程序常量寄存器 */
        RegisterType.VC = "vc";
        /** 顶点临时寄存器 */
        RegisterType.VT = "vt";
        /** 顶点程序输出寄存器 */
        RegisterType.OP = "op";
        /**变量寄存器 */
        RegisterType.V = "v";
        /** 片段程序的纹理寄存器 */
        RegisterType.FS = "fs";
        /** 片段程序常量寄存器 */
        RegisterType.FC = "fc";
        /** 片段程序临时寄存器 */
        RegisterType.FT = "ft";
        /** 片段程序输出寄存器 */
        RegisterType.OC = "oc";
        return RegisterType;
    }());
    feng3d.RegisterType = RegisterType;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 寄存器值
     * @author feng 2015-7-30
     */
    var RegisterValue = (function () {
        function RegisterValue() {
            /**
             * 寄存器长度
             */
            this.length = 1;
        }
        /**
         * 输出为字符串
         */
        RegisterValue.prototype.toString = function () {
            if (this.regType == feng3d.RegisterType.OP || this.regType == feng3d.RegisterType.OC)
                return this.regType;
            return this.regType + this.index;
        };
        return RegisterValue;
    }());
    feng3d.RegisterValue = RegisterValue;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 渲染寄存器缓存
     * @author feng 2014-6-5
     */
    var ShaderRegisterCache = (function () {
        /**
         * 创建渲染寄存器缓存
         */
        function ShaderRegisterCache() {
            if (ShaderRegisterCache._instance)
                throw new Error("ShaderRegisterCache 单例");
            ShaderRegisterCache._instance = this;
            this.init();
        }
        /**
         * 初始化
         */
        ShaderRegisterCache.prototype.init = function () {
            this._dataRegisterDic = {};
            this.registerPoolDic = {};
            this.usedDataRegisterNum = 0;
            for (var i = 0; i < ShaderRegisterCache.registerConfig.length; i++) {
                this.registerPoolDic[ShaderRegisterCache.registerConfig[i][0]] = new feng3d.RegisterPool(feng3d.as(ShaderRegisterCache.registerConfig[i][0], String), feng3d.as(ShaderRegisterCache.registerConfig[i][1], Number));
            }
            ShaderRegisterCache._dirty = false;
        };
        /**
         * 重置
         */
        ShaderRegisterCache.prototype.reset = function () {
            this._dataRegisterDic = {};
            this.usedDataRegisterNum = 0;
            this.registerPoolDic.forEach(function (registerPool) {
                registerPool.reset();
            });
            ShaderRegisterCache._dirty = false;
        };
        /**
         * 回收不需要再使用的临时寄存器
         * @param register 不需要再使用的临时寄存器
         */
        ShaderRegisterCache.prototype.removeTempUsage = function (dataTypeId) {
            var register = feng3d.FagalRegisterCenter.dataRegisterDic[dataTypeId];
            if (!register)
                return;
            var _fragmentTempCache = this.registerPoolDic[register.regType];
            _fragmentTempCache.removeUsage(register);
        };
        /**
         * 申请数据寄存器
         * @param dataType 数据类型
         * @param numRegister 寄存器的个数(默认1个)
         * @return 数据寄存器
         */
        ShaderRegisterCache.prototype.requestRegister = function (dataTypeId) {
            if (this._dataRegisterDic[dataTypeId])
                return;
            var register = feng3d.FagalRegisterCenter.dataRegisterDic[dataTypeId];
            var registerPool = this.registerPoolDic[register.regType];
            var registerValue = registerPool.requestFreeRegisters(register.regLen);
            registerValue.dataTypeId = register.regId;
            register.index = registerValue.index;
            this._dataRegisterDic[dataTypeId] = registerValue;
            this.usedDataRegisterNum++;
        };
        /**
         * 是否存在 dataType 类型寄存器
         * @param dataType 数据类型
         * @return
         */
        ShaderRegisterCache.prototype.hasReg = function (dataType) {
            return this._dataRegisterDic[dataType] != null;
        };
        /**
         * 注销
         */
        ShaderRegisterCache.prototype.dispose = function () {
            this.registerPoolDic.forEach(function (registerPool) {
                registerPool.dispose();
            });
            this._dataRegisterDic = null;
            this.registerPoolDic = null;
        };
        Object.defineProperty(ShaderRegisterCache, "instance", {
            /**
             * 实例
             */
            get: function () {
                ShaderRegisterCache._instance = ShaderRegisterCache._instance || new ShaderRegisterCache();
                if (ShaderRegisterCache._dirty)
                    ShaderRegisterCache._instance.reset();
                return ShaderRegisterCache._instance;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 使缓存失效
         */
        ShaderRegisterCache.invalid = function () {
            ShaderRegisterCache._dirty = true;
        };
        Object.defineProperty(ShaderRegisterCache.prototype, "dataRegisterDic", {
            /**
             * 数据寄存器缓存
             */
            get: function () {
                return this._dataRegisterDic;
            },
            enumerable: true,
            configurable: true
        });
        /** 脏标记 */
        ShaderRegisterCache._dirty = true;
        //		/** 寄存器配置 */
        //		private registerConfig:Array = //
        //			[[RegisterType.VA, 8], //
        //			[RegisterType.VC, 128], //
        //			[RegisterType.VT, 8], //
        //			[RegisterType.V, 8], //
        //			[RegisterType.FS, 8], //
        //			[RegisterType.FC, 28], //
        //			[RegisterType.FT, 8], //
        //			[RegisterType.OP, 1], //
        //			[RegisterType.OC, 1], //
        //			];
        /**
         * AGAL2寄存器配置
         */
        ShaderRegisterCache.registerConfig = [[feng3d.RegisterType.VA, 8],
            [feng3d.RegisterType.VC, 250],
            [feng3d.RegisterType.VT, 26],
            [feng3d.RegisterType.V, 10],
            [feng3d.RegisterType.FS, 8],
            [feng3d.RegisterType.FC, 64],
            [feng3d.RegisterType.FT, 16],
            [feng3d.RegisterType.OP, 1],
            [feng3d.RegisterType.OC, 1],
        ];
        return ShaderRegisterCache;
    }());
    feng3d.ShaderRegisterCache = ShaderRegisterCache;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 渲染器抽象基类
     * @author feng 2015-3-1
     */
    var RendererBase = (function () {
        /**
         * 创建一个渲染创新基类
         * @param renderToTexture		释放渲染到纹理
         */
        function RendererBase(renderToTexture) {
            if (renderToTexture === void 0) { renderToTexture = false; }
            //背景颜色
            this._backgroundR = 0;
            this._backgroundG = 0;
            this._backgroundB = 0;
            this._backgroundColor = 0;
            this._backgroundAlpha = 1;
            this._textureRatioX = 1;
            this._textureRatioY = 1;
            this._shareContext = false;
            this._renderableSorter = new feng3d.RenderableMergeSort();
        }
        /**
         * 创建一个实体收集器
         */
        RendererBase.prototype.createEntityCollector = function () {
            return new feng3d.EntityCollector();
        };
        Object.defineProperty(RendererBase.prototype, "viewWidth", {
            /**
             * 窗口宽度
             */
            get: function () {
                return this._viewWidth;
            },
            set: function (value) {
                this._viewWidth = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RendererBase.prototype, "viewHeight", {
            /**
             * 窗口高度
             */
            get: function () {
                return this._viewHeight;
            },
            set: function (value) {
                this._viewHeight = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RendererBase.prototype, "backgroundAlpha", {
            /**
             * 背景颜色透明度部分
             */
            get: function () {
                return this._backgroundAlpha;
            },
            set: function (value) {
                this._backgroundAlpha = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RendererBase.prototype, "backgroundColor", {
            /**
             * 背景颜色
             */
            get: function () {
                return this._backgroundColor;
            },
            set: function (value) {
                this._backgroundR = ((value >> 16) & 0xff) / 0xff;
                this._backgroundG = ((value >> 8) & 0xff) / 0xff;
                this._backgroundB = (value & 0xff) / 0xff;
                this._backgroundColor = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RendererBase.prototype, "shareContext", {
            /**
             * Defers control of Context3D clear() and present() calls to Stage3DProxy, enabling multiple Stage3D frameworks
             * to share the same Context3D object.
             *
             * @private
             */
            get: function () {
                return this._shareContext;
            },
            set: function (value) {
                this._shareContext = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 释放
         */
        RendererBase.prototype.dispose = function () {
        };
        /**
         * 渲染潜在可见几何体到缓冲区或纹理
         * @param stage3DProxy			3D舞台代理
         * @param entityCollector 		实体收集器
         * @param target 				目标纹理，默认为null表示渲染到缓冲区
         */
        RendererBase.prototype.render = function (stage3DProxy, entityCollector, target) {
            if (target === void 0) { target = null; }
            var _context = stage3DProxy.context3D;
            if (!stage3DProxy || !_context)
                return;
            //执行渲染
            this.executeRender(stage3DProxy, entityCollector, target);
            //清除3D环境缓存
            for (var i = 0; i < 8; ++i) {
                _context.setVertexBufferAt(i, null);
                _context.setTextureAt(i, null);
            }
        };
        /**
         * 执行渲染
         * @param stage3DProxy			3D舞台代理
         * @param entityCollector		实体收集器
         * @param target				渲染目标
         */
        RendererBase.prototype.executeRender = function (stage3DProxy, entityCollector, target) {
            if (target === void 0) { target = null; }
            var _context = stage3DProxy.context3D;
            if (this._renderableSorter)
                this._renderableSorter.sort(entityCollector);
            this._renderIndex = 0;
            //重置3D环境背景颜色
            if ((target || !this._shareContext))
                _context.clear(this._backgroundR, this._backgroundG, this._backgroundB, this._backgroundAlpha, 1, 0);
            _context.setDepthTest(false, feng3d.Context3DCompareMode.ALWAYS);
            //绘制
            this.draw(stage3DProxy, entityCollector, target);
        };
        return RendererBase;
    }());
    feng3d.RendererBase = RendererBase;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 默认渲染器，使用根据材质渲染场景图
     * @author feng 2015-3-5
     */
    var DefaultRenderer = (function (_super) {
        __extends(DefaultRenderer, _super);
        /**
         * 创建一个默认渲染器
         */
        function DefaultRenderer() {
            _super.call(this);
            this._depthRenderer = new feng3d.DepthRenderer();
            this._planarShadowRenderer = new feng3d.PlanarShadowRenderer();
        }
        /**
         * @inheritDoc
         */
        DefaultRenderer.prototype.executeRender = function (stage3DProxy, entityCollector, target) {
            if (target === void 0) { target = null; }
            if (!DefaultRenderer.usePlanarShadow) {
                this.updateLights(stage3DProxy, entityCollector);
            }
            _super.prototype.executeRender.call(this, stage3DProxy, entityCollector, target);
            if (DefaultRenderer.usePlanarShadow) {
                this._planarShadowRenderer.render(stage3DProxy, entityCollector, target);
            }
        };
        /**
         * @inheritDoc
         */
        DefaultRenderer.prototype.draw = function (stage3DProxy, entityCollector, target) {
            var _context = stage3DProxy.context3D;
            _context.setBlendFactors(feng3d.Context3DBlendFactor.ONE, feng3d.Context3DBlendFactor.ZERO);
            if (entityCollector.skyBox) {
                if (this._activeMaterial)
                    this._activeMaterial.deactivate();
                this._activeMaterial = null;
                _context.setDepthTest(false, feng3d.Context3DCompareMode.ALWAYS);
                this.drawSkyBox(stage3DProxy, entityCollector);
            }
            _context.setDepthTest(true, feng3d.Context3DCompareMode.LESS_EQUAL);
            this.drawRenderables(stage3DProxy, entityCollector.opaqueRenderableHead, entityCollector);
            this.drawRenderables(stage3DProxy, entityCollector.blendedRenderableHead, entityCollector);
            _context.setDepthTest(false, feng3d.Context3DCompareMode.LESS_EQUAL);
            if (this._activeMaterial)
                this._activeMaterial.deactivate();
            this._activeMaterial = null;
        };
        /**
         * Draw the skybox if present.
         * @param entityCollector The EntityCollector containing all potentially visible information.
         */
        /**
         * 绘制天空盒
         * @param stage3DProxy				3D舞台代理
         * @param entityCollector			实体收集器
         *
         */
        DefaultRenderer.prototype.drawSkyBox = function (stage3DProxy, entityCollector) {
            var renderable = entityCollector.skyBox.subMeshes[0].renderableBase;
            var camera = entityCollector.camera;
            var material = renderable.material;
            material.updateMaterial();
            var pass = material.getPass(0);
            //初始化渲染参数
            pass.shaderParams.initParams();
            //激活渲染通道
            pass.activate(camera);
            pass.render(renderable, stage3DProxy, camera, this._renderIndex++);
            pass.deactivate();
        };
        /**
         * 绘制可渲染列表
         * @param renderables 			可渲染列表
         * @param entityCollector 		实体收集器，包含所有潜在显示实体信息
         */
        DefaultRenderer.prototype.drawRenderables = function (stage3DProxy, item, entityCollector) {
            var numPasses;
            var j;
            var camera = entityCollector.camera;
            var item2;
            while (item) {
                this._activeMaterial = item.renderable.material;
                this._activeMaterial.updateMaterial();
                numPasses = this._activeMaterial.numPasses;
                j = 0;
                do {
                    item2 = item;
                    var pass = this._activeMaterial.getPass(j);
                    //初始化渲染参数
                    pass.shaderParams.initParams();
                    //激活渲染通道
                    pass.activate(camera);
                    do {
                        pass.render(item2.renderable, stage3DProxy, camera, this._renderIndex++);
                        item2 = item2.next;
                    } while (item2 && item2.renderable.material == this._activeMaterial);
                    this._activeMaterial.deactivatePass(j);
                } while (++j < numPasses);
                item = item2;
            }
        };
        /**
         * 更新灯光
         * @param stage3DProxy				3D场景代理
         * @param entityCollector			实体集合
         */
        DefaultRenderer.prototype.updateLights = function (stage3DProxy, entityCollector) {
            var dirLights = entityCollector.directionalLights;
            var len, i;
            var light;
            var shadowMapper;
            len = dirLights.length;
            for (i = 0; i < len; ++i) {
                light = dirLights[i];
                shadowMapper = light.shadowMapper;
                if (light.castsShadows && (shadowMapper.autoUpdateShadows || shadowMapper._shadowsInvalid))
                    shadowMapper.renderDepthMap(stage3DProxy, entityCollector, this._depthRenderer);
            }
        };
        DefaultRenderer.SCREEN_PASSES = 2;
        DefaultRenderer.ALL_PASSES = 3;
        return DefaultRenderer;
    }(feng3d.RendererBase));
    feng3d.DefaultRenderer = DefaultRenderer;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 深度渲染器
     * @author feng 2015-5-28
     */
    var DepthRenderer = (function (_super) {
        __extends(DepthRenderer, _super);
        /**
         * 创建一个深度渲染器
         */
        function DepthRenderer() {
            _super.call(this);
            this._backgroundR = 1;
            this._backgroundG = 1;
            this._backgroundB = 1;
        }
        /**
         * @inheritDoc
         */
        DepthRenderer.prototype.draw = function (stage3DProxy, entityCollector, target) {
            var _context = stage3DProxy.context3D;
            _context.setBlendFactors(feng3d.Context3DBlendFactor.ONE, feng3d.Context3DBlendFactor.ZERO);
            _context.setDepthTest(true, feng3d.Context3DCompareMode.LESS);
            this.drawRenderables(stage3DProxy, entityCollector.opaqueRenderableHead, entityCollector, target);
            this._activeMaterial = null;
        };
        /**
         * 绘制渲染列表
         * @param stage3DProxy			3D场景代理
         * @param item					渲染对象列表单元
         * @param entityCollector		实体集合
         * @param target				渲染目标
         */
        DepthRenderer.prototype.drawRenderables = function (stage3DProxy, item, entityCollector, target) {
            var camera = entityCollector.camera;
            var item2;
            while (item) {
                this._activeMaterial = item.renderable.material;
                var depthPass = this._activeMaterial.depthPass;
                //初始化渲染参数
                depthPass.shaderParams.initParams();
                //激活渲染通道
                depthPass.activate(camera, target);
                item2 = item;
                do {
                    depthPass.render(item2.renderable, stage3DProxy, camera, this._renderIndex++);
                    item2 = item2.next;
                } while (item2 && item2.renderable.material == this._activeMaterial);
                depthPass.deactivate();
                item = item2;
            }
        };
        return DepthRenderer;
    }(feng3d.RendererBase));
    feng3d.DepthRenderer = DepthRenderer;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 平面阴影渲染器
     * @author feng 2015-8-23
     */
    var PlanarShadowRenderer = (function (_super) {
        __extends(PlanarShadowRenderer, _super);
        /**
         * 创建一个深度渲染器
         */
        function PlanarShadowRenderer() {
            _super.call(this);
        }
        /**
         * @inheritDoc
         */
        PlanarShadowRenderer.prototype.executeRender = function (stage3DProxy, entityCollector, target) {
            if (target === void 0) { target = null; }
            var _context = stage3DProxy.context3D;
            if (this._renderableSorter)
                this._renderableSorter.sort(entityCollector);
            _context.setDepthTest(false, feng3d.Context3DCompareMode.ALWAYS);
            //绘制
            this.draw(stage3DProxy, entityCollector, target);
        };
        /**
         * @inheritDoc
         */
        PlanarShadowRenderer.prototype.draw = function (stage3DProxy, entityCollector, target) {
            var _context = stage3DProxy.context3D;
            _context.setBlendFactors(feng3d.Context3DBlendFactor.ONE, feng3d.Context3DBlendFactor.ZERO);
            _context.setDepthTest(true, feng3d.Context3DCompareMode.LESS);
            this.drawRenderables(stage3DProxy, entityCollector.opaqueRenderableHead, entityCollector, target);
            this._activeMaterial = null;
        };
        /**
         * 绘制渲染列表
         * @param stage3DProxy			3D场景代理
         * @param item					渲染对象列表单元
         * @param entityCollector		实体集合
         * @param target				渲染目标
         */
        PlanarShadowRenderer.prototype.drawRenderables = function (stage3DProxy, item, entityCollector, target) {
            var camera = entityCollector.camera;
            var item2;
            while (item) {
                this._activeMaterial = item.renderable.material;
                var planarShadowPass = this._activeMaterial.planarShadowPass;
                //初始化渲染参数
                planarShadowPass.shaderParams.initParams();
                //激活渲染通道
                planarShadowPass.activate(camera, target);
                item2 = item;
                do {
                    if (item2.renderable.castsShadows) {
                        planarShadowPass.render(item2.renderable, stage3DProxy, camera, this._renderIndex++);
                    }
                    item2 = item2.next;
                } while (item2 && item2.renderable.material == this._activeMaterial);
                planarShadowPass.deactivate();
                item = item2;
            }
        };
        return PlanarShadowRenderer;
    }(feng3d.RendererBase));
    feng3d.PlanarShadowRenderer = PlanarShadowRenderer;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 可渲染合并排序
     * <p>为了提升渲染性能，排序EntityCollector中潜在显示对象。</p>
     * <p>排序方式优先使用材质，其次是离摄像机的距离。不透明对象从前往后移，当对象需要混合的从后往前移，确保能够正确渲染。</p>
     * @author feng 2015-3-9
     */
    var RenderableMergeSort = (function () {
        /**
         * 创建一个可渲染合并排序对象
         */
        function RenderableMergeSort() {
        }
        /**
         * @inheritDoc
         */
        RenderableMergeSort.prototype.sort = function (collector) {
            collector.opaqueRenderableHead = this.mergeSortByMaterial(collector.opaqueRenderableHead);
            collector.blendedRenderableHead = this.mergeSortByDepth(collector.blendedRenderableHead);
        };
        /**
         * 合并按深度排序
         * @param head			可渲染链表（头元素）
         * @return				排好序的可渲染链表（头元素）
         */
        RenderableMergeSort.prototype.mergeSortByDepth = function (head) {
            var headB;
            var fast, slow;
            if (!head || !head.next)
                return head;
            // split in two sublists
            slow = head;
            fast = head.next;
            while (fast) {
                fast = fast.next;
                if (fast) {
                    slow = slow.next;
                    fast = fast.next;
                }
            }
            headB = slow.next;
            slow.next = null;
            // recurse
            head = this.mergeSortByDepth(head);
            headB = this.mergeSortByDepth(headB);
            // merge sublists while respecting order
            var result;
            var curr;
            var l;
            if (!head)
                return headB;
            if (!headB)
                return head;
            while (head && headB && head != null && headB != null) {
                if (head.zIndex < headB.zIndex) {
                    l = head;
                    head = head.next;
                }
                else {
                    l = headB;
                    headB = headB.next;
                }
                if (!result)
                    result = l;
                else
                    curr.next = l;
                curr = l;
            }
            if (head)
                curr.next = head;
            else if (headB)
                curr.next = headB;
            return result;
        };
        /**
         * 合并按材质排序
         * @param head			可渲染链表（头元素）
         * @return				排好序的可渲染链表（头元素）
         */
        RenderableMergeSort.prototype.mergeSortByMaterial = function (head) {
            var headB;
            var fast, slow;
            if (!head || !head.next)
                return head;
            // split in two sublists
            slow = head;
            fast = head.next;
            while (fast) {
                fast = fast.next;
                if (fast) {
                    slow = slow.next;
                    fast = fast.next;
                }
            }
            headB = slow.next;
            slow.next = null;
            // recurse
            head = this.mergeSortByMaterial(head);
            headB = this.mergeSortByMaterial(headB);
            // merge sublists while respecting order
            var result;
            var curr;
            var l;
            var cmp;
            if (!head)
                return headB;
            if (!headB)
                return head;
            while (head && headB && head != null && headB != null) {
                // first this.sort per render order id (reduces program3D switches),
                // then on material id (reduces setting props),
                // then on zIndex (reduces overdraw)
                var aid = head.renderOrderId;
                var bid = headB.renderOrderId;
                if (aid == bid) {
                    var ma = head.materialId;
                    var mb = headB.materialId;
                    if (ma == mb) {
                        if (head.zIndex < headB.zIndex)
                            cmp = 1;
                        else
                            cmp = -1;
                    }
                    else if (ma > mb)
                        cmp = 1;
                    else
                        cmp = -1;
                }
                else if (aid > bid)
                    cmp = 1;
                else
                    cmp = -1;
                if (cmp < 0) {
                    l = head;
                    head = head.next;
                }
                else {
                    l = headB;
                    headB = headB.next;
                }
                if (!result) {
                    result = l;
                    curr = l;
                }
                else {
                    curr.next = l;
                    curr = l;
                }
            }
            if (head)
                curr.next = head;
            else if (headB)
                curr.next = headB;
            return result;
        };
        return RenderableMergeSort;
    }());
    feng3d.RenderableMergeSort = RenderableMergeSort;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 分区横越者
     * @author feng 2015-3-1
     */
    var PartitionTraverser = (function () {
        /**
         * 构建一个分区横越者
         */
        function PartitionTraverser() {
        }
        /**
         * 进入节点
         * <p>正在穿过节点，或者正在与该节点进行检测</p>
         * @param node 		被进入的节点
         * @return			true：需要进一步检测子节点
         */
        PartitionTraverser.prototype.enterNode = function (node) {
            node = node;
            return true;
        };
        return PartitionTraverser;
    }());
    feng3d.PartitionTraverser = PartitionTraverser;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 实体收集器
     * <p>为场景分区收集所有场景图中被认为潜在显示对象</p>
     *
     * @see me.feng3d.core.partition.Partition3D
     * @see me.feng3d.entities.Entity
     *
     * @author feng 2015-3-1
     */
    var EntityCollector = (function (_super) {
        __extends(EntityCollector, _super);
        /**
         * 创建一个实体收集器
         */
        function EntityCollector() {
            _super.call(this);
            this.init();
        }
        /**
         * 初始化
         */
        EntityCollector.prototype.init = function () {
            this._lights = [];
            this._directionalLights = [];
            this._pointLights = [];
            this._renderableListItemPool = new feng3d.RenderableListItemPool();
            this._entityListItemPool = new feng3d.EntityListItemPool();
        };
        /**
         * 清除
         */
        EntityCollector.prototype.clear = function () {
            if (this._camera) {
                this._entryPoint = this._camera.scenePosition;
                this._cameraForward = feng3d.Matrix3DUtils.getForward(this._camera.transform3D.transform, this._cameraForward);
            }
            this._cullPlanes = this._customCullPlanes ? this._customCullPlanes : (this._camera ? this._camera.frustumPlanes : null);
            this._numCullPlanes = this._cullPlanes ? this._cullPlanes.length : 0;
            this._numTriangles = this._numMouseEnableds = 0;
            this._blendedRenderableHead = null;
            this._opaqueRenderableHead = null;
            this._renderableListItemPool.freeAll();
            this._entityListItemPool.freeAll();
            this._skyBox = null;
            if (this._numLights > 0)
                this._lights.length = this._numLights = 0;
            if (this._numDirectionalLights > 0)
                this._directionalLights.length = this._numDirectionalLights = 0;
            if (this._numPointLights > 0)
                this._pointLights.length = this._numPointLights = 0;
        };
        Object.defineProperty(EntityCollector.prototype, "camera", {
            /**
             * 提供可见视锥体的摄像机
             */
            get: function () {
                return this._camera;
            },
            set: function (value) {
                this._camera = value;
                this._entryPoint = this._camera.scenePosition;
                this._cameraForward = feng3d.Matrix3DUtils.getForward(this._camera.transform3D.transform, this._cameraForward);
                this._cullPlanes = this._camera.frustumPlanes;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EntityCollector.prototype, "cullPlanes", {
            /**
             * 视椎面
             */
            get: function () {
                return this._customCullPlanes;
            },
            set: function (value) {
                this._customCullPlanes = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EntityCollector.prototype, "skyBox", {
            /**
             * 天空盒对象
             */
            get: function () {
                return this._skyBox;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EntityCollector.prototype, "opaqueRenderableHead", {
            /**
             * 不透明渲染对象链表头
             */
            get: function () {
                return this._opaqueRenderableHead;
            },
            set: function (value) {
                this._opaqueRenderableHead = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EntityCollector.prototype, "blendedRenderableHead", {
            /**
             * 透明渲染对象链表头
             */
            get: function () {
                return this._blendedRenderableHead;
            },
            set: function (value) {
                this._blendedRenderableHead = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 添加渲染对象到潜在显示对象中
         * @param renderable	可渲染对象
         */
        EntityCollector.prototype.applyRenderable = function (renderable) {
            var material;
            var entity = renderable.sourceEntity;
            if (renderable.mouseEnabled)
                ++this._numMouseEnableds;
            this._numTriangles += renderable.numTriangles;
            material = renderable.material;
            if (material) {
                var item = this._renderableListItemPool.getItem();
                item.renderable = renderable;
                item.materialId = material._uniqueId;
                item.renderOrderId = material._renderOrderId;
                var entityScenePos = entity.scenePosition;
                var dx = this._entryPoint.x - entityScenePos.x;
                var dy = this._entryPoint.y - entityScenePos.y;
                var dz = this._entryPoint.z - entityScenePos.z;
                // project onto this.camera's z-axis
                item.zIndex = dx * this._cameraForward.x + dy * this._cameraForward.y + dz * this._cameraForward.z + entity.zOffset;
                item.renderSceneTransform = renderable.sourceEntity.getRenderSceneTransform(this.camera);
                if (material.requiresBlending) {
                    item.next = this._blendedRenderableHead;
                    this._blendedRenderableHead = item;
                }
                else {
                    item.next = this._opaqueRenderableHead;
                    this._opaqueRenderableHead = item;
                }
            }
        };
        /**
         * 判断节点是否出现在视锥体中
         * @param node 用于测试的节点
         */
        EntityCollector.prototype.enterNode = function (node) {
            var enter = feng3d.PartitionTraverser._collectionMark != node._collectionMark && node.isInFrustum(this._cullPlanes, this._numCullPlanes);
            node._collectionMark = feng3d.PartitionTraverser._collectionMark;
            return enter;
        };
        /**
         * @inheritDoc
         */
        EntityCollector.prototype.applySkyBox = function (skyBox) {
            this._skyBox = skyBox;
        };
        /**
         * @inheritDoc
         */
        EntityCollector.prototype.applyDirectionalLight = function (light) {
            this._lights[this._numLights++] = light;
            this._directionalLights[this._numDirectionalLights++] = light;
        };
        /**
         * @inheritDoc
         */
        EntityCollector.prototype.applyPointLight = function (light) {
            this._lights[this._numLights++] = light;
            this._pointLights[this._numPointLights++] = light;
        };
        Object.defineProperty(EntityCollector.prototype, "directionalLights", {
            /**
             * 方向光列表
             */
            get: function () {
                return this._directionalLights;
            },
            enumerable: true,
            configurable: true
        });
        return EntityCollector;
    }(feng3d.PartitionTraverser));
    feng3d.EntityCollector = EntityCollector;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 阴影投射者集合
     * @author feng 2015-5-29
     */
    var ShadowCasterCollector = (function (_super) {
        __extends(ShadowCasterCollector, _super);
        /**
         * 创建阴影投射者集合
         */
        function ShadowCasterCollector() {
            _super.call(this);
        }
        /**
         * 应用可渲染对象
         * @param renderable		可渲染对象
         */
        ShadowCasterCollector.prototype.applyRenderable = function (renderable) {
            var material = renderable.material;
            var entity = renderable.sourceEntity;
            //收集可投射阴影的可渲染对象
            if (renderable.castsShadows && material) {
                var item = this._renderableListItemPool.getItem();
                item.renderable = renderable;
                item.next = this._opaqueRenderableHead;
                var entityScenePos = entity.scenePosition;
                var dx = this._entryPoint.x - entityScenePos.x;
                var dy = this._entryPoint.y - entityScenePos.y;
                var dz = this._entryPoint.z - entityScenePos.z;
                item.zIndex = dx * this._cameraForward.x + dy * this._cameraForward.y + dz * this._cameraForward.z;
                item.renderSceneTransform = renderable.sourceEntity.getRenderSceneTransform(this._camera);
                this._opaqueRenderableHead = item;
            }
        };
        return ShadowCasterCollector;
    }(feng3d.EntityCollector));
    feng3d.ShadowCasterCollector = ShadowCasterCollector;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 3d环境缓存调试工具类
     * @author feng 2014-9-9
     */
    var Context3DBufferDebug = (function () {
        /**
         * 创建3d环境缓存调试工具类
         */
        function Context3DBufferDebug() {
        }
        /**
         * 调试Context3DCache
         * @param context3DCache			3D环境缓冲
         * @return							调试信息
         */
        Context3DBufferDebug.debug = function (context3DCache) {
            var debugInfos = [];
            var debugInfoItem;
            debugInfoItem = Context3DBufferDebug.debugInfo(context3DCache.programBuffer);
            debugInfos.push(debugInfoItem);
            for (var key in context3DCache.otherBufferDic) {
                if (context3DCache.otherBufferDic.hasOwnProperty(key)) {
                    var context3DDataBuffer = context3DCache.otherBufferDic[key];
                    debugInfoItem = Context3DBufferDebug.debugInfo(context3DDataBuffer);
                    debugInfos.push(debugInfoItem);
                }
            }
            for (var key in context3DCache.runRegBufferList) {
                if (context3DCache.runRegBufferList.hasOwnProperty(key)) {
                    var registerBuffer = context3DCache.runRegBufferList[key];
                    debugInfoItem = Context3DBufferDebug.debugInfo(registerBuffer);
                    debugInfoItem.shaderRegister = registerBuffer.firstRegister.toString();
                    debugInfos.push(debugInfoItem);
                }
            }
            debugInfoItem = Context3DBufferDebug.debugInfo(context3DCache.indexBuffer);
            debugInfos.push(debugInfoItem);
            return debugInfos;
        };
        /**
         * 调试Context3DCache
         * @param context3DBuffer			3D环境缓冲
         * @return							调试信息
         */
        Context3DBufferDebug.debugInfo = function (context3DBuffer) {
            var debugInfoItem = { className: feng3d.getQualifiedClassName(context3DBuffer), constructorParams: [context3DBuffer.dataTypeId, null] };
            var cla = feng3d.ClassUtils.getClass(context3DBuffer);
            switch (cla) {
                case feng3d.ProgramBuffer:
                    var programBuffer = context3DBuffer;
                    debugInfoItem.updateParams = [programBuffer.vertexCode, programBuffer.fragmentCode];
                    break;
                case feng3d.BlendFactorsBuffer:
                    var blendFactorsBuffer = context3DBuffer;
                    debugInfoItem.updateParams = [blendFactorsBuffer.sourceFactor, blendFactorsBuffer.destinationFactor];
                    break;
                case feng3d.CullingBuffer:
                    var cullingBuffer = context3DBuffer;
                    debugInfoItem.updateParams = [cullingBuffer.triangleFaceToCull];
                    break;
                case feng3d.DepthTestBuffer:
                    var depthTestBuffer = context3DBuffer;
                    debugInfoItem.updateParams = [depthTestBuffer.depthMask, depthTestBuffer.passCompareMode];
                    break;
                case feng3d.FCMatrixBuffer:
                    var fcMatrixBuffer = context3DBuffer;
                    debugInfoItem.updateParams = [fcMatrixBuffer.matrix, fcMatrixBuffer.transposedMatrix];
                    break;
                case feng3d.FCVectorBuffer:
                    var fcVectorBuffer = context3DBuffer;
                    debugInfoItem.updateParams = [fcVectorBuffer.data, fcVectorBuffer.numRegisters];
                    break;
                case feng3d.FSBuffer:
                    var fsBuffer = context3DBuffer;
                    debugInfoItem.updateParams = [fsBuffer.texture];
                    break;
                case feng3d.IndexBuffer:
                    var indexBuffer = context3DBuffer;
                    debugInfoItem.updateParams = [indexBuffer.data, indexBuffer.numIndices, indexBuffer.count, indexBuffer.firstIndex, indexBuffer.numTriangles];
                    break;
                case feng3d.VABuffer:
                    var vaBuffer = context3DBuffer;
                    debugInfoItem.updateParams = [vaBuffer.dataBuffer.data, vaBuffer.dataBuffer.numVertices, vaBuffer.dataBuffer.data32PerVertex];
                    break;
                case feng3d.VCMatrixBuffer:
                    var vcMatrixBuffer = context3DBuffer;
                    debugInfoItem.updateParams = [vcMatrixBuffer.matrix, vcMatrixBuffer.transposedMatrix];
                    break;
                case feng3d.VCVectorBuffer:
                    var vcVectorBuffer = context3DBuffer;
                    debugInfoItem.updateParams = [vcVectorBuffer.data, vcVectorBuffer.numRegisters];
                    break;
                default:
                    throw new Error("无法处理类型：" + cla);
            }
            //编码参数
            feng3d.ClassUtils.encodeParams(debugInfoItem.updateParams);
            return debugInfoItem;
        };
        /**
         * 获取Context3DCache
         * @param obj				3D环境数据
         * @return					3D环境实例
         */
        Context3DBufferDebug.getContext3DCache = function (obj) {
            var context3DCache = new feng3d.Context3DCache();
            var arr = feng3d.as(obj, Array);
            for (var i = 0; i < arr.length; i++) {
                var item = arr[i];
                var cla = feng3d.ClassUtils.getClass(item.className);
                var buff = feng3d.ClassUtils.structureInstance(cla, item.constructorParams);
                feng3d.ClassUtils.decodeParams(item.updateParams);
                feng3d.ClassUtils.call(buff, "update", item.updateParams);
                context3DCache.addDataBuffer(buff);
                if (feng3d.is(buff, feng3d.RegisterBuffer)) {
                    var regBuff = buff;
                    var regStr = item.shaderRegister;
                    var myPattern = /([a-z]+)(\d+)/;
                    var result = myPattern.exec(regStr);
                    //-------------------
                    regBuff.firstRegister = Number(result[2]);
                    if (context3DCache.runRegBufferList == null) {
                        context3DCache.runRegBufferList = [];
                    }
                    context3DCache.runRegBufferList.push(buff);
                }
            }
            return context3DCache;
        };
        return Context3DBufferDebug;
    }());
    feng3d.Context3DBufferDebug = Context3DBufferDebug;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 调试配置
     * @author feng 2014-4-13
     */
    var Debug = (function () {
        function Debug() {
        }
        /**
         * 是否开启AGAL调试
         */
        Debug.agalDebug = true;
        return Debug;
    }());
    feng3d.Debug = Debug;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     *
     * @author feng 2015-12-30
     */
    var SegmentUtils = (function () {
        function SegmentUtils() {
            this.LIMIT = 3 * 0xFFFF;
        }
        SegmentUtils.getSegmentSubGeometrys = function (_segments) {
            var segmentUtils = new SegmentUtils();
            var _segmentSubGeometry = segmentUtils.getSegmentSubGeometry(_segments);
            return _segmentSubGeometry;
        };
        SegmentUtils.prototype.getSegmentSubGeometry = function (_segments) {
            this._segmentSubGeometry = new feng3d.SegmentSubGeometry();
            this._indices = [];
            this._pointData0 = [];
            this._pointData1 = [];
            this._thicknessData = [];
            this._colorData = [];
            for (var i = 0; i < _segments.length; i++) {
                this.computeSegment(_segments[i], i);
            }
            //一条线段由4个顶点组成
            this._segmentSubGeometry.numVertices = _segments.length * 4;
            this._segmentSubGeometry.updateIndexData(this._indices);
            this._segmentSubGeometry.updatePointData0(this._pointData0);
            this._segmentSubGeometry.updatePointData1(this._pointData1);
            this._segmentSubGeometry.updateThicknessData(this._thicknessData);
            this._segmentSubGeometry.updateColorData(this._colorData);
            return this._segmentSubGeometry;
        };
        /**
         * 计算线段数据
         * @param segment 			线段数据
         * @param segmentIndex 		线段编号
         */
        SegmentUtils.prototype.computeSegment = function (segment, segmentIndex) {
            //to do: add support for curve segment
            var start = segment.start;
            var end = segment.end;
            var startX = start.x, startY = start.y, startZ = start.z;
            var endX = end.x, endY = end.y, endZ = end.z;
            var startR = segment.startR, startG = segment.startG, startB = segment.startB;
            var endR = segment.endR, endG = segment.endG, endB = segment.endB;
            var point0Index = segmentIndex * 4 * this._segmentSubGeometry.pointData0Stride;
            var point1Index = segmentIndex * 4 * this._segmentSubGeometry.pointData1Stride;
            var thicknessIndex = segmentIndex * 4 * this._segmentSubGeometry.thicknessDataStride;
            var colorIndex = segmentIndex * 4 * this._segmentSubGeometry.colorDataStride;
            var t = segment.thickness;
            //生成线段顶点数据
            this._pointData0[point0Index++] = startX;
            this._pointData0[point0Index++] = startY;
            this._pointData0[point0Index++] = startZ;
            this._pointData1[point1Index++] = endX;
            this._pointData1[point1Index++] = endY;
            this._pointData1[point1Index++] = endZ;
            this._thicknessData[thicknessIndex++] = t;
            this._colorData[colorIndex++] = startR;
            this._colorData[colorIndex++] = startG;
            this._colorData[colorIndex++] = startB;
            this._colorData[colorIndex++] = 1;
            this._pointData0[point0Index++] = endX;
            this._pointData0[point0Index++] = endY;
            this._pointData0[point0Index++] = endZ;
            this._pointData1[point1Index++] = startX;
            this._pointData1[point1Index++] = startY;
            this._pointData1[point1Index++] = startZ;
            this._thicknessData[thicknessIndex++] = -t;
            this._colorData[colorIndex++] = endR;
            this._colorData[colorIndex++] = endG;
            this._colorData[colorIndex++] = endB;
            this._colorData[colorIndex++] = 1;
            this._pointData0[point0Index++] = startX;
            this._pointData0[point0Index++] = startY;
            this._pointData0[point0Index++] = startZ;
            this._pointData1[point1Index++] = endX;
            this._pointData1[point1Index++] = endY;
            this._pointData1[point1Index++] = endZ;
            this._thicknessData[thicknessIndex++] = -t;
            this._colorData[colorIndex++] = startR;
            this._colorData[colorIndex++] = startG;
            this._colorData[colorIndex++] = startB;
            this._colorData[colorIndex++] = 1;
            this._pointData0[point0Index++] = endX;
            this._pointData0[point0Index++] = endY;
            this._pointData0[point0Index++] = endZ;
            this._pointData1[point1Index++] = startX;
            this._pointData1[point1Index++] = startY;
            this._pointData1[point1Index++] = startZ;
            this._thicknessData[thicknessIndex++] = t;
            this._colorData[colorIndex++] = endR;
            this._colorData[colorIndex++] = endG;
            this._colorData[colorIndex++] = endB;
            this._colorData[colorIndex++] = 1;
            //生成顶点索引数据
            var indexIndex = segmentIndex * 4;
            this._indices.push(indexIndex, indexIndex + 1, indexIndex + 2, indexIndex + 3, indexIndex + 2, indexIndex + 1);
        };
        return SegmentUtils;
    }());
    feng3d.SegmentUtils = SegmentUtils;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var AnimationSetError = (function (_super) {
        __extends(AnimationSetError, _super);
        function AnimationSetError(message) {
            _super.call(this, message);
        }
        return AnimationSetError;
    }(Error));
    feng3d.AnimationSetError = AnimationSetError;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 3D舞台事件
     * @author feng 2015-3-5
     */
    var Stage3DEvent = (function (_super) {
        __extends(Stage3DEvent, _super);
        /**
         * 构建一个3D舞台事件
         * @param type			事件的类型，可以作为 Event.type 访问。
         * @param bubbles		确定 Event 对象是否参与事件流的冒泡阶段。默认值为 false。
         */
        function Stage3DEvent(type, bubbles) {
            if (bubbles === void 0) { bubbles = false; }
            _super.call(this, type, bubbles);
        }
        /** 3D环境被创建事件 */
        Stage3DEvent.CONTEXT3D_CREATED = "Context3DCreated";
        /** 3D环境被摧毁事件 */
        Stage3DEvent.CONTEXT3D_DISPOSED = "Context3DDisposed";
        /** 3D环境被重新创建事件 */
        Stage3DEvent.CONTEXT3D_RECREATED = "Context3DRecreated";
        /** 视窗有发生变化 */
        Stage3DEvent.VIEWPORT_UPDATED = "ViewportUpdated";
        return Stage3DEvent;
    }(feng3d.Event));
    feng3d.Stage3DEvent = Stage3DEvent;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     *
     * @author feng 2015-9-25
     */
    function F_AlphaPremultiplied() {
        var _ = feng3d.FagalRE.instance.space;
        _.add(_.finalColor_ft_4.w, _.finalColor_ft_4.w, _.commonsData_fc_vector.z); //
        _.div(_.finalColor_ft_4.xyz, _.finalColor_ft_4, _.finalColor_ft_4.w); //
        _.sub(_.finalColor_ft_4.w, _.finalColor_ft_4.w, _.commonsData_fc_vector.z); //
        _.sat(_.finalColor_ft_4.xyz, _.finalColor_ft_4);
    }
    feng3d.F_AlphaPremultiplied = F_AlphaPremultiplied;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 环境光片段渲染程序
     * @author feng 2014-11-7
     */
    function F_Ambient() {
        var _ = feng3d.FagalRE.instance.space;
        var shaderParams = feng3d.FagalRE.instance.context3DCache.shaderParams;
        var commonShaderParams = shaderParams.getOrCreateComponentByClass(feng3d.CommonShaderParams);
        if (commonShaderParams.useAmbientTexture > 0) {
            var mAmbient_ft = _.getFreeTemp("环境颜色值临时变量");
            _.tex(mAmbient_ft, _.uv_v, _.ambientTexture_fs);
            // apparently, still needs to un-premultiply :s
            _.div(mAmbient_ft.xyz, mAmbient_ft.xyz, mAmbient_ft.w);
            _.mov(_.finalColor_ft_4, mAmbient_ft);
        }
        else {
            _.mov(_.finalColor_ft_4, _.ambientColor_fc_vector);
        }
    }
    feng3d.F_Ambient = F_Ambient;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * blinn-phong half vector model
     * @author feng 2015-9-24
     */
    function F_Blinn_Phong(singleSpecularColorReg, lightDirReg) {
        var _ = feng3d.FagalRE.instance.space;
        //入射光与视线方向的和 = 光照场景方向 add 标准视线方向
        _.add(singleSpecularColorReg, lightDirReg, _.viewDir_ft_4);
        //标准化入射光与视线的和
        _.nrm(singleSpecularColorReg.xyz, singleSpecularColorReg);
        //镜面反射光强度 = 法线 dp3 入射光与视线方向的和
        _.dp3(singleSpecularColorReg.w, _.normal_ft_4, singleSpecularColorReg);
        //镜面反射光强度 锁定在0-1之间
        _.sat(singleSpecularColorReg.w, singleSpecularColorReg.w);
    }
    feng3d.F_Blinn_Phong = F_Blinn_Phong;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 发布漫反射光
     * @author feng 2014-11-7
     */
    function F_DiffusePostLighting() {
        var shaderParams = feng3d.FagalRE.instance.context3DCache.shaderParams;
        var commonShaderParams = shaderParams.getOrCreateComponentByClass(feng3d.CommonShaderParams);
        var lightShaderParams = shaderParams.getOrCreateComponentByClass(feng3d.LightShaderParams);
        var shadowShaderParams = shaderParams.getOrCreateComponentByClass(feng3d.ShadowShaderParams);
        var _ = feng3d.FagalRE.instance.space;
        //把阴影使用到漫反射光上
        if (lightShaderParams.numLights > 0 && shadowShaderParams.needsShadowRegister > 0) {
            _.mul(_.totalDiffuseLightColor_ft_4.xyz, _.totalDiffuseLightColor_ft_4, _.shadowValue_ft_4.w);
        }
        //获取漫反射灯光
        if (commonShaderParams.hasDiffuseTexture > 0) {
            feng3d.F_DiffuseTexure();
        }
        else {
            feng3d.F_DiffuseColor();
        }
        if (lightShaderParams.numLights == 0) {
            _.mov(_.finalColor_ft_4, _.mDiff_ft);
            return;
        }
        //控制在0到1之间
        _.sat(_.totalDiffuseLightColor_ft_4, _.totalDiffuseLightColor_ft_4);
        if (commonShaderParams.useAmbientTexture > 0) {
            _.mul(_.mDiff_ft.xyz, _.mDiff_ft, _.totalDiffuseLightColor_ft_4); //
            _.mul(_.totalDiffuseLightColor_ft_4.xyz, _.finalColor_ft_4, _.totalDiffuseLightColor_ft_4); //
            _.sub(_.finalColor_ft_4.xyz, _.finalColor_ft_4, _.totalDiffuseLightColor_ft_4); //
            _.add(_.finalColor_ft_4.xyz, _.mDiff_ft, _.finalColor_ft_4);
        }
        else {
            //漫反射 + 环境光 因子
            _.add(_.finalColor_ft_4.xyz, _.totalDiffuseLightColor_ft_4, _.finalColor_ft_4);
            //混合漫反射光
            _.mul(_.finalColor_ft_4.xyz, _.mDiff_ft, _.finalColor_ft_4);
            //保存w值不变
            _.mov(_.finalColor_ft_4.w, _.mDiff_ft.w);
        }
    }
    feng3d.F_DiffusePostLighting = F_DiffusePostLighting;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 方向光渲染函数
     * @author feng 2014-11-7
     */
    function F_DirectionalLight() {
        var _ = feng3d.FagalRE.instance.space;
        var shaderParams = feng3d.FagalRE.instance.context3DCache.shaderParams;
        var commonShaderParams = shaderParams.getOrCreateComponentByClass(feng3d.CommonShaderParams);
        var lightShaderParams = shaderParams.getOrCreateComponentByClass(feng3d.LightShaderParams);
        var numDirectionalLights = lightShaderParams.numDirectionalLights;
        //遍历处理每个方向光
        for (var i = 0; i < numDirectionalLights; ++i) {
            //灯光方向寄存器
            var lightDirReg = _.dirLightSceneDir_fc_vector.getReg(i);
            //漫反射颜色寄存器
            var diffuseColorReg = _.dirLightDiffuse_fc_vector.getReg(i);
            //镜面反射颜色寄存器
            var specularColorReg = _.dirLightSpecular_fc_vector.getReg(i);
            //处理每个光的漫反射
            if (commonShaderParams.usingDiffuseMethod > 0) {
                feng3d.getDiffCodePerLight(lightDirReg, diffuseColorReg);
            }
            //处理每个光的镜面反射
            if (lightShaderParams.usingSpecularMethod > 0) {
                feng3d.getSpecCodePerLight(lightDirReg, specularColorReg);
            }
        }
    }
    feng3d.F_DirectionalLight = F_DirectionalLight;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * phong model
     * @author feng 2015-9-24
     */
    function F_Phong(singleSpecularColorReg, lightDirReg) {
        var _ = feng3d.FagalRE.instance.space;
        // phong model
        _.dp3(singleSpecularColorReg.w, lightDirReg, _.normal_ft_4); // sca1 = light.normal
        //find the reflected light vector R
        _.add(singleSpecularColorReg.w, singleSpecularColorReg.w, singleSpecularColorReg.w); // sca1 = sca1*2
        _.mul(singleSpecularColorReg.xyz, _.normal_ft_4, singleSpecularColorReg.w); // vec1 = normal*sca1
        _.sub(singleSpecularColorReg.xyz, singleSpecularColorReg, lightDirReg); // vec1 = vec1 - light (light vector is negative)
        //smooth the edge as incidence angle approaches 90
        _.add(singleSpecularColorReg.w, singleSpecularColorReg.w, _.commonsData_fc_vector.w); // sca1 = sca1 + smoothtep;
        _.sat(singleSpecularColorReg.w, singleSpecularColorReg.w); // sca1 range 0 - 1
        _.mul(singleSpecularColorReg.xyz, singleSpecularColorReg, singleSpecularColorReg.w); // vec1 = vec1*sca1
        //find the dot product between R and V
        _.dp3(singleSpecularColorReg.w, singleSpecularColorReg, _.viewDir_ft_4); // sca1 = vec1.view
        _.sat(singleSpecularColorReg.w, singleSpecularColorReg.w);
    }
    feng3d.F_Phong = F_Phong;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 点光源渲染
     * @author feng 2014-11-8
     */
    function F_PointLight() {
        var _ = feng3d.FagalRE.instance.space;
        var shaderParams = feng3d.FagalRE.instance.context3DCache.shaderParams;
        var commonShaderParams = shaderParams.getOrCreateComponentByClass(feng3d.CommonShaderParams);
        var lightShaderParams = shaderParams.getOrCreateComponentByClass(feng3d.LightShaderParams);
        var numPointLights = lightShaderParams.numPointLights;
        //
        //光线方向
        var pointLightDirReg;
        //点光源漫反射颜色寄存器
        var pointLightdiffuseColorReg;
        //点光源镜面反射颜色寄存器
        var pointLightSpecularColorReg;
        //点光源世界坐标寄存器
        var pointLightPosReg;
        pointLightDirReg = _.getFreeTemp("光照方向");
        //遍历点光源
        for (var i = 0; i < numPointLights; ++i) {
            pointLightPosReg = _.pointLightScenePos_fc_vector.getReg(i);
            pointLightdiffuseColorReg = _.pointLightDiffuse_fc_vector.getReg(i);
            pointLightSpecularColorReg = _.pointLightSpecular_fc_vector.getReg(i);
            _.comment("计算光照方向与光强");
            // 计算光衰减 （根据物体表面离光源的距离来计算光强）
            //物体表面到光源距离
            _.sub(pointLightDirReg, pointLightPosReg, _.globalPos_v);
            // attenuate
            _.dp3(pointLightDirReg.w, pointLightDirReg, pointLightDirReg);
            // w = d - radis
            _.sub(pointLightDirReg.w, pointLightDirReg.w, pointLightdiffuseColorReg.w);
            // w = (d - radius)/(max-min) 
            _.mul(pointLightDirReg.w, pointLightDirReg.w, pointLightSpecularColorReg.w);
            // w = clamp(w, 0, 1)
            _.sat(pointLightDirReg.w, pointLightDirReg.w);
            // w = 1-w (w为光强)
            _.sub(pointLightDirReg.w, pointLightPosReg.w, pointLightDirReg.w);
            // normalize
            _.nrm(pointLightDirReg.xyz, pointLightDirReg); //
            //计算漫反射
            if (commonShaderParams.usingDiffuseMethod) {
                feng3d.getDiffCodePerLight(pointLightDirReg, pointLightdiffuseColorReg);
            }
            //计算镜面反射
            if (lightShaderParams.usingSpecularMethod) {
                feng3d.getSpecCodePerLight(pointLightDirReg, pointLightSpecularColorReg);
            }
        }
    }
    feng3d.F_PointLight = F_PointLight;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 结算镜面反射光
     * @author feng 2014-11-7
     */
    function F_SpecularPostLighting() {
        var _ = feng3d.FagalRE.instance.space;
        var shaderParams = feng3d.FagalRE.instance.context3DCache.shaderParams;
        var lightShaderParams = shaderParams.getOrCreateComponentByClass(feng3d.LightShaderParams);
        var shadowShaderParams = shaderParams.getOrCreateComponentByClass(feng3d.ShadowShaderParams);
        //把阴影值使用到镜面反射上
        if (shadowShaderParams.needsShadowRegister) {
            _.mul(_.totalSpecularLightColor_ft_4.xyz, _.totalSpecularLightColor_ft_4, _.shadowValue_ft_4.w);
        }
        if (lightShaderParams.hasSpecularTexture > 0) {
            _.mul(_.totalSpecularLightColor_ft_4.xyz, _.totalSpecularLightColor_ft_4, _.specularTexData_ft_4.x);
        }
        //混合镜面反射光 = 镜面反射光颜色 mul 材质镜面反射颜色
        _.mul(_.totalSpecularLightColor_ft_4.xyz, _.totalSpecularLightColor_ft_4, _.specularData_fc_vector);
        //添加到最终颜色中
        _.add(_.finalColor_ft_4.xyz, _.finalColor_ft_4, _.totalSpecularLightColor_ft_4);
    }
    feng3d.F_SpecularPostLighting = F_SpecularPostLighting;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     *
     * @author feng 2015-9-24
     */
    var SpecularModelType = (function () {
        function SpecularModelType() {
        }
        SpecularModelType.BLINN_PHONG = "blinn-phong half vector model";
        SpecularModelType.PHONG = "phong model";
        return SpecularModelType;
    }());
    feng3d.SpecularModelType = SpecularModelType;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 处理
     * @author feng 2015-4-24
     */
    function getDiffCodePerLight(lightDirReg, diffuseColorReg) {
        var _ = feng3d.FagalRE.instance.space;
        var shaderParams = feng3d.FagalRE.instance.context3DCache.shaderParams;
        var lightShaderParams = shaderParams.getOrCreateComponentByClass(feng3d.LightShaderParams);
        var diffuseColorFtReg;
        if (lightShaderParams.isFirstDiffLight) {
            diffuseColorFtReg = _.totalDiffuseLightColor_ft_4;
        }
        else {
            diffuseColorFtReg = _.getFreeTemp("单个漫反射光寄存器");
        }
        //计算灯光方向与法线夹角
        _.dp3(diffuseColorFtReg.x, lightDirReg, _.normal_ft_4);
        //过滤负数
        _.max(diffuseColorFtReg.w, diffuseColorFtReg.x, _.commonsData_fc_vector.y);
        //灯光衰减
        if (lightShaderParams.useLightFallOff)
            _.mul(diffuseColorFtReg.w, diffuseColorFtReg.w, lightDirReg.w);
        if (shaderParams.diffuseModulateMethod != null) {
            shaderParams.diffuseModulateMethod(diffuseColorFtReg);
        }
        _.comment("漫反射光颜色 = 灯光漫反射颜色 mul 漫反射光强度");
        _.mul(diffuseColorFtReg, diffuseColorFtReg.w, diffuseColorReg);
        //叠加灯光
        if (!lightShaderParams.isFirstDiffLight) {
            _.add(_.totalDiffuseLightColor_ft_4.xyz, _.totalDiffuseLightColor_ft_4, diffuseColorFtReg);
        }
        lightShaderParams.isFirstDiffLight = false;
    }
    feng3d.getDiffCodePerLight = getDiffCodePerLight;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 计算单个镜面反射光
     * @author feng 2015-4-24
     */
    function getSpecCodePerLight(lightDirReg, specularColorReg) {
        var _ = feng3d.FagalRE.instance.space;
        var shaderParams = feng3d.FagalRE.instance.context3DCache.shaderParams;
        var lightShaderParams = shaderParams.getOrCreateComponentByClass(feng3d.LightShaderParams);
        //镜面反射光原理
        //法线 = 入射光方向 - 反射光方向------------1
        //物理光学已知：当视线方向与反射光方向相反时，反射光达到最亮。反射光强度和（反射光方向与-视线方向 的 夹角余弦值）相关
        //反射光方向与-视线 的 夹角 ---(代入1)--> (入射光方向 - 法线) 与 -视线 的 夹角 ----> 入射光方向+视线 与 法线的夹角
        //反射光方向与-视线方向 的 夹角余弦值 == 入射光方向+视线 与 法线 的 夹角余弦值  == 反射光强度
        var singleSpecularColorReg;
        if (lightShaderParams.isFirstSpecLight) {
            singleSpecularColorReg = _.totalSpecularLightColor_ft_4;
        }
        else {
            singleSpecularColorReg = _.getFreeTemp("单个镜面反射光寄存器");
        }
        //灯光模型
        if (shaderParams.specularModelType == feng3d.SpecularModelType.PHONG) {
            feng3d.F_Phong(singleSpecularColorReg, lightDirReg);
        }
        else {
            feng3d.F_Blinn_Phong(singleSpecularColorReg, lightDirReg);
        }
        if (lightShaderParams.hasSpecularTexture > 0) {
            //使用光照图调整高光
            //光泽纹理数据片段临时寄存器
            _.mul(_.specularTexData_ft_4.w, _.specularTexData_ft_4.y, _.specularData_fc_vector.w);
            _.pow(singleSpecularColorReg.w, singleSpecularColorReg.w, _.specularTexData_ft_4.w);
        }
        else {
            //镜面反射光强度 = 镜面反射光强度 pow 光泽度
            _.pow(singleSpecularColorReg.w, singleSpecularColorReg.w, _.specularData_fc_vector.w);
        }
        if (lightShaderParams.useLightFallOff) {
            //镜面反射光强度 = 镜面反射强度  nul (入射光强度？)
            _.mul(singleSpecularColorReg.w, singleSpecularColorReg.w, lightDirReg.w);
        }
        if (shaderParams.modulateMethod != null) {
            shaderParams.modulateMethod(singleSpecularColorReg);
        }
        _.comment("镜面反射光颜色 = 灯光镜面反射颜色 mul 镜面反射光强度");
        _.mul(singleSpecularColorReg.xyz, specularColorReg, singleSpecularColorReg.w);
        //叠加镜面反射光
        if (!lightShaderParams.isFirstSpecLight) {
            //总镜面反射光 = 总镜面反射光 + 单个镜面反射光
            _.add(_.totalSpecularLightColor_ft_4.xyz, _.totalSpecularLightColor_ft_4, singleSpecularColorReg);
        }
        lightShaderParams.isFirstSpecLight = false;
    }
    feng3d.getSpecCodePerLight = getSpecCodePerLight;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     *
     * @author feng 2015-9-24
     */
    function F_FresnelSpecular(target) {
        var _ = feng3d.FagalRE.instance.space;
        var shaderParams = feng3d.FagalRE.instance.context3DCache.shaderParams;
        var _dataReg = _.fresnelSpecularData_fc_vector;
        var _incidentLight = shaderParams.incidentLight;
        _.dp3(target.y, _.viewDir_ft_4.xyz, _incidentLight ? target.xyz : _.normal_ft_4.xyz); // dot(V, H)
        _.sub(target.y, _dataReg.z, target.y); // base = 1-dot(V, H)
        _.pow(target.x, target.y, _dataReg.y); // exp = pow(base, 5)
        _.sub(target.y, _dataReg.z, target.y); // 1 - exp
        _.mul(target.y, _dataReg.x, target.y); // f0*(1 - exp)
        _.add(target.y, target.x, target.y); // exp + f0*(1 - exp)
        _.mul(target.w, target.w, target.y);
    }
    feng3d.F_FresnelSpecular = F_FresnelSpecular;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     *
     * @author feng 2015-1-21
     */
    function F_ParticleColorCombination() {
        var _ = feng3d.FagalRE.instance.space;
        //			if (hasColorMulNode)
        _.mul(_.finalColor_ft_4, _.finalColor_ft_4, _.particleColorMultiplier_v);
        //			if (hasColorAddNode)
        _.add(_.finalColor_ft_4, _.finalColor_ft_4, _.particleColorOffset_v);
    }
    feng3d.F_ParticleColorCombination = F_ParticleColorCombination;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 粒子片段渲染程序
     * @author feng 2015-1-21
     */
    function F_Particles() {
        var shaderParams = feng3d.FagalRE.instance.context3DCache.shaderParams;
        var particleShaderParams = shaderParams.getOrCreateComponentByClass(feng3d.ParticleShaderParams);
        /** 粒子渲染参数 */
        if (particleShaderParams.ParticleColorGlobal) {
            feng3d.F_ParticleColorCombination();
        }
    }
    feng3d.F_Particles = F_Particles;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 编译阴影映射片段程序
     * @author feng 2015-6-23
     */
    function F_ShadowMap() {
        var _ = feng3d.FagalRE.instance.space;
        var shaderParams = feng3d.FagalRE.instance.context3DCache.shaderParams;
        var shadowShaderParams = shaderParams.getOrCreateComponentByClass(feng3d.ShadowShaderParams);
        feng3d.F_ShadowMapSample();
        _.add(_.shadowValue_ft_4.w, _.shadowValue_ft_4.w, _.shadowCommondata1_fc_vector.y); //添加(1-阴影透明度)
        _.sat(_.shadowValue_ft_4.w, _.shadowValue_ft_4.w); //使阴影值在(0,1)区间内
        var temp = _.getFreeTemp();
        if (shadowShaderParams.useNearShadowMap > 0) {
            //根据阴影离摄像机的距离计算阴影的透明度
            _.abs(temp, _.positionProjected_v.w); //获取顶点深度正值
            _.sub(temp, temp, _.secondary_fc_vector.x); //深度-最近可观察阴影距离
            _.mul(temp, temp, _.secondary_fc_vector.y); //计算衰减值
            _.sat(temp, temp); //
            _.sub(temp, _.secondary_fc_vector.w, temp); //ft5.x（阴影透明度）=1-衰减值
            _.sub(_.shadowValue_ft_4.w, _.secondary_fc_vector.w, _.shadowValue_ft_4.w); //ft0.w==1时为阴影
            _.mul(_.shadowValue_ft_4.w, _.shadowValue_ft_4.w, temp); //阴影乘以透明度
            _.sub(_.shadowValue_ft_4.w, _.secondary_fc_vector.w, _.shadowValue_ft_4.w); //ft0.w==0时为阴影
        }
    }
    feng3d.F_ShadowMap = F_ShadowMap;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 阴影图采样比较计算阴影值
     * @author feng 2015-7-17
     */
    function F_ShadowMapSample() {
        var _ = feng3d.FagalRE.instance.space;
        var depthCol = _.getFreeTemp("深度值临时寄存器");
        var uvReg = _.getFreeTemp("深度图uv临时寄存器");
        _.mov(uvReg, _.depthMapCoord_v); //计算阴影
        _.tex(depthCol, _.depthMapCoord_v, _.depthMap_fs); //读取阴影图值
        _.dp4(depthCol.z, depthCol, _.shadowCommondata0_fc_vector);
        _.slt(uvReg.z, _.depthMapCoord_v.z, depthCol.z); //比较深度 // 0 if in shadow
        _.add(uvReg.x, _.depthMapCoord_v.x, _.shadowCommondata2_fc_vector.z); //取(1,0)位置的深度值
        _.tex(depthCol, uvReg, _.depthMap_fs); //读取阴影图值
        _.dp4(depthCol.z, depthCol, _.shadowCommondata0_fc_vector);
        _.slt(uvReg.w, _.depthMapCoord_v.z, depthCol.z); //与(1,0)深度做比较 // 0 if in shadow
        _.mul(depthCol.x, _.depthMapCoord_v.x, _.shadowCommondata2_fc_vector.y); //计算顶点在阴影图的像素x位置
        _.frc(depthCol.x, depthCol.x); //取出分数部分  0<分数部分<1
        _.blend(_.shadowValue_ft_4.w, uvReg.z, uvReg.w, depthCol.x); //混合(0,0)与(1,0)的深度结果
        //与(0,1)深度做比较
        _.mov(uvReg.x, _.depthMapCoord_v.x);
        _.add(uvReg.y, _.depthMapCoord_v.y, _.shadowCommondata2_fc_vector.z); // (0, 1)
        _.tex(depthCol, uvReg, _.depthMap_fs);
        _.dp4(depthCol.z, depthCol, _.shadowCommondata0_fc_vector);
        _.slt(uvReg.z, _.depthMapCoord_v.z, depthCol.z); // 0 if in shadow
        //与(1,1)深度做比较
        _.add(uvReg.x, _.depthMapCoord_v.x, _.shadowCommondata2_fc_vector.z); // (1, 1)
        _.tex(depthCol, uvReg, _.depthMap_fs);
        _.dp4(depthCol.z, depthCol, _.shadowCommondata0_fc_vector);
        _.slt(uvReg.w, _.depthMapCoord_v.z, depthCol.z); // 0 if in shadow
        //根据X方向分数部分来混合(0,1)与(1,1)的深度结果  x1-x0
        _.mul(depthCol.x, _.depthMapCoord_v.x, _.shadowCommondata2_fc_vector.y);
        _.frc(depthCol.x, depthCol.x);
        _.blend(uvReg.w, uvReg.z, uvReg.w, depthCol.x);
        //再次根据Y方向分数部分来混合两次X方向混合的结果
        _.mul(depthCol.x, _.depthMapCoord_v.y, _.shadowCommondata2_fc_vector.y);
        _.frc(depthCol.x, depthCol.x);
        _.blend(_.shadowValue_ft_4.w, _.shadowValue_ft_4.w, uvReg.w, depthCol.x);
    }
    feng3d.F_ShadowMapSample = F_ShadowMapSample;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 漫反射材质颜色
     * @author feng 2014-11-6
     */
    function F_DiffuseColor() {
        var _ = feng3d.FagalRE.instance.space;
        //漫射输入静态数据 
        _.mov(_.mDiff_ft, _.diffuseInput_fc_vector);
    }
    feng3d.F_DiffuseColor = F_DiffuseColor;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 漫反射纹理取样
     * @author feng 2014-11-6
     */
    function F_DiffuseTexure() {
        var _ = feng3d.FagalRE.instance.space;
        var shaderParams = feng3d.FagalRE.instance.context3DCache.shaderParams;
        var commonShaderParams = shaderParams.getOrCreateComponentByClass(feng3d.CommonShaderParams);
        _.tex(_.mDiff_ft, _.uv_v, _.texture_fs);
        if (commonShaderParams.alphaThreshold > 0) {
            var cutOffReg = _.alphaThreshold_fc_vector;
            _.sub(_.mDiff_ft.w, _.mDiff_ft.w, cutOffReg.x);
            _.kil(_.mDiff_ft.w);
            _.add(_.mDiff_ft.w, _.mDiff_ft.w, cutOffReg.x);
        }
    }
    feng3d.F_DiffuseTexure = F_DiffuseTexure;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     *
     * @author feng 2015-9-5
     */
    function F_EnvMapMethod() {
        var _ = feng3d.FagalRE.instance.space;
        var shaderParams = feng3d.FagalRE.instance.context3DCache.shaderParams;
        var envShaderParams = shaderParams.getOrCreateComponentByClass(feng3d.EnvShaderParams);
        var dataRegister = _.envMapData_fc_vector;
        var temp = _.getFreeTemp("");
        var cubeMapReg = _.envMapcubeTexture_fs;
        var temp2 = _.getFreeTemp("");
        var targetReg = _.finalColor_ft_4;
        // r = I - 2(I.N)*N
        _.dp3(temp.w, _.viewDir_ft_4.xyz, _.normal_ft_4.xyz);
        _.add(temp.w, temp.w, temp.w);
        _.mul(temp.xyz, _.normal_ft_4.xyz, temp.w);
        _.sub(temp.xyz, temp.xyz, _.viewDir_ft_4.xyz);
        //有些没看懂..................................
        _.tex(temp, temp, cubeMapReg);
        _.sub(temp2.w, temp.w, _.commonsData_fc_vector.x); // -.5
        _.kil(temp2.w); // used for real time reflection mapping - if alpha is not 1 (mock texture) kil output
        _.sub(temp, temp, targetReg);
        if (envShaderParams.useEnvMapMask) {
            _.tex(temp2, _.uv_v, _.envMapMaskTexture_fs);
            _.mul(temp, temp2, temp);
        }
        _.mul(temp, temp, dataRegister.x);
        _.add(targetReg, targetReg, temp);
    }
    feng3d.F_EnvMapMethod = F_EnvMapMethod;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 最终颜色输出函数
     * @author feng 2014-11-7
     */
    function F_FinalOut() {
        var _ = feng3d.FagalRE.instance.space;
        _.mov(_._oc, _.finalColor_ft_4);
    }
    feng3d.F_FinalOut = F_FinalOut;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 雾片段着色器
     * @author feng 2015-8-27
     */
    function F_Fog() {
        var _ = feng3d.FagalRE.instance.space;
        var temp2 = _.getFreeTemp("");
        var temp = _.getFreeTemp("");
        //计算雾因子
        //fogRatio = max(0,min(1,(positionZ-minZ)/(maxZ-minZ)))
        _.sub(temp2.w, _.positionProjected_v.z, _.fogCommonData_fc_vector.x); //deltaZ=positionZ-minZ
        _.mul(temp2.w, temp2.w, _.fogCommonData_fc_vector.y); //fogRatio = deltaZ/(maxZ-minZ)
        _.sat(temp2.w, temp2.w); //fogRatio = max(0,fogRatio))
        //使用雾因子把雾颜色混合到最终颜色中
        //col = (fogColor - col) * fogRatio + col = fogRatio * fogColor + (1 - fogRatio) * col
        _.sub(temp, _.fogColor_fc_vector, _.finalColor_ft_4); // (fogColor- col)
        _.mul(temp, temp, temp2.w); // (fogColor- col)*fogRatio
        _.add(_.finalColor_ft_4, _.finalColor_ft_4, temp); // fogRatio*(fogColor- col) + col
    }
    feng3d.F_Fog = F_Fog;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 法线取样函数
     * @author feng 2014-10-23
     */
    function F_NormalSample() {
        var _ = feng3d.FagalRE.instance.space;
        //获取纹理数据
        _.tex(_.normalTexData_ft_4, _.uv_v, _.normalTexture_fs);
        //使法线纹理数据 【0,1】->【-0.5,0.5】
        _.sub(_.normalTexData_ft_4.xyz, _.normalTexData_ft_4.xyz, _.commonsData_fc_vector.xxx);
        //标准化法线纹理数据
        _.nrm(_.normalTexData_ft_4.xyz, _.normalTexData_ft_4.xyz);
    }
    feng3d.F_NormalSample = F_NormalSample;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 光泽图取样函数
     * @author feng 2014-10-23
     */
    function F_SpecularSample() {
        var _ = feng3d.FagalRE.instance.space;
        //获取纹理数据
        _.tex(_.specularTexData_ft_4, _.uv_v, _.specularTexture_fs);
    }
    feng3d.F_SpecularSample = F_SpecularSample;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 编译切线法线贴图片段程序
     * @author feng 2014-11-7
     */
    function F_TangentNormalMap() {
        var _ = feng3d.FagalRE.instance.space;
        //此处必须三个寄存器申请为寄存器数组来确保三个临时寄存器连续与同时销毁
        var normalMxt3 = _.getFreeTemps("动画后顶点法线空间寄存器向量，(切线，双切线，法线)", 3);
        var t = normalMxt3.getReg(0);
        var b = normalMxt3.getReg(1);
        var n = normalMxt3.getReg(2);
        //标准化切线
        _.nrm(t.xyz, _.tangent_v);
        //保存w不变
        _.mov(t.w, _.tangent_v.w);
        //标准化双切线
        _.nrm(b.xyz, _.bitangent_v);
        //标准化法线
        _.nrm(n.xyz, _.normal_v);
        feng3d.F_NormalSample();
        //标准化法线纹理数据
        _.m33(_.normal_ft_4.xyz, _.normalTexData_ft_4, t);
        //保存w不变
        _.mov(_.normal_ft_4.w, _.normal_v.w);
    }
    feng3d.F_TangentNormalMap = F_TangentNormalMap;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 编译切线片段程序(无法线图)
     * @author feng 2014-11-7
     */
    function F_TangentNormalNoMap() {
        var _ = feng3d.FagalRE.instance.space;
        //标准化法线
        _.nrm(_.normal_ft_4.xyz, _.normal_v);
        //保存w不变
        _.mov(_.normal_ft_4.w, _.normal_v.w);
    }
    feng3d.F_TangentNormalNoMap = F_TangentNormalNoMap;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 地形渲染函数
     * @author feng 2014-11-6
     */
    function F_TerrainDiffusePostLighting() {
        var _ = feng3d.FagalRE.instance.space;
        var shaderParams = feng3d.FagalRE.instance.context3DCache.shaderParams;
        var terrainShaderParams = shaderParams.getOrCreateComponentByClass(feng3d.TerrainShaderParams);
        var numSplattingLayers = terrainShaderParams.splatNum;
        //缩放后的uv坐标、uv计算后的颜色值
        var uvTemp = _.getFreeTemp("缩放后的uv坐标");
        //混合比例（4个分量表示4个纹理所占比重）
        var blendTemp = _.getFreeTemp("混合比例");
        _.mul(uvTemp, _.uv_v, _.tile_fc_vector.c(0)); // 缩放uv （表示将重复x*x遍） x=scaleRegister.c(0)
        _.tex(_.finalColor_ft_4, uvTemp, _.texture_fs); // 使用默认贴图 得到默认颜色值
        _.tex(blendTemp, _.uv_v, _.blendingtexture_fs); // 计算混合纹理
        for (var i = 0; i < numSplattingLayers; ++i) {
            _.mul(uvTemp, _.uv_v, _.tile_fc_vector.c(i + 1)); //  缩放uv （表示将重复x*x遍） x=scaleRegister.c(i + 1)
            _.tex(uvTemp, uvTemp, _.terrainTextures_fs_array.getReg(i)); // 使用地面纹理 得到该纹理颜色值
            _.sub(uvTemp, uvTemp, _.finalColor_ft_4); // uvtemp = uvtemp - targetreg; --------------1
            _.mul(uvTemp, uvTemp, blendTemp.c(i)); // uvtemp = uvtemp * blendtemp; ----------2  (0 <= blendtemp <= 1)
            _.add(_.finalColor_ft_4, _.finalColor_ft_4, uvTemp); // 添加到默认颜色值上  targetreg = targetreg + uvtemp; ------------3
        }
    }
    feng3d.F_TerrainDiffusePostLighting = F_TerrainDiffusePostLighting;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 视线片段渲染函数
     * @author feng 2014-11-7
     */
    function F_ViewDir() {
        var _ = feng3d.FagalRE.instance.space;
        //标准化视线
        _.nrm(_.viewDir_ft_4.xyz, _.viewDir_v);
        //保持w不变
        _.mov(_.viewDir_ft_4.w, _.viewDir_v.w);
    }
    feng3d.F_ViewDir = F_ViewDir;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * Fagal函数
     * @author feng 2014-10-23
     */
    var FagalMethod = (function () {
        /**
         * 构建一个Fagal函数
         */
        function FagalMethod() {
        }
        Object.defineProperty(FagalMethod.prototype, "shaderParams", {
            /**
             * 渲染参数
             */
            get: function () {
                return feng3d.FagalRE.instance.context3DCache.shaderParams;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FagalMethod.prototype, "shaderType", {
            /**
             * 着色器类型
             */
            get: function () {
                return this._shaderType;
            },
            enumerable: true,
            configurable: true
        });
        return FagalMethod;
    }());
    feng3d.FagalMethod = FagalMethod;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 深度图片段主程序
     * @author feng 2015-5-30
     */
    var F_Main_DepthMap = (function (_super) {
        __extends(F_Main_DepthMap, _super);
        /**
         * 创建深度图片段主程序
         */
        function F_Main_DepthMap() {
            _super.call(this);
            this._shaderType = feng3d.Context3DProgramType.FRAGMENT;
        }
        /**
         * @inheritDoc
         */
        F_Main_DepthMap.prototype.runFunc = function () {
            var _ = feng3d.FagalRE.instance.space;
            var positionReg = _.getFreeTemp("坐标"); //ft2
            //深度的（乘以1,255,255*255,255*255*255后）不同值
            var depthValueReg = _.getFreeTemp("深度值");
            var ft1 = _.getFreeTemp("");
            //计算深度值depth属于（0,1）,该范围外的将会被frc处理为0或1
            _.div(positionReg, _.positionProjected_v, _.positionProjected_v.w);
            //深度值保存为颜色值
            _.mul(depthValueReg, _.depthCommonData0_fc_vector, positionReg.z);
            //和上行代码配合，保存了深度的1/255/255/255的精度的值
            _.frc(depthValueReg, depthValueReg);
            //计算多余的值
            _.mul(ft1, depthValueReg.yzww, _.depthCommonData1_fc_vector);
            //真正的深度值 = 减去多余的(1/255)值  （精度在1/255/255/255）
            _.sub(_.depthMap_oc, depthValueReg, ft1);
            /*
    片段着色器计算貌似有些高深。。,
    其目的是使用rgba高精度方式保存深度值，并且可以从rgba中获取深度值。
    此处应把深度看为255进制数据，rgba分别保存4个位(1，1/255，1/255/255,1/255/255/255)的值。
    此处使用rgba分别保存（1，1/255,1/255/255,1/255/255/255）这4个不同精度的值
    depth = r*1 + g/255 + b/255/255 + a/255/255/255 + x；此处有depth,r,g,b,a属于(0,1)范围;地处x<1/255/255/255,x可忽略不计
    
    正常计算rgba的方法
    r=frc(depth)-frc(depth*255)/255;
    g=frc(depth*255)-frc(depth*255*255)/255;
    b=frc(depth*255*255)-frc(depth*255*255)/255;
    a=frc(depth*255*255*255)-frc(depth*255*255*255*255)/255;
    由于无法生成depth*255*255*255*255的值，精度就定在1/255/255/255，精度只会在1/255/255/255出有损失
    因此 a= frc(depth*255*255*255)
    
    
    通过渲染程序推倒
    mul ft0, fc0, ft2.z 		=> depth*(1,255,255*255,255*255*255)=(depth,depth*255,depth*255*255,depth*255*255*255)
    frc ft0, ft0				=> (frc(depth),frc(depth*255),frc(depth*255*255),frc(depth*255*255*255))
    mul ft1, ft0.yzww, fc1		=>	(frc(depth*255)/255,frc(depth*255*255)/255,frc(depth*255*255*255)/255,0)
    sub oc, ft0, ft1			=>	(frc(depth)-frc(depth*255)/255,frc(depth*255)-frc(depth*255*255)/255,frc(depth*255*255)-frc(depth*255*255*255)/255,frc(depth*255*255*255))
    =>	(r,g,b,a)
    */
        };
        return F_Main_DepthMap;
    }(feng3d.FagalMethod));
    feng3d.F_Main_DepthMap = F_Main_DepthMap;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 深度图片段主程序
     * @author feng 2015-5-30
     */
    var F_Main_PlanarShadow = (function (_super) {
        __extends(F_Main_PlanarShadow, _super);
        /**
         * 创建深度图片段主程序
         */
        function F_Main_PlanarShadow() {
            _super.call(this);
            this._shaderType = feng3d.Context3DProgramType.FRAGMENT;
        }
        /**
         * @inheritDoc
         */
        F_Main_PlanarShadow.prototype.runFunc = function () {
            var _ = feng3d.FagalRE.instance.space;
            _.mov(_._oc, _.shadowColorCommonsData_fc_vector);
        };
        return F_Main_PlanarShadow;
    }(feng3d.FagalMethod));
    feng3d.F_Main_PlanarShadow = F_Main_PlanarShadow;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 片段渲染程序主入口
     * @author feng 2014-10-30
     */
    var F_Main = (function (_super) {
        __extends(F_Main, _super);
        /**
         * 创建片段渲染程序主入口
         */
        function F_Main() {
            _super.call(this);
            this._shaderType = feng3d.Context3DProgramType.FRAGMENT;
        }
        /**
         * @inheritDoc
         */
        F_Main.prototype.runFunc = function () {
            this.shaderParams.preRunParams();
            var commonShaderParams = this.shaderParams.getOrCreateComponentByClass(feng3d.CommonShaderParams);
            var lightShaderParams = this.shaderParams.getOrCreateComponentByClass(feng3d.LightShaderParams);
            var shadowShaderParams = this.shaderParams.getOrCreateComponentByClass(feng3d.ShadowShaderParams);
            var fogShaderParams = this.shaderParams.getOrCreateComponentByClass(feng3d.FogShaderParams);
            var envShaderParams = this.shaderParams.getOrCreateComponentByClass(feng3d.EnvShaderParams);
            //计算法线
            if (lightShaderParams.needsNormals > 0) {
                if (lightShaderParams.hasNormalTexture) {
                    feng3d.F_TangentNormalMap();
                }
                else {
                    feng3d.F_TangentNormalNoMap();
                }
            }
            //光泽图采样
            if (lightShaderParams.hasSpecularTexture > 0) {
                feng3d.F_SpecularSample();
            }
            //计算视线
            if (lightShaderParams.needsViewDir > 0) {
                feng3d.F_ViewDir();
            }
            //处理方向灯光
            if (lightShaderParams.numDirectionalLights > 0) {
                feng3d.F_DirectionalLight();
            }
            //处理点灯光
            if (lightShaderParams.numPointLights > 0) {
                feng3d.F_PointLight();
            }
            //计算环境光
            if (lightShaderParams.numLights > 0) {
                feng3d.F_Ambient();
            }
            //渲染阴影
            if (shadowShaderParams.usingShadowMapMethod > 0) {
                feng3d.F_ShadowMap();
            }
            //计算漫反射
            if (commonShaderParams.usingDiffuseMethod) {
                lightShaderParams.diffuseMethod();
            }
            if (this.shaderParams.alphaPremultiplied) {
                feng3d.F_AlphaPremultiplied();
            }
            if (lightShaderParams.numLights > 0 && lightShaderParams.usingSpecularMethod > 0) {
                feng3d.F_SpecularPostLighting();
            }
            //调用粒子相关片段渲染程序
            feng3d.F_Particles();
            if (envShaderParams.useEnvMapMethod > 0) {
                feng3d.F_EnvMapMethod();
            }
            if (fogShaderParams.useFog > 0) {
                feng3d.F_Fog();
            }
            feng3d.F_FinalOut();
        };
        return F_Main;
    }(feng3d.FagalMethod));
    feng3d.F_Main = F_Main;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 线段片段渲染程序
     * @author feng 2014-10-28
     */
    var F_Segment = (function (_super) {
        __extends(F_Segment, _super);
        function F_Segment() {
            _super.call(this);
            this._shaderType = feng3d.Context3DProgramType.FRAGMENT;
        }
        F_Segment.prototype.runFunc = function () {
            var _ = feng3d.FagalRE.instance.space;
            _.comment("传递顶点颜色数据" + _.color_v + "到片段寄存器" + _._oc);
            _.mov(_._oc, _.color_v);
        };
        return F_Segment;
    }(feng3d.FagalMethod));
    feng3d.F_Segment = F_Segment;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 天空盒片段渲染程序
     * @author feng 2014-11-4
     */
    var F_SkyBox = (function (_super) {
        __extends(F_SkyBox, _super);
        function F_SkyBox() {
            _super.call(this);
            this._shaderType = feng3d.Context3DProgramType.FRAGMENT;
        }
        F_SkyBox.prototype.runFunc = function () {
            var _ = feng3d.FagalRE.instance.space;
            //获取纹理数据
            _.tex(_._oc, _.uv_v, _.skyboxTexture_fs);
        };
        return F_SkyBox;
    }(feng3d.FagalMethod));
    feng3d.F_SkyBox = F_SkyBox;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 深度图顶点主程序
     * @author feng 2015-5-30
     */
    var V_Main_DepthMap = (function (_super) {
        __extends(V_Main_DepthMap, _super);
        /**
         * 构建 深度图顶点主程序
         */
        function V_Main_DepthMap() {
            _super.call(this);
            this._shaderType = feng3d.Context3DProgramType.VERTEX;
        }
        /**
         * @inheritDoc
         */
        V_Main_DepthMap.prototype.runFunc = function () {
            var _ = feng3d.FagalRE.instance.space;
            this.buildAnimationAGAL();
            //普通动画
            //			_.mov(_.animatedPosition_vt_4, _.position_va_3);
            var outPosition = _.getFreeTemp("投影后的坐标");
            //计算投影
            _.m44(outPosition, _.animatedPosition_vt_4, _.projection_vc_matrix);
            //输出顶点坐标数据			
            _.mov(_._op, outPosition);
            //把顶点投影坐标输出到片段着色器
            _.mov(_.positionProjected_v, outPosition);
        };
        /**
         * 生成动画代码
         */
        V_Main_DepthMap.prototype.buildAnimationAGAL = function () {
            var animationShaderParams = this.shaderParams.getOrCreateComponentByClass(feng3d.AnimationShaderParams);
            switch (animationShaderParams.animationType) {
                case feng3d.AnimationType.NONE:
                    feng3d.V_BaseAnimation();
                    break;
                case feng3d.AnimationType.VERTEX_CPU:
                    feng3d.V_VertexAnimationCPU();
                    break;
                case feng3d.AnimationType.VERTEX_GPU:
                    feng3d.V_VertexAnimationGPU();
                    break;
                case feng3d.AnimationType.SKELETON_CPU:
                    feng3d.V_SkeletonAnimationCPU();
                    break;
                case feng3d.AnimationType.SKELETON_GPU:
                    feng3d.V_SkeletonAnimationGPU();
                    break;
                case feng3d.AnimationType.PARTICLE:
                    feng3d.V_Particles();
                    break;
                default:
                    throw new Error(feng3d.AnimationType.PARTICLE + "类型动画缺少FAGAL代码");
            }
        };
        return V_Main_DepthMap;
    }(feng3d.FagalMethod));
    feng3d.V_Main_DepthMap = V_Main_DepthMap;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 平面阴影顶点主程序
     * @author feng 2015-5-30
     */
    var V_Main_PlanarShadow = (function (_super) {
        __extends(V_Main_PlanarShadow, _super);
        /**
         * 构建 深度图顶点主程序
         */
        function V_Main_PlanarShadow() {
            _super.call(this);
            this._shaderType = feng3d.Context3DProgramType.VERTEX;
        }
        /**
         * @inheritDoc
         */
        V_Main_PlanarShadow.prototype.runFunc = function () {
            var _ = feng3d.FagalRE.instance.space;
            this.buildAnimationAGAL();
            var outPosition = _.getFreeTemp("投影后的坐标");
            //计算投影
            _.m44(outPosition, _.animatedPosition_vt_4, _.projection_vc_matrix);
            //输出顶点坐标数据			
            _.mov(_._op, outPosition);
            //把顶点投影坐标输出到片段着色器
            _.mov(_.positionProjected_v, outPosition);
        };
        /**
         * 生成动画代码
         */
        V_Main_PlanarShadow.prototype.buildAnimationAGAL = function () {
            var animationShaderParams = this.shaderParams.getOrCreateComponentByClass(feng3d.AnimationShaderParams);
            switch (animationShaderParams.animationType) {
                case feng3d.AnimationType.NONE:
                    feng3d.V_BaseAnimation();
                    break;
                case feng3d.AnimationType.VERTEX_CPU:
                    feng3d.V_VertexAnimationCPU();
                    break;
                case feng3d.AnimationType.VERTEX_GPU:
                    feng3d.V_VertexAnimationGPU();
                    break;
                case feng3d.AnimationType.SKELETON_CPU:
                    feng3d.V_SkeletonAnimationCPU();
                    break;
                case feng3d.AnimationType.SKELETON_GPU:
                    feng3d.V_SkeletonAnimationGPU();
                    break;
                case feng3d.AnimationType.PARTICLE:
                    feng3d.V_Particles();
                    break;
                default:
                    throw new Error(feng3d.AnimationType.PARTICLE + "类型动画缺少FAGAL代码");
            }
        };
        return V_Main_PlanarShadow;
    }(feng3d.FagalMethod));
    feng3d.V_Main_PlanarShadow = V_Main_PlanarShadow;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 顶点渲染程序主入口
     * @author feng 2014-10-30
     */
    var V_Main = (function (_super) {
        __extends(V_Main, _super);
        /**
         * 创建顶点渲染程序主入口
         *
         */
        function V_Main() {
            _super.call(this);
            this._shaderType = feng3d.Context3DProgramType.VERTEX;
        }
        /**
         * @inheritDoc
         */
        V_Main.prototype.runFunc = function () {
            var _ = feng3d.FagalRE.instance.space;
            var commonShaderParams = this.shaderParams.getOrCreateComponentByClass(feng3d.CommonShaderParams);
            var animationShaderParams = this.shaderParams.getOrCreateComponentByClass(feng3d.AnimationShaderParams);
            var lightShaderParams = this.shaderParams.getOrCreateComponentByClass(feng3d.LightShaderParams);
            var shadowShaderParams = this.shaderParams.getOrCreateComponentByClass(feng3d.ShadowShaderParams);
            this.buildPositionAnimationAGAL();
            //计算世界顶点坐标
            if (lightShaderParams.needWorldPosition)
                feng3d.V_WorldPosition();
            //输出世界坐标到片段寄存器
            if (lightShaderParams.usesGlobalPosFragment)
                feng3d.V_WorldPositionOut();
            //计算投影坐标
            feng3d.V_BaseOut();
            //输出数据到片段寄存器
            if (commonShaderParams.needsUV > 0) {
                //
                if (animationShaderParams.useUVAnimation > 0) {
                    feng3d.V_UVAnimation(_.uv_va_2, _.uv_v);
                }
                else if (animationShaderParams.useSpriteSheetAnimation > 0) {
                    feng3d.V_SpriteSheetAnimation(_.uv_va_2, _.uv_v);
                }
                else {
                    _.mov(_.uv_v, _.uv_va_2);
                }
            }
            //处理法线相关数据
            if (lightShaderParams.needsNormals > 0) {
                if (lightShaderParams.hasNormalTexture) {
                    feng3d.V_TangentNormalMap();
                }
                else {
                    feng3d.V_TangentNormalNoMap();
                }
            }
            //计算视线方向
            if (lightShaderParams.needsViewDir > 0) {
                feng3d.V_ViewDir();
            }
            //计算阴影相关数据
            if (shadowShaderParams.usingShadowMapMethod > 0) {
                feng3d.V_ShadowMap();
            }
        };
        /**
         * 生成动画代码
         */
        V_Main.prototype.buildPositionAnimationAGAL = function () {
            var animationShaderParams = this.shaderParams.getOrCreateComponentByClass(feng3d.AnimationShaderParams);
            switch (animationShaderParams.animationType) {
                case feng3d.AnimationType.NONE:
                    feng3d.V_BaseAnimation();
                    break;
                case feng3d.AnimationType.VERTEX_CPU:
                    feng3d.V_VertexAnimationCPU();
                    break;
                case feng3d.AnimationType.VERTEX_GPU:
                    feng3d.V_VertexAnimationGPU();
                    break;
                case feng3d.AnimationType.SKELETON_CPU:
                    feng3d.V_SkeletonAnimationCPU();
                    break;
                case feng3d.AnimationType.SKELETON_GPU:
                    feng3d.V_SkeletonAnimationGPU();
                    break;
                case feng3d.AnimationType.PARTICLE:
                    feng3d.V_Particles();
                    break;
                default:
                    throw new Error(feng3d.AnimationType.PARTICLE + "类型动画缺少FAGAL代码");
            }
        };
        return V_Main;
    }(feng3d.FagalMethod));
    feng3d.V_Main = V_Main;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 线段顶点渲染程序
     * @author feng 2014-10-28
     */
    var V_Segment = (function (_super) {
        __extends(V_Segment, _super);
        function V_Segment() {
            _super.call(this);
            this._shaderType = feng3d.Context3DProgramType.VERTEX;
        }
        V_Segment.prototype.runFunc = function () {
            var _ = feng3d.FagalRE.instance.space;
            var cStartPosReg = _.getFreeTemp("摄像机空间起点坐标");
            var cEndPosReg = _.getFreeTemp("摄像机空间终点坐标");
            var lenghtReg = _.getFreeTemp("线段长度");
            var temp3 = _.getFreeTemp("");
            var temp4 = _.getFreeTemp("");
            var temp5 = _.getFreeTemp("");
            _.comment("计算相机坐标系起点位置、终点位置、线段距离");
            _.m44(cStartPosReg, _.segmentStart_va_3, _.segmentM2cMatrix_vc_matrix);
            _.m44(cEndPosReg, _.segmentEnd_va_3, _.segmentM2cMatrix_vc_matrix);
            _.sub(lenghtReg, cEndPosReg, cStartPosReg);
            // test if behind camera near plane
            // if 0 - Q0.z < Camera.near then the point needs to be clipped
            //"neg "+temp5+".x, "+temp0+".z				\n" + // 0 - Q0.z
            _.slt(temp5.x, cStartPosReg.z, _.segmentConstants_vc_vector.z); // behind = ( 0 - Q0.z < -Camera.near ) ? 1 : 0
            _.sub(temp5.y, _.segmentOne_vc_vector.x, temp5.x); // !behind = 1 - behind
            // p = point on the plane (0,0,-near)
            // n = plane normal (0,0,-1)
            // D = Q1 - Q0
            // t = ( dot( n, ( p - Q0 ) ) / ( dot( n, d )
            // solve for t where line crosses Camera.near
            _.add(temp4.x, cStartPosReg.z, _.segmentConstants_vc_vector.z); // Q0.z + ( -Camera.near )
            _.sub(temp4.y, cStartPosReg.z, cEndPosReg.z); // Q0.z - Q1.z
            // fix divide by zero for horizontal lines
            _.seq(temp4.z, temp4.y, _.segmentFront_vc_vector.x); // offset = (Q0.z - Q1.z)==0 ? 1 : 0
            _.add(temp4.y, temp4.y, temp4.z); // ( Q0.z - Q1.z ) + offset
            _.div(temp4.z, temp4.x, temp4.y); // t = ( Q0.z - near ) / ( Q0.z - Q1.z )
            _.mul(temp4.xyz, temp4.zzz, lenghtReg.xyz); // t(L)
            _.add(temp3.xyz, cStartPosReg.xyz, temp4.xyz); // Qclipped = Q0 + t(L)
            _.mov(temp3.w, _.segmentOne_vc_vector.x); // Qclipped.w = 1
            // If necessary, replace Q0 with new Qclipped
            _.mul(cStartPosReg, cStartPosReg, temp5.yyyy); // !behind * Q0
            _.mul(temp3, temp3, temp5.xxxx); // behind * Qclipped
            _.add(cStartPosReg, cStartPosReg, temp3); // newQ0 = Q0 + Qclipped
            // calculate side vector for line
            _.sub(lenghtReg, cEndPosReg, cStartPosReg); // L = Q1 - Q0
            _.nrm(lenghtReg.xyz, lenghtReg.xyz); // normalize( L )
            _.nrm(temp5.xyz, cStartPosReg.xyz); // D = normalize( Q1 )
            _.mov(temp5.w, _.segmentOne_vc_vector.x); // D.w = 1
            _.crs(temp3.xyz, lenghtReg, temp5); // S = L x D
            _.nrm(temp3.xyz, temp3.xyz); // normalize( S )
            // face the side vector properly for the given point
            _.mul(temp3.xyz, temp3.xyz, _.segmentThickness_va_1.xxx); // S *= weight
            _.mov(temp3.w, _.segmentOne_vc_vector.x); // S.w = 1
            // calculate the amount required to move at the point's distance to correspond to the line's pixel width
            // scale the side vector by that amount
            _.dp3(temp4.x, cStartPosReg, _.segmentFront_vc_vector); // distance = dot( view )
            _.mul(temp4.x, temp4.x, _.segmentConstants_vc_vector.x); // distance *= vpsod
            _.mul(temp3.xyz, temp3.xyz, temp4.xxx); // S.xyz *= pixelScaleFactor
            // add scaled side vector to Q0 and transform to clip space
            _.add(cStartPosReg.xyz, cStartPosReg.xyz, temp3.xyz); // Q0 + S
            _.m44(_._op, cStartPosReg, _.segmentC2pMatrix_vc_matrix); // transform Q0 to clip space
            // interpolate color
            _.mov(_.color_v, _.segmentColor_va_4);
        };
        return V_Segment;
    }(feng3d.FagalMethod));
    feng3d.V_Segment = V_Segment;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 天空盒顶点渲染程序
     * @author feng 2014-11-4
     */
    var V_SkyBox = (function (_super) {
        __extends(V_SkyBox, _super);
        function V_SkyBox() {
            _super.call(this);
            this._shaderType = feng3d.Context3DProgramType.VERTEX;
        }
        V_SkyBox.prototype.runFunc = function () {
            var _ = feng3d.FagalRE.instance.space;
            var vt0 = _.getFreeTemp("缩放后的顶点坐标");
            _.comment("缩放到天空盒应有的大小");
            _.mul(vt0, _.position_va_3, _.scaleSkybox_vc_vector);
            _.comment("把天空盒中心放到摄像机位置");
            _.add(vt0, vt0, _.camerapos_vc_vector);
            _.comment("投影天空盒坐标");
            _.m44(_._op, vt0, _.projection_vc_matrix);
            _.comment("占坑用的，猜的");
            _.mov(_.uv_v, _.position_va_3);
        };
        return V_SkyBox;
    }(feng3d.FagalMethod));
    feng3d.V_SkyBox = V_SkyBox;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 骨骼动画渲染程序(CPU)
     * @author feng 2014-11-3
     */
    function V_SkeletonAnimationCPU() {
        var _ = feng3d.FagalRE.instance.space;
        _.mov(_.animatedPosition_vt_4, _.animated_va_3);
    }
    feng3d.V_SkeletonAnimationCPU = V_SkeletonAnimationCPU;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 骨骼动画渲染程序(GPU)
     * @author feng 2014-11-3
     */
    function V_SkeletonAnimationGPU() {
        var _ = feng3d.FagalRE.instance.space;
        var shaderParams = feng3d.FagalRE.instance.context3DCache.shaderParams;
        var animationShaderParams = shaderParams.getOrCreateComponentByClass(feng3d.AnimationShaderParams);
        //
        var vt1 = _.getFreeTemp();
        var vt2 = _.getFreeTemp();
        _.globalmatrices_vc_vector.regLen = animationShaderParams.numJoints * 3;
        _.comment("计算该顶点坐标通关该关节得到的x值-----------1");
        _.dp4(vt1.x, _.position_va_3, _.globalmatrices_vc_vector.getReg1(_.jointindex_va_x.x));
        _.comment("计算该顶点坐标通关该关节得到的y值-----------2");
        _.dp4(vt1.y, _.position_va_3, _.globalmatrices_vc_vector.getReg1(_.jointindex_va_x.x, 1));
        _.comment("计算该顶点坐标通关该关节得到的z值-----------3");
        _.dp4(vt1.z, _.position_va_3, _.globalmatrices_vc_vector.getReg1(_.jointindex_va_x.x, 2));
        _.comment("w值不变-----------------4");
        _.mov(vt1.w, _.position_va_3.w);
        _.comment("通过权重计算该关节对顶点的影响值---------------5");
        _.mul(vt1, vt1, _.jointweights_va_x.x);
        _.comment("vt2保存了计算后的顶点坐标，第一个关节影响值使用mov赋值，后面的关节将会使用add来累加-----------------6(1到6将会对每个与该顶点相关的关节调用，该实例中只有一个关节，所以少了个for循环)");
        _.mov(vt2, vt1);
        _.comment("赋值给顶点坐标寄存器，提供给后面投影使用");
        _.mov(_.animatedPosition_vt_4, vt2);
        return _.animatedPosition_vt_4;
    }
    feng3d.V_SkeletonAnimationGPU = V_SkeletonAnimationGPU;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * Sprite动画顶点渲染程序
     * @author feng 2015-9-5
     */
    function V_SpriteSheetAnimation(UVSource, UVTarget) {
        var _ = feng3d.FagalRE.instance.space;
        var tempUV = _.getFreeTemp();
        var constantRegID = _.spriteSheetVectorFrame_vc_vector;
        //计算平移缩放
        _.mov(tempUV, UVSource);
        _.mul(tempUV.xy, tempUV.xy, constantRegID.zw);
        _.add(tempUV.xy, tempUV.xy, constantRegID.xy);
        _.mov(UVTarget, tempUV);
    }
    feng3d.V_SpriteSheetAnimation = V_SpriteSheetAnimation;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * UV动画顶点渲染程序
     * @author feng 2015-9-5
     */
    function V_UVAnimation(UVSource, UVTarget) {
        var _ = feng3d.FagalRE.instance.space;
        var tempUV = _.getFreeTemp();
        var tempUV2 = _.getFreeTemp("用点乘代替m44运算的临时寄存器");
        var uvTranslateReg = _.uvAnimatorTranslate_vc_vector;
        var uvTransformReg = _.uvAnimatorMatrix2d_vc_vector;
        _.mov(tempUV, UVSource);
        _.sub(tempUV.xy, tempUV.xy, uvTranslateReg.zw);
        //使用矩阵对UV操作（使用点乘代替矩阵运算）	_.m44(tempUV, tempUV, uvTransformReg);
        _.dp3(tempUV2.x, tempUV, uvTransformReg.getReg1(0));
        _.dp3(tempUV2.y, tempUV, uvTransformReg.getReg1(1));
        _.mov(tempUV.xy, tempUV2.xy);
        //计算平移缩放
        _.add(tempUV.xy, tempUV.xy, uvTranslateReg.xy);
        _.add(tempUV.xy, tempUV.xy, uvTranslateReg.zw);
        _.mov(UVTarget, tempUV);
    }
    feng3d.V_UVAnimation = V_UVAnimation;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 顶点动画渲染程序(CPU)
     * @author feng 2014-11-3
     */
    function V_VertexAnimationCPU() {
        var _ = feng3d.FagalRE.instance.space;
        _.mov(_.animatedPosition_vt_4, _.position_va_3);
    }
    feng3d.V_VertexAnimationCPU = V_VertexAnimationCPU;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 顶点动画渲染程序(GPU)
     * @author feng 2014-11-3
     */
    function V_VertexAnimationGPU() {
        var _ = feng3d.FagalRE.instance.space;
        //		
        var tempVts0 = _.getFreeTemp();
        var tempVts1 = _.getFreeTemp();
        //			_.comment("计算第0个顶点混合值");
        _.mul(tempVts0, _.position0_va_3, _.weights_vc_vector.x);
        //			_.comment("计算第1个顶点混合值");
        _.mul(tempVts1, _.position1_va_3, _.weights_vc_vector.y);
        //			_.comment("混合两个顶点");
        _.add(_.animatedPosition_vt_4, tempVts0, tempVts1);
    }
    feng3d.V_VertexAnimationGPU = V_VertexAnimationGPU;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 粒子广告牌节点顶点渲染程序
     * @param particleBillboardMtx			广告牌旋转矩阵(3个长度向量形式)
     * @param animatedPosition				动画后的顶点坐标数据
     * @author feng 2014-12-26
     */
    function V_ParticleBillboard(particleBillboardMtx, animatedPosition) {
        var _ = feng3d.FagalRE.instance.space;
        //使用广告牌 朝向摄像机
        _.m33(animatedPosition.xyz, animatedPosition.xyz, particleBillboardMtx); //计算旋转
    }
    feng3d.V_ParticleBillboard = V_ParticleBillboard;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 粒子颜色变化结算顶点渲染程序
     * @param colorMulTarget			粒子颜色乘数因子，用于乘以纹理上的颜色值
     * @param colorAddTarget			粒子颜色偏移值，在片段渲染的最终颜色值上偏移
     * @param colorMulVary				粒子颜色乘数因子，用于乘以纹理上的颜色值
     * @param colorAddVary				粒子颜色偏移值，在片段渲染的最终颜色值上偏移
     * @author feng 2015-1-20
     */
    function V_ParticleColorEnd(colorMulTarget, colorAddTarget, colorMulVary, colorAddVary) {
        var _ = feng3d.FagalRE.instance.space;
        //			if (hasColorMulNode)
        _.mov(colorMulVary, colorMulTarget);
        //			if (hasColorAddNode)
        _.mov(colorAddVary, colorAddTarget);
    }
    feng3d.V_ParticleColorEnd = V_ParticleColorEnd;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 粒子颜色节点顶点渲染程序
     * @author feng 2015-1-20
     */
    function V_ParticleColorGlobal(startMultiplierValue, deltaMultiplierValue, startOffsetValue, deltaOffsetValue, inCycleTimeTemp, colorMulTarget, colorAddTarget) {
        var _ = feng3d.FagalRE.instance.space;
        var temp = _.getFreeTemp();
        //			if (animationRegisterCache.needFragmentAnimation) {
        //				var temp:ShaderRegisterElement = animationRegisterCache.getFreeVertexVectorTemp();
        //				if (_usesCycle) {
        //					var cycleConst:ShaderRegisterElement = animationRegisterCache.getFreeVertexConstant();
        //					animationRegisterCache.setRegisterIndex(this, CYCLE_INDEX, cycleConst.index);
        //					
        //					animationRegisterCache.addVertexTempUsages(temp, 1);
        //					var sin:ShaderRegisterElement = animationRegisterCache.getFreeVertexSingleTemp();
        //					animationRegisterCache.removeVertexTempUsage(temp);
        //					
        //					code += "mul " + sin + "," + animationRegisterCache.vertexTime + "," + cycleConst + ".x\n";
        //					
        //					if (_usesPhase)
        //						code += "add " + sin + "," + sin + "," + cycleConst + ".y\n";
        //					
        //					code += "sin " + sin + "," + sin + "\n";
        //				}
        //				if (_usesMultiplier) {
        //					var startMultiplierValue:ShaderRegisterElement = (_mode == ParticlePropertiesMode.GLOBAL)? animationRegisterCache.getFreeVertexConstant() : animationRegisterCache.getFreeVertexAttribute();
        //					var deltaMultiplierValue:ShaderRegisterElement = (_mode == ParticlePropertiesMode.GLOBAL)? animationRegisterCache.getFreeVertexConstant() : animationRegisterCache.getFreeVertexAttribute();
        //					
        //					animationRegisterCache.setRegisterIndex(this, START_MULTIPLIER_INDEX, startMultiplierValue.index);
        //					animationRegisterCache.setRegisterIndex(this, DELTA_MULTIPLIER_INDEX, deltaMultiplierValue.index);
        _.mul(temp, deltaMultiplierValue, inCycleTimeTemp.y);
        _.add(temp, temp, startMultiplierValue);
        _.mul(colorMulTarget, temp, colorMulTarget);
        //				}
        //				if (_usesOffset) {
        //					var startOffsetValue:ShaderRegisterElement = (_mode == ParticlePropertiesMode.LOCAL_STATIC)? animationRegisterCache.getFreeVertexAttribute() : animationRegisterCache.getFreeVertexConstant();
        //					var deltaOffsetValue:ShaderRegisterElement = (_mode == ParticlePropertiesMode.LOCAL_STATIC)? animationRegisterCache.getFreeVertexAttribute() : animationRegisterCache.getFreeVertexConstant();
        //					
        //					animationRegisterCache.setRegisterIndex(this, START_OFFSET_INDEX, startOffsetValue.index);
        //					animationRegisterCache.setRegisterIndex(this, DELTA_OFFSET_INDEX, deltaOffsetValue.index);
        _.mul(temp, deltaOffsetValue, inCycleTimeTemp.y);
        _.add(temp, temp, startOffsetValue);
        _.add(colorAddTarget, temp, colorAddTarget);
        //				}
        //			}
    }
    feng3d.V_ParticleColorGlobal = V_ParticleColorGlobal;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 粒子结算偏移坐标渲染程序
     * @param animatedPosition			动画后的顶点坐标数据
     * @param positionTemp				偏移坐标临时寄存器
     * @author feng 2014-12-26
     */
    function V_ParticlePositionEnd(animatedPosition, positionTemp) {
        var _ = feng3d.FagalRE.instance.space;
        //得到最终坐标
        _.add(animatedPosition.xyz, animatedPosition.xyz, positionTemp.xyz);
    }
    feng3d.V_ParticlePositionEnd = V_ParticlePositionEnd;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 粒子缩放节点顶点渲染程序
     * @param scaleRegister				粒子缩放常数数据
     * @param inCycleTimeTemp			粒子周期内时间临时寄存器
     * @param animatedPosition			动画后的顶点坐标数据
     * @author feng 2014-12-26
     */
    function V_ParticleScaleGlobal(scaleRegister, inCycleTimeTemp, animatedPosition) {
        var _ = feng3d.FagalRE.instance.space;
        var temp = _.getFreeTemp();
        //			if (_usesCycle) {
        //				code += "mul " + temp + "," + animationRegisterCache.vertexTime + "," + scaleRegister + ".z\n";
        //				
        //				if (_usesPhase)
        //					code += "add " + temp + "," + temp + "," + scaleRegister + ".w\n";
        //				
        //				code += "sin " + temp + "," + temp + "\n";
        //			}
        _.mul(temp, scaleRegister.y, inCycleTimeTemp.y); //计算  随时间增量  = 差值 * 本周期比例
        _.add(temp, scaleRegister.x, temp); //缩放值 = 最小值 + 随时间增量
        _.mul(animatedPosition.xyz, animatedPosition.xyz, temp); //缩放应用到顶点坐标上
    }
    feng3d.V_ParticleScaleGlobal = V_ParticleScaleGlobal;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 粒子速度节点顶点渲染程序
     * @param particleVelocity			粒子速度数据
     * @param positionTemp				偏移坐标临时寄存器
     * @param inCycleTimeTemp			粒子周期内时间临时寄存器
     * @author feng 2014-12-26
     */
    function V_ParticleVelocity(particleVelocity, positionTemp, inCycleTimeTemp) {
        var _ = feng3d.FagalRE.instance.space;
        var vt3 = _.getFreeTemp();
        //计算速度
        _.mul(vt3, inCycleTimeTemp.x, particleVelocity); //时间*速度
        _.add(positionTemp.xyz, vt3, positionTemp.xyz); //计算偏移量
    }
    feng3d.V_ParticleVelocity = V_ParticleVelocity;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 粒子速度节点顶点渲染程序
     * @param particleVelocity			粒子速度数据
     * @param positionTemp				偏移坐标临时寄存器
     * @param inCycleTimeTemp			粒子周期内时间临时寄存器
     * @author feng 2014-12-26
     */
    function V_ParticleVelocityGlobal(particleVelocity, positionTemp, inCycleTimeTemp) {
        var _ = feng3d.FagalRE.instance.space;
        var vt3 = _.getFreeTemp();
        //计算速度
        _.mul(vt3, inCycleTimeTemp.x, particleVelocity); //时间*速度
        _.add(positionTemp.xyz, vt3, positionTemp.xyz); //计算偏移量
    }
    feng3d.V_ParticleVelocityGlobal = V_ParticleVelocityGlobal;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 粒子顶点渲染程序
     * @author feng 2014-11-14
     */
    function V_Particles() {
        var _ = feng3d.FagalRE.instance.space;
        var shaderParams = feng3d.FagalRE.instance.context3DCache.shaderParams;
        var particleShaderParams = shaderParams.getOrCreateComponentByClass(feng3d.ParticleShaderParams);
        //初始化
        if (particleShaderParams.changePosition > 0) {
            feng3d.V_ParticlesInit(_.particlePositionTemp_vt_4, _.animatedPosition_vt_4, _.position_va_3, _.particleCommon_vc_vector);
        }
        //粒子颜色初始化
        if (particleShaderParams.changeColor > 0) {
            feng3d.V_ParticlesInitColor(_.particleCommon_vc_vector, _.particleColorMultiplier_vt_4, _.particleColorOffset_vt_4);
        }
        //计算时间
        if (particleShaderParams.ParticleTimeLocalStatic) {
            feng3d.V_ParticlesTime(_.particleCommon_vc_vector, _.animatedPosition_vt_4, _.particleTime_va_4, _.particleTime_vc_vector, _.inCycleTime_vt_4);
        }
        //粒子速度节点顶点渲染程序
        if (particleShaderParams.ParticleVelocityGlobal) {
            feng3d.V_ParticleVelocityGlobal(_.particleVelocity_vc_vector, _.particlePositionTemp_vt_4, _.inCycleTime_vt_4);
        }
        //计算速度
        if (particleShaderParams.ParticleVelocityLocalStatic) {
            feng3d.V_ParticleVelocity(_.particleVelocity_va_3, _.particlePositionTemp_vt_4, _.inCycleTime_vt_4);
        }
        //粒子缩放节点顶点渲染程序
        if (particleShaderParams.ParticleScaleGlobal) {
            feng3d.V_ParticleScaleGlobal(_.particleScale_vc_vector, _.inCycleTime_vt_4, _.animatedPosition_vt_4);
        }
        //使用广告牌 朝向摄像机
        if (particleShaderParams.ParticleBillboardGlobal) {
            feng3d.V_ParticleBillboard(_.particleBillboard_vc_matrix, _.animatedPosition_vt_4);
        }
        //粒子颜色节点顶点渲染程序
        if (particleShaderParams.changeColor > 0) {
            feng3d.V_ParticleColorGlobal(_.particleStartColorMultiplier_vc_vector, _.particleDeltaColorMultiplier_vc_vector, _.particleStartColorOffset_vc_vector, _.particleDeltaColorOffset_vc_vector, _.inCycleTime_vt_4, _.particleColorMultiplier_vt_4, _.particleColorOffset_vt_4);
        }
        //结算坐标偏移
        if (particleShaderParams.changePosition > 0) {
            feng3d.V_ParticlePositionEnd(_.animatedPosition_vt_4, _.particlePositionTemp_vt_4);
        }
        //结算颜色
        if (particleShaderParams.ParticleColorGlobal) {
            feng3d.V_ParticleColorEnd(_.particleColorMultiplier_vt_4, _.particleColorOffset_vt_4, _.particleColorMultiplier_v, _.particleColorOffset_v);
        }
    }
    feng3d.V_Particles = V_Particles;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 粒子初始化顶点渲染程序
     * @param positionTemp			偏移坐标临时寄存器
     * @param animatedPosition		动画后的顶点坐标数据
     * @param positionReg			顶点坐标数据
     * @param particleCommon		粒子常数数据[0,1,2,0]
     * @author feng 2014-12-26
     */
    function V_ParticlesInit(positionTemp, animatedPosition, positionReg, particleCommon) {
        var _ = feng3d.FagalRE.instance.space;
        _.comment("初始化粒子");
        _.mov(animatedPosition, positionReg); //坐标赋值
        _.mov(positionTemp.xyz, particleCommon.x); //初始化偏移位置0
    }
    feng3d.V_ParticlesInit = V_ParticlesInit;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 粒子颜色初始化
     * @param particleCommon		粒子常数数据[0,1,2,0]
     * @param colorMulTarget		粒子颜色乘数因子，用于乘以纹理上的颜色值
     * @param colorAddTarget		粒子颜色偏移值，在片段渲染的最终颜色值上偏移
     * @author feng 2015-1-20
     */
    function V_ParticlesInitColor(particleCommon, colorMulTarget, colorAddTarget) {
        var _ = feng3d.FagalRE.instance.space;
        //初始化  粒子颜色乘数因子 为(1,1,1,1)
        _.mov(colorMulTarget, particleCommon.y);
        //初始化 粒子颜色偏移值 为(0,0,0,0)
        _.mov(colorAddTarget, particleCommon.x);
    }
    feng3d.V_ParticlesInitColor = V_ParticlesInitColor;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 粒子时间节点顶点渲染程序
     * @author feng 2014-12-26
     */
    function V_ParticlesTime(particleCommon, animatedPosition, particleTimeVA, particleTimeVC, inCycleTimeTemp) {
        var _ = feng3d.FagalRE.instance.space;
        var vt3 = _.getFreeTemp();
        //计算时间
        _.sub(inCycleTimeTemp.x, particleTimeVC, particleTimeVA.x); //生存了的时间  = 粒子特效时间 - 粒子出生时间
        _.sge(vt3.x, inCycleTimeTemp.x, particleCommon.x); //粒子是否出生  = 生存了的时间 [inCycleTimeTemp.x] > 0[particleCommon.x] ? 1 : 0
        _.mul(animatedPosition.xyz, animatedPosition.xyz, vt3.x); //粒子顶点坐标 = 粒子顶点坐标 * 粒子是否出生
        //处理循环
        _.mul(vt3.x, inCycleTimeTemp.x, particleTimeVA.w); //粒子生存的周期数 = 生存了的时间 * 周期倒数
        _.frc(vt3.x, vt3.x); //本周期比例 = 粒子生存的周期数取小数部分
        _.mul(inCycleTimeTemp.x, vt3.x, particleTimeVA.y); //周期内时间 = 本周期比例 * 周期 
        //计算周期数(vt2.y)
        _.mul(inCycleTimeTemp.y, inCycleTimeTemp.x, particleTimeVA.w); //本周期比例 = 周期内时间 * 周期倒数
    }
    feng3d.V_ParticlesTime = V_ParticlesTime;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 编译阴影映射顶点程序
     * @author feng 2015-6-23
     */
    function V_ShadowMap() {
        var shaderParams = feng3d.FagalRE.instance.context3DCache.shaderParams;
        var shadowShaderParams = shaderParams.getOrCreateComponentByClass(feng3d.ShadowShaderParams);
        shadowShaderParams.usePoint > 0 ? feng3d.V_ShadowMapPoint() : feng3d.V_ShadowMapPlanar();
    }
    feng3d.V_ShadowMap = V_ShadowMap;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 方向光阴影映射
     * @author feng 2015-7-17
     */
    function V_ShadowMapPlanar() {
        var _ = feng3d.FagalRE.instance.space;
        var temp = _.getFreeTemp();
        //计算顶点深度值
        _.m44(temp, _.globalPosition_vt_4, _.depthMap_vc_matrix);
        //计算顶点深度值(x,y计算深度图中的uv，z计算深度)
        _.div(temp, temp, temp.w);
        //x,y计算深度图中的uv
        _.mul(temp.xy, temp.xy, _.shadowCommondata0_vc_vector.xy);
        //计算深度图坐标
        _.add(_.depthMapCoord_v, temp, _.shadowCommondata0_vc_vector.xxwz);
    }
    feng3d.V_ShadowMapPlanar = V_ShadowMapPlanar;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 点光源阴影映射
     * @author feng 2015-7-17
     */
    function V_ShadowMapPoint() {
    }
    feng3d.V_ShadowMapPoint = V_ShadowMapPoint;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 基础动画顶点渲染函数(无动画)
     * @author feng 2014-11-3
     */
    function V_BaseAnimation() {
        var _ = feng3d.FagalRE.instance.space;
        _.mov(_.animatedPosition_vt_4, _.position_va_3);
    }
    feng3d.V_BaseAnimation = V_BaseAnimation;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 基本顶点投影渲染
     * @author feng 2014-10-30
     */
    function V_BaseOut() {
        var _ = feng3d.FagalRE.instance.space;
        var shaderParams = feng3d.FagalRE.instance.context3DCache.shaderParams;
        var shadowShaderParams = shaderParams.getOrCreateComponentByClass(feng3d.ShadowShaderParams);
        //阴影渲染需要 投影后的顶点坐标
        if (shadowShaderParams.needsProjection > 0) {
            var vt5 = _.getFreeTemp("投影后顶点坐标");
            _.m44(vt5, _.animatedPosition_vt_4, _.projection_vc_matrix);
            //保存投影坐标数据
            _.mov(_.positionProjected_v, vt5);
            _.mov(_._op, vt5);
        }
        else {
            _.m44(_._op, _.animatedPosition_vt_4, _.projection_vc_matrix);
        }
    }
    feng3d.V_BaseOut = V_BaseOut;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 编译切线顶点程序
     * @author feng 2014-11-7
     */
    function V_TangentNormalMap() {
        var _ = feng3d.FagalRE.instance.space;
        var animatedNormal = _.getFreeTemp("动画后顶点法线临时寄存器");
        var animatedTangent = _.getFreeTemp("动画后顶点切线临时寄存器");
        var bitanTemp = _.getFreeTemp("动画后顶点双切线临时寄存器");
        //赋值法线数据
        _.mov(animatedNormal, _.normal_va_3);
        //赋值切线数据
        _.mov(animatedTangent, _.tangent_va_3);
        //计算顶点世界法线 vc8：模型转世界矩阵
        _.m33(animatedNormal.xyz, animatedNormal, _.normalSceneTransform_vc_matrix);
        //标准化顶点世界法线
        _.nrm(animatedNormal.xyz, animatedNormal);
        //计算顶点世界切线
        _.m33(animatedTangent.xyz, animatedTangent, _.normalSceneTransform_vc_matrix);
        //标准化顶点世界切线
        _.nrm(animatedTangent.xyz, animatedTangent);
        //计算切线x
        _.mov(_.tangent_v.x, animatedTangent.x);
        //计算切线z
        _.mov(_.tangent_v.z, animatedNormal.x);
        //计算切线w
        _.mov(_.tangent_v.w, _.normal_va_3.w);
        //计算双切线x
        _.mov(_.bitangent_v.x, animatedTangent.y);
        //计算双切线z
        _.mov(_.bitangent_v.z, animatedNormal.y);
        //计算双切线w
        _.mov(_.bitangent_v.w, _.normal_va_3.w);
        //计算法线x
        _.mov(_.normal_v.x, animatedTangent.z);
        //计算法线z
        _.mov(_.normal_v.z, animatedNormal.z);
        //计算法线w
        _.mov(_.normal_v.w, _.normal_va_3.w);
        //计算双切线
        _.crs(bitanTemp.xyz, animatedNormal, animatedTangent);
        //计算切线y
        _.mov(_.tangent_v.y, bitanTemp.x);
        //计算双切线y
        _.mov(_.bitangent_v.y, bitanTemp.y);
        //计算法线y
        _.mov(_.normal_v.y, bitanTemp.z);
    }
    feng3d.V_TangentNormalMap = V_TangentNormalMap;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 编译切线顶点程序(无法线图)
     * @author feng 2014-11-7
     */
    function V_TangentNormalNoMap() {
        var _ = feng3d.FagalRE.instance.space;
        _.comment("转换法线到全局");
        _.m33(_.normal_v.xyz, _.normal_va_3, _.normalSceneTransform_vc_matrix);
        //保存w不变
        _.mov(_.normal_v.w, _.normal_va_3.w);
    }
    feng3d.V_TangentNormalNoMap = V_TangentNormalNoMap;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 视线顶点渲染函数
     * @author feng 2014-11-7
     */
    function V_ViewDir() {
        var _ = feng3d.FagalRE.instance.space;
        _.comment("计算视线方向");
        _.sub(_.viewDir_v, _.cameraPosition_vc_vector, _.globalPosition_vt_4);
    }
    feng3d.V_ViewDir = V_ViewDir;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 顶点世界坐标渲染函数
     * @author feng 2014-11-7
     */
    function V_WorldPosition() {
        var _ = feng3d.FagalRE.instance.space;
        _.comment("场景坐标转换");
        _.m44(_.globalPosition_vt_4, _.animatedPosition_vt_4, _.sceneTransform_vc_matrix);
    }
    feng3d.V_WorldPosition = V_WorldPosition;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 世界坐标输出函数
     * @author feng 2014-11-7
     */
    function V_WorldPositionOut() {
        var _ = feng3d.FagalRE.instance.space;
        _.mov(_.globalPos_v, _.globalPosition_vt_4);
    }
    feng3d.V_WorldPositionOut = V_WorldPositionOut;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * Fagal标记
     * @author feng 2014-10-22
     */
    var FagalToken = (function () {
        function FagalToken() {
        }
        /** AGAL换行符 */
        FagalToken.BREAK = "\n";
        /** 单行注释符 */
        FagalToken.COMMENT = "//";
        return FagalToken;
    }());
    feng3d.FagalToken = FagalToken;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 寄存器单元
     * @author feng 2014-10-22
     */
    var RegisterComponent = (function () {
        /**
         * 创建一个寄存器单元
         * @param register 寄存器类型
         * @param prop 单元名称
         */
        function RegisterComponent(register, prop) {
            this._prop = prop;
            this._register = register;
            this._regType = register.regType;
            this._regId = register.regId;
            if (!RegisterComponent.valid(prop))
                throw new Error("无效寄存器分量: " + this._register);
        }
        Object.defineProperty(RegisterComponent.prototype, "regId", {
            /** 寄存器id */
            get: function () {
                return this._regId;
            },
            /**
             * @private
             */
            set: function (value) {
                this._regId = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RegisterComponent.prototype, "regType", {
            /**
             * @inheritDoc
             */
            get: function () {
                return this._regType;
            },
            enumerable: true,
            configurable: true
        });
        RegisterComponent.prototype.toString = function () {
            return this._register + "." + this._prop;
        };
        /**
         * 判断是否有效
         * @param prop
         * @return			true：有效，false：无效
         */
        RegisterComponent.valid = function (prop) {
            switch (prop) {
                case "x":
                case "y":
                case "z":
                case "w":
                case "r":
                case "g":
                case "b":
                case "a":
                    return true;
            }
            return false;
        };
        Object.defineProperty(RegisterComponent.prototype, "desc", {
            /**
             * @inheritDoc
             */
            get: function () {
                return this.toString();
            },
            enumerable: true,
            configurable: true
        });
        return RegisterComponent;
    }());
    feng3d.RegisterComponent = RegisterComponent;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 寄存器单元组合
     * @author feng 2014-10-22
     */
    var RegisterComponentSelection = (function () {
        /**
         * 创建一个寄存器单元组合
         * @param register 		寄存器类型
         * @param prop 			组合名称
         */
        function RegisterComponentSelection(register, prop) {
            this._register = register;
            this._prop = prop;
            this._regType = register.regType;
            this._regId = register.regId;
            // Validate components
            if (prop.length > 4)
                throw new Error("无效寄存器分量: " + this._register);
            for (var i = 0; i < prop.length; i++) {
                if (!feng3d.RegisterComponent.valid(prop.substr(i, 1)))
                    throw new Error("无效寄存器分量: " + this._register);
            }
        }
        Object.defineProperty(RegisterComponentSelection.prototype, "regId", {
            /** 寄存器id */
            get: function () {
                return this._regId;
            },
            /**
             * @private
             */
            set: function (value) {
                this._regId = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RegisterComponentSelection.prototype, "regType", {
            /**
             * @inheritDoc
             */
            get: function () {
                return this._regType;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        RegisterComponentSelection.prototype.toString = function () {
            return this._register + ((this._prop.length > 0) ? ("." + this._prop) : "");
        };
        Object.defineProperty(RegisterComponentSelection.prototype, "desc", {
            /**
             * @inheritDoc
             */
            get: function () {
                return this.toString();
            },
            enumerable: true,
            configurable: true
        });
        return RegisterComponentSelection;
    }());
    feng3d.RegisterComponentSelection = RegisterComponentSelection;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 纹理类型
     * @author feng 2014-10-23
     */
    var TextureType = (function () {
        function TextureType() {
        }
        /**  Images in this texture all are 2-dimensional. They have width and height, but no depth. */
        TextureType.TYPE_2D = "2d";
        /**  Images in this texture all are 3-dimensional. They have width, height, and depth. */
        TextureType.TYPE_3D = "3d";
        /**  There are exactly 6 distinct sets of 2D images, all of the same size. They act as 6 faces of a cube. */
        TextureType.TYPE_CUBE = "cube";
        return TextureType;
    }());
    feng3d.TextureType = TextureType;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * Fagal编号中心
     * @author feng 2015-7-23
     */
    var FagalIdCenter = (function (_super) {
        __extends(FagalIdCenter, _super);
        function FagalIdCenter() {
            _super.apply(this, arguments);
        }
        /**
         * 创建Fagal编号中心
         */
        FagalIdCenter.prototype.FagalIdCenter = function () {
            if (FagalIdCenter._instance)
                throw new Error("该类为单例");
            FagalIdCenter._instance = this;
        };
        /**
         * @inheritDoc
         */
        FagalIdCenter.prototype.hasOwnProperty = function (V) {
            if (V === void 0) { V = null; }
            var attr = V;
            return feng3d.FagalRE.idDic[attr] != null;
        };
        /**
         * @inheritDoc
         */
        FagalIdCenter.prototype.getProperty = function (name) {
            var attr = name;
            return attr;
        };
        Object.defineProperty(FagalIdCenter, "instance", {
            /**
             * Fagal编号中心实例
             */
            get: function () {
                return FagalIdCenter._instance || new FagalIdCenter();
            },
            enumerable: true,
            configurable: true
        });
        return FagalIdCenter;
    }(feng3d.Proxy));
    feng3d.FagalIdCenter = FagalIdCenter;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * fagal函数单元
     * @author feng 2015-8-8
     */
    var FagalItem = (function () {
        /**
         * 创建一个fagal函数单元
         * @param funcName			函数名称
         * @param parameters		参数
         */
        function FagalItem(funcName, parameters) {
            this.funcName = funcName;
            this.parameters = parameters;
        }
        /**
         * 获取参数中出现的寄存器id以及次数
         * @param parameters			拥有寄存器的参数
         * @return						寄存器id字典(key:regID,value:count)
         */
        FagalItem.prototype.getRegCountDic = function () {
            var dic = {};
            //针对使用到的寄存器计数
            if (this.funcName == "comment") {
                return dic;
            }
            var list = this.getIFieldList();
            list.forEach(function (reg) {
                dic[reg.regId] = dic[reg.regId] + 1;
            });
            return dic;
        };
        /**
         * 获取寄存器列表
         */
        FagalItem.prototype.getIFieldList = function () {
            var list = [];
            this.parameters.forEach(function (reg) {
                var registerArrayComplexItem = reg;
                if (registerArrayComplexItem != null) {
                    registerArrayComplexItem.complexArgs.forEach(function (complexArg) {
                        list.push(complexArg);
                    });
                }
                //记录寄存器使用次数
                if (reg != null) {
                    list.push(reg);
                }
            });
            return list;
        };
        return FagalItem;
    }());
    feng3d.FagalItem = FagalItem;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * Fagal函数运行环境(FagalMethodRuntimeEnvironment)
     * @author feng 2014-10-24
     */
    var FagalRE = (function () {
        /**
         * 创建一个Fagal函数运行环境
         */
        function FagalRE() {
            if (FagalRE._instance)
                throw new Error("该类为单例");
            FagalRE._instance = this;
        }
        /**
         * 添加3d缓冲编号配置
         * @param configs
         */
        FagalRE.addBufferID = function (configs) {
            for (var i = 0; i < configs.length; i++) {
                FagalRE.idDic[configs[i][0]] = configs[i];
            }
        };
        Object.defineProperty(FagalRE.prototype, "space", {
            /**
             * Fagal运行环境空间
             */
            get: function () {
                return this._space = this._space || new feng3d.FagalRESpace();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FagalRE.prototype, "context3DCache", {
            /**
             * 3D环境缓存类(方便调试与管理渲染操作)
             */
            get: function () {
                return this._context3DCache;
            },
            set: function (value) {
                this._context3DCache = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 运行Fagal函数
         * @param agalMethod Fagal函数
         */
        FagalRE.runShader = function (vertexShader, fragmentShader) {
            return FagalRE.instance.runShader(vertexShader, fragmentShader);
        };
        Object.defineProperty(FagalRE.prototype, "registerCenter", {
            /**
             * Fagal寄存器中心
             */
            get: function () {
                return feng3d.FagalRegisterCenter.instance;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 运行Fagal函数
         * @param agalMethod Fagal函数
         */
        FagalRE.prototype.runShader = function (vertexShader, fragmentShader) {
            //清理缓存
            feng3d.FagalRegisterCenter.clear();
            feng3d.ShaderRegisterCache.invalid();
            var shaderResult = new feng3d.FagalShaderResult();
            //运行顶点渲染函数
            shaderResult.vertexCallLog = this.run(vertexShader);
            //运行片段渲染函数
            shaderResult.fragmentCallLog = this.run(fragmentShader);
            shaderResult.print();
            return shaderResult;
        };
        /**
         * 运行Fagal函数
         * @param agalMethod Fagal函数
         */
        FagalRE.prototype.run = function (agalMethod) {
            //Fagal函数类实例
            var agalMethodInstance = feng3d.ClassUtils.getInstance(agalMethod);
            //着色器类型
            this._shaderType = agalMethodInstance.shaderType;
            //运行Fagal函数
            var callLog = this.space.run(agalMethodInstance.runFunc);
            return callLog;
        };
        Object.defineProperty(FagalRE.prototype, "shaderType", {
            /**
             * 着色器类型
             */
            get: function () {
                return this._shaderType;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FagalRE, "instance", {
            /**
             * Fagal函数运行环境实例
             */
            get: function () {
                return FagalRE._instance || new FagalRE();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 数据id字典
         */
        FagalRE.idDic = {};
        return FagalRE;
    }());
    feng3d.FagalRE = FagalRE;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * Fagal运行环境空间
     * @author feng 2015-7-23
     */
    var FagalRESpace = (function (_super) {
        __extends(FagalRESpace, _super);
        function FagalRESpace() {
            _super.apply(this, arguments);
        }
        Object.defineProperty(FagalRESpace.prototype, "math", {
            /**
             * Fagal数学运算
             */
            get: function () {
                return this._math = this._math || new feng3d.FagalMath();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FagalRESpace.prototype, "registerCenter", {
            /**
             * Fagal寄存器中心
             */
            get: function () {
                return feng3d.FagalRegisterCenter.instance;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 创建Fagal运行环境空间
         */
        FagalRESpace.prototype.FagalRESpace = function () {
        };
        /**
         * @inheritDoc
         */
        FagalRESpace.prototype.getProperty = function (name) {
            var attr = name;
            if (FagalRESpace.prototype[attr] != null) {
                return FagalRESpace.prototype[attr];
            }
            if (this.registerCenter.hasOwnProperty(attr)) {
                var value = FagalRESpace.prototype[attr] = this.registerCenter[attr];
                return value;
            }
            throw new ReferenceError("在 " + feng3d.getQualifiedClassName(this) + " 上找不到属性 " + attr + "，且没有默认值");
        };
        /**
         * @inheritDoc
         */
        FagalRESpace.prototype.callProperty = function (name) {
            var parameters = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                parameters[_i - 1] = arguments[_i];
            }
            var funcName = name;
            var func = this.math[funcName];
            feng3d.assert(func != null, "在Fagal中尝试调用" + feng3d.getQualifiedClassName(this.math) + "." + funcName + "中不存在的函数");
            this.callLog.push(new feng3d.FagalItem(funcName, parameters));
        };
        /**
         * 执行渲染函数
         * @param fagalMethod
         * @return
         */
        FagalRESpace.prototype.run = function (fagalMethod) {
            this.callLog = [];
            fagalMethod();
            return this.callLog;
        };
        /**
         * 获取临时寄存器
         * @param description 寄存器描述
         * @return
         * @author feng 2015-4-24
         */
        FagalRESpace.prototype.getFreeTemp = function (description) {
            if (description === void 0) { description = ""; }
            var register = feng3d.FagalRegisterCenter.getFreeTemp(description);
            return register;
        };
        /**
         * 获取临时寄存器
         * @param description 寄存器描述
         * @return
         * @author feng 2015-4-24
         */
        FagalRESpace.prototype.getFreeTemps = function (description, num) {
            if (description === void 0) { description = ""; }
            if (num === void 0) { num = 1; }
            var register = feng3d.FagalRegisterCenter.getFreeTemps(description, num);
            return register;
        };
        return FagalRESpace;
    }(feng3d.Proxy));
    feng3d.FagalRESpace = FagalRESpace;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * Fagal寄存器中心
     * @author feng 2015-7-23
     */
    var FagalRegisterCenter = (function (_super) {
        __extends(FagalRegisterCenter, _super);
        function FagalRegisterCenter() {
            _super.apply(this, arguments);
        }
        /**
         * 构建Fagal寄存器中心
         */
        FagalRegisterCenter.prototype.FagalRegisterCenter = function () {
            if (FagalRegisterCenter._instance)
                throw new Error("该类为单例");
            FagalRegisterCenter._instance = this;
        };
        Object.defineProperty(FagalRegisterCenter, "dataRegisterDic", {
            /**
             * 数据寄存器缓存
             */
            get: function () {
                return FagalRegisterCenter._dataRegisterDic = FagalRegisterCenter._dataRegisterDic || {};
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        FagalRegisterCenter.prototype.hasOwnProperty = function (V) {
            if (V === void 0) { V = null; }
            var attr = V;
            return feng3d.FagalRE.idDic[attr] != null;
        };
        /**
         * @inheritDoc
         */
        FagalRegisterCenter.prototype.getProperty = function (name) {
            var attr = name;
            var idData = feng3d.FagalRE.idDic[attr];
            //获取寄存器
            var register = FagalRegisterCenter.createRegister(idData[0]);
            register.description = idData[1];
            return register;
        };
        /**
         * 创建寄存器
         * @param dataTypeId
         * @param numRegister
         * @return
         */
        FagalRegisterCenter.createRegister = function (dataTypeId) {
            if (FagalRegisterCenter.dataRegisterDic[dataTypeId])
                return FagalRegisterCenter.dataRegisterDic[dataTypeId];
            var bufferType = feng3d.Context3DBufferTypeManager.getBufferType(dataTypeId);
            var register;
            if (bufferType.dataType == feng3d.RgisterDataType.MATRIX) {
                //获取寄存器矩阵
                register = new feng3d.RegisterMatrix(dataTypeId);
            }
            else if (bufferType.dataType == feng3d.RgisterDataType.ARRAY) {
                register = new feng3d.RegisterArray(dataTypeId);
            }
            else if (bufferType.dataType == feng3d.RgisterDataType.VECTOR) {
                //获取寄存器数组
                register = new feng3d.RegisterArray(dataTypeId);
            }
            else {
                register = new feng3d.Register(dataTypeId);
            }
            FagalRegisterCenter.dataRegisterDic[dataTypeId] = register;
            return register;
        };
        /**
         * 获取临时寄存器
         * @param description 寄存器描述
         * @return
         * @author feng 2015-4-24
         */
        FagalRegisterCenter.getFreeTemp = function (description) {
            if (description === void 0) { description = ""; }
            var tempTypeId;
            if (feng3d.FagalRE.instance.shaderType == feng3d.Context3DProgramType.VERTEX) {
                tempTypeId = "temp" + (FagalRegisterCenter.tempIndex++) + "_vt_4";
            }
            else if (feng3d.FagalRE.instance.shaderType == feng3d.Context3DProgramType.FRAGMENT) {
                tempTypeId = "temp" + (FagalRegisterCenter.tempIndex++) + "_ft_4";
            }
            var register = FagalRegisterCenter.createRegister(tempTypeId);
            register.description = description;
            return register;
        };
        /**
         * 获取临时寄存器
         * @param description 寄存器描述
         * @return
         * @author feng 2015-4-24
         */
        FagalRegisterCenter.getFreeTemps = function (description, num) {
            if (description === void 0) { description = ""; }
            if (num === void 0) { num = 1; }
            var tempTypeId;
            if (feng3d.FagalRE.instance.shaderType == feng3d.Context3DProgramType.VERTEX) {
                if (num > 1) {
                    tempTypeId = "temp" + (FagalRegisterCenter.tempIndex++) + "_vt_" + feng3d.RgisterDataType.ARRAY;
                }
                else {
                    tempTypeId = "temp" + (FagalRegisterCenter.tempIndex++) + "_vt_4";
                }
            }
            else if (feng3d.FagalRE.instance.shaderType == feng3d.Context3DProgramType.FRAGMENT) {
                if (num > 1) {
                    tempTypeId = "temp" + (FagalRegisterCenter.tempIndex++) + "_ft_" + feng3d.RgisterDataType.ARRAY;
                }
                else {
                    tempTypeId = "temp" + (FagalRegisterCenter.tempIndex++) + "_ft_4";
                }
            }
            var register = FagalRegisterCenter.createRegister(tempTypeId);
            register.description = description;
            return register;
        };
        /**
         * 清理寄存器值
         */
        FagalRegisterCenter.clear = function () {
            FagalRegisterCenter.dataRegisterDic.forEach(function (register) {
                register.clear();
            });
        };
        Object.defineProperty(FagalRegisterCenter, "instance", {
            /**
             * Fagal寄存器中心实例
             */
            get: function () {
                return FagalRegisterCenter._instance || new FagalRegisterCenter();
            },
            enumerable: true,
            configurable: true
        });
        return FagalRegisterCenter;
    }(feng3d.Proxy));
    feng3d.FagalRegisterCenter = FagalRegisterCenter;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * Fagal渲染结果
     * @author feng 2015-8-8
     */
    var FagalShaderResult = (function () {
        /**
         * 创建一个Fagal渲染结果
         */
        function FagalShaderResult() {
            this.agalCode = "";
        }
        /**
         * 打印输出结果
         */
        FagalShaderResult.prototype.print = function () {
            this.vertexFCode = this.doCallLog(this.vertexCallLog, feng3d.Register.NAME);
            this.fragmentFCode = this.doCallLog(this.fragmentCallLog, feng3d.Register.NAME);
            this.requestRegisterValue();
            this.vertexCode = this.doCallLog(this.vertexCallLog, feng3d.Register.VALUE);
            this.fragmentCode = this.doCallLog(this.fragmentCallLog, feng3d.Register.VALUE);
            feng3d.logger("------------Compiling Register info------------------");
            this.regDic.forEach(function (register) {
                feng3d.logger(register.desc);
            });
            feng3d.logger("Compiling FAGAL Code:");
            feng3d.logger("--------------------");
            feng3d.logger(this.vertexFCode);
            feng3d.logger("--------------------");
            feng3d.logger(this.fragmentFCode);
            feng3d.logger("Compiling AGAL Code:");
            feng3d.logger("--------------------");
            feng3d.logger(this.vertexCode);
            feng3d.logger("--------------------");
            feng3d.logger(this.fragmentCode);
            feng3d.logger("------------Compiling info end------------------");
        };
        /**
         * 根据寄存器引用计数进行申请与释放寄存器
         * 处理寄存器值(va0,vc0....)
         */
        FagalShaderResult.prototype.requestRegisterValue = function () {
            //使用寄存器计数字典
            var useRegDic = {};
            var callLog = this.vertexCallLog.concat(this.fragmentCallLog);
            var i;
            var regCountDic;
            var regId;
            var fagalItem;
            for (i = 0; i < callLog.length; i++) {
                fagalItem = callLog[i];
                regCountDic = fagalItem.getRegCountDic();
                for (regId in regCountDic) {
                    //记录寄存器使用次数
                    useRegDic[regId] = useRegDic[regId] + regCountDic[regId];
                }
            }
            for (i = 0; i < callLog.length; i++) {
                regCountDic = callLog[i].getRegCountDic();
                //申请寄存器
                for (regId in regCountDic) {
                    //申请寄存器 此处并不会重复申请，内部有判断过滤
                    this.regCache.requestRegister(regId);
                }
                //注：申请寄存器与释放临时寄存器需要分开处理，如此可避免同一个agal函数中有两个不同的数据使用相同的寄存器
                //计算使用计数，释放计数为0的临时寄存器
                for (regId in regCountDic) {
                    //记录寄存器使用次数
                    useRegDic[regId] = useRegDic[regId] - regCountDic[regId];
                    //移除临时寄存器
                    if (useRegDic[regId] == 0) {
                        this.regCache.removeTempUsage(regId);
                    }
                }
            }
            this.regDic = {};
            var register;
            feng3d.Register.TO_STRING = feng3d.Register.NAME;
            for (regId in useRegDic) {
                feng3d.assert(useRegDic[regId] == 0, "不应该存在寄存器使用次数为负数的情况");
                register = feng3d.FagalRegisterCenter.dataRegisterDic[regId];
                this.regDic[register.regId] = register;
            }
        };
        /**
         * 执行Fagal函数记录
         */
        FagalShaderResult.prototype.doCallLog = function (callLog, type) {
            feng3d.Register.TO_STRING = type;
            this.fagalCodeList = [];
            this.math.addEventListener(feng3d.FagalMathEvent.FAGALMATHEVENT_APPEND, this.onFagalCodeAppend);
            var funcName;
            var parameters;
            for (var i = 0; i < callLog.length; i++) {
                funcName = callLog[i].funcName;
                parameters = callLog[i].parameters;
                var func = this.math[funcName];
                func.apply(null, parameters);
            }
            this.math.removeEventListener(feng3d.FagalMathEvent.FAGALMATHEVENT_APPEND, this.onFagalCodeAppend);
            var fagalCode = this.fagalCodeList.join(feng3d.FagalToken.BREAK);
            return fagalCode;
        };
        Object.defineProperty(FagalShaderResult.prototype, "regCache", {
            /**
             * 寄存器缓存
             */
            get: function () {
                return feng3d.ShaderRegisterCache.instance;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FagalShaderResult.prototype, "math", {
            /**
             * Fagal数学运算
             */
            get: function () {
                if (this._math == null) {
                    this._math = new feng3d.FagalMath();
                }
                return this._math;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 处理Fagal数学函数事件
         */
        FagalShaderResult.prototype.onFagalCodeAppend = function (event) {
            this.fagalCodeList.push(event.code);
        };
        return FagalShaderResult;
    }());
    feng3d.FagalShaderResult = FagalShaderResult;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var AssetType = (function () {
        function AssetType() {
        }
        /** 实体 */
        AssetType.ENTITY = 'entity';
        /** 天空盒 */
        AssetType.SKYBOX = 'skybox';
        /** 摄像机 */
        AssetType.CAMERA = 'camera';
        /** 线条 */
        AssetType.SEGMENT_SET = 'segmentSet';
        /** 网格 */
        AssetType.MESH = 'mesh';
        /** 几何体 */
        AssetType.GEOMETRY = 'geometry';
        /** 骨骼 */
        AssetType.SKELETON = 'skeleton';
        /** 骨骼姿势 */
        AssetType.SKELETON_POSE = 'skeletonPose';
        /** 容器 */
        AssetType.CONTAINER = 'container';
        /** 纹理 */
        AssetType.TEXTURE = 'texture';
        AssetType.TEXTURE_PROJECTOR = 'textureProjector';
        /** 材质 */
        AssetType.MATERIAL = 'material';
        AssetType.ANIMATION_SET = 'animationSet';
        /** 动画状态 */
        AssetType.ANIMATION_STATE = 'animationState';
        /** 动画节点 */
        AssetType.ANIMATION_NODE = 'animationNode';
        /** 动画 */
        AssetType.ANIMATOR = 'animator';
        AssetType.STATE_TRANSITION = 'stateTransition';
        /** 灯光 */
        AssetType.LIGHT = 'light';
        /** 灯光采集器 */
        AssetType.LIGHT_PICKER = 'lightPicker';
        /** 阴影投射方法 */
        AssetType.SHADOW_MAP_METHOD = 'shadowMapMethod';
        AssetType.EFFECTS_METHOD = 'effectsMethod';
        return AssetType;
    }());
    feng3d.AssetType = AssetType;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 拥有名字的对象
     * @author feng 2014-5-7
     */
    var NamedAsset = (function () {
        /**
         * 创建一个拥有名字的对象
         */
        function NamedAsset(asset, assetType) {
            this._asset = asset;
            this._assetType = assetType;
        }
        Object.defineProperty(NamedAsset.prototype, "name", {
            /**
             * 名称
             */
            get: function () {
                if (!this._name) {
                    var defaultName = feng3d.ClassUtils.getDefaultName(this);
                    this._name = defaultName + NamedAsset.nameDic[defaultName];
                    NamedAsset.nameDic[defaultName] = NamedAsset.nameDic[defaultName] + 1;
                }
                return this._name;
            },
            set: function (value) {
                //			if (this._name)
                //				throw new Error(getQualifiedClassName(this) + " -- 对象已经有名称，无法更改");
                this._name = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NamedAsset.prototype, "assetType", {
            /**
             * @inheritDoc
             */
            get: function () {
                return this._assetType;
            },
            enumerable: true,
            configurable: true
        });
        NamedAsset.nameDic = {};
        return NamedAsset;
    }());
    feng3d.NamedAsset = NamedAsset;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 阴影映射基类
     * @author feng 2015-5-28
     */
    var ShadowMapperBase = (function () {
        /**
         * 创建阴影映射
         */
        function ShadowMapperBase() {
            this._depthMapSize = 2048;
            this._autoUpdateShadows = true;
            this._casterCollector = this.createCasterCollector();
        }
        /**
         * 创建阴影投射者集合
         */
        ShadowMapperBase.prototype.createCasterCollector = function () {
            return new feng3d.ShadowCasterCollector();
        };
        Object.defineProperty(ShadowMapperBase.prototype, "light", {
            /**
             * 灯光
             */
            get: function () {
                return this._light;
            },
            set: function (value) {
                this._light = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ShadowMapperBase.prototype, "depthMap", {
            /**
             * 深度图
             */
            get: function () {
                return this._depthMap = this._depthMap || this.createDepthTexture();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ShadowMapperBase.prototype, "autoUpdateShadows", {
            /**
             * 是否自动更新阴影
             */
            get: function () {
                return this._autoUpdateShadows;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 渲染深度图
         * @param stage3DProxy			3D场景代理
         * @param entityCollector		实体集合
         * @param renderer				渲染器
         */
        ShadowMapperBase.prototype.renderDepthMap = function (stage3DProxy, entityCollector, renderer) {
            this._shadowsInvalid = false;
            this.updateDepthProjection(entityCollector.camera);
            this._depthMap = this._depthMap || this.createDepthTexture();
            this.drawDepthMap(this._depthMap, stage3DProxy, entityCollector.scene, renderer);
        };
        /**
         * 创建深度纹理
         */
        ShadowMapperBase.prototype.createDepthTexture = function () {
            return new feng3d.RenderTexture(this._depthMapSize, this._depthMapSize);
        };
        Object.defineProperty(ShadowMapperBase.prototype, "depthMapSize", {
            /**
             * 深度图尺寸
             */
            get: function () {
                return this._depthMapSize;
            },
            set: function (value) {
                if (value == this._depthMapSize)
                    return;
                this._depthMapSize = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 销毁
         */
        ShadowMapperBase.prototype.dispose = function () {
        };
        return ShadowMapperBase;
    }());
    feng3d.ShadowMapperBase = ShadowMapperBase;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 方向光阴影映射
     * @author feng 2015-5-28
     */
    var DirectionalShadowMapper = (function (_super) {
        __extends(DirectionalShadowMapper, _super);
        /**
         * 创建方向光阴影映射
         */
        function DirectionalShadowMapper() {
            _super.call(this);
            this._lightOffset = 10000;
            this._snap = 64;
            this._cullPlanes = [];
            this._overallDepthLens = new feng3d.FreeMatrixLens();
            this._overallDepthCamera = new feng3d.Camera3D(this._overallDepthLens);
            this._localFrustum = [];
            this._localFrustum.length = 8 * 3;
            this._matrix = new feng3d.Matrix3D();
        }
        Object.defineProperty(DirectionalShadowMapper.prototype, "depthProjection", {
            /**
             * 深度投影矩阵
             * <p>世界坐标转换为深度图空间</p>
             */
            get: function () {
                return this._overallDepthCamera.viewProjection;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DirectionalShadowMapper.prototype, "depth", {
            /**
             * 投影深度
             * Depth projection matrix that projects from scene space to depth map.
             */
            get: function () {
                return this._maxZ - this._minZ;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        DirectionalShadowMapper.prototype.drawDepthMap = function (target, stage3DProxy, scene, renderer) {
            this._casterCollector.camera = this._overallDepthCamera;
            this._casterCollector.cullPlanes = this._cullPlanes;
            this._casterCollector.clear();
            scene.traversePartitions(this._casterCollector);
            renderer.render(stage3DProxy, this._casterCollector, target);
        };
        DirectionalShadowMapper.prototype.updateCullPlanes = function (viewCamera) {
            var lightFrustumPlanes = this._overallDepthCamera.frustumPlanes;
            var viewFrustumPlanes = viewCamera.frustumPlanes;
            this._cullPlanes.length = 4;
            this._cullPlanes[0] = lightFrustumPlanes[0];
            this._cullPlanes[1] = lightFrustumPlanes[1];
            this._cullPlanes[2] = lightFrustumPlanes[2];
            this._cullPlanes[3] = lightFrustumPlanes[3];
            var dir = feng3d.as(this._light, feng3d.DirectionalLight).sceneDirection;
            var dirX = dir.x;
            var dirY = dir.y;
            var dirZ = dir.z;
            var j = 4;
            for (var i = 0; i < 6; ++i) {
                var plane = viewFrustumPlanes[i];
                if (plane.a * dirX + plane.b * dirY + plane.c * dirZ < 0)
                    this._cullPlanes[j++] = plane;
            }
        };
        DirectionalShadowMapper.prototype.updateDepthProjection = function (viewCamera) {
            this.updateProjectionFromFrustumCorners(viewCamera, viewCamera.lens.frustumCorners, this._matrix);
            this._overallDepthLens.matrix = this._matrix;
            this.updateCullPlanes(viewCamera);
        };
        /**
         * 更新投影矩阵
         * @param viewCamera		摄像机
         * @param corners
         * @param matrix
         */
        DirectionalShadowMapper.prototype.updateProjectionFromFrustumCorners = function (viewCamera, corners, matrix) {
            var raw = feng3d.Matrix3DUtils.RAW_DATA_CONTAINER;
            var dir;
            var x, y, z;
            var minX, minY;
            var maxX, maxY;
            var i;
            dir = feng3d.as(this._light, feng3d.DirectionalLight).sceneDirection;
            this._overallDepthCamera.transform3D.transform = this._light.sceneTransform;
            x = Math.floor((viewCamera.transform3D.x - dir.x * this._lightOffset) / this._snap) * this._snap;
            y = Math.floor((viewCamera.transform3D.y - dir.y * this._lightOffset) / this._snap) * this._snap;
            z = Math.floor((viewCamera.transform3D.z - dir.z * this._lightOffset) / this._snap) * this._snap;
            this._overallDepthCamera.transform3D.x = x;
            this._overallDepthCamera.transform3D.y = y;
            this._overallDepthCamera.transform3D.z = z;
            this._matrix.copyFrom(this._overallDepthCamera.inverseSceneTransform);
            this._matrix.prepend(viewCamera.sceneTransform);
            this._matrix.transformVectors(corners, this._localFrustum);
            minX = maxX = this._localFrustum[0];
            minY = maxY = this._localFrustum[1];
            this._maxZ = this._localFrustum[2];
            i = 3;
            while (i < 24) {
                x = this._localFrustum[i];
                y = this._localFrustum[i + 1];
                z = this._localFrustum[i + 2];
                if (x < minX)
                    minX = x;
                if (x > maxX)
                    maxX = x;
                if (y < minY)
                    minY = y;
                if (y > maxY)
                    maxY = y;
                if (z > this._maxZ)
                    this._maxZ = z;
                i += 3;
            }
            this._minZ = 1;
            var w = maxX - minX;
            var h = maxY - minY;
            var d = 1 / (this._maxZ - this._minZ);
            if (minX < 0)
                minX -= this._snap; // because number() rounds up for < 0
            if (minY < 0)
                minY -= this._snap;
            minX = Math.floor(minX / this._snap) * this._snap;
            minY = Math.floor(minY / this._snap) * this._snap;
            var snap2 = 2 * this._snap;
            w = Math.floor(w / snap2 + 2) * snap2;
            h = Math.floor(h / snap2 + 2) * snap2;
            maxX = minX + w;
            maxY = minY + h;
            w = 1 / w;
            h = 1 / h;
            raw[0] = 2 * w;
            raw[5] = 2 * h;
            raw[10] = d;
            raw[12] = -(maxX + minX) * w;
            raw[13] = -(maxY + minY) * h;
            raw[14] = -this._minZ * d;
            raw[15] = 1;
            raw[1] = raw[2] = raw[3] = raw[4] = raw[6] = raw[7] = raw[8] = raw[9] = raw[11] = 0;
            matrix.copyRawDataFrom(raw);
        };
        return DirectionalShadowMapper;
    }(feng3d.ShadowMapperBase));
    feng3d.DirectionalShadowMapper = DirectionalShadowMapper;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 近方向光阴影映射
     * @author feng 2015-5-28
     */
    var NearDirectionalShadowMapper = (function (_super) {
        __extends(NearDirectionalShadowMapper, _super);
        /**
         * 创建近方向光阴影映射
         * @param coverageRatio		覆盖比例
         */
        function NearDirectionalShadowMapper(coverageRatio) {
            if (coverageRatio === void 0) { coverageRatio = .5; }
            _super.call(this);
            this.coverageRatio = coverageRatio;
        }
        Object.defineProperty(NearDirectionalShadowMapper.prototype, "coverageRatio", {
            /**
             * 阴影的覆盖视椎体的比例
             * <p>0表示视椎体内看不到阴影，0.5表示从近平面到与远平面之间可以看到阴影，1表示视椎体内都可以看到阴影。</p>
             * <p><b>注：看到阴影的前提是有阴影产生</b></p>
             */
            get: function () {
                return this._coverageRatio;
            },
            set: function (value) {
                if (value > 1)
                    value = 1;
                else if (value < 0)
                    value = 0;
                this._coverageRatio = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        NearDirectionalShadowMapper.prototype.updateDepthProjection = function (viewCamera) {
            var corners = viewCamera.lens.frustumCorners;
            for (var i = 0; i < 12; ++i) {
                var v = corners[i];
                this._localFrustum[i] = v;
                this._localFrustum[i + 12] = v + (corners[i + 12] - v) * this._coverageRatio;
            }
            this.updateProjectionFromFrustumCorners(viewCamera, this._localFrustum, this._matrix);
            this._overallDepthLens.matrix = this._matrix;
        };
        return NearDirectionalShadowMapper;
    }(feng3d.DirectionalShadowMapper));
    feng3d.NearDirectionalShadowMapper = NearDirectionalShadowMapper;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var Point = (function () {
        function Point(x, y) {
            if (x === void 0) { x = 0; }
            if (y === void 0) { y = 0; }
            this.x = x;
            this.y = y;
        }
        return Point;
    }());
    feng3d.Point = Point;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * Matrix3D 类表示一个转换矩阵，该矩阵确定三维 (3D) 显示对象的位置和方向。
     * 该矩阵可以执行转换功能，包括平移（沿 x、y 和 z 轴重新定位）、旋转和缩放（调整大小）。
     * Matrix3D 类还可以执行透视投影，这会将 3D 坐标空间中的点映射到二维 (2D) 视图。
     *
     *  ---            方向              平移 ---
     *  |   scaleX      0         0       tx    |
     *  |     0       scaleY      0       ty    |
     *  |     0         0       scaleZ    tz    |
     *  |     0         0         0       tw    |
     *  ---  x轴        y轴      z轴          ---
     *
     *  ---            方向              平移 ---
     *  |     0         4         8       12    |
     *  |     1         5         9       13    |
     *  |     2         6        10       14    |
     *  |     3         7        11       15    |
     *  ---  x轴        y轴      z轴          ---
     */
    var Matrix3D = (function () {
        /**
         * 创建 Matrix3D 对象。
         * @param   datas    一个由 16 个数字组成的矢量，其中，每四个元素可以是 4x4 矩阵的一列。
         */
        function Matrix3D(datas) {
            if (datas === void 0) { datas = null; }
            if (datas) {
                this.rawData = datas.concat();
            }
            else
                this.rawData = [
                    1, 0, 0, 0,
                    0, 1, 0, 0,
                    0, 0, 1, 0,
                    0, 0, 0, 1 //
                ];
        }
        Object.defineProperty(Matrix3D.prototype, "position", {
            /**
             * 一个保存显示对象在转换参照帧中的 3D 坐标 (x,y,z) 位置的 Vector3D 对象。
             */
            get: function () {
                return new feng3d.Vector3D(this.rawData[12], this.rawData[13], this.rawData[14]);
            },
            set: function (value) {
                this.rawData[12] = value.x;
                this.rawData[13] = value.y;
                this.rawData[14] = value.z;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Matrix3D.prototype, "determinant", {
            /**
             * 一个用于确定矩阵是否可逆的数字。
             */
            get: function () {
                return ((this.rawData[0] * this.rawData[5] - this.rawData[4] * this.rawData[1]) * (this.rawData[10] * this.rawData[15] - this.rawData[14] * this.rawData[11]) //
                    - (this.rawData[0] * this.rawData[9] - this.rawData[8] * this.rawData[1]) * (this.rawData[6] * this.rawData[15] - this.rawData[14] * this.rawData[7]) //
                    + (this.rawData[0] * this.rawData[13] - this.rawData[12] * this.rawData[1]) * (this.rawData[6] * this.rawData[11] - this.rawData[10] * this.rawData[7]) //
                    + (this.rawData[4] * this.rawData[9] - this.rawData[8] * this.rawData[5]) * (this.rawData[2] * this.rawData[15] - this.rawData[14] * this.rawData[3]) //
                    - (this.rawData[4] * this.rawData[13] - this.rawData[12] * this.rawData[5]) * (this.rawData[2] * this.rawData[11] - this.rawData[10] * this.rawData[3]) //
                    + (this.rawData[8] * this.rawData[13] - this.rawData[12] * this.rawData[9]) * (this.rawData[2] * this.rawData[7] - this.rawData[6] * this.rawData[3]) //
                );
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Matrix3D.prototype, "forward", {
            /**
             * 前方（+Z轴方向）
             */
            get: function () {
                var v = new feng3d.Vector3D(0.0, 0.0, 0.0);
                this.copyColumnTo(2, v);
                v.normalize();
                return v;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Matrix3D.prototype, "up", {
            /**
             * 上方（+y轴方向）
             */
            get: function () {
                var v = new feng3d.Vector3D();
                this.copyColumnTo(1, v);
                v.normalize();
                return v;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Matrix3D.prototype, "right", {
            /**
             * 右方（+x轴方向）
             */
            get: function () {
                var v = new feng3d.Vector3D();
                this.copyColumnTo(0, v);
                v.normalize();
                return v;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 创建旋转矩阵
         * @param   degrees         角度
         * @param   axis            旋转轴
         * @param   pivotPoint      旋转中心点
         */
        Matrix3D.createRotationMatrix3D = function (degrees, axis) {
            var n = axis.clone();
            n.normalize();
            var q = degrees * Math.PI / 180;
            var sinq = Math.sin(q);
            var cosq = Math.cos(q);
            var lcosq = 1 - cosq;
            var rotationMat = new Matrix3D([
                n.x * n.x * lcosq + cosq, n.x * n.y * lcosq + n.z * sinq, n.x * n.z * lcosq - n.y * sinq, 0,
                n.x * n.y * lcosq - n.z * sinq, n.y * n.y * lcosq + cosq, n.y * n.z * lcosq + n.x * sinq, 0,
                n.x * n.z * lcosq + n.y * sinq, n.y * n.z * lcosq - n.x * sinq, n.z * n.z * lcosq + cosq, 0,
                0, 0, 0, 1 //
            ]);
            return rotationMat;
        };
        /**
         * 创建缩放矩阵
         * @param   xScale      用于沿 x 轴缩放对象的乘数。
         * @param   yScale      用于沿 y 轴缩放对象的乘数。
         * @param   zScale      用于沿 z 轴缩放对象的乘数。
         */
        Matrix3D.createScaleMatrix3D = function (xScale, yScale, zScale) {
            var rotationMat = new Matrix3D([
                xScale, 0.0000, 0.0000, 0,
                0.0000, yScale, 0.0000, 0,
                0.0000, 0.0000, zScale, 0,
                0.0000, 0.0000, 0.0000, 1 //
            ]);
            return rotationMat;
        };
        /**
         * 创建位移矩阵
         * @param   x   沿 x 轴的增量平移。
         * @param   y   沿 y 轴的增量平移。
         * @param   z   沿 z 轴的增量平移。
         */
        Matrix3D.createTranslationMatrix3D = function (x, y, z) {
            var rotationMat = new Matrix3D([
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                x, y, z, 1 //
            ]);
            return rotationMat;
        };
        /**
         * 通过将另一个 Matrix3D 对象与当前 Matrix3D 对象相乘来后置一个矩阵。
         */
        Matrix3D.prototype.append = function (lhs) {
            var //
            m111 = this.rawData[0], m121 = this.rawData[4], m131 = this.rawData[8], m141 = this.rawData[12], //
            m112 = this.rawData[1], m122 = this.rawData[5], m132 = this.rawData[9], m142 = this.rawData[13], //
            m113 = this.rawData[2], m123 = this.rawData[6], m133 = this.rawData[10], m143 = this.rawData[14], //
            m114 = this.rawData[3], m124 = this.rawData[7], m134 = this.rawData[11], m144 = this.rawData[15], //
            m211 = lhs.rawData[0], m221 = lhs.rawData[4], m231 = lhs.rawData[8], m241 = lhs.rawData[12], //
            m212 = lhs.rawData[1], m222 = lhs.rawData[5], m232 = lhs.rawData[9], m242 = lhs.rawData[13], //
            m213 = lhs.rawData[2], m223 = lhs.rawData[6], m233 = lhs.rawData[10], m243 = lhs.rawData[14], //
            m214 = lhs.rawData[3], m224 = lhs.rawData[7], m234 = lhs.rawData[11], m244 = lhs.rawData[15];
            this.rawData[0] = m111 * m211 + m112 * m221 + m113 * m231 + m114 * m241;
            this.rawData[1] = m111 * m212 + m112 * m222 + m113 * m232 + m114 * m242;
            this.rawData[2] = m111 * m213 + m112 * m223 + m113 * m233 + m114 * m243;
            this.rawData[3] = m111 * m214 + m112 * m224 + m113 * m234 + m114 * m244;
            this.rawData[4] = m121 * m211 + m122 * m221 + m123 * m231 + m124 * m241;
            this.rawData[5] = m121 * m212 + m122 * m222 + m123 * m232 + m124 * m242;
            this.rawData[6] = m121 * m213 + m122 * m223 + m123 * m233 + m124 * m243;
            this.rawData[7] = m121 * m214 + m122 * m224 + m123 * m234 + m124 * m244;
            this.rawData[8] = m131 * m211 + m132 * m221 + m133 * m231 + m134 * m241;
            this.rawData[9] = m131 * m212 + m132 * m222 + m133 * m232 + m134 * m242;
            this.rawData[10] = m131 * m213 + m132 * m223 + m133 * m233 + m134 * m243;
            this.rawData[11] = m131 * m214 + m132 * m224 + m133 * m234 + m134 * m244;
            this.rawData[12] = m141 * m211 + m142 * m221 + m143 * m231 + m144 * m241;
            this.rawData[13] = m141 * m212 + m142 * m222 + m143 * m232 + m144 * m242;
            this.rawData[14] = m141 * m213 + m142 * m223 + m143 * m233 + m144 * m243;
            this.rawData[15] = m141 * m214 + m142 * m224 + m143 * m234 + m144 * m244;
        };
        /**
         * 在 Matrix3D 对象上后置一个增量旋转。
         * @param   degrees         角度
         * @param   axis            旋转轴
         * @param   pivotPoint      旋转中心点
         */
        Matrix3D.prototype.appendRotation = function (degrees, axis, pivotPoint) {
            if (pivotPoint === void 0) { pivotPoint = new feng3d.Vector3D(); }
            var rotationMat = Matrix3D.createRotationMatrix3D(degrees, axis);
            if (pivotPoint != null) {
                this.appendTranslation(-pivotPoint.x, -pivotPoint.y, -pivotPoint.z);
            }
            this.append(rotationMat);
            if (pivotPoint != null) {
                this.appendTranslation(pivotPoint.x, pivotPoint.y, pivotPoint.z);
            }
        };
        /**
         * 在 Matrix3D 对象上后置一个增量缩放，沿 x、y 和 z 轴改变位置。
         * @param   xScale      用于沿 x 轴缩放对象的乘数。
         * @param   yScale      用于沿 y 轴缩放对象的乘数。
         * @param   zScale      用于沿 z 轴缩放对象的乘数。
         */
        Matrix3D.prototype.appendScale = function (xScale, yScale, zScale) {
            var scaleMat = Matrix3D.createScaleMatrix3D(xScale, yScale, zScale);
            this.append(scaleMat);
        };
        /**
         * 在 Matrix3D 对象上后置一个增量平移，沿 x、y 和 z 轴重新定位。
         * @param   x   沿 x 轴的增量平移。
         * @param   y   沿 y 轴的增量平移。
         * @param   z   沿 z 轴的增量平移。
         */
        Matrix3D.prototype.appendTranslation = function (x, y, z) {
            this.rawData[12] += x;
            this.rawData[13] += y;
            this.rawData[14] += z;
        };
        /**
         * 返回一个新 Matrix3D 对象，它是与当前 Matrix3D 对象完全相同的副本。
         */
        Matrix3D.prototype.clone = function () {
            var ret = new Matrix3D();
            ret.copyFrom(this);
            return ret;
        };
        /**
         * 将 Vector3D 对象复制到调用方 Matrix3D 对象的特定列中。
         * @param   column      副本的目标列。
         * @param   vector3D    要从中复制数据的 Vector3D 对象。
         */
        Matrix3D.prototype.copyColumnFrom = function (column, vector3D) {
            this.rawData[column * 4 + 0] = vector3D.x;
            this.rawData[column * 4 + 1] = vector3D.y;
            this.rawData[column * 4 + 2] = vector3D.z;
            this.rawData[column * 4 + 3] = vector3D.w;
        };
        /**
         * 将调用方 Matrix3D 对象的特定列复制到 Vector3D 对象中。
         * @param   column       要从中复制数据的列。
         * @param   vector3D     副本的目标 Vector3D 对象。
         */
        Matrix3D.prototype.copyColumnTo = function (column, vector3D) {
            vector3D.x = this.rawData[column * 4 + 0];
            vector3D.y = this.rawData[column * 4 + 1];
            vector3D.z = this.rawData[column * 4 + 2];
            vector3D.w = this.rawData[column * 4 + 3];
        };
        /**
         * 将源 Matrix3D 对象中的所有矩阵数据复制到调用方 Matrix3D 对象中。
         * @param   sourceMatrix3D      要从中复制数据的 Matrix3D 对象。
         */
        Matrix3D.prototype.copyFrom = function (sourceMatrix3D) {
            for (var i = 0; i < 16; i++) {
                this.rawData[i] = sourceMatrix3D.rawData[i];
            }
        };
        /**
         * 将源 Vector 对象中的所有矢量数据复制到调用方 Matrix3D 对象中。利用可选索引参数，您可以选择矢量中的任何起始文字插槽。
         * @param   vector      要从中复制数据的 Vector 对象。
         * @param   index       vector中的起始位置
         * @param   transpose   是否转置当前矩阵
         */
        Matrix3D.prototype.copyRawDataFrom = function (vector, index, transpose) {
            if (index === void 0) { index = 0; }
            if (transpose === void 0) { transpose = false; }
            if (vector.length - index < 16) {
                throw new ArgumentError();
            }
            for (var i = 0; i < 16; i++) {
                this.rawData[i] = vector[index + i];
            }
            if (transpose) {
                this.transpose();
            }
        };
        /**
         * 将调用方 Matrix3D 对象中的所有矩阵数据复制到提供的矢量中。
         * @param   vector      要将数据复制到的 Vector 对象。
         * @param   index       vector中的起始位置
         * @param   transpose   是否转置当前矩阵
         */
        Matrix3D.prototype.copyRawDataTo = function (vector, index, transpose) {
            if (index === void 0) { index = 0; }
            if (transpose === void 0) { transpose = false; }
            if (transpose) {
                this.transpose();
            }
            for (var i = 0; i < 16; i++) {
                vector[i + index] = this.rawData[i];
            }
            if (transpose) {
                this.transpose();
            }
        };
        /**
         * 将 Vector3D 对象复制到调用方 Matrix3D 对象的特定行中。
         * @param   row         要将数据复制到的行。
         * @param   vector3D    要从中复制数据的 Vector3D 对象。
         */
        Matrix3D.prototype.copyRowFrom = function (row, vector3D) {
            this.rawData[row + 4 * 0] = vector3D.x;
            this.rawData[row + 4 * 1] = vector3D.y;
            this.rawData[row + 4 * 2] = vector3D.z;
            this.rawData[row + 4 * 3] = vector3D.w;
        };
        /**
         * 将调用方 Matrix3D 对象的特定行复制到 Vector3D 对象中。
         * @param   row         要从中复制数据的行。
         * @param   vector3D    将作为数据复制目的地的 Vector3D 对象。
         */
        Matrix3D.prototype.copyRowTo = function (row, vector3D) {
            vector3D.x = this.rawData[row + 4 * 0];
            vector3D.y = this.rawData[row + 4 * 1];
            vector3D.z = this.rawData[row + 4 * 2];
            vector3D.w = this.rawData[row + 4 * 3];
        };
        /**
         * 拷贝当前矩阵
         * @param   dest    目标矩阵
         */
        Matrix3D.prototype.copyToMatrix3D = function (dest) {
            dest.rawData = this.rawData.slice(0);
        };
        /**
         * 将转换矩阵的平移、旋转和缩放设置作为由三个 Vector3D 对象组成的矢量返回。
         * @return      一个由三个 Vector3D 对象组成的矢量，其中，每个对象分别容纳平移、旋转和缩放设置。
         */
        Matrix3D.prototype.decompose = function () {
            var vec = [];
            var m = this.clone();
            var mr = m.rawData;
            var pos = new feng3d.Vector3D(mr[12], mr[13], mr[14]);
            mr[12] = 0;
            mr[13] = 0;
            mr[14] = 0;
            var scale = new feng3d.Vector3D();
            scale.x = Math.sqrt(mr[0] * mr[0] + mr[1] * mr[1] + mr[2] * mr[2]);
            scale.y = Math.sqrt(mr[4] * mr[4] + mr[5] * mr[5] + mr[6] * mr[6]);
            scale.z = Math.sqrt(mr[8] * mr[8] + mr[9] * mr[9] + mr[10] * mr[10]);
            if (mr[0] * (mr[5] * mr[10] - mr[6] * mr[9]) - mr[1] * (mr[4] * mr[10] - mr[6] * mr[8]) + mr[2] * (mr[4] * mr[9] - mr[5] * mr[8]) < 0)
                scale.z = -scale.z;
            mr[0] /= scale.x;
            mr[1] /= scale.x;
            mr[2] /= scale.x;
            mr[4] /= scale.y;
            mr[5] /= scale.y;
            mr[6] /= scale.y;
            mr[8] /= scale.z;
            mr[9] /= scale.z;
            mr[10] /= scale.z;
            var rot = new feng3d.Vector3D();
            rot.y = Math.asin(-mr[2]);
            if (mr[2] != 1 && mr[2] != -1) {
                rot.x = Math.atan2(mr[6], mr[10]);
                rot.z = Math.atan2(mr[1], mr[0]);
            }
            else {
                rot.z = 0;
                rot.x = Math.atan2(mr[4], mr[5]);
            }
            vec.push(pos);
            vec.push(rot);
            vec.push(scale);
            return vec;
        };
        /**
         * 使用不含平移元素的转换矩阵将 Vector3D 对象从一个空间坐标转换到另一个空间坐标。
         * @param   v   一个容纳要转换的坐标的 Vector3D 对象。
         * @return  一个包含转换后的坐标的 Vector3D 对象。
         */
        Matrix3D.prototype.deltaTransformVector = function (v) {
            var tempx = this.rawData[12];
            var tempy = this.rawData[13];
            var tempz = this.rawData[14];
            this.rawData[12] = 0;
            this.rawData[13] = 0;
            this.rawData[14] = 0;
            var result = this.transformVector(v);
            this.rawData[12] = tempx;
            this.rawData[13] = tempy;
            this.rawData[14] = tempz;
            return result;
        };
        /**
         * 将当前矩阵转换为恒等或单位矩阵。
         */
        Matrix3D.prototype.identity = function () {
            this.rawData[1] = 0;
            this.rawData[2] = 0;
            this.rawData[3] = 0;
            this.rawData[4] = 0;
            this.rawData[6] = 0;
            this.rawData[7] = 0;
            this.rawData[8] = 0;
            this.rawData[9] = 0;
            this.rawData[11] = 0;
            this.rawData[12] = 0;
            this.rawData[13] = 0;
            this.rawData[14] = 0;
            this.rawData[0] = 1;
            this.rawData[5] = 1;
            this.rawData[10] = 1;
            this.rawData[15] = 1;
        };
        /**
         * 反转当前矩阵。逆矩阵
         * @return      如果成功反转矩阵，则返回 true。
         */
        Matrix3D.prototype.invert = function () {
            var d = this.determinant;
            var invertable = Math.abs(d) > 0.00000000001;
            if (invertable) {
                d = 1 / d;
                var m11 = this.rawData[0];
                var m21 = this.rawData[4];
                var m31 = this.rawData[8];
                var m41 = this.rawData[12];
                var m12 = this.rawData[1];
                var m22 = this.rawData[5];
                var m32 = this.rawData[9];
                var m42 = this.rawData[13];
                var m13 = this.rawData[2];
                var m23 = this.rawData[6];
                var m33 = this.rawData[10];
                var m43 = this.rawData[14];
                var m14 = this.rawData[3];
                var m24 = this.rawData[7];
                var m34 = this.rawData[11];
                var m44 = this.rawData[15];
                this.rawData[0] = d * (m22 * (m33 * m44 - m43 * m34) - m32 * (m23 * m44 - m43 * m24) + m42 * (m23 * m34 - m33 * m24));
                this.rawData[1] = -d * (m12 * (m33 * m44 - m43 * m34) - m32 * (m13 * m44 - m43 * m14) + m42 * (m13 * m34 - m33 * m14));
                this.rawData[2] = d * (m12 * (m23 * m44 - m43 * m24) - m22 * (m13 * m44 - m43 * m14) + m42 * (m13 * m24 - m23 * m14));
                this.rawData[3] = -d * (m12 * (m23 * m34 - m33 * m24) - m22 * (m13 * m34 - m33 * m14) + m32 * (m13 * m24 - m23 * m14));
                this.rawData[4] = -d * (m21 * (m33 * m44 - m43 * m34) - m31 * (m23 * m44 - m43 * m24) + m41 * (m23 * m34 - m33 * m24));
                this.rawData[5] = d * (m11 * (m33 * m44 - m43 * m34) - m31 * (m13 * m44 - m43 * m14) + m41 * (m13 * m34 - m33 * m14));
                this.rawData[6] = -d * (m11 * (m23 * m44 - m43 * m24) - m21 * (m13 * m44 - m43 * m14) + m41 * (m13 * m24 - m23 * m14));
                this.rawData[7] = d * (m11 * (m23 * m34 - m33 * m24) - m21 * (m13 * m34 - m33 * m14) + m31 * (m13 * m24 - m23 * m14));
                this.rawData[8] = d * (m21 * (m32 * m44 - m42 * m34) - m31 * (m22 * m44 - m42 * m24) + m41 * (m22 * m34 - m32 * m24));
                this.rawData[9] = -d * (m11 * (m32 * m44 - m42 * m34) - m31 * (m12 * m44 - m42 * m14) + m41 * (m12 * m34 - m32 * m14));
                this.rawData[10] = d * (m11 * (m22 * m44 - m42 * m24) - m21 * (m12 * m44 - m42 * m14) + m41 * (m12 * m24 - m22 * m14));
                this.rawData[11] = -d * (m11 * (m22 * m34 - m32 * m24) - m21 * (m12 * m34 - m32 * m14) + m31 * (m12 * m24 - m22 * m14));
                this.rawData[12] = -d * (m21 * (m32 * m43 - m42 * m33) - m31 * (m22 * m43 - m42 * m23) + m41 * (m22 * m33 - m32 * m23));
                this.rawData[13] = d * (m11 * (m32 * m43 - m42 * m33) - m31 * (m12 * m43 - m42 * m13) + m41 * (m12 * m33 - m32 * m13));
                this.rawData[14] = -d * (m11 * (m22 * m43 - m42 * m23) - m21 * (m12 * m43 - m42 * m13) + m41 * (m12 * m23 - m22 * m13));
                this.rawData[15] = d * (m11 * (m22 * m33 - m32 * m23) - m21 * (m12 * m33 - m32 * m13) + m31 * (m12 * m23 - m22 * m13));
            }
            return invertable;
        };
        /**
         * 通过将当前 Matrix3D 对象与另一个 Matrix3D 对象相乘来前置一个矩阵。得到的结果将合并两个矩阵转换。
         * @param   rhs     个右侧矩阵，它与当前 Matrix3D 对象相乘。
         */
        Matrix3D.prototype.prepend = function (rhs) {
            var mat = this.clone();
            this.copyFrom(rhs);
            this.append(mat);
        };
        /**
         * 在 Matrix3D 对象上前置一个增量旋转。在将 Matrix3D 对象应用于显示对象时，矩阵会在 Matrix3D 对象中先执行旋转，然后再执行其他转换。
         * @param   degrees     旋转的角度。
         * @param   axis        旋转的轴或方向。常见的轴为 X_AXIS (Vector3D(1,0,0))、Y_AXIS (Vector3D(0,1,0)) 和 Z_AXIS (Vector3D(0,0,1))。此矢量的长度应为 1。
         * @param   pivotPoint  一个用于确定旋转中心的点。对象的默认轴点为该对象的注册点。
         */
        Matrix3D.prototype.prependRotation = function (degrees, axis, pivotPoint) {
            if (pivotPoint === void 0) { pivotPoint = new feng3d.Vector3D(); }
            var rotationMat = Matrix3D.createRotationMatrix3D(degrees, axis);
            this.prepend(rotationMat);
        };
        /**
         * 在 Matrix3D 对象上前置一个增量缩放，沿 x、y 和 z 轴改变位置。在将 Matrix3D 对象应用于显示对象时，矩阵会在 Matrix3D 对象中先执行缩放更改，然后再执行其他转换。
         * @param   xScale      用于沿 x 轴缩放对象的乘数。
         * @param   yScale      用于沿 y 轴缩放对象的乘数。
         * @param   zScale      用于沿 z 轴缩放对象的乘数。
         */
        Matrix3D.prototype.prependScale = function (xScale, yScale, zScale) {
            var scaleMat = Matrix3D.createScaleMatrix3D(xScale, yScale, zScale);
            this.prepend(scaleMat);
        };
        /**
         * 在 Matrix3D 对象上前置一个增量平移，沿 x、y 和 z 轴重新定位。在将 Matrix3D 对象应用于显示对象时，矩阵会在 Matrix3D 对象中先执行平移更改，然后再执行其他转换。
         * @param   x   沿 x 轴的增量平移。
         * @param   y   沿 y 轴的增量平移。
         * @param   z   沿 z 轴的增量平移。
         */
        Matrix3D.prototype.prependTranslation = function (x, y, z) {
            var translationMat = Matrix3D.createTranslationMatrix3D(x, y, z);
            this.prepend(translationMat);
        };
        /**
         * 设置转换矩阵的平移、旋转和缩放设置。
         * @param   components      一个由三个 Vector3D 对象组成的矢量，这些对象将替代 Matrix3D 对象的平移、旋转和缩放元素。
         */
        Matrix3D.prototype.recompose = function (components) {
            this.identity();
            this.appendRotation(components[1].x * feng3d.MathConsts.RADIANS_TO_DEGREES, feng3d.Vector3D.X_AXIS);
            this.appendRotation(components[1].y * feng3d.MathConsts.RADIANS_TO_DEGREES, feng3d.Vector3D.Y_AXIS);
            this.appendRotation(components[1].z * feng3d.MathConsts.RADIANS_TO_DEGREES, feng3d.Vector3D.Z_AXIS);
            this.appendScale(components[2].x, components[2].y, components[2].z);
            this.appendTranslation(components[0].x, components[0].y, components[0].z);
            return true;
        };
        /**
         * 使用转换矩阵将 Vector3D 对象从一个空间坐标转换到另一个空间坐标。
         * @param   v   一个容纳要转换的坐标的 Vector3D 对象。
         * @return  一个包含转换后的坐标的 Vector3D 对象。
         */
        Matrix3D.prototype.transformVector = function (v) {
            if (v == null)
                return new feng3d.Vector3D();
            var x = v.x;
            var y = v.y;
            var z = v.z;
            var out = new feng3d.Vector3D();
            out.x = x * this.rawData[0] + y * this.rawData[4] + z * this.rawData[8] + this.rawData[12];
            out.y = x * this.rawData[1] + y * this.rawData[5] + z * this.rawData[9] + this.rawData[13];
            out.z = x * this.rawData[2] + y * this.rawData[6] + z * this.rawData[10] + this.rawData[14];
            out.w = x * this.rawData[3] + y * this.rawData[7] + z * this.rawData[11] + this.rawData[15];
            return out;
        };
        /**
         * 使用转换矩阵将由数字构成的矢量从一个空间坐标转换到另一个空间坐标。
         * @param   vin     一个由多个数字组成的矢量，其中每三个数字构成一个要转换的 3D 坐标 (x,y,z)。
         * @param   vout    一个由多个数字组成的矢量，其中每三个数字构成一个已转换的 3D 坐标 (x,y,z)。
         */
        Matrix3D.prototype.transformVectors = function (vin, vout) {
            var vec = new feng3d.Vector3D();
            for (var i = 0; i < vin.length; i += 3) {
                vec.setTo(vin[i], vin[i + 1], vin[i + 2]);
                vec = this.transformVector(vec);
                vout[i] = vec.x;
                vout[i + 1] = vec.y;
                vout[i + 2] = vec.z;
            }
        };
        /**
         * 将当前 Matrix3D 对象转换为一个矩阵，并将互换其中的行和列。
         */
        Matrix3D.prototype.transpose = function () {
            var swap;
            for (var i = 0; i < 4; i++) {
                for (var j = 0; j < 4; j++) {
                    if (i > j) {
                        swap = this.rawData[i * 4 + j];
                        this.rawData[i * 4 + j] = this.rawData[j * 4 + i];
                        this.rawData[j * 4 + i] = swap;
                    }
                }
            }
        };
        /**
         * 比较矩阵是否相等
         */
        Matrix3D.prototype.compare = function (matrix3D, precision) {
            if (precision === void 0) { precision = 0.0001; }
            var r2 = matrix3D.rawData;
            for (var i = 0; i < 16; ++i) {
                if (Math.abs(this.rawData[i] - r2[i]) > precision)
                    return false;
            }
            return true;
        };
        /**
         * 以字符串返回矩阵的值
         */
        Matrix3D.prototype.toString = function () {
            var str = "";
            var showLen = 5;
            var precision = Math.pow(10, showLen - 1);
            for (var i = 0; i < 4; i++) {
                for (var j = 0; j < 4; j++) {
                    str += StringUtils.getString(Math.round(this.rawData[i * 4 + j] * precision) / precision, showLen, " ");
                }
                if (i != 3)
                    str += "\n";
            }
            return str;
        };
        return Matrix3D;
    }());
    feng3d.Matrix3D = Matrix3D;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * Orientation3D 类是用于表示 Matrix3D 对象的方向样式的常量值枚举。方向的三个类型分别为欧拉角、轴角和四元数。Matrix3D 对象的 decompose 和 recompose 方法采用其中的某一个枚举类型来标识矩阵的旋转组件。
     * @author feng 2016-3-21
     */
    var Orientation3D = (function () {
        function Orientation3D() {
        }
        /**
        * 轴角方向结合使用轴和角度来确定方向。
        */
        Orientation3D.AXIS_ANGLE = "axisAngle";
        /**
        * 欧拉角（decompose() 和 recompose() 方法的默认方向）通过三个不同的对应于每个轴的旋转角来定义方向。
        */
        Orientation3D.EULER_ANGLES = "eulerAngles";
        /**
        * 四元数方向使用复数。
        */
        Orientation3D.QUATERNION = "quaternion";
        return Orientation3D;
    }());
    feng3d.Orientation3D = Orientation3D;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * A Quaternion object which can be used to represent rotations.
     */
    var Quaternion = (function () {
        /**
         * Creates a new Quaternion object.
         * @param x The x value of the quaternion.
         * @param y The y value of the quaternion.
         * @param z The z value of the quaternion.
         * @param w The w value of the quaternion.
         */
        function Quaternion(x, y, z, w) {
            if (x === void 0) { x = 0; }
            if (y === void 0) { y = 0; }
            if (z === void 0) { z = 0; }
            if (w === void 0) { w = 1; }
            /**
             * The x value of the quaternion.
             */
            this.x = 0;
            /**
             * The y value of the quaternion.
             */
            this.y = 0;
            /**
             * The z value of the quaternion.
             */
            this.z = 0;
            /**
             * The w value of the quaternion.
             */
            this.w = 1;
            this.x = x;
            this.y = y;
            this.z = z;
            this.w = w;
        }
        Object.defineProperty(Quaternion.prototype, "magnitude", {
            /**
             * Returns the magnitude of the quaternion object.
             */
            get: function () {
                return Math.sqrt(this.w * this.w + this.x * this.x + this.y * this.y + this.z * this.z);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Fills the quaternion object with the result from a multiplication of two quaternion objects.
         *
         * @param    qa    The first quaternion in the multiplication.
         * @param    qb    The second quaternion in the multiplication.
         */
        Quaternion.prototype.multiply = function (qa, qb) {
            var w1 = qa.w, x1 = qa.x, y1 = qa.y, z1 = qa.z;
            var w2 = qb.w, x2 = qb.x, y2 = qb.y, z2 = qb.z;
            this.w = w1 * w2 - x1 * x2 - y1 * y2 - z1 * z2;
            this.x = w1 * x2 + x1 * w2 + y1 * z2 - z1 * y2;
            this.y = w1 * y2 - x1 * z2 + y1 * w2 + z1 * x2;
            this.z = w1 * z2 + x1 * y2 - y1 * x2 + z1 * w2;
        };
        Quaternion.prototype.multiplyVector = function (vector, target) {
            if (target === void 0) { target = null; }
            target = target || new Quaternion();
            var x2 = vector.x;
            var y2 = vector.y;
            var z2 = vector.z;
            target.w = -this.x * x2 - this.y * y2 - this.z * z2;
            target.x = this.w * x2 + this.y * z2 - this.z * y2;
            target.y = this.w * y2 - this.x * z2 + this.z * x2;
            target.z = this.w * z2 + this.x * y2 - this.y * x2;
            return target;
        };
        /**
         * Fills the quaternion object with values representing the given rotation around a vector.
         *
         * @param    axis    The axis around which to rotate
         * @param    angle    The angle in radians of the rotation.
         */
        Quaternion.prototype.fromAxisAngle = function (axis, angle) {
            var sin_a = Math.sin(angle / 2);
            var cos_a = Math.cos(angle / 2);
            this.x = axis.x * sin_a;
            this.y = axis.y * sin_a;
            this.z = axis.z * sin_a;
            this.w = cos_a;
            this.normalize();
        };
        /**
         * Spherically interpolates between two quaternions, providing an interpolation between rotations with constant angle change rate.
         * @param qa The first quaternion to interpolate.
         * @param qb The second quaternion to interpolate.
         * @param t The interpolation weight, a value between 0 and 1.
         */
        Quaternion.prototype.slerp = function (qa, qb, t) {
            var w1 = qa.w, x1 = qa.x, y1 = qa.y, z1 = qa.z;
            var w2 = qb.w, x2 = qb.x, y2 = qb.y, z2 = qb.z;
            var dot = w1 * w2 + x1 * x2 + y1 * y2 + z1 * z2;
            // shortest direction
            if (dot < 0) {
                dot = -dot;
                w2 = -w2;
                x2 = -x2;
                y2 = -y2;
                z2 = -z2;
            }
            if (dot < 0.95) {
                // interpolate angle linearly
                var angle = Math.acos(dot);
                var s = 1 / Math.sin(angle);
                var s1 = Math.sin(angle * (1 - t)) * s;
                var s2 = Math.sin(angle * t) * s;
                this.w = w1 * s1 + w2 * s2;
                this.x = x1 * s1 + x2 * s2;
                this.y = y1 * s1 + y2 * s2;
                this.z = z1 * s1 + z2 * s2;
            }
            else {
                // nearly identical angle, interpolate linearly
                this.w = w1 + t * (w2 - w1);
                this.x = x1 + t * (x2 - x1);
                this.y = y1 + t * (y2 - y1);
                this.z = z1 + t * (z2 - z1);
                var len = 1.0 / Math.sqrt(this.w * this.w + this.x * this.x + this.y * this.y + this.z * this.z);
                this.w *= len;
                this.x *= len;
                this.y *= len;
                this.z *= len;
            }
        };
        /**
         * 线性求插值
         * @param qa 第一个四元素
         * @param qb 第二个四元素
         * @param t 权重
         */
        Quaternion.prototype.lerp = function (qa, qb, t) {
            var w1 = qa.w, x1 = qa.x, y1 = qa.y, z1 = qa.z;
            var w2 = qb.w, x2 = qb.x, y2 = qb.y, z2 = qb.z;
            var len;
            // shortest direction
            if (w1 * w2 + x1 * x2 + y1 * y2 + z1 * z2 < 0) {
                w2 = -w2;
                x2 = -x2;
                y2 = -y2;
                z2 = -z2;
            }
            this.w = w1 + t * (w2 - w1);
            this.x = x1 + t * (x2 - x1);
            this.y = y1 + t * (y2 - y1);
            this.z = z1 + t * (z2 - z1);
            len = 1.0 / Math.sqrt(this.w * this.w + this.x * this.x + this.y * this.y + this.z * this.z);
            this.w *= len;
            this.x *= len;
            this.y *= len;
            this.z *= len;
        };
        /**
         * Fills the quaternion object with values representing the given euler rotation.
         *
         * @param    ax        The angle in radians of the rotation around the ax axis.
         * @param    ay        The angle in radians of the rotation around the ay axis.
         * @param    az        The angle in radians of the rotation around the az axis.
         */
        Quaternion.prototype.fromEulerAngles = function (ax, ay, az) {
            var halfX = ax * .5, halfY = ay * .5, halfZ = az * .5;
            var cosX = Math.cos(halfX), sinX = Math.sin(halfX);
            var cosY = Math.cos(halfY), sinY = Math.sin(halfY);
            var cosZ = Math.cos(halfZ), sinZ = Math.sin(halfZ);
            this.w = cosX * cosY * cosZ + sinX * sinY * sinZ;
            this.x = sinX * cosY * cosZ - cosX * sinY * sinZ;
            this.y = cosX * sinY * cosZ + sinX * cosY * sinZ;
            this.z = cosX * cosY * sinZ - sinX * sinY * cosZ;
        };
        /**
         * Fills a target Vector3D object with the Euler angles that form the rotation represented by this quaternion.
         * @param target An optional Vector3D object to contain the Euler angles. If not provided, a new object is created.
         * @return The Vector3D containing the Euler angles.
         */
        Quaternion.prototype.toEulerAngles = function (target) {
            if (target === void 0) { target = null; }
            target = target || new feng3d.Vector3D();
            target.x = Math.atan2(2 * (this.w * this.x + this.y * this.z), 1 - 2 * (this.x * this.x + this.y * this.y));
            target.y = Math.asin(2 * (this.w * this.y - this.z * this.x));
            target.z = Math.atan2(2 * (this.w * this.z + this.x * this.y), 1 - 2 * (this.y * this.y + this.z * this.z));
            return target;
        };
        /**
         * Normalises the quaternion object.
         */
        Quaternion.prototype.normalize = function (val) {
            if (val === void 0) { val = 1; }
            var mag = val / Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
            this.x *= mag;
            this.y *= mag;
            this.z *= mag;
            this.w *= mag;
        };
        /**
         * Used to trace the values of a quaternion.
         *
         * @return A string representation of the quaternion object.
         */
        Quaternion.prototype.toString = function () {
            return "{this.x:" + this.x + " this.y:" + this.y + " this.z:" + this.z + " this.w:" + this.w + "}";
        };
        /**
         * Converts the quaternion to a Matrix3D object representing an equivalent rotation.
         * @param target An optional Matrix3D container to store the transformation in. If not provided, a new object is created.
         * @return A Matrix3D object representing an equivalent rotation.
         */
        Quaternion.prototype.toMatrix3D = function (target) {
            if (target === void 0) { target = null; }
            var rawData = feng3d.Matrix3DUtils.RAW_DATA_CONTAINER;
            var xy2 = 2.0 * this.x * this.y, xz2 = 2.0 * this.x * this.z, xw2 = 2.0 * this.x * this.w;
            var yz2 = 2.0 * this.y * this.z, yw2 = 2.0 * this.y * this.w, zw2 = 2.0 * this.z * this.w;
            var xx = this.x * this.x, yy = this.y * this.y, zz = this.z * this.z, ww = this.w * this.w;
            rawData[0] = xx - yy - zz + ww;
            rawData[4] = xy2 - zw2;
            rawData[8] = xz2 + yw2;
            rawData[12] = 0;
            rawData[1] = xy2 + zw2;
            rawData[5] = -xx + yy - zz + ww;
            rawData[9] = yz2 - xw2;
            rawData[13] = 0;
            rawData[2] = xz2 - yw2;
            rawData[6] = yz2 + xw2;
            rawData[10] = -xx - yy + zz + ww;
            rawData[14] = 0;
            rawData[3] = 0.0;
            rawData[7] = 0.0;
            rawData[11] = 0;
            rawData[15] = 1;
            if (!target)
                return new feng3d.Matrix3D(rawData);
            target.copyRawDataFrom(rawData);
            return target;
        };
        /**
         * Extracts a quaternion rotation matrix out of a given Matrix3D object.
         * @param matrix The Matrix3D out of which the rotation will be extracted.
         */
        Quaternion.prototype.fromMatrix = function (matrix) {
            var v = matrix.decompose()[1];
            this.fromEulerAngles(v.x, v.y, v.z);
        };
        /**
         * Converts the quaternion to a Vector.&lt;number&gt; matrix representation of a rotation equivalent to this quaternion.
         * @param target The Vector.&lt;number&gt; to contain the raw matrix data.
         * @param exclude4thRow If true, the last row will be omitted, and a 4x3 matrix will be generated instead of a 4x4.
         */
        Quaternion.prototype.toRawData = function (target, exclude4thRow) {
            if (exclude4thRow === void 0) { exclude4thRow = false; }
            var xy2 = 2.0 * this.x * this.y, xz2 = 2.0 * this.x * this.z, xw2 = 2.0 * this.x * this.w;
            var yz2 = 2.0 * this.y * this.z, yw2 = 2.0 * this.y * this.w, zw2 = 2.0 * this.z * this.w;
            var xx = this.x * this.x, yy = this.y * this.y, zz = this.z * this.z, ww = this.w * this.w;
            target[0] = xx - yy - zz + ww;
            target[1] = xy2 - zw2;
            target[2] = xz2 + yw2;
            target[4] = xy2 + zw2;
            target[5] = -xx + yy - zz + ww;
            target[6] = yz2 - xw2;
            target[8] = xz2 - yw2;
            target[9] = yz2 + xw2;
            target[10] = -xx - yy + zz + ww;
            target[3] = target[7] = target[11] = 0;
            if (!exclude4thRow) {
                target[12] = target[13] = target[14] = 0;
                target[15] = 1;
            }
        };
        /**
         * Clones the quaternion.
         * @return An exact duplicate of the current Quaternion.
         */
        Quaternion.prototype.clone = function () {
            return new Quaternion(this.x, this.y, this.z, this.w);
        };
        /**
         * Rotates a point.
         * @param vector The Vector3D object to be rotated.
         * @param target An optional Vector3D object that will contain the rotated coordinates. If not provided, a new object will be created.
         * @return A Vector3D object containing the rotated point.
         */
        Quaternion.prototype.rotatePoint = function (vector, target) {
            if (target === void 0) { target = null; }
            var x1, y1, z1, w1;
            var x2 = vector.x, y2 = vector.y, z2 = vector.z;
            target = target || new feng3d.Vector3D();
            // p*q'
            w1 = -this.x * x2 - this.y * y2 - this.z * z2;
            x1 = this.w * x2 + this.y * z2 - this.z * y2;
            y1 = this.w * y2 - this.x * z2 + this.z * x2;
            z1 = this.w * z2 + this.x * y2 - this.y * x2;
            target.x = -w1 * this.x + x1 * this.w - y1 * this.z + z1 * this.y;
            target.y = -w1 * this.y + x1 * this.z + y1 * this.w - z1 * this.x;
            target.z = -w1 * this.z - x1 * this.y + y1 * this.x + z1 * this.w;
            return target;
        };
        /**
         * Copies the data from a quaternion into this instance.
         * @param q The quaternion to copy from.
         */
        Quaternion.prototype.copyFrom = function (q) {
            this.x = q.x;
            this.y = q.y;
            this.z = q.z;
            this.w = q.w;
        };
        return Quaternion;
    }());
    feng3d.Quaternion = Quaternion;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * Vector3D 类使用笛卡尔坐标 x、y 和 z 表示三维空间中的点或位置
     * @author feng 2016-3-21
     */
    var Vector3D = (function () {
        /**
         * 创建 Vector3D 对象的实例。如果未指定构造函数的参数，则将使用元素 (0,0,0,0) 创建 Vector3D 对象。
         * @param x 第一个元素，例如 x 坐标。
         * @param y 第二个元素，例如 y 坐标。
         * @param z 第三个元素，例如 z 坐标。
         * @param w 表示额外数据的可选元素，例如旋转角度
         */
        function Vector3D(x, y, z, w) {
            if (x === void 0) { x = 0; }
            if (y === void 0) { y = 0; }
            if (z === void 0) { z = 0; }
            if (w === void 0) { w = 0; }
            this.x = x;
            this.y = y;
            this.z = z;
            this.w = w;
        }
        Object.defineProperty(Vector3D.prototype, "length", {
            /**
            * 当前 Vector3D 对象的长度（大小），即从原点 (0,0,0) 到该对象的 x、y 和 z 坐标的距离。w 属性将被忽略。单位矢量具有的长度或大小为一。
            */
            get: function () {
                return Math.sqrt(this.lengthSquared);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Vector3D.prototype, "lengthSquared", {
            /**
            * 当前 Vector3D 对象长度的平方，它是使用 x、y 和 z 属性计算出来的。w 属性将被忽略。尽可能使用 lengthSquared() 方法，而不要使用 Vector3D.length() 方法的 Math.sqrt() 方法调用，后者速度较慢。
            */
            get: function () {
                return this.x * this.x + this.y * this.y + this.z * this.z;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 将当前 Vector3D 对象的 x、y 和 z 元素的值与另一个 Vector3D 对象的 x、y 和 z 元素的值相加。
         * @param a 要与当前 Vector3D 对象相加的 Vector3D 对象。
         * @return 一个 Vector3D 对象，它是将当前 Vector3D 对象与另一个 Vector3D 对象相加所产生的结果。
         */
        Vector3D.prototype.add = function (a) {
            return new Vector3D(this.x + a.x, this.y + a.y, this.z + a.z, this.w + a.w);
        };
        /**
         * 返回一个新 Vector3D 对象，它是与当前 Vector3D 对象完全相同的副本。
         * @return 一个新 Vector3D 对象，它是当前 Vector3D 对象的副本。
         */
        Vector3D.prototype.clone = function () {
            return new Vector3D(this.x, this.y, this.z, this.w);
        };
        /**
         * 将源 Vector3D 对象中的所有矢量数据复制到调用方 Vector3D 对象中。
         * @return 要从中复制数据的 Vector3D 对象。
         */
        Vector3D.prototype.copyFrom = function (sourceVector3D) {
            this.x = sourceVector3D.x;
            this.y = sourceVector3D.y;
            this.z = sourceVector3D.z;
            this.w = sourceVector3D.w;
        };
        /**
         * 返回一个新的 Vector3D 对象，它与当前 Vector3D 对象和另一个 Vector3D 对象垂直（成直角）。
         */
        Vector3D.prototype.crossProduct = function (a) {
            return new Vector3D(this.y * a.z - this.z * a.y, this.z * a.x - this.x * a.z, this.x * a.y - this.y * a.x, 1);
        };
        /**
         * 按照指定的 Vector3D 对象的 x、y 和 z 元素的值递减当前 Vector3D 对象的 x、y 和 z 元素的值。
         */
        Vector3D.prototype.decrementBy = function (a) {
            this.x -= a.x;
            this.y -= a.y;
            this.z -= a.z;
        };
        /**
         * 返回两个 Vector3D 对象之间的距离。
         */
        Vector3D.distance = function (pt1, pt2) {
            var x = (pt1.x - pt2.x);
            var y = (pt1.y - pt2.y);
            var z = (pt1.z - pt2.z);
            return Math.sqrt(x * x + y * y + z * z);
        };
        /**
         * 如果当前 Vector3D 对象和作为参数指定的 Vector3D 对象均为单位顶点，此方法将返回这两个顶点之间所成角的余弦值。
         */
        Vector3D.prototype.dotProduct = function (a) {
            return this.x * a.x + this.y * a.y + this.z * a.z;
        };
        /**
         * 通过将当前 Vector3D 对象的 x、y 和 z 元素与指定的 Vector3D 对象的 x、y 和 z 元素进行比较，确定这两个对象是否相等。
         */
        Vector3D.prototype.equals = function (toCompare, allFour) {
            if (allFour === void 0) { allFour = false; }
            return (this.x == toCompare.x && this.y == toCompare.y && this.z == toCompare.z && (!allFour || this.w == toCompare.w));
        };
        /**
         * 按照指定的 Vector3D 对象的 x、y 和 z 元素的值递增当前 Vector3D 对象的 x、y 和 z 元素的值。
         */
        Vector3D.prototype.incrementBy = function (a) {
            this.x += a.x;
            this.y += a.y;
            this.z += a.z;
        };
        /**
         * 将当前 Vector3D 对象设置为其逆对象。
         */
        Vector3D.prototype.negate = function () {
            this.x = -this.x;
            this.y = -this.y;
            this.z = -this.z;
        };
        /**
         * 通过将最前面的三个元素（x、y、z）除以矢量的长度可将 Vector3D 对象转换为单位矢量。
         */
        Vector3D.prototype.normalize = function (thickness) {
            if (thickness === void 0) { thickness = 1; }
            if (this.length != 0) {
                var invLength = thickness / this.length;
                this.x *= invLength;
                this.y *= invLength;
                this.z *= invLength;
                return;
            }
        };
        /**
         * 按标量（大小）缩放当前的 Vector3D 对象。
         */
        Vector3D.prototype.scaleBy = function (s) {
            this.x *= s;
            this.y *= s;
            this.z *= s;
        };
        /**
         * 将 Vector3D 的成员设置为指定值
         */
        Vector3D.prototype.setTo = function (xa, ya, za) {
            this.x = xa;
            this.y = ya;
            this.z = za;
        };
        /**
         * 从另一个 Vector3D 对象的 x、y 和 z 元素的值中减去当前 Vector3D 对象的 x、y 和 z 元素的值。
         */
        Vector3D.prototype.subtract = function (a) {
            return new Vector3D(this.x - a.x, this.y - a.y, this.z - a.z);
        };
        /**
         * 返回当前 Vector3D 对象的字符串表示形式。
         */
        Vector3D.prototype.toString = function () {
            return "<" + this.x + ", " + this.y + ", " + this.z + ">";
        };
        /**
        * 定义为 Vector3D 对象的 x 轴，坐标为 (1,0,0)。
        */
        Vector3D.X_AXIS = new Vector3D(1, 0, 0);
        /**
        * 定义为 Vector3D 对象的 y 轴，坐标为 (0,1,0)
        */
        Vector3D.Y_AXIS = new Vector3D(0, 1, 0);
        /**
        * 定义为 Vector3D 对象的 z 轴，坐标为 (0,0,1)
        */
        Vector3D.Z_AXIS = new Vector3D(0, 0, 1);
        return Vector3D;
    }());
    feng3d.Vector3D = Vector3D;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 3d直线
     * @author feng 2013-6-13
     */
    var Line3D = (function () {
        /**
         * 根据直线某点与方向创建直线
         * @param position 直线上某点
         * @param direction 直线的方向
         */
        function Line3D(position, direction) {
            if (position === void 0) { position = null; }
            if (direction === void 0) { direction = null; }
            this.position = position ? position : new feng3d.Vector3D();
            this.direction = direction ? direction : new feng3d.Vector3D(0, 0, 1);
        }
        /**
         * 根据直线上两点初始化直线
         * @param p0 Vector3D
         * @param p1 Vector3D
         */
        Line3D.prototype.fromPoints = function (p0, p1) {
            this.position = p0;
            this.direction = p1.subtract(p0);
        };
        /**
         * 根据直线某点与方向初始化直线
         * @param position 直线上某点
         * @param direction 直线的方向
         */
        Line3D.prototype.fromPosAndDir = function (position, direction) {
            this.position = position;
            this.direction = direction;
        };
        /**
         * 获取直线上的一个点
         * @param length 与原点距离
         */
        Line3D.prototype.getPoint = function (length) {
            if (length === void 0) { length = 0; }
            var lengthDir = this.direction.clone();
            lengthDir.scaleBy(length);
            var newPoint = this.position.add(lengthDir);
            return newPoint;
        };
        return Line3D;
    }());
    feng3d.Line3D = Line3D;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 3D射线
     * @author feng 2013-6-13
     */
    var Ray3D = (function (_super) {
        __extends(Ray3D, _super);
        function Ray3D(position, direction) {
            if (position === void 0) { position = null; }
            if (direction === void 0) { direction = null; }
            _super.call(this, position, direction);
        }
        return Ray3D;
    }(feng3d.Line3D));
    feng3d.Ray3D = Ray3D;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 数学常量类
     */
    var MathConsts = (function () {
        function MathConsts() {
        }
        /**
         * 弧度转角度因子
         */
        MathConsts.RADIANS_TO_DEGREES = 180 / Math.PI;
        /**
         * 角度转弧度因子
         */
        MathConsts.DEGREES_TO_RADIANS = Math.PI / 180;
        return MathConsts;
    }());
    feng3d.MathConsts = MathConsts;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 矩阵工具类
     * Matrix3DUtils provides additional Matrix3D math functions.
     */
    var Matrix3DUtils = (function () {
        function Matrix3DUtils() {
        }
        /**
         * Fills the 3d matrix object with values representing the transformation made by the given quaternion.
         *
         * @param    quarternion    The quarterion object to convert.
         */
        Matrix3DUtils.quaternion2matrix = function (quarternion, m) {
            if (m === void 0) { m = null; }
            var x = quarternion.x;
            var y = quarternion.y;
            var z = quarternion.z;
            var w = quarternion.w;
            var xx = x * x;
            var xy = x * y;
            var xz = x * z;
            var xw = x * w;
            var yy = y * y;
            var yz = y * z;
            var yw = y * w;
            var zz = z * z;
            var zw = z * w;
            var raw = Matrix3DUtils.RAW_DATA_CONTAINER;
            raw[0] = 1 - 2 * (yy + zz);
            raw[1] = 2 * (xy + zw);
            raw[2] = 2 * (xz - yw);
            raw[4] = 2 * (xy - zw);
            raw[5] = 1 - 2 * (xx + zz);
            raw[6] = 2 * (yz + xw);
            raw[8] = 2 * (xz + yw);
            raw[9] = 2 * (yz - xw);
            raw[10] = 1 - 2 * (xx + yy);
            raw[3] = raw[7] = raw[11] = raw[12] = raw[13] = raw[14] = 0;
            raw[15] = 1;
            if (m) {
                m.copyRawDataFrom(raw);
                return m;
            }
            else
                return new feng3d.Matrix3D(raw);
        };
        /**
         *
         * Returns a normalised <code>Vector3D</code> object representing the forward vector of the given matrix.
         * @param    m        The Matrix3D object to use to get the forward vector
         * @param    v        [optional] A vector holder to prevent make new Vector3D instance if already exists. Default is null.
         * @return            The forward vector
         */
        Matrix3DUtils.getForward = function (m, v) {
            if (v === void 0) { v = null; }
            if (!v)
                v = new feng3d.Vector3D();
            m.copyColumnTo(2, v);
            v.normalize();
            return v;
        };
        /**
         * Returns a normalised <code>Vector3D</code> object representing the up vector of the given matrix.
         * @param    m        The Matrix3D object to use to get the up vector
         * @param    v        [optional] A vector holder to prevent make new Vector3D instance if already exists. Default is null.
         * @return            The up vector
         */
        Matrix3DUtils.getUp = function (m, v) {
            if (v === void 0) { v = null; }
            if (!v)
                v = new feng3d.Vector3D();
            m.copyColumnTo(1, v);
            v.normalize();
            return v;
        };
        /**
         * Returns a normalised <code>Vector3D</code> object representing the right vector of the given matrix.
         * @param    m        The Matrix3D object to use to get the right vector
         * @param    v        [optional] A vector holder to prevent make new Vector3D instance if already exists. Default is null.
         * @return            The right vector
         */
        Matrix3DUtils.getRight = function (m, v) {
            if (v === void 0) { v = null; }
            if (!v)
                v = new feng3d.Vector3D();
            m.copyColumnTo(0, v);
            v.normalize();
            return v;
        };
        /**
         * Returns a boolean value representing whether there is any significant difference between the two given 3d matrices.
         */
        Matrix3DUtils.compare = function (m1, m2) {
            var r1 = Matrix3DUtils.RAW_DATA_CONTAINER;
            var r2 = m2.rawData;
            m1.copyRawDataTo(r1);
            for (var i = 0; i < 16; ++i) {
                if (r1[i] != r2[i])
                    return false;
            }
            return true;
        };
        Matrix3DUtils.lookAt = function (matrix, pos, dir, up) {
            var dirN;
            var upN;
            var lftN;
            var raw = Matrix3DUtils.RAW_DATA_CONTAINER;
            lftN = dir.crossProduct(up);
            lftN.normalize();
            upN = lftN.crossProduct(dir);
            upN.normalize();
            dirN = dir.clone();
            dirN.normalize();
            raw[0] = lftN.x;
            raw[1] = upN.x;
            raw[2] = -dirN.x;
            raw[3] = 0.0;
            raw[4] = lftN.y;
            raw[5] = upN.y;
            raw[6] = -dirN.y;
            raw[7] = 0.0;
            raw[8] = lftN.z;
            raw[9] = upN.z;
            raw[10] = -dirN.z;
            raw[11] = 0.0;
            raw[12] = -lftN.dotProduct(pos);
            raw[13] = -upN.dotProduct(pos);
            raw[14] = dirN.dotProduct(pos);
            raw[15] = 1.0;
            matrix.copyRawDataFrom(raw);
        };
        Matrix3DUtils.reflection = function (plane, target) {
            if (target === void 0) { target = null; }
            target = target || new feng3d.Matrix3D();
            var a = plane.a, b = plane.b, c = plane.c, d = plane.d;
            var rawData = Matrix3DUtils.RAW_DATA_CONTAINER;
            var ab2 = -2 * a * b;
            var ac2 = -2 * a * c;
            var bc2 = -2 * b * c;
            // Matrix3DUtils.reflection matrix
            rawData[0] = 1 - 2 * a * a;
            rawData[4] = ab2;
            rawData[8] = ac2;
            rawData[12] = -2 * a * d;
            rawData[1] = ab2;
            rawData[5] = 1 - 2 * b * b;
            rawData[9] = bc2;
            rawData[13] = -2 * b * d;
            rawData[2] = ac2;
            rawData[6] = bc2;
            rawData[10] = 1 - 2 * c * c;
            rawData[14] = -2 * c * d;
            rawData[3] = 0;
            rawData[7] = 0;
            rawData[11] = 0;
            rawData[15] = 1;
            target.copyRawDataFrom(rawData);
            return target;
        };
        Matrix3DUtils.decompose = function (sourceMatrix, orientationStyle) {
            if (orientationStyle === void 0) { orientationStyle = "eulerAngles"; }
            var raw = Matrix3DUtils.RAW_DATA_CONTAINER;
            sourceMatrix.copyRawDataTo(raw);
            var a = raw[0];
            var e = raw[1];
            var i = raw[2];
            var b = raw[4];
            var f = raw[5];
            var j = raw[6];
            var c = raw[8];
            var g = raw[9];
            var k = raw[10];
            var x = raw[12];
            var y = raw[13];
            var z = raw[14];
            var tx = Math.sqrt(a * a + e * e + i * i);
            var ty = Math.sqrt(b * b + f * f + j * j);
            var tz = Math.sqrt(c * c + g * g + k * k);
            var tw = 0;
            var scaleX = tx;
            var scaleY = ty;
            var scaleZ = tz;
            if (a * (f * k - j * g) - e * (b * k - j * c) + i * (b * g - f * c) < 0) {
                scaleZ = -scaleZ;
            }
            a = a / scaleX;
            e = e / scaleX;
            i = i / scaleX;
            b = b / scaleY;
            f = f / scaleY;
            j = j / scaleY;
            c = c / scaleZ;
            g = g / scaleZ;
            k = k / scaleZ;
            //from away3d-ts
            if (orientationStyle == feng3d.Orientation3D.EULER_ANGLES) {
                tx = Math.atan2(j, k);
                ty = Math.atan2(-i, Math.sqrt(a * a + e * e));
                var s1 = Math.sin(tx);
                var c1 = Math.cos(tx);
                tz = Math.atan2(s1 * c - c1 * b, c1 * f - s1 * g);
            }
            else if (orientationStyle == feng3d.Orientation3D.AXIS_ANGLE) {
                tw = Math.acos((a + f + k - 1) / 2);
                var len = Math.sqrt((j - g) * (j - g) + (c - i) * (c - i) + (e - b) * (e - b));
                tx = (j - g) / len;
                ty = (c - i) / len;
                tz = (e - b) / len;
            }
            else {
                var tr = a + f + k;
                if (tr > 0) {
                    tw = Math.sqrt(1 + tr) / 2;
                    tx = (j - g) / (4 * tw);
                    ty = (c - i) / (4 * tw);
                    tz = (e - b) / (4 * tw);
                }
                else if ((a > f) && (a > k)) {
                    tx = Math.sqrt(1 + a - f - k) / 2;
                    tw = (j - g) / (4 * tx);
                    ty = (e + b) / (4 * tx);
                    tz = (c + i) / (4 * tx);
                }
                else if (f > k) {
                    ty = Math.sqrt(1 + f - a - k) / 2;
                    tx = (e + b) / (4 * ty);
                    tw = (c - i) / (4 * ty);
                    tz = (j + g) / (4 * ty);
                }
                else {
                    tz = Math.sqrt(1 + k - a - f) / 2;
                    tx = (c + i) / (4 * tz);
                    ty = (j + g) / (4 * tz);
                    tw = (e - b) / (4 * tz);
                }
            }
            var v = Matrix3DUtils.CALCULATION_DECOMPOSE;
            v[0].x = x;
            v[0].y = y;
            v[0].z = z;
            v[1].x = tx;
            v[1].y = ty;
            v[1].z = tz;
            v[1].w = tw;
            v[2].x = scaleX;
            v[2].y = scaleY;
            v[2].z = scaleZ;
            return v;
        };
        Matrix3DUtils.transformVector = function (matrix, vector, result) {
            if (result === void 0) { result = null; }
            if (!result)
                result = new feng3d.Vector3D();
            var raw = Matrix3DUtils.RAW_DATA_CONTAINER;
            matrix.copyRawDataTo(raw);
            var a = raw[0];
            var e = raw[1];
            var i = raw[2];
            var m = raw[3];
            var b = raw[4];
            var f = raw[5];
            var j = raw[6];
            var n = raw[7];
            var c = raw[8];
            var g = raw[9];
            var k = raw[10];
            var o = raw[11];
            var d = raw[12];
            var h = raw[13];
            var l = raw[14];
            var p = raw[15];
            var x = vector.x;
            var y = vector.y;
            var z = vector.z;
            result.x = a * x + b * y + c * z + d;
            result.y = e * x + f * y + g * z + h;
            result.z = i * x + j * y + k * z + l;
            result.w = m * x + n * y + o * z + p;
            return result;
        };
        Matrix3DUtils.deltaTransformVector = function (matrix, vector, result) {
            if (result === void 0) { result = null; }
            if (!result)
                result = new feng3d.Vector3D();
            var raw = Matrix3DUtils.RAW_DATA_CONTAINER;
            matrix.copyRawDataTo(raw);
            var a = raw[0];
            var e = raw[1];
            var i = raw[2];
            var m = raw[3];
            var b = raw[4];
            var f = raw[5];
            var j = raw[6];
            var n = raw[7];
            var c = raw[8];
            var g = raw[9];
            var k = raw[10];
            var o = raw[11];
            var x = vector.x;
            var y = vector.y;
            var z = vector.z;
            result.x = a * x + b * y + c * z;
            result.y = e * x + f * y + g * z;
            result.z = i * x + j * y + k * z;
            result.w = m * x + n * y + o * z;
            return result;
        };
        Matrix3DUtils.getTranslation = function (transform, result) {
            if (result === void 0) { result = null; }
            if (!result)
                result = new feng3d.Vector3D();
            transform.copyColumnTo(3, result);
            return result;
        };
        Matrix3DUtils.deltaTransformVectors = function (matrix, vin, vout) {
            var raw = Matrix3DUtils.RAW_DATA_CONTAINER;
            matrix.copyRawDataTo(raw);
            var a = raw[0];
            var e = raw[1];
            var i = raw[2];
            var m = raw[3];
            var b = raw[4];
            var f = raw[5];
            var j = raw[6];
            var n = raw[7];
            var c = raw[8];
            var g = raw[9];
            var k = raw[10];
            var o = raw[11];
            var outIndex = 0;
            var length = vin.length;
            for (var index = 0; index < length; index += 3) {
                var x = vin[index];
                var y = vin[index + 1];
                var z = vin[index + 2];
                vout[outIndex++] = a * x + b * y + c * z;
                vout[outIndex++] = e * x + f * y + g * z;
                vout[outIndex++] = i * x + j * y + k * z;
            }
        };
        /**
         * 更新本地射线
         * @param inverseSceneTransform 逆场景变换矩阵
         * @param ray3D 场景射线
         * @param localRay 本地射线
         */
        Matrix3DUtils.updateLocalRay = function (inverseSceneTransform, ray3D, localRay) {
            Matrix3DUtils.transformVector(inverseSceneTransform, ray3D.position, localRay.position);
            Matrix3DUtils.deltaTransformVector(inverseSceneTransform, ray3D.direction, localRay.direction);
        };
        /**
         * A reference to a Vector to be used as a temporary raw data container, to prevent object creation.
         */
        Matrix3DUtils.RAW_DATA_CONTAINER = [];
        Matrix3DUtils.CALCULATION_MATRIX = new feng3d.Matrix3D();
        Matrix3DUtils.CALCULATION_VECTOR3D = new feng3d.Vector3D();
        Matrix3DUtils.CALCULATION_DECOMPOSE = [new feng3d.Vector3D(), new feng3d.Vector3D(), new feng3d.Vector3D()];
        return Matrix3DUtils;
    }());
    feng3d.Matrix3DUtils = Matrix3DUtils;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 3d面
     */
    var Plane3D = (function () {
        /**
         * 创建一个平面
         * @param a		A系数
         * @param b		B系数
         * @param c		C系数
         * @param d		D系数
         */
        function Plane3D(a, b, c, d) {
            if (a === void 0) { a = 0; }
            if (b === void 0) { b = 0; }
            if (c === void 0) { c = 0; }
            if (d === void 0) { d = 0; }
            this.a = a;
            this.b = b;
            this.c = c;
            this.d = d;
            if (a == 0 && b == 0)
                this._alignment = Plane3D.ALIGN_XY_AXIS;
            else if (b == 0 && c == 0)
                this._alignment = Plane3D.ALIGN_YZ_AXIS;
            else if (a == 0 && c == 0)
                this._alignment = Plane3D.ALIGN_XZ_AXIS;
            else
                this._alignment = Plane3D.ALIGN_ANY;
        }
        /**
         * 通过3顶点定义一个平面
         * @param p0		点0
         * @param p1		点1
         * @param p2		点2
         */
        Plane3D.prototype.fromPoints = function (p0, p1, p2) {
            //计算向量1
            var d1x = p1.x - p0.x;
            var d1y = p1.y - p0.y;
            var d1z = p1.z - p0.z;
            //计算向量2
            var d2x = p2.x - p0.x;
            var d2y = p2.y - p0.y;
            var d2z = p2.z - p0.z;
            //叉乘计算法线
            this.a = d1y * d2z - d1z * d2y;
            this.b = d1z * d2x - d1x * d2z;
            this.c = d1x * d2y - d1y * d2x;
            //平面上点与法线点乘计算D值
            this.d = this.a * p0.x + this.b * p0.y + this.c * p0.z;
            //法线平行z轴
            if (this.a == 0 && this.b == 0)
                this._alignment = Plane3D.ALIGN_XY_AXIS;
            else if (this.b == 0 && this.c == 0)
                this._alignment = Plane3D.ALIGN_YZ_AXIS;
            else if (this.a == 0 && this.c == 0)
                this._alignment = Plane3D.ALIGN_XZ_AXIS;
            else
                this._alignment = Plane3D.ALIGN_ANY;
        };
        /**
         * 根据法线与点定义平面
         * @param normal		平面法线
         * @param point			平面上任意一点
         */
        Plane3D.prototype.fromNormalAndPoint = function (normal, point) {
            this.a = normal.x;
            this.b = normal.y;
            this.c = normal.z;
            this.d = this.a * point.x + this.b * point.y + this.c * point.z;
            if (this.a == 0 && this.b == 0)
                this._alignment = Plane3D.ALIGN_XY_AXIS;
            else if (this.b == 0 && this.c == 0)
                this._alignment = Plane3D.ALIGN_YZ_AXIS;
            else if (this.a == 0 && this.c == 0)
                this._alignment = Plane3D.ALIGN_XZ_AXIS;
            else
                this._alignment = Plane3D.ALIGN_ANY;
        };
        /**
         * 标准化平面
         * @return		标准化后的平面
         */
        Plane3D.prototype.normalize = function () {
            var len = 1 / Math.sqrt(this.a * this.a + this.b * this.b + this.c * this.c);
            this.a *= len;
            this.b *= len;
            this.c *= len;
            this.d *= len;
            return this;
        };
        /**
         * 计算点与平面的距离
         * @param p		点
         * @returns		距离
         */
        Plane3D.prototype.distance = function (p) {
            if (this._alignment == Plane3D.ALIGN_YZ_AXIS)
                return this.a * p.x - this.d;
            else if (this._alignment == Plane3D.ALIGN_XZ_AXIS)
                return this.b * p.y - this.d;
            else if (this._alignment == Plane3D.ALIGN_XY_AXIS)
                return this.c * p.z - this.d;
            else
                return this.a * p.x + this.b * p.y + this.c * p.z - this.d;
        };
        /**
         * 顶点分类
         * <p>把顶点分为后面、前面、相交三类</p>
         * @param p			顶点
         * @return			顶点类型 PlaneClassification.BACK,PlaneClassification.FRONT,PlaneClassification.INTERSECT
         * @see				me.feng3d.core.math.PlaneClassification
         */
        Plane3D.prototype.classifyPoint = function (p, epsilon) {
            if (epsilon === void 0) { epsilon = 0.01; }
            // check NaN
            if (this.d != this.d)
                return feng3d.PlaneClassification.FRONT;
            var len;
            if (this._alignment == Plane3D.ALIGN_YZ_AXIS)
                len = this.a * p.x - this.d;
            else if (this._alignment == Plane3D.ALIGN_XZ_AXIS)
                len = this.b * p.y - this.d;
            else if (this._alignment == Plane3D.ALIGN_XY_AXIS)
                len = this.c * p.z - this.d;
            else
                len = this.a * p.x + this.b * p.y + this.c * p.z - this.d;
            if (len < -epsilon)
                return feng3d.PlaneClassification.BACK;
            else if (len > epsilon)
                return feng3d.PlaneClassification.FRONT;
            else
                return feng3d.PlaneClassification.INTERSECT;
        };
        /**
         * 输出字符串
         */
        Plane3D.prototype.toString = function () {
            return "Plane3D [this.a:" + this.a + ", this.b:" + this.b + ", this.c:" + this.c + ", this.d:" + this.d + "]";
        };
        /**
         * 普通平面
         * <p>不与对称轴平行或垂直</p>
         */
        Plane3D.ALIGN_ANY = 0;
        /**
         * XY方向平面
         * <p>法线与Z轴平行</p>
         */
        Plane3D.ALIGN_XY_AXIS = 1;
        /**
         * YZ方向平面
         * <p>法线与X轴平行</p>
         */
        Plane3D.ALIGN_YZ_AXIS = 2;
        /**
         * XZ方向平面
         * <p>法线与Y轴平行</p>
         */
        Plane3D.ALIGN_XZ_AXIS = 3;
        return Plane3D;
    }());
    feng3d.Plane3D = Plane3D;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 点与面的相对位置
     * @author feng
     */
    var PlaneClassification = (function () {
        function PlaneClassification() {
        }
        /**
         * 在平面后面
         * <p>等价于平面内</p>
         * @see #IN
         */
        PlaneClassification.BACK = 0;
        /**
         * 在平面前面
         * <p>等价于平面外</p>
         * @see #OUT
         */
        PlaneClassification.FRONT = 1;
        /**
         * 在平面内
         * <p>等价于在平面后</p>
         * @see #BACK
         */
        PlaneClassification.IN = 0;
        /**
         * 在平面外
         * <p>等价于平面前面</p>
         * @see #FRONT
         */
        PlaneClassification.OUT = 1;
        /**
         * 与平面相交
         */
        PlaneClassification.INTERSECT = 2;
        return PlaneClassification;
    }());
    feng3d.PlaneClassification = PlaneClassification;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 三角形
     * @author feng 2014-5-4
     */
    var Triangle3D = (function () {
        function Triangle3D(p0, p1, p2) {
            this.p0 = p0;
            this.p1 = p1;
            this.p2 = p2;
        }
        /**
         * 测试是否与直线相交
         * @param line3D 直线
         * @return 是否相交
         */
        Triangle3D.prototype.testLineCollision = function (line3D) {
            return false;
        };
        Object.defineProperty(Triangle3D.prototype, "p0", {
            /**
             * 第1个点
             */
            get: function () {
                return this._p0;
            },
            set: function (value) {
                this._p0 = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Triangle3D.prototype, "p1", {
            /**
             * 第2个点
             */
            get: function () {
                return this._p1;
            },
            set: function (value) {
                this._p1 = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Triangle3D.prototype, "p2", {
            /**
             * 第3个点
             */
            get: function () {
                return this._p2;
            },
            set: function (value) {
                this._p2 = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Triangle3D.prototype, "normal", {
            /**
             * 法线
             */
            get: function () {
                if (this._normal == null)
                    this.updateNomal();
                return this._normal;
            },
            enumerable: true,
            configurable: true
        });
        Triangle3D.prototype.updateNomal = function () {
            this._normal = this.p1.subtract(this.p0).crossProduct(this.p2.subtract(this.p0));
        };
        return Triangle3D;
    }());
    feng3d.Triangle3D = Triangle3D;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 解析工具类
     */
    var ParserUtil = (function () {
        function ParserUtil() {
        }
        /**
         * 把数据转换为字符串
         * @param data 数据
         * @param length 需要转换的长度
         * @return
         */
        ParserUtil.toString = function (data, length) {
            if (length === void 0) { length = 0; }
            var ba;
            length = length || Number.MAX_VALUE;
            if (feng3d.is(data, String))
                return feng3d.as(data, String).substr(0, length);
            ba = feng3d.as(data, feng3d.ByteArray);
            if (ba) {
                ba.position = 0;
                return ba.readUTFBytes(Math.min(ba.bytesAvailable, length));
            }
            return null;
        };
        return ParserUtil;
    }());
    feng3d.ParserUtil = ParserUtil;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 解析数据的格式
     */
    var ParserDataFormat = (function () {
        function ParserDataFormat() {
        }
        /**
         * 二进制文件
         */
        ParserDataFormat.BINARY = "binary";
        /**
         * 明文
         */
        ParserDataFormat.PLAIN_TEXT = "plainText";
        return ParserDataFormat;
    }());
    feng3d.ParserDataFormat = ParserDataFormat;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 资源依赖(包含需要加载与处理的资源)
     * @author feng 2014-5-19
     */
    var ResourceDependency = (function () {
        /**
         * 创建资源依赖
         * @param id 编号
         * @param req url请求
         * @param data 数据
         * @param parentParser 被依赖的解析者
         * @param retrieveAsRawData
         * @param suppressAssetEvents
         */
        function ResourceDependency(id, req, data, parentParser, retrieveAsRawData, suppressAssetEvents) {
            if (retrieveAsRawData === void 0) { retrieveAsRawData = false; }
            if (suppressAssetEvents === void 0) { suppressAssetEvents = false; }
            this._id = id;
            this._req = req;
            this._parentParser = parentParser;
            this._data = data;
            this._retrieveAsRawData = retrieveAsRawData;
            this._suppressAssetEvents = suppressAssetEvents;
            this._assets = [];
            this._dependencies = [];
        }
        Object.defineProperty(ResourceDependency.prototype, "id", {
            get: function () {
                return this._id;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ResourceDependency.prototype, "assets", {
            get: function () {
                return this._assets;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ResourceDependency.prototype, "dependencies", {
            get: function () {
                return this._dependencies;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ResourceDependency.prototype, "request", {
            get: function () {
                return this._req;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ResourceDependency.prototype, "retrieveAsRawData", {
            get: function () {
                return this._retrieveAsRawData;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ResourceDependency.prototype, "suppresAssetEvents", {
            get: function () {
                return this._suppressAssetEvents;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ResourceDependency.prototype, "data", {
            get: function () {
                return this._data;
            },
            enumerable: true,
            configurable: true
        });
        ResourceDependency.prototype.setData = function (data) {
            this._data = data;
        };
        Object.defineProperty(ResourceDependency.prototype, "parentParser", {
            /**
             * 被依赖的解析者
             */
            get: function () {
                return this._parentParser;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 解决依赖
         */
        ResourceDependency.prototype.resolve = function () {
            if (this._parentParser)
                this._parentParser.resolveDependency(this);
        };
        /**
         * 解决失败
         */
        ResourceDependency.prototype.resolveFailure = function () {
            if (this._parentParser)
                this._parentParser.resolveDependencyFailure(this);
        };
        /**
         * 解决资源的名称
         */
        ResourceDependency.prototype.resolveName = function (asset) {
            if (this._parentParser)
                return this._parentParser.resolveDependencyName(this, asset);
            return asset.namedAsset.name;
        };
        return ResourceDependency;
    }());
    feng3d.ResourceDependency = ResourceDependency;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 单条线段数据
     * @author feng 2014-4-9
     */
    var Segment = (function () {
        /**
         * 创建一条线段数据
         * @param start 起点坐标
         * @param end 终点坐标
         * @param colorStart 起点颜色
         * @param colorEnd 终点颜色
         * @param thickness 线段厚度
         */
        function Segment(start, end, colorStart, colorEnd, thickness) {
            if (colorStart === void 0) { colorStart = 0x333333; }
            if (colorEnd === void 0) { colorEnd = 0x333333; }
            if (thickness === void 0) { thickness = 1; }
            this._thickness = thickness * .5;
            this._start = start;
            this._end = end;
            this.startColor = colorStart;
            this.endColor = colorEnd;
        }
        /**
         * 更新线段信息
         * @param start 起点坐标
         * @param end 终点坐标
         * @param colorStart 起点颜色
         * @param colorEnd 终点颜色
         * @param thickness 线段厚度
         */
        Segment.prototype.updateSegment = function (start, end, colorStart, colorEnd, thickness) {
            if (colorStart === void 0) { colorStart = 0x333333; }
            if (colorEnd === void 0) { colorEnd = 0x333333; }
            if (thickness === void 0) { thickness = 1; }
            this._start = start;
            this._end = end;
            if (this._startColor != colorStart)
                this.startColor = colorStart;
            if (this._endColor != colorEnd)
                this.endColor = colorEnd;
            this._thickness = thickness * .5;
        };
        Object.defineProperty(Segment.prototype, "start", {
            /**
             * 起点坐标
             */
            get: function () {
                return this._start;
            },
            set: function (value) {
                this._start = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Segment.prototype, "end", {
            /**
             * 终点坐标
             */
            get: function () {
                return this._end;
            },
            set: function (value) {
                this._end = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Segment.prototype, "thickness", {
            /**
             * 线段厚度
             */
            get: function () {
                return this._thickness * 2;
            },
            set: function (value) {
                this._thickness = value * .5;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Segment.prototype, "startColor", {
            /**
             * 起点颜色
             */
            get: function () {
                return this._startColor;
            },
            set: function (color) {
                this._startR = ((color >> 16) & 0xff) / 255;
                this._startG = ((color >> 8) & 0xff) / 255;
                this._startB = (color & 0xff) / 255;
                this._startColor = color;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Segment.prototype, "endColor", {
            /**
             * 终点颜色
             */
            get: function () {
                return this._endColor;
            },
            set: function (color) {
                this._endR = ((color >> 16) & 0xff) / 255;
                this._endG = ((color >> 8) & 0xff) / 255;
                this._endB = (color & 0xff) / 255;
                this._endColor = color;
            },
            enumerable: true,
            configurable: true
        });
        Segment.prototype.dispose = function () {
            this._start = null;
            this._end = null;
        };
        Object.defineProperty(Segment.prototype, "startR", {
            get: function () {
                return this._startR;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Segment.prototype, "startG", {
            get: function () {
                return this._startG;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Segment.prototype, "startB", {
            get: function () {
                return this._startB;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Segment.prototype, "endR", {
            get: function () {
                return this._endR;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Segment.prototype, "endG", {
            get: function () {
                return this._endG;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Segment.prototype, "endB", {
            get: function () {
                return this._endB;
            },
            enumerable: true,
            configurable: true
        });
        return Segment;
    }());
    feng3d.Segment = Segment;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * A Line Segment primitive.
     */
    var LineSegment = (function (_super) {
        __extends(LineSegment, _super);
        /**
         * Create a line segment
         * @param v0 Start position of the line segment
         * @param v1 Ending position of the line segment
         * @param color0 Starting color of the line segment
         * @param color1 Ending colour of the line segment
         * @param thickness Thickness of the line
         */
        function LineSegment(v0, v1, color0, color1, thickness) {
            if (color0 === void 0) { color0 = 0x333333; }
            if (color1 === void 0) { color1 = 0x333333; }
            if (thickness === void 0) { thickness = 1; }
            _super.call(this, v0, v1, color0, color1, thickness);
            this.TYPE = "line";
        }
        return LineSegment;
    }(feng3d.Segment));
    feng3d.LineSegment = LineSegment;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 测试基类
     * @author feng 2014-4-9
     */
    var TestBase = (function (_super) {
        __extends(TestBase, _super);
        function TestBase() {
            _super.call(this);
            this.rootPaths = [
                "http://127.0.0.1:9080/",
                "http://images.feng3d.me/feng3dDemo/assets/",
            ];
            //资源根路径
            this.rootPath = "http://127.0.0.1:9080/";
            this.initModules();
            this.tryConnect();
        }
        TestBase.prototype.initModules = function () {
            feng3d.Task.init();
            feng3d.Load.init();
        };
        TestBase.prototype.tryConnect = function () {
            var tryRootPath = new feng3d.TryConnectURL();
            tryRootPath.addEventListener(feng3d.TaskEvent.COMPLETED, this.tryRootPathComplete);
            tryRootPath.tryConnect(this.rootPaths);
        };
        TestBase.prototype.tryRootPathComplete = function (event) {
            var tryConnectURL = event.currentTarget;
            if (tryConnectURL.connectedUrls.length == 0) {
                console.log("没有可连接的资源路径！");
            }
            else {
                console.log("以下为可连接的资源路径：");
                console.log(tryConnectURL.connectedUrls);
                this.rootPath = tryConnectURL.connectedUrls[0];
                this.loadTextures();
            }
        };
        /**
         * 加载纹理资源
         */
        TestBase.prototype.loadTextures = function () {
            this.resourceDic = {};
            //加载资源
            var loadObj = new feng3d.LoadModuleEventData();
            loadObj.urls = [];
            for (var i = 0; this.resourceList != null && i < this.resourceList.length; i++) {
                if (feng3d.is(this.resourceList[i], String)) {
                    loadObj.urls.push(this.rootPath + this.resourceList[i]);
                }
                else {
                    this.resourceList[i].url = this.rootPath + this.resourceList[i].url;
                    loadObj.urls.push(this.resourceList[i]);
                }
            }
            loadObj.addEventListener(feng3d.LoadUrlEvent.LOAD_SINGLE_COMPLETE, this.singleGeometryComplete);
            loadObj.addEventListener(feng3d.LoadUrlEvent.LOAD_COMPLETE, this.allItemsLoaded);
            feng3d.GlobalDispatcher.instance.dispatchEvent(new feng3d.LoadModuleEvent(feng3d.LoadModuleEvent.LOAD_RESOURCE, loadObj));
        };
        /** 单个资源加载完毕 */
        TestBase.prototype.singleGeometryComplete = function (evnet) {
            var path = evnet.loadTaskItem.url;
            path = path.substr(this.rootPath.length);
            this.resourceDic[path] = evnet.loadTaskItem.loadingItem.content;
        };
        /**
         * 处理全部加载完成事件
         */
        TestBase.prototype.allItemsLoaded = function (event) {
            //配置3d缓存编号
            feng3d.FagalRE.addBufferID(feng3d.Context3DBufferIDConfig.bufferIdConfigs);
            this["init"]();
        };
        return TestBase;
    }(feng3d.Sprite));
    feng3d.TestBase = TestBase;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 粒子几何体帮助类
     */
    var ParticleGeometryHelper = (function () {
        function ParticleGeometryHelper() {
        }
        /**
         * 创建一个粒子几何体
         * @param geometries 单个粒子几何体列表
         * @param transforms
         * @return 粒子几何体
         */
        ParticleGeometryHelper.generateGeometry = function (geometries) {
            var particleGeometry = new feng3d.ParticleGeometry();
            /** 粒子数量 */
            var numParticles = particleGeometry.numParticles = geometries.length;
            /** 粒子数据 */
            var particles = particleGeometry.particles = [];
            particles.length = numParticles;
            /** 当前粒子子几何体 */
            var particleSubGeometry = ParticleGeometryHelper.createParticleSubGeometry();
            particleGeometry.addSubGeometry(particleSubGeometry);
            //单个粒子几何体
            var sourceGeometry;
            /** 单个粒子子几何体列表 */
            var sourceSubGeometries;
            /** 单个粒子的子几何体 */
            var sourceSubGeometry;
            /** 单个粒子子几何体数 */
            var numSubGeometries;
            /** 单个粒子子几何体索引 */
            var srcIndex = 0;
            /** 粒子索引 */
            var i;
            //遍历粒子
            for (i = 0; i < numParticles; i++) {
                sourceGeometry = geometries[i];
                if (sourceGeometry.numVertices > ParticleGeometryHelper.MAX_VERTEX)
                    throw new Error("不支持顶点数大于" + ParticleGeometryHelper.MAX_VERTEX + "的粒子");
                sourceSubGeometries = geometries[i].subGeometries;
                numSubGeometries = sourceSubGeometries.length;
                //判断 当前单个粒子子网格 是否会使当前粒子子几何体顶点数量超出最大值 ,如果超出就创建一个新的粒子子几何体
                if (sourceGeometry.numVertices + particleSubGeometry.numVertices > ParticleGeometryHelper.MAX_VERTEX) {
                    particleSubGeometry = ParticleGeometryHelper.createParticleSubGeometry();
                    particleGeometry.addSubGeometry(particleSubGeometry);
                }
                //收集粒子数据
                var particleData = new feng3d.ParticleData();
                particleData.numVertices = sourceGeometry.numVertices;
                particleData.startVertexIndex = particleSubGeometry.numVertices;
                particleData.subGeometry = particleSubGeometry;
                particles[i] = particleData;
                //遍历单个粒子的子几何体
                for (srcIndex = 0; srcIndex < numSubGeometries; srcIndex++) {
                    //设置当前单个粒子子网格
                    sourceSubGeometry = sourceSubGeometries[srcIndex];
                    //添加 单个粒子的子几何体 到  当前粒子子几何体
                    feng3d.GeomUtil.addSubGeometry(sourceSubGeometry, particleSubGeometry);
                }
            }
            return particleGeometry;
        };
        ParticleGeometryHelper.createParticleSubGeometry = function () {
            /** 当前粒子子几何体 */
            var particleSubGeometry = new feng3d.SubGeometry();
            particleSubGeometry.updateIndexData([]);
            return particleSubGeometry;
        };
        /** stage3d单次渲染支持的最大顶点数 */
        ParticleGeometryHelper.MAX_VERTEX = 65535;
        return ParticleGeometryHelper;
    }());
    feng3d.ParticleGeometryHelper = ParticleGeometryHelper;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * sprite动画剪辑节帮助程序
     * @author feng 2015-9-18
     */
    var SpriteSheetHelper = (function () {
        /**
         * 创建sprite动画剪辑节帮助程序实例
         */
        function SpriteSheetHelper() {
        }
        /**
         * 根据影片剪辑生成纹理列表
         * @param sourceMC					源影片剪辑
         * @param cols						U方向个数
         * @param rows						V方向个数
         * @param width						宽度
         * @param height					高度
         * @param transparent 				是否透明
         * @param backgroundColor			贝爷颜色
         */
        SpriteSheetHelper.prototype.generateFromMovieClip = function (sourceMC, cols, rows, width, height, transparent, backgroundColor) {
            if (transparent === void 0) { transparent = false; }
            if (backgroundColor === void 0) { backgroundColor = 0; }
            var spriteSheets = [];
            var framesCount = sourceMC.totalFrames;
            var i = framesCount;
            var w = width;
            var h = height;
            if (!feng3d.TextureUtils.isPowerOfTwo(w))
                w = feng3d.TextureUtils.getBestPowerOf2(w);
            if (!feng3d.TextureUtils.isPowerOfTwo(h))
                h = feng3d.TextureUtils.getBestPowerOf2(h);
            var spriteSheet;
            var destCellW = Math.round(h / cols);
            var destCellH = Math.round(w / rows);
            //var cellRect:Rectangle = new Rectangle(0, 0, destCellW, destCellH);
            var mcFrameW = sourceMC.width;
            var mcFrameH = sourceMC.height;
            var sclw = destCellW / mcFrameW;
            var sclh = destCellH / mcFrameH;
            var t = new feng3d.Matrix();
            t.scale(sclw, sclh);
            var tmpCache = new feng3d.BitmapData(mcFrameW * sclw, mcFrameH * sclh, transparent, transparent ? 0x00FFFFFF : backgroundColor);
            var u, v;
            var cellsPerMap = cols * rows;
            var maps = framesCount / cellsPerMap;
            if (maps < framesCount / cellsPerMap)
                maps++;
            var pastePoint = new feng3d.Point();
            var frameNum = 0;
            var bitmapTexture;
            while (maps--) {
                u = v = 0;
                spriteSheet = new feng3d.BitmapData(w, h, transparent, transparent ? 0x00FFFFFF : backgroundColor);
                for (i = 0; i < cellsPerMap; i++) {
                    frameNum++;
                    if (frameNum <= framesCount) {
                        pastePoint.x = Math.round(destCellW * u);
                        pastePoint.y = Math.round(destCellH * v);
                        sourceMC.gotoAndStop(frameNum);
                        tmpCache.draw(sourceMC, t, null, "normal", tmpCache.rect, true);
                        spriteSheet.copyPixels(tmpCache, tmpCache.rect, pastePoint);
                        if (transparent)
                            tmpCache.fillRect(tmpCache.rect, 0x00FFFFFF);
                        u++;
                        if (u == cols) {
                            u = 0;
                            v++;
                        }
                    }
                    else
                        break;
                }
                bitmapTexture = new feng3d.BitmapTexture(spriteSheet);
                spriteSheets.push(bitmapTexture);
            }
            tmpCache.dispose();
            return spriteSheets;
        };
        /**
         * 生成一个SpriteSheetClipNode
         * @param animID					动画编号
         * @param cols						U方向个数
         * @param rows						V方向个数
         * @param mapCount					映射数量
         * @param from						起始索引
         * @param to						终止索引
         */
        SpriteSheetHelper.prototype.generateSpriteSheetClipNode = function (animID, cols, rows, mapCount, from, to) {
            if (mapCount === void 0) { mapCount = 1; }
            if (from === void 0) { from = 0; }
            if (to === void 0) { to = 0; }
            var spriteSheetClipNode = new feng3d.SpriteSheetClipNode();
            spriteSheetClipNode.name = animID;
            var u, v;
            var framesCount = cols * rows;
            if (mapCount < 1)
                mapCount = 1;
            if (to == 0 || to < from || to > framesCount * mapCount)
                to = cols * rows * mapCount;
            if (from > to)
                throw new Error("Param 'from' must be lower than the 'to' param.");
            var scaleV = 1 / rows;
            var scaleU = 1 / cols;
            var frame;
            var i, j;
            var animFrames = 0;
            for (i = 0; i < mapCount; ++i) {
                u = v = 0;
                for (j = 0; j < framesCount; ++j) {
                    if (animFrames >= from && animFrames < to) {
                        frame = new feng3d.SpriteSheetAnimationFrame();
                        frame.offsetU = scaleU * u;
                        frame.offsetV = scaleV * v;
                        frame.scaleU = scaleU;
                        frame.scaleV = scaleV;
                        frame.mapID = i;
                        spriteSheetClipNode.addFrame(frame, 16);
                    }
                    if (animFrames == to)
                        return spriteSheetClipNode;
                    animFrames++;
                    u++;
                    if (u == cols) {
                        u = 0;
                        v++;
                    }
                }
            }
            return spriteSheetClipNode;
        };
        return SpriteSheetHelper;
    }());
    feng3d.SpriteSheetHelper = SpriteSheetHelper;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * Helper Class to retrieve objects bounds <code>Bounds</code>
     */
    var Bounds = (function () {
        function Bounds() {
        }
        /**
         * Calculate the bounds of a Mesh object
         * @param mesh        Mesh. The Mesh to get the bounds from.
         * Use the getters of this class to retrieve the results
         */
        Bounds.getMeshBounds = function (mesh) {
            Bounds.getObjectContainerBounds(mesh);
        };
        /**
         * Calculate the bounds of an ObjectContainer3D object
         * @param container        ObjectContainer3D. The ObjectContainer3D to get the bounds from.
         * Use the getters of this class to retrieve the results
         */
        Bounds.getObjectContainerBounds = function (container, worldBased) {
            if (worldBased === void 0) { worldBased = true; }
            Bounds.reset();
            Bounds.parseObjectContainerBounds(container);
            if (Bounds.isInfinite(Bounds._minX) || Bounds.isInfinite(Bounds._minY) || Bounds.isInfinite(Bounds._minZ) || Bounds.isInfinite(Bounds._maxX) || Bounds.isInfinite(Bounds._maxY) || Bounds.isInfinite(Bounds._maxZ)) {
                return;
            }
            // Transform min/max values to the scene if required
            if (worldBased) {
                var b = [Infinity, Infinity, Infinity, -Infinity, -Infinity, -Infinity];
                var c = Bounds.getBoundsCorners(Bounds._minX, Bounds._minY, Bounds._minZ, Bounds._maxX, Bounds._maxY, Bounds._maxZ);
                Bounds.transformContainer(b, c, container.sceneTransform);
                Bounds._minX = b[0];
                Bounds._minY = b[1];
                Bounds._minZ = b[2];
                Bounds._maxX = b[3];
                Bounds._maxY = b[4];
                Bounds._maxZ = b[5];
            }
        };
        /**
         * Calculate the bounds from a vector of number representing the vertices. &lt;x,y,z,x,y,z.....&gt;
         * @param vertices        Vector.&lt;number&gt;. The vertices to get the bounds from.
         * Use the getters of this class to retrieve the results
         */
        Bounds.getVerticesVectorBounds = function (vertices) {
            Bounds.reset();
            var l = vertices.length;
            if (l % 3 != 0)
                return;
            var x;
            var y;
            var z;
            for (var i = 0; i < l; i += 3) {
                x = vertices[i];
                y = vertices[i + 1];
                z = vertices[i + 2];
                if (x < Bounds._minX)
                    Bounds._minX = x;
                if (x > Bounds._maxX)
                    Bounds._maxX = x;
                if (y < Bounds._minY)
                    Bounds._minY = y;
                if (y > Bounds._maxY)
                    Bounds._maxY = y;
                if (z < Bounds._minZ)
                    Bounds._minZ = z;
                if (z > Bounds._maxZ)
                    Bounds._maxZ = z;
            }
        };
        /**
         * @param outCenter        Vector3D. Optional Vector3D, if provided the same Vector3D is returned with the bounds center.
         * @return the center of the bound
         */
        Bounds.getCenter = function (outCenter) {
            if (outCenter === void 0) { outCenter = null; }
            var center = outCenter || new feng3d.Vector3D();
            center.x = Bounds._minX + (Bounds._maxX - Bounds._minX) * .5;
            center.y = Bounds._minY + (Bounds._maxY - Bounds._minY) * .5;
            center.z = Bounds._minZ + (Bounds._maxZ - Bounds._minZ) * .5;
            return center;
        };
        Object.defineProperty(Bounds, "minX", {
            /**
             * @return the smalest x value
             */
            get: function () {
                return Bounds._minX;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Bounds, "minY", {
            /**
             * @return the smalest y value
             */
            get: function () {
                return Bounds._minY;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Bounds, "minZ", {
            /**
             * @return the smalest z value
             */
            get: function () {
                return Bounds._minZ;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Bounds, "maxX", {
            /**
             * @return the biggest x value
             */
            get: function () {
                return Bounds._maxX;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Bounds, "maxY", {
            /**
             * @return the biggest y value
             */
            get: function () {
                return Bounds._maxY;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Bounds, "maxZ", {
            /**
             * @return the biggest z value
             */
            get: function () {
                return Bounds._maxZ;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Bounds, "width", {
            /**
             * @return the width value from the bounds
             */
            get: function () {
                return Bounds._maxX - Bounds._minX;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Bounds, "height", {
            /**
             * @return the height value from the bounds
             */
            get: function () {
                return Bounds._maxY - Bounds._minY;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Bounds, "depth", {
            /**
             * @return the depth value from the bounds
             */
            get: function () {
                return Bounds._maxZ - Bounds._minZ;
            },
            enumerable: true,
            configurable: true
        });
        Bounds.reset = function () {
            Bounds._containers.clear();
            Bounds._minX = Bounds._minY = Bounds._minZ = Infinity;
            Bounds._maxX = Bounds._maxY = Bounds._maxZ = -Infinity;
            Bounds._defaultPosition.x = 0.0;
            Bounds._defaultPosition.y = 0.0;
            Bounds._defaultPosition.z = 0.0;
        };
        Bounds.parseObjectContainerBounds = function (obj, parentTransform) {
            if (parentTransform === void 0) { parentTransform = null; }
            if (!obj.visible)
                return;
            var containerBounds = Bounds._containers.get(obj) || [Infinity, Infinity, Infinity, -Infinity, -Infinity, -Infinity];
            Bounds._containers.push(obj, containerBounds);
            var child;
            var isEntity = obj;
            var containerTransform = new feng3d.Matrix3D();
            if (isEntity && parentTransform) {
                Bounds.parseObjectBounds(obj, parentTransform);
                containerTransform = obj.transform3D.transform.clone();
                if (parentTransform)
                    containerTransform.append(parentTransform);
            }
            else if (isEntity && !parentTransform) {
                var mat = obj.transform3D.transform.clone();
                mat.invert();
                Bounds.parseObjectBounds(obj, mat);
            }
            for (var i = 0; i < obj.numChildren; ++i) {
                child = obj.getChildAt(i);
                Bounds.parseObjectContainerBounds(child, containerTransform);
            }
            var parentBounds = Bounds._containers.get(obj.parent);
            if (!isEntity && parentTransform)
                Bounds.parseObjectBounds(obj, parentTransform, true);
            if (parentBounds) {
                parentBounds[0] = Math.min(parentBounds[0], containerBounds[0]);
                parentBounds[1] = Math.min(parentBounds[1], containerBounds[1]);
                parentBounds[2] = Math.min(parentBounds[2], containerBounds[2]);
                parentBounds[3] = Math.max(parentBounds[3], containerBounds[3]);
                parentBounds[4] = Math.max(parentBounds[4], containerBounds[4]);
                parentBounds[5] = Math.max(parentBounds[5], containerBounds[5]);
            }
            else {
                Bounds._minX = containerBounds[0];
                Bounds._minY = containerBounds[1];
                Bounds._minZ = containerBounds[2];
                Bounds._maxX = containerBounds[3];
                Bounds._maxY = containerBounds[4];
                Bounds._maxZ = containerBounds[5];
            }
        };
        Bounds.isInfinite = function (value) {
            return value == Number.POSITIVE_INFINITY || value == Number.NEGATIVE_INFINITY;
        };
        Bounds.parseObjectBounds = function (oC, parentTransform, resetBounds) {
            if (parentTransform === void 0) { parentTransform = null; }
            if (resetBounds === void 0) { resetBounds = false; }
            if (feng3d.is(oC, feng3d.LightBase))
                return;
            var e = oC;
            var corners;
            var mat = oC.transform3D.transform.clone();
            var cB = Bounds._containers.get(oC);
            if (e) {
                if (Bounds.isInfinite(e.minX) || Bounds.isInfinite(e.minY) || Bounds.isInfinite(e.minZ) || Bounds.isInfinite(e.maxX) || Bounds.isInfinite(e.maxY) || Bounds.isInfinite(e.maxZ)) {
                    return;
                }
                corners = Bounds.getBoundsCorners(e.minX, e.minY, e.minZ, e.maxX, e.maxY, e.maxZ);
                if (parentTransform)
                    mat.append(parentTransform);
            }
            else {
                corners = Bounds.getBoundsCorners(cB[0], cB[1], cB[2], cB[3], cB[4], cB[5]);
                if (parentTransform)
                    mat.prepend(parentTransform);
            }
            if (resetBounds) {
                cB[0] = cB[1] = cB[2] = Infinity;
                cB[3] = cB[4] = cB[5] = -Infinity;
            }
            Bounds.transformContainer(cB, corners, mat);
        };
        Bounds.getBoundsCorners = function (minX, minY, minZ, maxX, maxY, maxZ) {
            return [minX, minY, minZ, minX, minY, maxZ, minX, maxY, minZ, minX, maxY, maxZ, maxX, minY, minZ, maxX, minY, maxZ, maxX, maxY, minZ, maxX, maxY, maxZ];
        };
        Bounds.transformContainer = function (bounds, corners, matrix) {
            matrix.transformVectors(corners, corners);
            var x;
            var y;
            var z;
            var pCtr = 0;
            while (pCtr < corners.length) {
                x = corners[pCtr++];
                y = corners[pCtr++];
                z = corners[pCtr++];
                if (x < bounds[0])
                    bounds[0] = x;
                if (x > bounds[3])
                    bounds[3] = x;
                if (y < bounds[1])
                    bounds[1] = y;
                if (y > bounds[4])
                    bounds[4] = y;
                if (z < bounds[2])
                    bounds[2] = z;
                if (z > bounds[5])
                    bounds[5] = z;
            }
        };
        Bounds._defaultPosition = new feng3d.Vector3D(0.0, 0.0, 0.0);
        Bounds._containers = new feng3d.Map();
        return Bounds;
    }());
    feng3d.Bounds = Bounds;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 资源处理
     * @author feng 2014-3-24
     */
    var Cast = (function () {
        function Cast() {
        }
        /**
         * 获取类定义
         * @param name		类描述字符串
         * @return			类定义
         */
        Cast.tryClass = function (name) {
            if (Cast._notClasses[name])
                return name;
            var result = Cast._classes[name];
            if (result != null)
                return result;
            try {
                result = feng3d.getDefinitionByName(name);
                Cast._classes[name] = result;
                return result;
            }
            catch (error) {
            }
            Cast._notClasses[name] = true;
            return name;
        };
        /**
         * 转换位图数据
         * @param data		位图数据
         * @return 			位图数据
         */
        Cast.bitmapData = function (data) {
            if (data == null)
                return null;
            if (feng3d.is(data, String))
                data = Cast.tryClass(data);
            if (feng3d.is(data, Function)) {
                try {
                    data = new data;
                }
                catch (bitmapError) {
                    data = new data(0, 0);
                }
            }
            if (feng3d.is(data, feng3d.BitmapData))
                return data;
            if (feng3d.is(data, feng3d.Bitmap)) {
                if (data.hasOwnProperty("Cast.bitmapData"))
                    return feng3d.as(data, feng3d.Bitmap).bitmapData;
            }
            if (feng3d.is(data, feng3d.DisplayObject)) {
                var ds = data;
                var bmd = new feng3d.BitmapData(ds.width, ds.height, true, 0x00FFFFFF);
                var mat = ds.transform.matrix.clone();
                mat.tx = 0;
                mat.ty = 0;
                bmd.draw(ds, mat, ds.transform.colorTransform, ds.blendMode, bmd.rect, true);
                return bmd;
            }
            throw new Error("Can't cast to BitmapData: " + data);
        };
        /**
         * 转换位图纹理
         * @param data		位图数据
         * @return 			位图纹理
         */
        Cast.bitmapTexture = function (data) {
            if (data == null)
                return null;
            if (feng3d.is(data, String))
                data = Cast.tryClass(data);
            if (feng3d.is(data, Function)) {
                try {
                    data = new data;
                }
                catch (materialError) {
                    data = new data(0, 0);
                }
            }
            if (feng3d.is(data, feng3d.Texture))
                return data;
            try {
                var bmd = Cast.bitmapData(data);
                return new feng3d.BitmapTexture(bmd);
            }
            catch (error) {
            }
            throw new Error("Can't cast to BitmapTexture: " + data);
        };
        Cast._notClasses = {};
        Cast._classes = {};
        return Cast;
    }());
    feng3d.Cast = Cast;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     *
     * @author feng 2015-4-28
     */
    var ColliderUtils = (function () {
        function ColliderUtils() {
        }
        /**
         * 射线与三角形碰撞
         * @param rayPosition		射线顶点
         * @param rayDirection		射线方向
         * @param p0				三角形顶点0
         * @param p1				三角形顶点1
         * @param p2				三角形顶点2
         * @return					交点
         */
        ColliderUtils.rayTriangleCollision = function (rayPosition, rayDirection, p0, p1, p2) {
            var t;
            var rx, ry, rz;
            var nx, ny, nz;
            var cx, cy, cz;
            var coeff, u, v, w;
            var p0x, p0y, p0z;
            var p1x, p1y, p1z;
            var p2x, p2y, p2z;
            var s0x, s0y, s0z;
            var s1x, s1y, s1z;
            var nl, nDotV, D, disToPlane;
            var Q1Q2, Q1Q1, Q2Q2, RQ1, RQ2;
            //三角形三个顶点数据
            p0x = p0.x;
            p0y = p0.y;
            p0z = p0.z;
            p1x = p1.x;
            p1y = p1.y;
            p1z = p1.z;
            p2x = p2.x;
            p2y = p2.y;
            p2z = p2.z;
            //计算出三角面的法线
            s0x = p1x - p0x; // s0 = p1 - p0
            s0y = p1y - p0y;
            s0z = p1z - p0z;
            s1x = p2x - p0x; // s1 = p2 - p0
            s1y = p2y - p0y;
            s1z = p2z - p0z;
            nx = s0y * s1z - s0z * s1y; // n = s0 x s1
            ny = s0z * s1x - s0x * s1z;
            nz = s0x * s1y - s0y * s1x;
            nl = 1 / Math.sqrt(nx * nx + ny * ny + nz * nz); // normalize n
            nx *= nl;
            ny *= nl;
            nz *= nl;
            //计算射线与法线的点积，小于零表示射线所在直线与三角面相交
            nDotV = nx * rayDirection.x + ny * +rayDirection.y + nz * rayDirection.z; // rayDirection . normal
            //判断射线所在直线是否与三角面相交
            if (nDotV != 0.0) {
                //计算平面方程D值，参考Plane3D
                D = -(nx * p0x + ny * p0y + nz * p0z);
                //射线点到平面的距离
                disToPlane = -(nx * rayPosition.x + ny * rayPosition.y + nz * rayPosition.z + D);
                t = disToPlane / nDotV;
                //得到交点
                cx = rayPosition.x + t * rayDirection.x;
                cy = rayPosition.y + t * rayDirection.y;
                cz = rayPosition.z + t * rayDirection.z;
                //判断交点是否在三角形内( using barycentric coordinates )
                Q1Q2 = s0x * s1x + s0y * s1y + s0z * s1z;
                Q1Q1 = s0x * s0x + s0y * s0y + s0z * s0z;
                Q2Q2 = s1x * s1x + s1y * s1y + s1z * s1z;
                rx = cx - p0x;
                ry = cy - p0y;
                rz = cz - p0z;
                RQ1 = rx * s0x + ry * s0y + rz * s0z;
                RQ2 = rx * s1x + ry * s1y + rz * s1z;
                coeff = 1 / (Q1Q1 * Q2Q2 - Q1Q2 * Q1Q2);
                v = coeff * (Q2Q2 * RQ1 - Q1Q2 * RQ2);
                w = coeff * (-Q1Q2 * RQ1 + Q1Q1 * RQ2);
                if (v < 0)
                    return null;
                if (w < 0)
                    return null;
                u = 1 - v - w;
                //u v w都大于0表示点在三角形内 射线的坐标t大于0表示射线朝向三角面
                if (u >= 0 && t > 0) {
                    return new feng3d.Vector3D(cx, cy, cz);
                }
            }
            return null;
        };
        return ColliderUtils;
    }());
    feng3d.ColliderUtils = ColliderUtils;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var DefaultMaterialManager = (function () {
        function DefaultMaterialManager() {
        }
        DefaultMaterialManager.getDefaultMaterial = function () {
            if (!DefaultMaterialManager._defaultTexture)
                DefaultMaterialManager.createDefaultTexture();
            if (!DefaultMaterialManager._defaultMaterial)
                DefaultMaterialManager.createDefaultMaterial();
            return DefaultMaterialManager._defaultMaterial;
        };
        DefaultMaterialManager.getDefaultTexture = function () {
            if (!DefaultMaterialManager._defaultTexture)
                DefaultMaterialManager.createDefaultTexture();
            return DefaultMaterialManager._defaultTexture;
        };
        DefaultMaterialManager.createDefaultTexture = function (color) {
            if (color === void 0) { color = 0XFFFFFF; }
            DefaultMaterialManager._defaultTextureBitmapData = new feng3d.BitmapData(8, 8, false, 0x0);
            //create chekerboard
            var i, j;
            for (i = 0; i < 8; i++) {
                for (j = 0; j < 8; j++) {
                    if ((j & 1) ^ (i & 1))
                        DefaultMaterialManager._defaultTextureBitmapData.setPixel(i, j, 0XFFFFFF);
                }
            }
            DefaultMaterialManager._defaultTexture = new feng3d.BitmapTexture(DefaultMaterialManager._defaultTextureBitmapData);
        };
        DefaultMaterialManager.createDefaultMaterial = function () {
            DefaultMaterialManager._defaultMaterial = new feng3d.TextureMaterial(DefaultMaterialManager._defaultTexture);
            DefaultMaterialManager._defaultMaterial.mipmap = false;
            DefaultMaterialManager._defaultMaterial.smooth = false;
        };
        return DefaultMaterialManager;
    }());
    feng3d.DefaultMaterialManager = DefaultMaterialManager;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     *
     * @author feng 2014-5-19
     */
    var GeomUtil = (function () {
        function GeomUtil() {
        }
        /**
         * 根据数据数组创建子网格
         * @param verts
         * @param indices
         * @param uvs
         * @param normals
         * @param tangents
         * @param weights
         * @param jointIndices
         * @param triangleOffset
         * @return
         */
        GeomUtil.fromVectors = function (verts, indices, uvs, weights, jointIndices, triangleOffset) {
            if (triangleOffset === void 0) { triangleOffset = 0; }
            var LIMIT_VERTS = 3 * 0xffff;
            var LIMIT_INDICES = 15 * 0xffff;
            var subs = [];
            if (uvs && !uvs.length)
                uvs = null;
            if (weights && !weights.length)
                weights = null;
            if (jointIndices && !jointIndices.length)
                jointIndices = null;
            if ((indices.length >= LIMIT_INDICES) || (verts.length >= LIMIT_VERTS)) {
                var i, len, outIndex, j;
                var splitVerts = [];
                var splitIndices = [];
                var splitUvs = (uvs != null) ? [] : null;
                var splitWeights = (weights != null) ? [] : null;
                var splitJointIndices = (jointIndices != null) ? [] : null;
                var mappings = [];
                mappings.length = verts.length / 3;
                i = mappings.length;
                while (i-- > 0)
                    mappings[i] = -1;
                var originalIndex;
                var splitIndex;
                var o0, o1, o2, s0, s1, s2, su, ou, sv, ov;
                // Loop over all triangles
                outIndex = 0;
                len = indices.length;
                for (i = 0; i < len; i += 3) {
                    splitIndex = splitVerts.length + 6;
                    if (((outIndex + 2) >= LIMIT_INDICES) || (splitIndex >= LIMIT_VERTS)) {
                        subs.push(GeomUtil.constructSubGeometry(splitVerts, splitIndices, splitUvs, splitWeights, splitJointIndices, triangleOffset));
                        splitVerts = [];
                        splitIndices = [];
                        splitUvs = (uvs != null) ? [] : null;
                        splitWeights = (weights != null) ? [] : null;
                        splitJointIndices = (jointIndices != null) ? [] : null;
                        splitIndex = 0;
                        j = mappings.length;
                        while (j-- > 0)
                            mappings[j] = -1;
                        outIndex = 0;
                    }
                    // Loop over all vertices in triangle
                    for (j = 0; j < 3; j++) {
                        originalIndex = indices[i + j];
                        if (mappings[originalIndex] >= 0)
                            splitIndex = mappings[originalIndex];
                        else {
                            o0 = originalIndex * 3 + 0;
                            o1 = originalIndex * 3 + 1;
                            o2 = originalIndex * 3 + 2;
                            // This vertex does not yet exist in the split list and
                            // needs to be copied from the long list.
                            splitIndex = splitVerts.length / 3;
                            s0 = splitIndex * 3 + 0;
                            s1 = splitIndex * 3 + 1;
                            s2 = splitIndex * 3 + 2;
                            splitVerts[s0] = verts[o0];
                            splitVerts[s1] = verts[o1];
                            splitVerts[s2] = verts[o2];
                            if (uvs) {
                                su = splitIndex * 2 + 0;
                                sv = splitIndex * 2 + 1;
                                ou = originalIndex * 2 + 0;
                                ov = originalIndex * 2 + 1;
                                splitUvs[su] = uvs[ou];
                                splitUvs[sv] = uvs[ov];
                            }
                            if (weights) {
                                splitWeights[s0] = weights[o0];
                                splitWeights[s1] = weights[o1];
                                splitWeights[s2] = weights[o2];
                            }
                            if (jointIndices) {
                                splitJointIndices[s0] = jointIndices[o0];
                                splitJointIndices[s1] = jointIndices[o1];
                                splitJointIndices[s2] = jointIndices[o2];
                            }
                            mappings[originalIndex] = splitIndex;
                        }
                        // Store new index, which may have come from the mapping look-up,
                        // or from copying a new set of vertex data from the original vector
                        splitIndices[outIndex + j] = splitIndex;
                    }
                    outIndex += 3;
                }
                if (splitVerts.length > 0) {
                    // More was added in the last iteration of the loop.
                    subs.push(GeomUtil.constructSubGeometry(splitVerts, splitIndices, splitUvs, splitWeights, splitJointIndices, triangleOffset));
                }
            }
            else
                subs.push(GeomUtil.constructSubGeometry(verts, indices, uvs, weights, jointIndices, triangleOffset));
            return subs;
        };
        GeomUtil.constructSubGeometry = function (verts, indices, uvs, weights, jointIndices, triangleOffset) {
            var sub = new feng3d.SubGeometry();
            if (weights && jointIndices) {
                // If there were weights and joint indices defined, this
                // is a skinned mesh and needs to be built from skinned
                // sub-geometries.
                var skinnedSubGeometry = new feng3d.SkinnedSubGeometry(weights.length / (verts.length / 3));
                sub.addComponent(skinnedSubGeometry);
                skinnedSubGeometry.updateJointWeightsData(weights);
                skinnedSubGeometry.updateJointIndexData(jointIndices);
            }
            else
                sub = new feng3d.SubGeometry();
            sub.numVertices = verts.length / 3;
            sub.updateIndexData(indices);
            sub.fromVectors(verts, uvs);
            sub.getOrCreateComponentByClass(feng3d.AutoDeriveVertexNormals);
            sub.getOrCreateComponentByClass(feng3d.AutoDeriveVertexTangents);
            return sub;
        };
        /**
         * 拷贝子网格数据
         * @param source 源子网格
         * @param target 目标子网格
         */
        GeomUtil.copyDataSubGeom = function (source, target) {
            target.numVertices = source.numVertices;
            target.updateVertexPositionData(source.vertexPositionData.concat());
            target.updateUVData(source.UVData.concat());
            target.updateIndexData(source.indices.concat());
        };
        /**
         * source添加到target中
         * @param source 源自几何体
         * @param target 目标子几何体
         * @return true：添加成功；false：添加失败，应该是顶点个数超出最大值65535
         */
        GeomUtil.addSubGeometry = function (source, target) {
            if (source.numVertices + target.numVertices > GeomUtil.MAX_VERTEX)
                return false;
            //顶点属性编号列表
            var vaIdList = source.vaIdList;
            var vaId;
            /** 顶点数据字典 */
            var sourceVertexDataDic = {};
            var targetVertexDataDic = {};
            vaIdList.forEach(function (vaId) {
                sourceVertexDataDic[vaId] = source.getVAData(vaId);
                feng3d.assert(sourceVertexDataDic[vaId].length == source.getVALen(vaId) * source.numVertices);
                targetVertexDataDic[vaId] = target.getVAData(vaId);
                feng3d.assert(targetVertexDataDic[vaId].length == target.getVALen(vaId) * target.numVertices);
            });
            //添加索引数据
            var indices = feng3d.VectorUtils.add1(source.indices, target.indices, target.numVertices);
            target.updateIndexData(indices);
            //更改顶点数量
            target.numVertices = source.numVertices + target.numVertices;
            var vertexData;
            //添加顶点数据
            vaIdList.forEach(function (vaId) {
                //
                vertexData = feng3d.VectorUtils.add(sourceVertexDataDic[vaId], targetVertexDataDic[vaId]);
                target.setVAData(vaId, vertexData);
            });
            return true;
        };
        /** stage3d单次渲染支持的最大顶点数 */
        GeomUtil.MAX_VERTEX = 65535;
        return GeomUtil;
    }());
    feng3d.GeomUtil = GeomUtil;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 纹理材质工厂
     * @author feng 2014-7-7
     */
    var MaterialUtils = (function () {
        function MaterialUtils() {
        }
        /**
         * 创建纹理材质
         * @param url		贴图路径
         * @return			纹理材质
         */
        MaterialUtils.createTextureMaterial = function (url) {
            feng3d.Load.init();
            var textureMaterial = new feng3d.TextureMaterial(feng3d.DefaultMaterialManager.getDefaultTexture());
            var loadObj = new feng3d.LoadModuleEventData();
            loadObj.urls = [url];
            loadObj.addEventListener(feng3d.LoadUrlEvent.LOAD_SINGLE_COMPLETE, MaterialUtils.onLoadSingleComplete);
            loadObj.data = { textureMaterial: textureMaterial };
            MaterialUtils.dispatcher.dispatchEvent(new feng3d.LoadModuleEvent(feng3d.LoadModuleEvent.LOAD_RESOURCE, loadObj));
            return textureMaterial;
        };
        MaterialUtils.onLoadSingleComplete = function (event) {
            var loadData = event.target;
            var textureMaterial = loadData.data.textureMaterial;
            var bitmap = event.loadTaskItem.loadingItem.content;
            textureMaterial.texture = feng3d.Cast.bitmapTexture(bitmap);
        };
        MaterialUtils.dispatcher = feng3d.GlobalDispatcher.instance;
        return MaterialUtils;
    }());
    feng3d.MaterialUtils = MaterialUtils;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * MipmapGenerator is a helper class that uploads BitmapData to a Texture including mipmap levels.
     */
    var MipmapGenerator = (function () {
        function MipmapGenerator() {
        }
        /**
         * Uploads a BitmapData with mip maps to a target Texture object.
         * @param source The source BitmapData to upload.
         * @param target The target Texture to upload to.
         * @param mipmap An optional mip map holder to avoids creating new instances for fe animated materials.
         * @param alpha Indicate whether or not the uploaded bitmapData is transparent.
         */
        MipmapGenerator.generateMipMaps = function (source, target, mipmap, alpha, side) {
            if (mipmap === void 0) { mipmap = null; }
            if (alpha === void 0) { alpha = false; }
            if (side === void 0) { side = -1; }
            var w = source.width, h = source.height;
            var i;
            var regen = mipmap != null;
            mipmap = mipmap || new feng3d.BitmapData(w, h, alpha);
            MipmapGenerator._rect.width = w;
            MipmapGenerator._rect.height = h;
            while (w >= 1 || h >= 1) {
                if (alpha)
                    mipmap.fillRect(MipmapGenerator._rect, 0);
                MipmapGenerator._matrix.a = MipmapGenerator._rect.width / source.width;
                MipmapGenerator._matrix.d = MipmapGenerator._rect.height / source.height;
                mipmap.draw(source, MipmapGenerator._matrix, null, null, null, true);
                if (feng3d.is(target, feng3d.Texture))
                    feng3d.as(target, feng3d.Texture).uploadFromBitmapData(mipmap, i++);
                else
                    feng3d.as(target, feng3d.CubeTexture).uploadFromBitmapData(mipmap, side, i++);
                w = w / 2;
                h = h / 2;
                MipmapGenerator._rect.width = w > 1 ? w : 1;
                MipmapGenerator._rect.height = h > 1 ? h : 1;
            }
            if (!regen)
                mipmap.dispose();
        };
        MipmapGenerator._matrix = new feng3d.Matrix();
        MipmapGenerator._rect = new feng3d.Rectangle();
        return MipmapGenerator;
    }());
    feng3d.MipmapGenerator = MipmapGenerator;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     *
     * @author feng 2014-12-18
     */
    var SubGeomUtil = (function () {
        function SubGeomUtil() {
        }
        /**
         * 更新面法线数据
         * @param _faceNormals
         * @param vertices
         * @param _faceWeights
         * @param _indices
         * @param _useFaceWeights
         * @return
         */
        SubGeomUtil.updateFaceNormals = function (_faceNormals, vertices, _indices) {
            var i, j, k;
            var index;
            var len = _indices.length;
            var x1, x2, x3;
            var y1, y2, y3;
            var z1, z2, z3;
            var dx1, dy1, dz1;
            var dx2, dy2, dz2;
            var cx, cy, cz;
            var d;
            var posStride = 3;
            var posOffset = 0;
            _faceNormals = _faceNormals || [];
            _faceNormals.length = len;
            while (i < len) {
                index = posOffset + _indices[i++] * posStride;
                x1 = vertices[index];
                y1 = vertices[index + 1];
                z1 = vertices[index + 2];
                index = posOffset + _indices[i++] * posStride;
                x2 = vertices[index];
                y2 = vertices[index + 1];
                z2 = vertices[index + 2];
                index = posOffset + _indices[i++] * posStride;
                x3 = vertices[index];
                y3 = vertices[index + 1];
                z3 = vertices[index + 2];
                dx1 = x3 - x1;
                dy1 = y3 - y1;
                dz1 = z3 - z1;
                dx2 = x2 - x1;
                dy2 = y2 - y1;
                dz2 = z2 - z1;
                cx = dz1 * dy2 - dy1 * dz2;
                cy = dx1 * dz2 - dz1 * dx2;
                cz = dy1 * dx2 - dx1 * dy2;
                d = Math.sqrt(cx * cx + cy * cy + cz * cz);
                // length of cross product = 2*triangle area
                d = 1 / d;
                _faceNormals[j++] = cx * d;
                _faceNormals[j++] = cy * d;
                _faceNormals[j++] = cz * d;
            }
            return _faceNormals;
        };
        /**
         * 更新面切线数据
         * @param _faceTangents
         * @param vertices
         * @param uvs
         * @param _indices
         * @return
         *
         */
        SubGeomUtil.updateFaceTangents = function (_faceTangents, vertices, uvs, _indices) {
            var i;
            var index1, index2, index3;
            var len = _indices.length;
            var ui, vi;
            var v0;
            var dv1, dv2;
            var denom;
            var x0, y0, z0;
            var dx1, dy1, dz1;
            var dx2, dy2, dz2;
            var cx, cy, cz;
            var posStride = 3;
            var texStride = 2;
            _faceTangents = _faceTangents || [];
            _faceTangents.length = _indices.length;
            while (i < len) {
                index1 = _indices[i];
                index2 = _indices[i + 1];
                index3 = _indices[i + 2];
                ui = index1 * texStride + 1;
                v0 = uvs[ui];
                ui = index2 * texStride + 1;
                dv1 = uvs[ui] - v0;
                ui = index3 * texStride + 1;
                dv2 = uvs[ui] - v0;
                vi = index1 * posStride;
                x0 = vertices[vi];
                y0 = vertices[vi + 1];
                z0 = vertices[vi + 2];
                vi = index2 * posStride;
                dx1 = vertices[vi] - x0;
                dy1 = vertices[vi + 1] - y0;
                dz1 = vertices[vi + 2] - z0;
                vi = index3 * posStride;
                dx2 = vertices[vi] - x0;
                dy2 = vertices[vi + 1] - y0;
                dz2 = vertices[vi + 2] - z0;
                cx = dv2 * dx1 - dv1 * dx2;
                cy = dv2 * dy1 - dv1 * dy2;
                cz = dv2 * dz1 - dv1 * dz2;
                denom = 1 / Math.sqrt(cx * cx + cy * cy + cz * cz);
                _faceTangents[i++] = denom * cx;
                _faceTangents[i++] = denom * cy;
                _faceTangents[i++] = denom * cz;
            }
            return _faceTangents;
        };
        /**
         * 计算顶点法线数据
         * @param target
         * @param _faceNormals
         * @param _faceWeights
         * @param _indices
         * @param numVertices
         * @param _useFaceWeights
         * @return
         */
        SubGeomUtil.updateVertexNormals = function (target, _faceNormals, _indices, numVertices) {
            var v1;
            var f1 = 0, f2 = 1, f3 = 2;
            var lenV = numVertices * 3;
            var normalStride = 3;
            target = target || [];
            target.length = lenV;
            v1 = 0;
            while (v1 < lenV) {
                target[v1] = 0.0;
                target[v1 + 1] = 0.0;
                target[v1 + 2] = 0.0;
                v1 += normalStride;
            }
            var i, k;
            var lenI = _indices.length;
            var index;
            while (i < lenI) {
                index = _indices[i++] * normalStride;
                target[index++] += _faceNormals[f1];
                target[index++] += _faceNormals[f2];
                target[index] += _faceNormals[f3];
                index = _indices[i++] * normalStride;
                target[index++] += _faceNormals[f1];
                target[index++] += _faceNormals[f2];
                target[index] += _faceNormals[f3];
                index = _indices[i++] * normalStride;
                target[index++] += _faceNormals[f1];
                target[index++] += _faceNormals[f2];
                target[index] += _faceNormals[f3];
                f1 += 3;
                f2 += 3;
                f3 += 3;
            }
            v1 = 0;
            while (v1 < lenV) {
                var vx = target[v1];
                var vy = target[v1 + 1];
                var vz = target[v1 + 2];
                var d = 1.0 / Math.sqrt(vx * vx + vy * vy + vz * vz);
                target[v1] = vx * d;
                target[v1 + 1] = vy * d;
                target[v1 + 2] = vz * d;
                v1 += normalStride;
            }
            return target;
        };
        /**
         * 计算切线数据
         * @param target
         * @param _faceTangents
         * @param _faceWeights
         * @param _indices
         * @param numVertices
         * @param _useFaceWeights
         * @return
         */
        SubGeomUtil.updateVertexTangents = function (target, _faceTangents, _indices, numVertices) {
            var i;
            var lenV = numVertices * 3;
            var tangentStride = 3;
            target = target || [];
            target.length = lenV;
            i = 0;
            while (i < lenV) {
                target[i] = 0.0;
                target[i + 1] = 0.0;
                target[i + 2] = 0.0;
                i += tangentStride;
            }
            var k;
            var lenI = _indices.length;
            var index;
            var f1 = 0, f2 = 1, f3 = 2;
            i = 0;
            while (i < lenI) {
                index = _indices[i++] * tangentStride;
                target[index++] += _faceTangents[f1];
                target[index++] += _faceTangents[f2];
                target[index] += _faceTangents[f3];
                index = _indices[i++] * tangentStride;
                target[index++] += _faceTangents[f1];
                target[index++] += _faceTangents[f2];
                target[index] += _faceTangents[f3];
                index = _indices[i++] * tangentStride;
                target[index++] += _faceTangents[f1];
                target[index++] += _faceTangents[f2];
                target[index] += _faceTangents[f3];
                f1 += 3;
                f2 += 3;
                f3 += 3;
            }
            i = 0;
            while (i < lenV) {
                var vx = target[i];
                var vy = target[i + 1];
                var vz = target[i + 2];
                var d = 1.0 / Math.sqrt(vx * vx + vy * vy + vz * vz);
                target[i] = vx * d;
                target[i + 1] = vy * d;
                target[i + 2] = vz * d;
                i += tangentStride;
            }
            return target;
        };
        return SubGeomUtil;
    }());
    feng3d.SubGeomUtil = SubGeomUtil;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 纹理工具类
     * @author feng 2015-7-7
     */
    var TextureUtils = (function () {
        function TextureUtils() {
        }
        /**
         * 判断是否为有效位图
         * @param bitmapData		位图
         * @return
         */
        TextureUtils.isBitmapDataValid = function (bitmapData) {
            if (bitmapData == null)
                return true;
            return TextureUtils.isDimensionValid(bitmapData.width) && TextureUtils.isDimensionValid(bitmapData.height);
        };
        /**
         * 尺寸是否有效
         * @param d		尺寸
         * @return
         */
        TextureUtils.isDimensionValid = function (d) {
            return d >= 1 && d <= TextureUtils.MAX_SIZE && TextureUtils.isPowerOfTwo(d);
        };
        /**
         * 是否为2的指数次方
         * @param value			被检查的值
         * @return
         */
        TextureUtils.isPowerOfTwo = function (value) {
            return value ? ((value & -value) == value) : false;
        };
        /**
         * 转换为最佳2的指数次方值
         * @param value			尺寸
         * @return
         */
        TextureUtils.getBestPowerOf2 = function (value) {
            var p = 1;
            while (p < value)
                p <<= 1;
            if (p > TextureUtils.MAX_SIZE)
                p = TextureUtils.MAX_SIZE;
            return p;
        };
        /**
         * 获取纹理取样参数
         * @param useMipmapping 		是否使用贴图分层细化
         * @param useSmoothTextures 	是否使用平滑纹理
         * @param repeatTextures 		是否重复纹理
         * @param texture 				取样纹理
         * @param forceWrap 			强制重复纹理参数
         * @return
         */
        TextureUtils.getFlags = function (useMipmapping, useSmoothTextures, repeatTextures, texture, forceWrap) {
            if (forceWrap === void 0) { forceWrap = null; }
            var flags = [texture.type];
            var enableMipMaps = useMipmapping && texture.hasMipMaps;
            if (useSmoothTextures) {
                flags.push(feng3d.Context3DTextureFilter.LINEAR);
                if (enableMipMaps)
                    flags.push(feng3d.Context3DMipFilter.MIPLINEAR);
            }
            else {
                flags.push(feng3d.Context3DTextureFilter.NEAREST);
                if (enableMipMaps)
                    flags.push(feng3d.Context3DMipFilter.MIPNEAREST);
            }
            if (forceWrap) {
                flags.push(forceWrap);
            }
            else {
                if (!(feng3d.is(texture, feng3d.BitmapCubeTexture))) {
                    if (repeatTextures) {
                        flags.push(feng3d.Context3DWrapMode.REPEAT);
                    }
                    else {
                        flags.push(feng3d.Context3DWrapMode.CLAMP);
                    }
                }
            }
            return flags;
        };
        /**
         * 支持的最大纹理尺寸
         */
        TextureUtils.MAX_SIZE = 4096;
        return TextureUtils;
    }());
    feng3d.TextureUtils = TextureUtils;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 向量工具类
     * @author feng 2014-12-10
     */
    var VectorUtils = (function () {
        function VectorUtils() {
        }
        /**
         * 把source添加到target中
         * @param source 源向量
         * @param target 目标向量
         */
        VectorUtils.add = function (source, target) {
            var sourceLen = target.length;
            var targetLen = source.length;
            target.length = target.length + source.length;
            for (var i = 0; i < targetLen; i++) {
                target[sourceLen + i] = source[i];
            }
            return target;
        };
        /**
         * 拷贝数组
         * @param source		源数组
         * @param target		目标数组
         * @param offset		在源数组中的偏移量
         */
        VectorUtils.copy = function (source, target, offset) {
            source.forEach(function (item, index) {
                var args = [];
                for (var _i = 2; _i < arguments.length; _i++) {
                    args[_i - 2] = arguments[_i];
                }
                target[offset + index] = item;
            });
        };
        /**
         * 把source添加到target中
         * @param source 源向量
         * @param target 目标向量
         */
        VectorUtils.add1 = function (source, target, addNum) {
            var sourceLen = target.length;
            var targetLen = source.length;
            target.length = target.length + source.length;
            for (var i = 0; i < targetLen; i++) {
                target[sourceLen + i] = source[i] + addNum;
            }
            return target;
        };
        return VectorUtils;
    }());
    feng3d.VectorUtils = VectorUtils;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * Fagal
     * @author feng 2015-4-27
     */
    var Fagal = (function () {
        function Fagal() {
        }
        /**
         * 网站
         */
        Fagal.WEBSITE_URL = "http://www.feng3d.me";
        /**
         * Fagal版本号
         */
        Fagal.REVISION = "2015.4.27";
        return Fagal;
    }());
    feng3d.Fagal = Fagal;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var Bitmap = (function (_super) {
        __extends(Bitmap, _super);
        function Bitmap() {
            _super.apply(this, arguments);
        }
        return Bitmap;
    }(feng3d.DisplayObject));
    feng3d.Bitmap = Bitmap;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var BitmapData = (function () {
        function BitmapData(sclw, sclh, transparent, c) {
        }
        BitmapData.prototype.draw = function (sourceMC, t, s, dd, rect, d) {
        };
        BitmapData.prototype.copyPixels = function (tmpCache, rect, pastePoint) {
        };
        BitmapData.prototype.fillRect = function (rect, d) {
        };
        BitmapData.prototype.dispose = function () {
        };
        BitmapData.prototype.setPixel = function (i, j, k) {
        };
        return BitmapData;
    }());
    feng3d.BitmapData = BitmapData;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var BlendMode = (function () {
        function BlendMode() {
        }
        // [静态] 将显示对象的原色值添加到它的背景颜色中，上限值为 0xFF。
        BlendMode.ADD = "add";
        // [静态] 将显示对象的每个像素的 Alpha 值应用于背景。
        BlendMode.ALPHA = "alpha";
        // [静态] 在显示对象原色和背景颜色中选择相对较暗的颜色（具有较小值的颜色）。
        BlendMode.DARKEN = "darken";
        // [静态] 将显示对象的原色与背景颜色进行比较，然后从较亮的原色值中减去较暗的原色值。
        BlendMode.DIFFERENCE = "difference";
        // [静态] 根据显示对象的 Alpha 值擦除背景。
        BlendMode.ERASE = "erase";
        // [静态] 根据显示对象的暗度调整每个像素的颜色。
        BlendMode.HARDLIGHT = "hardlight";
        // [静态] 反转背景。
        BlendMode.INVERT = "invert";
        // [静态] 强制为该显示对象创建一个透明度组。
        BlendMode.LAYER = "layer";
        // [静态] 在显示对象原色和背景颜色中选择相对较亮的颜色（具有较大值的颜色）。
        BlendMode.LIGHTEN = "lighten";
        // [静态] 将显示对象的原色值与背景颜色的原色值相乘，然后除以 0xFF 进行标准化，从而得到较暗的颜色。
        BlendMode.MULTIPLY = "multiply";
        // [静态] 该显示对象出现在背景前面。
        BlendMode.NORMAL = "normal";
        // [静态] 根据背景的暗度调整每个像素的颜色。
        BlendMode.OVERLAY = "overlay";
        // [静态] 将显示对象颜色的补色（反色）与背景颜色的补色相乘，会产生漂白效果。
        BlendMode.SCREEN = "screen";
        // [静态] 使用着色器来定义对象之间的混合。
        BlendMode.SHADER = "shader";
        // [静态] 从背景颜色的值中减去显示对象原色的值，下限值为 0。
        BlendMode.SUBTRACT = "subtract";
        return BlendMode;
    }());
    feng3d.BlendMode = BlendMode;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var BulkLoader = (function (_super) {
        __extends(BulkLoader, _super);
        function BulkLoader(a) {
            _super.call(this);
        }
        BulkLoader.prototype.hasItem = function (_url) {
        };
        BulkLoader.prototype.add = function (_url, d) {
        };
        BulkLoader.prototype.get = function (_url) {
            return null;
        };
        return BulkLoader;
    }(feng3d.EventDispatcher));
    feng3d.BulkLoader = BulkLoader;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var BulkProgressEvent = (function () {
        function BulkProgressEvent() {
        }
        return BulkProgressEvent;
    }());
    feng3d.BulkProgressEvent = BulkProgressEvent;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var ColorTransform = (function () {
        function ColorTransform() {
        }
        return ColorTransform;
    }());
    feng3d.ColorTransform = ColorTransform;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var Context3DBlendFactor = (function () {
        function Context3DBlendFactor() {
        }
        return Context3DBlendFactor;
    }());
    feng3d.Context3DBlendFactor = Context3DBlendFactor;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var Context3DCompareMode = (function () {
        function Context3DCompareMode() {
        }
        return Context3DCompareMode;
    }());
    feng3d.Context3DCompareMode = Context3DCompareMode;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var Context3DMipFilter = (function () {
        function Context3DMipFilter() {
        }
        return Context3DMipFilter;
    }());
    feng3d.Context3DMipFilter = Context3DMipFilter;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var Context3DProfile = (function () {
        function Context3DProfile() {
        }
        return Context3DProfile;
    }());
    feng3d.Context3DProfile = Context3DProfile;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var Context3DTextureFormat = (function () {
        function Context3DTextureFormat() {
        }
        return Context3DTextureFormat;
    }());
    feng3d.Context3DTextureFormat = Context3DTextureFormat;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var Context3DTriangleFace = (function () {
        function Context3DTriangleFace() {
        }
        return Context3DTriangleFace;
    }());
    feng3d.Context3DTriangleFace = Context3DTriangleFace;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var CubeTexture = (function () {
        function CubeTexture() {
        }
        return CubeTexture;
    }());
    feng3d.CubeTexture = CubeTexture;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var DisplayObject = (function (_super) {
        __extends(DisplayObject, _super);
        function DisplayObject() {
            _super.apply(this, arguments);
        }
        DisplayObject.prototype.getx = function () {
            return this.x;
        };
        DisplayObject.prototype.gety = function () {
            return this.y;
        };
        return DisplayObject;
    }(feng3d.EventDispatcher));
    feng3d.DisplayObject = DisplayObject;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var Endian = (function () {
        function Endian() {
        }
        return Endian;
    }());
    feng3d.Endian = Endian;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var ImageItem = (function () {
        function ImageItem() {
        }
        return ImageItem;
    }());
    feng3d.ImageItem = ImageItem;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var IOErrorEvent = (function () {
        function IOErrorEvent() {
        }
        return IOErrorEvent;
    }());
    feng3d.IOErrorEvent = IOErrorEvent;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var Loader = (function () {
        function Loader() {
        }
        return Loader;
    }());
    feng3d.Loader = Loader;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var LoadingItem = (function (_super) {
        __extends(LoadingItem, _super);
        function LoadingItem() {
            _super.apply(this, arguments);
        }
        return LoadingItem;
    }(feng3d.EventDispatcher));
    feng3d.LoadingItem = LoadingItem;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var Matrix = (function () {
        function Matrix() {
        }
        Matrix.prototype.scale = function (sclw, sclh) {
        };
        return Matrix;
    }());
    feng3d.Matrix = Matrix;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var MovieClip = (function (_super) {
        __extends(MovieClip, _super);
        function MovieClip() {
            _super.apply(this, arguments);
        }
        MovieClip.prototype.gotoAndStop = function (a) {
        };
        MovieClip.prototype.draw = function (sourceMC, t, a, b, rect, d) {
        };
        return MovieClip;
    }(feng3d.Sprite));
    feng3d.MovieClip = MovieClip;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var Rectangle = (function () {
        function Rectangle() {
        }
        return Rectangle;
    }());
    feng3d.Rectangle = Rectangle;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var SecurityErrorEvent = (function () {
        function SecurityErrorEvent() {
        }
        return SecurityErrorEvent;
    }());
    feng3d.SecurityErrorEvent = SecurityErrorEvent;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var Shape = (function (_super) {
        __extends(Shape, _super);
        function Shape() {
            _super.apply(this, arguments);
        }
        return Shape;
    }(feng3d.DisplayObject));
    feng3d.Shape = Shape;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var Sprite = (function (_super) {
        __extends(Sprite, _super);
        function Sprite() {
            _super.apply(this, arguments);
        }
        return Sprite;
    }(feng3d.DisplayObject));
    feng3d.Sprite = Sprite;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var Stage = (function (_super) {
        __extends(Stage, _super);
        function Stage() {
            _super.apply(this, arguments);
        }
        return Stage;
    }(feng3d.DisplayObject));
    feng3d.Stage = Stage;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var Texture = (function () {
        function Texture() {
        }
        Texture.prototype.uploadFromBitmapData = function (bitmapData, n) {
        };
        return Texture;
    }());
    feng3d.Texture = Texture;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var TextureBase = (function () {
        function TextureBase() {
        }
        return TextureBase;
    }());
    feng3d.TextureBase = TextureBase;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var Timer = (function (_super) {
        __extends(Timer, _super);
        function Timer(a, b) {
            _super.call(this);
        }
        Timer.prototype.start = function () {
        };
        Timer.prototype.stop = function () {
        };
        return Timer;
    }(feng3d.EventDispatcher));
    feng3d.Timer = Timer;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var TimerEvent = (function () {
        function TimerEvent() {
        }
        return TimerEvent;
    }());
    feng3d.TimerEvent = TimerEvent;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var URLLoader = (function (_super) {
        __extends(URLLoader, _super);
        function URLLoader() {
            _super.apply(this, arguments);
        }
        return URLLoader;
    }(feng3d.EventDispatcher));
    feng3d.URLLoader = URLLoader;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var URLRequest = (function () {
        function URLRequest(url) {
        }
        return URLRequest;
    }());
    feng3d.URLRequest = URLRequest;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var Context3D = (function () {
        function Context3D() {
        }
        Context3D.prototype.createTexture = function (width, height, format, b) {
            return null;
        };
        Context3D.prototype.createProgram = function () {
            return null;
        };
        Context3D.prototype.setRenderToBackBuffer = function () {
        };
        Context3D.prototype.setTextureAt = function (i, b) {
        };
        return Context3D;
    }());
    feng3d.Context3D = Context3D;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var Context3DProgramType = (function () {
        function Context3DProgramType() {
        }
        Context3DProgramType.FRAGMENT = "fragment";
        Context3DProgramType.VERTEX = "vertex";
        return Context3DProgramType;
    }());
    feng3d.Context3DProgramType = Context3DProgramType;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var Context3DRenderMode = (function () {
        function Context3DRenderMode() {
        }
        return Context3DRenderMode;
    }());
    feng3d.Context3DRenderMode = Context3DRenderMode;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var Context3DTextureFilter = (function () {
        function Context3DTextureFilter() {
        }
        Context3DTextureFilter.ANISOTROPIC16X = "anisotropic16x";
        Context3DTextureFilter.ANISOTROPIC2X = "anisotropic2x";
        Context3DTextureFilter.ANISOTROPIC4X = "anisotropic4x";
        Context3DTextureFilter.ANISOTROPIC8X = "anisotropic8x";
        Context3DTextureFilter.LINEAR = "linear";
        Context3DTextureFilter.NEAREST = "nearest";
        return Context3DTextureFilter;
    }());
    feng3d.Context3DTextureFilter = Context3DTextureFilter;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var Context3DVertexBufferFormat = (function () {
        function Context3DVertexBufferFormat() {
        }
        return Context3DVertexBufferFormat;
    }());
    feng3d.Context3DVertexBufferFormat = Context3DVertexBufferFormat;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var Context3DWrapMode = (function () {
        function Context3DWrapMode() {
        }
        Context3DWrapMode.CLAMP = "clamp";
        Context3DWrapMode.CLAMP_U_REPEAT_V = "clamp_u_repeat_v";
        Context3DWrapMode.REPEAT = "repeat";
        Context3DWrapMode.REPEAT_U_CLAMP_V = "repeat_u_clamp_v";
        return Context3DWrapMode;
    }());
    feng3d.Context3DWrapMode = Context3DWrapMode;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var IndexBuffer3D = (function () {
        function IndexBuffer3D() {
        }
        return IndexBuffer3D;
    }());
    feng3d.IndexBuffer3D = IndexBuffer3D;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var Program3D = (function () {
        function Program3D() {
        }
        Program3D.prototype.upload = function (vertexByteCode, fragmentByteCode) {
        };
        return Program3D;
    }());
    feng3d.Program3D = Program3D;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var Stage3D = (function (_super) {
        __extends(Stage3D, _super);
        function Stage3D() {
            _super.apply(this, arguments);
        }
        return Stage3D;
    }(feng3d.DisplayObject));
    feng3d.Stage3D = Stage3D;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var VertexBuffer3D = (function () {
        function VertexBuffer3D() {
        }
        return VertexBuffer3D;
    }());
    feng3d.VertexBuffer3D = VertexBuffer3D;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var AGALMiniAssembler = (function () {
        function AGALMiniAssembler(b) {
        }
        AGALMiniAssembler.prototype.assemble = function (a, noCommentCode) {
        };
        return AGALMiniAssembler;
    }());
    feng3d.AGALMiniAssembler = AGALMiniAssembler;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var ByteArray = (function () {
        function ByteArray() {
        }
        ByteArray.prototype.readUTFBytes = function (a) {
            return "";
        };
        ByteArray.prototype.readUnsignedShort = function () {
            return 0;
        };
        ByteArray.prototype.readFloat = function () {
            return 0;
        };
        ByteArray.prototype.readUnsignedInt = function () {
            return 0;
        };
        ByteArray.prototype.readShort = function () {
            return 0;
        };
        ByteArray.prototype.readByte = function () {
            return 0;
        };
        ByteArray.prototype.readUnsignedByte = function () {
            return 0;
        };
        return ByteArray;
    }());
    feng3d.ByteArray = ByteArray;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var Proxy = (function () {
        function Proxy() {
        }
        return Proxy;
    }());
    feng3d.Proxy = Proxy;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var MouseEvent = (function (_super) {
        __extends(MouseEvent, _super);
        function MouseEvent() {
            _super.apply(this, arguments);
        }
        return MouseEvent;
    }(feng3d.Event));
    feng3d.MouseEvent = MouseEvent;
})(feng3d || (feng3d = {}));
//# sourceMappingURL=feng3d.js.map